# Comparing `tmp/qumulo_api-6.0.2-py3-none-any.whl.zip` & `tmp/qumulo_api-6.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,107 +1,109 @@
-Zip file size: 244729 bytes, number of entries: 105
--rw-r--r--  2.0 unx       22 b- defN 23-Mar-17 20:54 qumulo/__init__.py
--rw-r--r--  2.0 unx    10792 b- defN 23-Mar-17 20:54 qumulo/rest_client.py
--rw-r--r--  2.0 unx     5463 b- defN 23-Mar-17 20:54 qumulo/retry.py
--rw-r--r--  2.0 unx     1163 b- defN 23-Mar-17 20:54 qumulo/commands/__init__.py
--rw-r--r--  2.0 unx     7430 b- defN 23-Mar-17 20:54 qumulo/commands/access_tokens.py
--rw-r--r--  2.0 unx    15993 b- defN 23-Mar-17 20:54 qumulo/commands/ad.py
--rw-r--r--  2.0 unx     5048 b- defN 23-Mar-17 20:54 qumulo/commands/analytics.py
--rw-r--r--  2.0 unx     6531 b- defN 23-Mar-17 20:54 qumulo/commands/audit.py
--rw-r--r--  2.0 unx    35605 b- defN 23-Mar-17 20:54 qumulo/commands/auth.py
--rw-r--r--  2.0 unx     1045 b- defN 23-Mar-17 20:54 qumulo/commands/checksumming.py
--rw-r--r--  2.0 unx    18179 b- defN 23-Mar-17 20:54 qumulo/commands/cluster.py
--rw-r--r--  2.0 unx     4605 b- defN 23-Mar-17 20:54 qumulo/commands/dns.py
--rw-r--r--  2.0 unx     1506 b- defN 23-Mar-17 20:54 qumulo/commands/encryption.py
--rw-r--r--  2.0 unx     2843 b- defN 23-Mar-17 20:54 qumulo/commands/file_permissions_help.py
--rw-r--r--  2.0 unx   130311 b- defN 23-Mar-17 20:54 qumulo/commands/fs.py
--rw-r--r--  2.0 unx     3933 b- defN 23-Mar-17 20:54 qumulo/commands/ftp.py
--rw-r--r--  2.0 unx     3603 b- defN 23-Mar-17 20:54 qumulo/commands/kerberos.py
--rw-r--r--  2.0 unx    12310 b- defN 23-Mar-17 20:54 qumulo/commands/ldap.py
--rw-r--r--  2.0 unx     6846 b- defN 23-Mar-17 20:54 qumulo/commands/login.py
--rw-r--r--  2.0 unx     1070 b- defN 23-Mar-17 20:54 qumulo/commands/metrics.py
--rw-r--r--  2.0 unx    18994 b- defN 23-Mar-17 20:54 qumulo/commands/multitenancy.py
--rw-r--r--  2.0 unx     9981 b- defN 23-Mar-17 20:54 qumulo/commands/multitenancy_nfs.py
--rw-r--r--  2.0 unx     8845 b- defN 23-Mar-17 20:54 qumulo/commands/multitenancy_smb.py
--rw-r--r--  2.0 unx    20655 b- defN 23-Mar-17 20:54 qumulo/commands/network.py
--rw-r--r--  2.0 unx    34897 b- defN 23-Mar-17 20:54 qumulo/commands/nfs.py
--rw-r--r--  2.0 unx     1015 b- defN 23-Mar-17 20:54 qumulo/commands/node_state.py
--rw-r--r--  2.0 unx    10630 b- defN 23-Mar-17 20:54 qumulo/commands/object_replication.py
--rw-r--r--  2.0 unx     6173 b- defN 23-Mar-17 20:54 qumulo/commands/quota.py
--rw-r--r--  2.0 unx     2531 b- defN 23-Mar-17 20:54 qumulo/commands/raw.py
--rw-r--r--  2.0 unx    32784 b- defN 23-Mar-17 20:54 qumulo/commands/replication.py
--rw-r--r--  2.0 unx    14355 b- defN 23-Mar-17 20:54 qumulo/commands/roles.py
--rw-r--r--  2.0 unx    15644 b- defN 23-Mar-17 20:54 qumulo/commands/s3.py
--rw-r--r--  2.0 unx     5323 b- defN 23-Mar-17 20:54 qumulo/commands/saml.py
--rw-r--r--  2.0 unx     3259 b- defN 23-Mar-17 20:54 qumulo/commands/shutdown.py
--rw-r--r--  2.0 unx    49507 b- defN 23-Mar-17 20:54 qumulo/commands/smb.py
--rw-r--r--  2.0 unx    30790 b- defN 23-Mar-17 20:54 qumulo/commands/snapshot.py
--rw-r--r--  2.0 unx     7403 b- defN 23-Mar-17 20:54 qumulo/commands/support.py
--rw-r--r--  2.0 unx     2935 b- defN 23-Mar-17 20:54 qumulo/commands/time_config.py
--rw-r--r--  2.0 unx     4604 b- defN 23-Mar-17 20:54 qumulo/commands/tree_delete.py
--rw-r--r--  2.0 unx     1403 b- defN 23-Mar-17 20:54 qumulo/commands/unconfigured_node_operations.py
--rw-r--r--  2.0 unx    21797 b- defN 23-Mar-17 20:54 qumulo/commands/upgrade.py
--rw-r--r--  2.0 unx      976 b- defN 23-Mar-17 20:54 qumulo/commands/version.py
--rw-r--r--  2.0 unx     7374 b- defN 23-Mar-17 20:54 qumulo/commands/web_ui.py
--rw-r--r--  2.0 unx      669 b- defN 23-Mar-17 20:54 qumulo/lib/__init__.py
--rw-r--r--  2.0 unx    12849 b- defN 23-Mar-17 20:54 qumulo/lib/acl_util.py
--rw-r--r--  2.0 unx     4047 b- defN 23-Mar-17 20:54 qumulo/lib/auth.py
--rw-r--r--  2.0 unx     1833 b- defN 23-Mar-17 20:54 qumulo/lib/duration.py
--rw-r--r--  2.0 unx    11107 b- defN 23-Mar-17 20:54 qumulo/lib/identity_util.py
--rw-r--r--  2.0 unx     2230 b- defN 23-Mar-17 20:54 qumulo/lib/obj.py
--rw-r--r--  2.0 unx     8874 b- defN 23-Mar-17 20:54 qumulo/lib/opts.py
--rw-r--r--  2.0 unx     6016 b- defN 23-Mar-17 20:54 qumulo/lib/qq.py
--rw-r--r--  2.0 unx    24972 b- defN 23-Mar-17 20:54 qumulo/lib/request.py
--rw-r--r--  2.0 unx     1058 b- defN 23-Mar-17 20:54 qumulo/lib/rest_util.py
--rw-r--r--  2.0 unx      926 b- defN 23-Mar-17 20:54 qumulo/lib/rfc3339.py
--rw-r--r--  2.0 unx     2009 b- defN 23-Mar-17 20:54 qumulo/lib/tenant.py
--rw-r--r--  2.0 unx     3350 b- defN 23-Mar-17 20:54 qumulo/lib/uri.py
--rw-r--r--  2.0 unx    14792 b- defN 23-Mar-17 20:54 qumulo/lib/util.py
--rw-r--r--  2.0 unx     1167 b- defN 23-Mar-17 20:54 qumulo/rest/__init__.py
--rw-r--r--  2.0 unx     4501 b- defN 23-Mar-17 20:54 qumulo/rest/access_tokens.py
--rw-r--r--  2.0 unx     7654 b- defN 23-Mar-17 20:54 qumulo/rest/ad.py
--rw-r--r--  2.0 unx     2204 b- defN 23-Mar-17 20:54 qumulo/rest/analytics.py
--rw-r--r--  2.0 unx     5909 b- defN 23-Mar-17 20:54 qumulo/rest/audit.py
--rw-r--r--  2.0 unx     8419 b- defN 23-Mar-17 20:54 qumulo/rest/auth.py
--rw-r--r--  2.0 unx      914 b- defN 23-Mar-17 20:54 qumulo/rest/checksumming.py
--rw-r--r--  2.0 unx     8793 b- defN 23-Mar-17 20:54 qumulo/rest/cluster.py
--rw-r--r--  2.0 unx     3056 b- defN 23-Mar-17 20:54 qumulo/rest/dns.py
--rw-r--r--  2.0 unx     1148 b- defN 23-Mar-17 20:54 qumulo/rest/encryption.py
--rw-r--r--  2.0 unx    45742 b- defN 23-Mar-17 20:54 qumulo/rest/fs.py
--rw-r--r--  2.0 unx     4531 b- defN 23-Mar-17 20:54 qumulo/rest/ftp.py
--rw-r--r--  2.0 unx     4410 b- defN 23-Mar-17 20:54 qumulo/rest/groups.py
--rw-r--r--  2.0 unx     2897 b- defN 23-Mar-17 20:54 qumulo/rest/kerberos.py
--rw-r--r--  2.0 unx     4490 b- defN 23-Mar-17 20:54 qumulo/rest/ldap.py
--rw-r--r--  2.0 unx     1251 b- defN 23-Mar-17 20:54 qumulo/rest/metrics.py
--rw-r--r--  2.0 unx     5484 b- defN 23-Mar-17 20:54 qumulo/rest/multitenancy.py
--rw-r--r--  2.0 unx     5260 b- defN 23-Mar-17 20:54 qumulo/rest/multitenancy_nfs.py
--rw-r--r--  2.0 unx     3616 b- defN 23-Mar-17 20:54 qumulo/rest/multitenancy_smb.py
--rw-r--r--  2.0 unx     8417 b- defN 23-Mar-17 20:54 qumulo/rest/network.py
--rw-r--r--  2.0 unx     8467 b- defN 23-Mar-17 20:54 qumulo/rest/nfs.py
--rw-r--r--  2.0 unx      910 b- defN 23-Mar-17 20:54 qumulo/rest/node_state.py
--rw-r--r--  2.0 unx     4468 b- defN 23-Mar-17 20:54 qumulo/rest/object_replication.py
--rw-r--r--  2.0 unx     3426 b- defN 23-Mar-17 20:54 qumulo/rest/quota.py
--rw-r--r--  2.0 unx    10612 b- defN 23-Mar-17 20:54 qumulo/rest/replication.py
--rw-r--r--  2.0 unx     6628 b- defN 23-Mar-17 20:54 qumulo/rest/roles.py
--rw-r--r--  2.0 unx     9857 b- defN 23-Mar-17 20:54 qumulo/rest/s3.py
--rw-r--r--  2.0 unx     2687 b- defN 23-Mar-17 20:54 qumulo/rest/saml.py
--rw-r--r--  2.0 unx     1944 b- defN 23-Mar-17 20:54 qumulo/rest/shutdown.py
--rw-r--r--  2.0 unx    11128 b- defN 23-Mar-17 20:54 qumulo/rest/smb.py
--rw-r--r--  2.0 unx    10951 b- defN 23-Mar-17 20:54 qumulo/rest/snapshot.py
--rw-r--r--  2.0 unx     3265 b- defN 23-Mar-17 20:54 qumulo/rest/support.py
--rw-r--r--  2.0 unx     1972 b- defN 23-Mar-17 20:54 qumulo/rest/time_config.py
--rw-r--r--  2.0 unx     2706 b- defN 23-Mar-17 20:54 qumulo/rest/tree_delete.py
--rw-r--r--  2.0 unx     1780 b- defN 23-Mar-17 20:54 qumulo/rest/unconfigured_node_operations.py
--rw-r--r--  2.0 unx     1960 b- defN 23-Mar-17 20:54 qumulo/rest/upgrade.py
--rw-r--r--  2.0 unx     2968 b- defN 23-Mar-17 20:54 qumulo/rest/upgrade_v2.py
--rw-r--r--  2.0 unx     1234 b- defN 23-Mar-17 20:54 qumulo/rest/upgrade_v3.py
--rw-r--r--  2.0 unx     4689 b- defN 23-Mar-17 20:54 qumulo/rest/users.py
--rw-r--r--  2.0 unx     1593 b- defN 23-Mar-17 20:54 qumulo/rest/version.py
--rw-r--r--  2.0 unx     3679 b- defN 23-Mar-17 20:54 qumulo/rest/web_ui.py
--rw-r--r--  2.0 unx    11358 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     3776 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/METADATA
--r--r--r--  2.0 unx      290 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/NOTICE
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       68 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     8567 b- defN 23-Mar-17 20:54 qumulo_api-6.0.2.dist-info/RECORD
-105 files, 931850 bytes uncompressed, 231477 bytes compressed:  75.2%
+Zip file size: 253263 bytes, number of entries: 107
+-rw-r--r--  2.0 unx       22 b- defN 23-May-08 23:57 qumulo/__init__.py
+-rw-r--r--  2.0 unx    10792 b- defN 23-May-08 23:57 qumulo/rest_client.py
+-rw-r--r--  2.0 unx     5463 b- defN 23-May-08 23:57 qumulo/retry.py
+-rw-r--r--  2.0 unx     1178 b- defN 23-May-08 23:57 qumulo/commands/__init__.py
+-rw-r--r--  2.0 unx     7430 b- defN 23-May-08 23:57 qumulo/commands/access_tokens.py
+-rw-r--r--  2.0 unx    15993 b- defN 23-May-08 23:57 qumulo/commands/ad.py
+-rw-r--r--  2.0 unx     5048 b- defN 23-May-08 23:57 qumulo/commands/analytics.py
+-rw-r--r--  2.0 unx     6531 b- defN 23-May-08 23:57 qumulo/commands/audit.py
+-rw-r--r--  2.0 unx    35605 b- defN 23-May-08 23:57 qumulo/commands/auth.py
+-rw-r--r--  2.0 unx     1045 b- defN 23-May-08 23:57 qumulo/commands/checksumming.py
+-rw-r--r--  2.0 unx    18179 b- defN 23-May-08 23:57 qumulo/commands/cluster.py
+-rw-r--r--  2.0 unx     4605 b- defN 23-May-08 23:57 qumulo/commands/dns.py
+-rw-r--r--  2.0 unx     1506 b- defN 23-May-08 23:57 qumulo/commands/encryption.py
+-rw-r--r--  2.0 unx     2843 b- defN 23-May-08 23:57 qumulo/commands/file_permissions_help.py
+-rw-r--r--  2.0 unx   129986 b- defN 23-May-08 23:57 qumulo/commands/fs.py
+-rw-r--r--  2.0 unx     3933 b- defN 23-May-08 23:57 qumulo/commands/ftp.py
+-rw-r--r--  2.0 unx     3603 b- defN 23-May-08 23:57 qumulo/commands/kerberos.py
+-rw-r--r--  2.0 unx    21410 b- defN 23-May-08 23:57 qumulo/commands/key_store.py
+-rw-r--r--  2.0 unx    12310 b- defN 23-May-08 23:57 qumulo/commands/ldap.py
+-rw-r--r--  2.0 unx     6846 b- defN 23-May-08 23:57 qumulo/commands/login.py
+-rw-r--r--  2.0 unx     1070 b- defN 23-May-08 23:57 qumulo/commands/metrics.py
+-rw-r--r--  2.0 unx    15745 b- defN 23-May-08 23:57 qumulo/commands/multitenancy.py
+-rw-r--r--  2.0 unx     9981 b- defN 23-May-08 23:57 qumulo/commands/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     8845 b- defN 23-May-08 23:57 qumulo/commands/multitenancy_smb.py
+-rw-r--r--  2.0 unx    20655 b- defN 23-May-08 23:57 qumulo/commands/network.py
+-rw-r--r--  2.0 unx    34897 b- defN 23-May-08 23:57 qumulo/commands/nfs.py
+-rw-r--r--  2.0 unx     1015 b- defN 23-May-08 23:57 qumulo/commands/node_state.py
+-rw-r--r--  2.0 unx    10630 b- defN 23-May-08 23:57 qumulo/commands/object_replication.py
+-rw-r--r--  2.0 unx     6173 b- defN 23-May-08 23:57 qumulo/commands/quota.py
+-rw-r--r--  2.0 unx     2531 b- defN 23-May-08 23:57 qumulo/commands/raw.py
+-rw-r--r--  2.0 unx    32784 b- defN 23-May-08 23:57 qumulo/commands/replication.py
+-rw-r--r--  2.0 unx    14355 b- defN 23-May-08 23:57 qumulo/commands/roles.py
+-rw-r--r--  2.0 unx    15644 b- defN 23-May-08 23:57 qumulo/commands/s3.py
+-rw-r--r--  2.0 unx     5323 b- defN 23-May-08 23:57 qumulo/commands/saml.py
+-rw-r--r--  2.0 unx     3259 b- defN 23-May-08 23:57 qumulo/commands/shutdown.py
+-rw-r--r--  2.0 unx    50961 b- defN 23-May-08 23:57 qumulo/commands/smb.py
+-rw-r--r--  2.0 unx    45290 b- defN 23-May-08 23:57 qumulo/commands/snapshot.py
+-rw-r--r--  2.0 unx     7403 b- defN 23-May-08 23:57 qumulo/commands/support.py
+-rw-r--r--  2.0 unx     2935 b- defN 23-May-08 23:57 qumulo/commands/time_config.py
+-rw-r--r--  2.0 unx     4604 b- defN 23-May-08 23:57 qumulo/commands/tree_delete.py
+-rw-r--r--  2.0 unx     1403 b- defN 23-May-08 23:57 qumulo/commands/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx    21797 b- defN 23-May-08 23:57 qumulo/commands/upgrade.py
+-rw-r--r--  2.0 unx      976 b- defN 23-May-08 23:57 qumulo/commands/version.py
+-rw-r--r--  2.0 unx     7374 b- defN 23-May-08 23:57 qumulo/commands/web_ui.py
+-rw-r--r--  2.0 unx      669 b- defN 23-May-08 23:57 qumulo/lib/__init__.py
+-rw-r--r--  2.0 unx    12849 b- defN 23-May-08 23:57 qumulo/lib/acl_util.py
+-rw-r--r--  2.0 unx     4047 b- defN 23-May-08 23:57 qumulo/lib/auth.py
+-rw-r--r--  2.0 unx     1833 b- defN 23-May-08 23:57 qumulo/lib/duration.py
+-rw-r--r--  2.0 unx    11107 b- defN 23-May-08 23:57 qumulo/lib/identity_util.py
+-rw-r--r--  2.0 unx     3551 b- defN 23-May-08 23:57 qumulo/lib/keys.py
+-rw-r--r--  2.0 unx     2230 b- defN 23-May-08 23:57 qumulo/lib/obj.py
+-rw-r--r--  2.0 unx     8873 b- defN 23-May-08 23:57 qumulo/lib/opts.py
+-rw-r--r--  2.0 unx     6016 b- defN 23-May-08 23:57 qumulo/lib/qq.py
+-rw-r--r--  2.0 unx    24972 b- defN 23-May-08 23:57 qumulo/lib/request.py
+-rw-r--r--  2.0 unx     1058 b- defN 23-May-08 23:57 qumulo/lib/rest_util.py
+-rw-r--r--  2.0 unx      926 b- defN 23-May-08 23:57 qumulo/lib/rfc3339.py
+-rw-r--r--  2.0 unx     2009 b- defN 23-May-08 23:57 qumulo/lib/tenant.py
+-rw-r--r--  2.0 unx     3350 b- defN 23-May-08 23:57 qumulo/lib/uri.py
+-rw-r--r--  2.0 unx    14792 b- defN 23-May-08 23:57 qumulo/lib/util.py
+-rw-r--r--  2.0 unx     1167 b- defN 23-May-08 23:57 qumulo/rest/__init__.py
+-rw-r--r--  2.0 unx     4501 b- defN 23-May-08 23:57 qumulo/rest/access_tokens.py
+-rw-r--r--  2.0 unx     7654 b- defN 23-May-08 23:57 qumulo/rest/ad.py
+-rw-r--r--  2.0 unx     2204 b- defN 23-May-08 23:57 qumulo/rest/analytics.py
+-rw-r--r--  2.0 unx     5909 b- defN 23-May-08 23:57 qumulo/rest/audit.py
+-rw-r--r--  2.0 unx     8419 b- defN 23-May-08 23:57 qumulo/rest/auth.py
+-rw-r--r--  2.0 unx      914 b- defN 23-May-08 23:57 qumulo/rest/checksumming.py
+-rw-r--r--  2.0 unx     8793 b- defN 23-May-08 23:57 qumulo/rest/cluster.py
+-rw-r--r--  2.0 unx     3056 b- defN 23-May-08 23:57 qumulo/rest/dns.py
+-rw-r--r--  2.0 unx     1148 b- defN 23-May-08 23:57 qumulo/rest/encryption.py
+-rw-r--r--  2.0 unx    49457 b- defN 23-May-08 23:57 qumulo/rest/fs.py
+-rw-r--r--  2.0 unx     4531 b- defN 23-May-08 23:57 qumulo/rest/ftp.py
+-rw-r--r--  2.0 unx     4410 b- defN 23-May-08 23:57 qumulo/rest/groups.py
+-rw-r--r--  2.0 unx     2897 b- defN 23-May-08 23:57 qumulo/rest/kerberos.py
+-rw-r--r--  2.0 unx     4490 b- defN 23-May-08 23:57 qumulo/rest/ldap.py
+-rw-r--r--  2.0 unx     1251 b- defN 23-May-08 23:57 qumulo/rest/metrics.py
+-rw-r--r--  2.0 unx     4909 b- defN 23-May-08 23:57 qumulo/rest/multitenancy.py
+-rw-r--r--  2.0 unx     5260 b- defN 23-May-08 23:57 qumulo/rest/multitenancy_nfs.py
+-rw-r--r--  2.0 unx     3616 b- defN 23-May-08 23:57 qumulo/rest/multitenancy_smb.py
+-rw-r--r--  2.0 unx     8417 b- defN 23-May-08 23:57 qumulo/rest/network.py
+-rw-r--r--  2.0 unx     8467 b- defN 23-May-08 23:57 qumulo/rest/nfs.py
+-rw-r--r--  2.0 unx      910 b- defN 23-May-08 23:57 qumulo/rest/node_state.py
+-rw-r--r--  2.0 unx     4468 b- defN 23-May-08 23:57 qumulo/rest/object_replication.py
+-rw-r--r--  2.0 unx     3426 b- defN 23-May-08 23:57 qumulo/rest/quota.py
+-rw-r--r--  2.0 unx    10612 b- defN 23-May-08 23:57 qumulo/rest/replication.py
+-rw-r--r--  2.0 unx     6628 b- defN 23-May-08 23:57 qumulo/rest/roles.py
+-rw-r--r--  2.0 unx     9857 b- defN 23-May-08 23:57 qumulo/rest/s3.py
+-rw-r--r--  2.0 unx     2687 b- defN 23-May-08 23:57 qumulo/rest/saml.py
+-rw-r--r--  2.0 unx     1944 b- defN 23-May-08 23:57 qumulo/rest/shutdown.py
+-rw-r--r--  2.0 unx    11128 b- defN 23-May-08 23:57 qumulo/rest/smb.py
+-rw-r--r--  2.0 unx    12813 b- defN 23-May-08 23:57 qumulo/rest/snapshot.py
+-rw-r--r--  2.0 unx     3265 b- defN 23-May-08 23:57 qumulo/rest/support.py
+-rw-r--r--  2.0 unx     1972 b- defN 23-May-08 23:57 qumulo/rest/time_config.py
+-rw-r--r--  2.0 unx     2706 b- defN 23-May-08 23:57 qumulo/rest/tree_delete.py
+-rw-r--r--  2.0 unx     1780 b- defN 23-May-08 23:57 qumulo/rest/unconfigured_node_operations.py
+-rw-r--r--  2.0 unx     1960 b- defN 23-May-08 23:57 qumulo/rest/upgrade.py
+-rw-r--r--  2.0 unx     2968 b- defN 23-May-08 23:57 qumulo/rest/upgrade_v2.py
+-rw-r--r--  2.0 unx     1234 b- defN 23-May-08 23:57 qumulo/rest/upgrade_v3.py
+-rw-r--r--  2.0 unx     4689 b- defN 23-May-08 23:57 qumulo/rest/users.py
+-rw-r--r--  2.0 unx     1593 b- defN 23-May-08 23:57 qumulo/rest/version.py
+-rw-r--r--  2.0 unx     3679 b- defN 23-May-08 23:57 qumulo/rest/web_ui.py
+-rw-r--r--  2.0 unx    11358 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3776 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/METADATA
+-r--r--r--  2.0 unx      290 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/NOTICE
+-rw-r--r--  2.0 unx       92 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       68 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     8728 b- defN 23-May-08 23:57 qumulo_api-6.1.0.dist-info/RECORD
+107 files, 974368 bytes uncompressed, 239767 bytes compressed:  75.4%
```

## zipnote {}

```diff
@@ -45,14 +45,17 @@
 
 Filename: qumulo/commands/ftp.py
 Comment: 
 
 Filename: qumulo/commands/kerberos.py
 Comment: 
 
+Filename: qumulo/commands/key_store.py
+Comment: 
+
 Filename: qumulo/commands/ldap.py
 Comment: 
 
 Filename: qumulo/commands/login.py
 Comment: 
 
 Filename: qumulo/commands/metrics.py
@@ -138,14 +141,17 @@
 
 Filename: qumulo/lib/duration.py
 Comment: 
 
 Filename: qumulo/lib/identity_util.py
 Comment: 
 
+Filename: qumulo/lib/keys.py
+Comment: 
+
 Filename: qumulo/lib/obj.py
 Comment: 
 
 Filename: qumulo/lib/opts.py
 Comment: 
 
 Filename: qumulo/lib/qq.py
@@ -288,29 +294,29 @@
 
 Filename: qumulo/rest/version.py
 Comment: 
 
 Filename: qumulo/rest/web_ui.py
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/LICENSE
+Filename: qumulo_api-6.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/METADATA
+Filename: qumulo_api-6.1.0.dist-info/METADATA
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/NOTICE
+Filename: qumulo_api-6.1.0.dist-info/NOTICE
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/WHEEL
+Filename: qumulo_api-6.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/entry_points.txt
+Filename: qumulo_api-6.1.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/top_level.txt
+Filename: qumulo_api-6.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: qumulo_api-6.0.2.dist-info/RECORD
+Filename: qumulo_api-6.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qumulo/__init__.py

```diff
@@ -1 +1 @@
-__version__ = "6.0.2"
+__version__ = "6.1.0"
```

## qumulo/commands/__init__.py

```diff
@@ -21,14 +21,15 @@
     cluster,
     dns,
     encryption,
     file_permissions_help,
     fs,
     ftp,
     kerberos,
+    key_store,
     ldap,
     login,
     metrics,
     multitenancy,
     multitenancy_nfs,
     multitenancy_smb,
     network,
```

## qumulo/commands/fs.py

```diff
@@ -3554,39 +3554,36 @@
     NAME = 'fs_set_notify_settings'
     SYNOPSIS = 'Set FS notify settings'
 
     DESCRIPTION = SYNOPSIS + textwrap.dedent(
         """
         Change global FS settings for notify and change watch.
 
-        There is one setting for recursive mode. The use of recursive mode may have
-        performance impact for some workloads, so be default, recursive change watches
-        are disabled. These are the available modes:
+        Available modes:
 
         DISABLED_ERROR
-            Recursive change notify requests will immediately return an error. This is
-            the default setting as it avoids the performance impact of recursive
-            notifications while clearly presenting errors when applications try to
-            initiate a recursive watch.
+            Recursive change-notify requests return errors immediately.
 
         DISABLED_IGNORE
             Recursive change notify requests will be accepted, but notifications will
             only be sent for the top level directory being watched. In other words, it
             will behave as if the recursive flag was not provided. This setting can be
             used to improve compatibility with applications that request recursion but
             don't actually depend on it. For some applications, however, this can cause
             hangs or other unexpected behavior when recursion is needed in order to
             function properly.
 
         ENABLED
             Real recursive change notify support. Notifications for all descendants of
-            the watched directory will be pushed to the watcher. It can be quite
-            expensive in term of performance. For example, consider that a watch on the
-            root of the file system will receive a notification for every single change
-            on the entire cluster."""
+            the watched directory are pushed to the watcher. It can be quite expensive
+            in term of performance. For example, consider that a watch on the root of
+            the file system will receive a notification for every single change on the
+            entire cluster. ENABLED is the default mode unless configured otherwise
+            using this command.
+        """
     )
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         parser.add_argument(
             '--recursive-mode',
             help='Notify recursive mode to set (ENABLED, DISABLED_ERROR, DISABLED_IGNORE)',
```

## qumulo/commands/multitenancy.py

```diff
@@ -12,15 +12,15 @@
 
 import argparse
 import textwrap
 
 import qumulo.lib.opts
 
 from qumulo.lib.request import pretty_json
-from qumulo.rest.multitenancy import TenantConfigCreate, TenantConfigCreateFirst, TenantConfigPatch
+from qumulo.rest.multitenancy import TenantConfigCreate, TenantConfigPatch
 from qumulo.rest_client import RestClient
 
 
 class CreateTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_create_tenant'
     SYNOPSIS = 'Create a tenant'
     DESCRIPTION = textwrap.dedent(
@@ -28,20 +28,14 @@
     {SYNOPSIS}
 
     Multitenancy allows access to different management and data protocols to be isolated to specific
     tenants by network, including tagged VLANs or the untagged network. Individual services can be
     enabled or disabled for each tenant to allow or disallow access to that protocol on the networks
     associated with the tenant.
 
-    By default, when no tenants are configured, all multitenancy-aware services are available on all
-    networks to which the cluster is connected, excepting those services which must be explicitly
-    enabled cluster-wide through their own separate server settings.
-
-    The first tenant must be created using multitenancy_enable.
-
     WARNING: It is possible for access to services to be disabled on all networks, including
     management services such as the REST API, Web UI, and SSH, effectively disabling remote
     administrative access to the cluster. Management services are always available locally through
     a remote or physical server console.
     """
     )
 
@@ -170,55 +164,14 @@
             nfs_enabled=args.nfs_enabled,
             smb_enabled=args.smb_enabled,
             networks=args.network_id,
         )
         print(pretty_json(rest_client.multitenancy.create_tenant(config).data.to_dict()))
 
 
-class EnableMultitenancyCommand(qumulo.lib.opts.Subcommand):
-    NAME = 'multitenancy_enable'
-    SYNOPSIS = 'Enable multitenancy and create the first tenant'
-    DESCRIPTION = textwrap.dedent(
-        f"""
-    {SYNOPSIS}
-
-    Multitenancy allows access to different management and data protocols to be isolated to specific
-    tenants by network, including tagged VLANs or the untagged network. Individual services can be
-    enabled or disabled for each tenant to allow or disallow access to that protocol on the networks
-    associated with the tenant.
-
-    By default, when no tenants are configured, all multitenancy-aware services are available on all
-    networks to which the cluster is connected, excepting those services which must be explicitly
-    enabled cluster-wide through their own separate server settings.
-
-    When multitenancy is enabled, the first tenant is created and all existing networks and
-    tenant-assignable resources are automatically assigned to this tenant. All multitenancy-aware
-    services are enabled to start but may be disabled through multitenancy_modify_tenant. Additional
-    tenants may be created through multitenancy_create_tenant. New networks and tenant-assignable
-    resources must be explicitly assigned to a tenant.
-
-    WARNING: It is possible for access to services to be disabled on all networks, including
-    management services such as the REST API, Web UI, and SSH, effectively disabling remote
-    administrative access to the cluster. Management services are always available locally through
-    a remote or physical server console.
-    """
-    )
-
-    @staticmethod
-    def options(parser: argparse.ArgumentParser) -> None:
-        parser.add_argument(
-            '--name', type=str, help='Unique name of the tenant chosen by the user.', required=True
-        )
-
-    @staticmethod
-    def main(rest_client: RestClient, args: argparse.Namespace) -> None:
-        config = TenantConfigCreateFirst(name=args.name)
-        print(pretty_json(rest_client.multitenancy.create_first_tenant(config).data.to_dict()))
-
-
 class GetTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_get_tenant'
     SYNOPSIS = 'Get a tenant'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
@@ -242,18 +195,17 @@
 class DeleteTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_delete_tenant'
     SYNOPSIS = 'Delete a tenant'
     DESCRIPTION = textwrap.dedent(
         f"""
     {SYNOPSIS}
 
-    A tenant may only be deleted if it has no networks assigned.  Use the
-    `multitenancy_modify_tenant` or `multitenancy_reassign_network` commands to unassign or reassign
-    any associated networks before deleting a tenant. See `multitenancy_disable` to remove the last
-    tenant.
+    A tenant may only be deleted if it has no networks assigned. Use the
+    `multitenancy_modify_tenant` or `network_mod_network` commands to unassign or reassign
+    any associated networks before deleting a tenant. The last tenant cannot be deleted.
     """
     )
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
             '--id', type=int, help='The unique ID of the tenant to delete.', required=True
@@ -261,19 +213,15 @@
         parser.add_argument('--force', action='store_true', help='Do not prompt')
 
     @staticmethod
     def _ask_confirmation(rest_client: RestClient, tenant_id: int) -> bool:
         cls = DeleteTenantCommand
         tenants = rest_client.multitenancy.list_tenants()
         if len(tenants) == 1:
-            msg = (
-                'Cannot delete the last tenant in this way. See `multitenancy_disable` to remove '
-                'the last tenant.'
-            )
-            print(msg)
+            print('Cannot delete the last tenant.')
             return False
         else:
             exports = rest_client.nfs.nfs_list_exports()['entries']
             num_exports = sum(1 for export in exports if export['tenant_id'] == tenant_id)
             shares = rest_client.smb.smb_list_shares()['entries']
             num_shares = sum(1 for share in shares if share['tenant_id'] == tenant_id)
             confirmation = (
@@ -286,33 +234,14 @@
 
     @staticmethod
     def main(rest_client: RestClient, args: argparse.Namespace) -> None:
         if args.force or DeleteTenantCommand._ask_confirmation(rest_client, args.id):
             rest_client.multitenancy.delete_tenant(args.id)
 
 
-class DisableMultitenancyCommand(qumulo.lib.opts.Subcommand):
-    NAME = 'multitenancy_disable'
-    SYNOPSIS = 'Delete the last tenant and disable multitenancy'
-    DESCRIPTION = textwrap.dedent(
-        f"""
-    {SYNOPSIS}
-
-    Deletes the last and only tenant. See `multitenancy_delete_tenant` to delete tenants.
-
-    WARNING: Disabling multitenancy will delete the last tenant, immediately unassigning any
-    networks and making all services accessible on all configured networks.
-    """
-    )
-
-    @staticmethod
-    def main(rest_client: RestClient, _: argparse.Namespace) -> None:
-        rest_client.multitenancy.delete_last_tenant()
-
-
 class ModifyTenantCommand(qumulo.lib.opts.Subcommand):
     NAME = 'multitenancy_modify_tenant'
     SYNOPSIS = 'Modify a tenant'
 
     @staticmethod
     def options(parser: argparse.ArgumentParser) -> None:
         parser.add_argument(
```

## qumulo/commands/smb.py

```diff
@@ -340,55 +340,75 @@
 
     return acl.acl
 
 
 def _add_network_permissions_args(parser: argparse.ArgumentParser) -> None:
     net_group = parser.add_argument_group(
         'Network Permissions',
-        'Options for controlling share access by client address. '
-        'By default, all hosts are permitted whatever rights are granted by '
-        'both share and file permissions.',
+        textwrap.dedent(
+            """
+            Options for controlling share access by client address. By default, all hosts are
+            permitted whatever rights are granted by both share and file permissions.
+
+            You can add multiple entries per Deny or Allow option by providing a space-separated
+            list of IP addresses or subnet ranges in CIDR notation. You can also use the wildcard
+            "*" (including quotes to prevent shell expansion) to represent all addresses.
+
+            To remove all entries and return to the default state apply --full-control-hosts "*".
+
+            Examples of acceptable entries:
+
+            Single IP address: 172.16.33.10
+            IP address ranges: 10.120.150.50-60 (.50 to .60 inclusive)
+            Space-separated list of IP addresses: 10.0.10.10 10.0.10.20
+            Subnet ranges in CIDR notation: 10.120.0.0/16
+            Space-separated combinations of any of the above: 10.200.0.10 10.220.0.0/16 10.120.1.10-15
+            """
+        ),
     )
     net_group.add_argument(
         '--full-control-hosts',
         type=str_decode,
         nargs='+',
         default=None,
-        metavar='RANGE',
-        help=(
-            'Address ranges which should be permitted all access that '
-            'is also granted by share permissions and file permissions. '
-            'May be individual IP addresses, CIDR masks (e.g. 10.1.2.0/24), '
-            'or ranges (e.g. 10.2.3.23-47, fd00::42:1fff-c000).'
-        ),
+        metavar='IP/RANGE',
+        help="""
+            Host addresses or subnet ranges which should be permitted all access that is also
+            granted by share permissions and file permissions.
+            """,
     )
     net_group.add_argument(
         '--read-only-hosts',
         type=str_decode,
         nargs='+',
         default=None,
-        metavar='RANGE',
+        metavar='IP/RANGE',
         help='Address ranges which should be permitted read-only access at most.',
     )
     net_group.add_argument(
         '--deny-hosts',
         type=str_decode,
         nargs='+',
         default=None,
-        metavar='RANGE',
-        help=(
-            'Address ranges which should be denied access to this '
-            'share, regardless of other permissions.'
-        ),
+        metavar='IP/RANGE',
+        help="""
+            Host addresses or subnet ranges which should be denied access to this share, regardless
+            of other permissions. Applying this option by itself will result in all hosts being
+            denied access, so please ensure that you also add the appropriate --full-control-hosts
+            or --read-only-hosts entries.
+            """,
     )
     net_group.add_argument(
         '--deny-all-hosts',
         default=False,
         action='store_true',
-        help='Deny all access to this share.',
+        help="""
+            Deny all access to this share. It is an error to apply this option in concert with any
+            of the other options.
+            """,
     )
 
 
 def _net_permissions_from_args(
     args: argparse.Namespace, default: Optional[List[Dict[str, Any]]]
 ) -> Optional[List[Dict[str, Any]]]:
     have_hosts = (None, None, None) != (
@@ -447,27 +467,27 @@
             action='store_true',
             help='Creates the specified file system path if it does not exist',
         )
         parser.add_argument(
             '--default-file-create-mode',
             type=str_decode,
             default=None,
-            help=(
-                'Default POSIX file create mode bits on this SMB share (octal, 0644 will be used '
-                'if not provided)'
-            ),
+            help="""
+                Change default POSIX file create mode bits (octal) on this SMB share. This option
+                has no effect if an inheritable ACE in present in the permissions ACL.
+                """,
         )
         parser.add_argument(
             '--default-directory-create-mode',
             type=str_decode,
             default=None,
-            help=(
-                'Default POSIX directory create mode bits on this SMB share (octal, 0755 will be '
-                'used if not provided)'
-            ),
+            help="""
+                Change default POSIX directory create mode bits (octal) on this SMB share. This
+                option has no effect if an inheritable ACE in present in the permissions ACL.
+                """,
         )
 
         parser.add_argument(
             '--require-encryption',
             type=bool_from_string,
             default=False,
             metavar='{true,false}',
@@ -599,21 +619,27 @@
             action='store_true',
             help='Creates the specified file system path if it does not exist',
         )
         parser.add_argument(
             '--default-file-create-mode',
             type=str_decode,
             default=None,
-            help='Change default POSIX file create mode bits (octal) on this SMB share',
+            help="""
+                Set default POSIX file create mode bits (octal) on this SMB share. This option has
+                no effect if an inheritable ACE in present in the permissions ACL.
+                """,
         )
         parser.add_argument(
             '--default-directory-create-mode',
             type=str_decode,
             default=None,
-            help='Change default POSIX directory create mode bits (octal) on this SMB share',
+            help="""
+                Set default POSIX directory create mode bits (octal) on this SMB share. This option
+                has no effect if an inheritable ACE in present in the permissions ACL.
+                """,
         )
         parser.add_argument(
             '--require-encryption',
             type=bool_from_string,
             default=False,
             metavar='{true,false}',
             help=(
```

## qumulo/commands/snapshot.py

```diff
@@ -8,17 +8,19 @@
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
 import re
+import textwrap
 
-from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser, Namespace, SUPPRESS
+from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser, FileType, Namespace, SUPPRESS
 from datetime import datetime
+from enum import Enum
 from typing import Any, Dict, Mapping, Optional, Sequence, Tuple
 
 import qumulo.lib.opts
 import qumulo.lib.request as request
 import qumulo.rest.fs as fs
 import qumulo.rest.snapshot as snapshot
 
@@ -28,50 +30,56 @@
 
 EXPIRATION_HELP_MSG = (
     'Time of snapshot expiration. An empty string indicates that the snapshot never expires. '
     'The time format follows RFC 3339, a normalized subset of ISO 8601.'
 )
 
 POLICY_TTL_HELP = (
-    'Duration after which to expire snapshots created by this '
-    'policy, in format <quantity><units>, where <quantity> is a positive '
-    'integer less than 100 and <units> is one of [months, weeks, days, hours, '
-    'minutes], For example, 5days or 1hours. Empty string or never indicates snapshots '
-    'should never expire.'
+    'The time duration after which the snapshots created by using this policy expire. Format:'
+    ' <quantity><units>, where <quantity> is a positive integer less than 100 and <units> is one of'
+    ' the following values: months, weeks, days, hours, minutes. The following are example time'
+    ' durations: 5days, 1hours. An empty string or the word "never" indicates that snapshots never'
+    ' expire.'
 )
 
 PERIOD_HELP = (
     'How often to take a snapshot, in the format <quantity><units>, '
     'where <quantity> is a positive integer less than 100 and <units> is one '
     'of [hours, minutes], For example, 5minutes or 6hours.'
 )
 
 NAME_TEMPLATE_HELP = (
-    'Template for custom naming of policy snapshots. '
-    'Available variables: {ID}, {Year}, {Month}, {Day}, {Hour}, {Minute}, {Policy}, {Directory}. '
-    'For example, {ID}_snapshot_taken_at_{Hour}_{Minute}.'
-    '(default: {ID}_{Policy} for snapshots on root directory. '
-    '{ID}_{Policy}_{Directory} for all other directory snapshots.) '
+    'A template for custom policy snapshot naming. Available variables: {ID}, {Year}, {Month},'
+    ' {Day}, {Hour}, {Minute}, {Policy}, {Directory}. The following is an example custom policy'
+    ' snapshot name: {ID}_snapshot_taken_at_{Hour}_{Minute}. The default name is {ID}_{Policy} for'
+    ' snapshots of the root directory and {ID}_{Policy}_{Directory} for all other directory'
+    ' snapshots.'
 )
 
 
+# XXX dog: delete in 6.2.0
 class ListAllSnapshotsCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_list_snapshots'
 
-    SYNOPSIS = 'List all snapshots'
+    SYNOPSIS = SUPPRESS
+
+    DESCRIPTION = (
+        'This command is deprecated. Use the qq snapshot_list_statuses command to list the'
+        ' information for all snapshots.'
+    )
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         group = parser.add_mutually_exclusive_group(required=False)
         group.add_argument(
             '--exclude-in-delete',
             action='store_const',
             const=snapshot.InDeleteFilter.EXCLUDE_IN_DELETE,
             dest='in_delete_filter',
-            help='Exclude all snapshots in process of being deleted.',
+            help='Exclude all snapshots in process of being deleted from the list',
         )
         group.add_argument(
             '--only-in-delete',
             action='store_const',
             const=snapshot.InDeleteFilter.ONLY_IN_DELETE,
             dest='in_delete_filter',
             help='Display only snapshots in process of being deleted.',
@@ -83,23 +91,29 @@
             args.in_delete_filter if args.in_delete_filter else snapshot.InDeleteFilter.ALL
         )
         print(
             snapshot.list_snapshots(rest_client.conninfo, rest_client.credentials, in_delete_filter)
         )
 
 
+# XXX dog: delete in 6.2.0
 class GetSnapshotCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_get_snapshot'
 
-    SYNOPSIS = 'Get a single snapshot'
+    SYNOPSIS = SUPPRESS
+
+    DESCRIPTION = (
+        'This command is deprecated. Use the qq snapshot_get_status command to list the information'
+        ' for a single snapshot.'
+    )
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         parser.add_argument(
-            '-i', '--id', type=int, required=True, help='Identifier of the snapshot to list.'
+            '-i', '--id', type=int, required=True, help='The identifier of the snapshot to list.'
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
         print(snapshot.get_snapshot(rest_client.conninfo, rest_client.credentials, args.id))
 
 
@@ -133,33 +147,68 @@
                 args.expiration,
                 args.source_file_id,
                 args.path,
             )
         )
 
 
+class LockingObject(Enum):
+    SNAPSHOT = 'snapshot'
+    SNAPSHOT_POLICY = 'snapshot policy'
+
+
+def modify_expiration_when_locked_prompt_confirmed(
+    object_type: LockingObject, object_id: int
+) -> bool:
+    return qumulo.lib.opts.ask(
+        f'{object_type.value} expiration time change',
+        f'You are requesting to change the expiration time for locked {object_type.value}'
+        f' {object_id}.\nImportant: Unless you unlock a snapshot first, you cannot modify or delete'
+        ' a locked snapshot before its expiration time.Change the expiration time?',
+    )
+
+
 class ModifySnapshotCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_modify_snapshot'
 
     SYNOPSIS = 'Modify an existing snapshot'
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
-        parser.add_argument('-i', '--id', type=int, required=True, help='Snapshot ID')
+        parser.add_argument(
+            '-i', '--id', type=int, required=True, help='Identifier of the snapshot to modify.'
+        )
         parser.add_argument(
             '-e', '--expiration', type=str_decode, default=None, help=EXPIRATION_HELP_MSG
         )
+        parser.add_argument(
+            '-f',
+            '--force',
+            action='store_true',
+            help='Do not prompt for confirmation. The default setting is "false".',
+        )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
-        print(
-            snapshot.modify_snapshot(
-                rest_client.conninfo, rest_client.credentials, args.id, args.expiration
+        def snapshot_is_locked() -> bool:
+            response = snapshot.get_snapshot_status(
+                rest_client.conninfo, rest_client.credentials, args.id
+            )
+            return response.data['lock_key'] is not None
+
+        if (
+            args.force
+            or not snapshot_is_locked()
+            or modify_expiration_when_locked_prompt_confirmed(LockingObject.SNAPSHOT, args.id)
+        ):
+            print(
+                snapshot.modify_snapshot(
+                    rest_client.conninfo, rest_client.credentials, args.id, args.expiration
+                )
             )
-        )
 
 
 class DeleteSnapshotCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_delete_snapshot'
 
     SYNOPSIS = 'Delete a single snapshot'
 
@@ -171,55 +220,85 @@
     def main(rest_client: RestClient, args: Namespace) -> None:
         snapshot.delete_snapshot(rest_client.conninfo, rest_client.credentials, args.id)
 
 
 class ListAllSnapshotStatusesCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_list_statuses'
 
-    SYNOPSIS = 'List all snapshot statuses'
+    SYNOPSIS = 'List the information for every snapshot.'
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
-        group = parser.add_mutually_exclusive_group(required=False)
-        group.add_argument(
+        in_delete_filter = parser.add_mutually_exclusive_group(required=False)
+        in_delete_filter.add_argument(
             '--exclude-in-delete',
             action='store_const',
-            const=snapshot.InDeleteFilter.EXCLUDE_IN_DELETE,
+            const=snapshot.SnapshotStatusFilter.EXCLUDE_IN_DELETE,
             dest='in_delete_filter',
-            help='Exclude all snapshots in process of being deleted.',
+            help=(
+                'Exclude all snapshots in process of being deleted from the list. You can use this'
+                ' flag together with the --exclude-locked or --only-locked flag.'
+            ),
         )
-        group.add_argument(
+        in_delete_filter.add_argument(
             '--only-in-delete',
             action='store_const',
-            const=snapshot.InDeleteFilter.ONLY_IN_DELETE,
+            const=snapshot.SnapshotStatusFilter.ONLY_IN_DELETE,
             dest='in_delete_filter',
-            help='Display only snapshots in process of being deleted.',
+            help=(
+                'Display only snapshots in process of being deleted. You can use this flag together'
+                ' with the  --exclude-locked or --only-locked flag.'
+            ),
+        )
+        locked_filter = parser.add_mutually_exclusive_group(required=False)
+        locked_filter.add_argument(
+            '--exclude-locked',
+            action='store_const',
+            const=snapshot.SnapshotStatusFilter.EXCLUDE_LOCKED,
+            dest='locked_filter',
+            help=(
+                'Exclude all locked snapshots from the list. You can use this flag together with'
+                ' the  --exclude-in-delete or --only-in-delete flag.'
+            ),
+        )
+        locked_filter.add_argument(
+            '--only-locked',
+            action='store_const',
+            const=snapshot.SnapshotStatusFilter.ONLY_LOCKED,
+            dest='locked_filter',
+            help=(
+                'List only locked snapshots. You can use this flag together with the'
+                ' --exclude-in-delete or --only-in-delete flag.'
+            ),
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
-        in_delete_filter = (
-            args.in_delete_filter if args.in_delete_filter else snapshot.InDeleteFilter.ALL
-        )
+        snapshot_status_filter = []
+        if args.in_delete_filter:
+            snapshot_status_filter.append(args.in_delete_filter)
+        if args.locked_filter:
+            snapshot_status_filter.append(args.locked_filter)
+
         print(
             snapshot.list_snapshot_statuses(
-                rest_client.conninfo, rest_client.credentials, in_delete_filter
+                rest_client.conninfo, rest_client.credentials, snapshot_status_filter
             )
         )
 
 
 class GetSnapshotStatusCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_get_status'
 
-    SYNOPSIS = 'Get a single snapshot status'
+    SYNOPSIS = 'Get the information for a single snapshot.'
 
     @staticmethod
     def options(parser: ArgumentParser) -> None:
         parser.add_argument(
-            '-i', '--id', type=int, required=True, help='Identifier of the snapshot.'
+            '-i', '--id', type=int, required=True, help='The identifier of the snapshot to list.'
         )
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
         print(snapshot.get_snapshot_status(rest_client.conninfo, rest_client.credentials, args.id))
 
 
@@ -309,14 +388,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_hourly_or_less(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def get_schedule_daily(args: Namespace) -> Mapping[str, object]:
     try:
         at_time_of_day = datetime.strptime(args.at, '%H:%M')
@@ -342,14 +422,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_daily(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def get_schedule_monthly(args: Namespace) -> Mapping[str, object]:
     try:
         at_time_of_day = datetime.strptime(args.at, '%H:%M')
@@ -375,14 +456,15 @@
             args.name,
             get_schedule_info(
                 get_schedule_monthly(args), args.time_to_live if args.time_to_live else ''
             ),
             args.snapshot_name_template,
             args.file_id,
             args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def add_hourly_specific_args(hourly_parser: ArgumentParser) -> None:
     hourly_parser.add_argument(
         '-s',
@@ -424,43 +506,44 @@
 def add_general_schedule_args(schedule_parser: ArgumentParser) -> None:
     schedule_parser.add_argument(
         '-z',
         '--timezone',
         type=str_decode,
         default='UTC',
         help=(
-            'The time zone according to which the schedule is interpreted. '
-            '(For example: America/Los_Angeles or UTC). For a complete list of supported time '
-            'zones, see the qq time_list_timezones command.'
+            'The time zone according to which the system interprets the schedule, UTC by default.'
+            ' For example: America/Los_Angeles or UTC. For a complete list of supported time zones,'
+            ' see the qq time_list_timezones command.'
         ),
     )
 
 
 # Shared by hourly and daily subcommands
 hourly_daily_common_parser = ArgumentParser(add_help=False)
 hourly_daily_common_parser.add_argument(
     '-d',
     '--days-of-week',
     type=str_decode,
     default='ALL',
     help=(
-        'Days of the week to allow snapshots. Comma separated list '
-        '(For example: MON,TUE,WED,THU,FRI,SAT,SUN,ALL).'
+        'The days of the week on which to allow the system to take snapshots. Enter the days as a'
+        ' comma-separated list. For example: MON,TUE,WED,THU,FRI,SAT,SUN or ALL. The default'
+        ' setting is ALL.'
     ),
 )
 
 # Shared by daily and monthly subcommands
 daily_monthly_common_parser = ArgumentParser(add_help=False)
 daily_monthly_common_parser.add_argument(
     '-a',
     '--at',
     type=str_decode,
     required=True,
     default=SUPPRESS,
-    help='Take a snapshot at this time of day, in 24-hour format. (For example: 20:00)',
+    help='The time of day at which to take a snapshot, in 24-hour format. For example: 20:00.',
 )
 
 
 class CreatePolicyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_create_policy'
 
     SYNOPSIS = 'Create a new snapshot scheduling policy.'
@@ -474,38 +557,38 @@
         common_parser = ArgumentParser(add_help=False)
         common_parser.add_argument(
             '-n',
             '--name',
             type=str_decode,
             required=True,
             default=SUPPRESS,
-            help='Name of the policy',
+            help='The policy name.',
         )
         parser.set_defaults(name=None)
         common_parser.add_argument(
             '--snapshot-name-template', type=str_decode, default=SUPPRESS, help=NAME_TEMPLATE_HELP
         )
         parser.set_defaults(snapshot_name_template=None)
 
         # Directory
         group = common_parser.add_mutually_exclusive_group(required=False)
         group.add_argument(
             '--path',
             type=str_decode,
             default=SUPPRESS,
-            help='Path of directory upon which to take snapshots.',
+            help='The path to the directory from which to take snapshots.',
         )
         parser.set_defaults(path=None)
         group.add_argument(
             '--file-id',
             type=str_decode,
             default=SUPPRESS,
             help=(
-                'ID of directory upon which to take snapshots. (Defaults to root directory if no '
-                'path and no file id is given.)'
+                'The identifier of the directory from which to take snapshots. If you do not'
+                ' specify a path and a file ID, this flag uses the root directory by default.'
             ),
         )
         parser.set_defaults(file_id=None)
         common_parser.add_argument(
             '-t', '--time-to-live', type=str_decode, default=SUPPRESS, help=POLICY_TTL_HELP
         )
         parser.set_defaults(time_to_live=None)
@@ -514,25 +597,51 @@
         # Enabled?
         group = common_parser.add_mutually_exclusive_group(required=False)
         group.add_argument(
             '--enabled',
             dest='enabled',
             action='store_true',
             default=SUPPRESS,
-            help='Create policy enabled (This is the default).',
+            help='Create and enable policy. This is the default setting.',
         )
         group.add_argument(
             '--disabled',
             dest='enabled',
             action='store_false',
             default=SUPPRESS,
-            help='Create policy disabled.',
+            help='Create but do not enable policy.',
         )
         parser.set_defaults(enabled=None)
 
+        key_ref_group = common_parser.add_mutually_exclusive_group(required=False)
+        key_ref_group.add_argument(
+            '-k',
+            '--lock-key-id',
+            type=int,
+            help=(
+                'The identifier of the key in the file system key store that protects all snapshots'
+                ' created with this policy in the future.'
+            ),
+        )
+        key_ref_group.add_argument(
+            '--lock-key-name',
+            type=str,
+            help=(
+                'The name of the key in the file system key store that protects all snapshots'
+                ' created with this policy in the future.'
+            ),
+        )
+
+        common_parser.add_argument(
+            '-f',
+            '--force',
+            action='store_true',
+            help='Do not prompt for confirmation. The default setting is "false".',
+        )
+
         # Hourly or less subparser
         hourly_parser = subparsers.add_parser(
             'hourly_or_less',
             parents=[common_parser, hourly_daily_common_parser],
             formatter_class=ArgumentDefaultsHelpFormatter,
         )
         add_hourly_specific_args(hourly_parser)
@@ -553,33 +662,54 @@
             formatter_class=ArgumentDefaultsHelpFormatter,
         )
         add_monthly_specific_args(monthly_parser)
         monthly_parser.set_defaults(command=create_monthly)
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
+        lock_key_ref = lock_key_ref_from_args(args)
+
         if args.path:
             attr = fs.get_file_attr(rest_client.conninfo, rest_client.credentials, path=args.path)
             args.file_id = attr.lookup('file_number')
 
-        args.command(rest_client.conninfo, rest_client.credentials, args)
+        if (
+            not (lock_key_ref and lock_key_ref.ref is not None)
+            or args.force
+            or locking_prompt_confirmed(
+                rest_client, lock_key_ref.ref, LockingObject.SNAPSHOT_POLICY, args.name
+            )
+        ):
+            args.command(rest_client.conninfo, rest_client.credentials, args)
+
+
+def lock_key_ref_from_args(args: Namespace) -> Optional[snapshot.LockKeyRef]:
+    if args.lock_key_id is not None:
+        return snapshot.LockKeyRef(str(args.lock_key_id))
+    elif args.lock_key_name is not None:
+        return snapshot.LockKeyRef(args.lock_key_name)
+    elif 'clear_lock_key' in args and args.clear_lock_key:
+        return snapshot.LockKeyRef(None)
+    else:
+        return None
 
 
 def modify_non_schedule_fields(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
     print(
         snapshot.modify_policy(
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(None, args.time_to_live),
             enabled=args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def modify_hourly(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -588,14 +718,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_hourly_or_less(args), args.time_to_live),
             enabled=args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def modify_daily(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -604,14 +735,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_daily(args), args.time_to_live),
             enabled=args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 def modify_monthly(
     conninfo: request.Connection, credentials: Optional[Credentials], args: Namespace
 ) -> None:
@@ -620,14 +752,15 @@
             conninfo,
             credentials,
             args.id,
             name=args.name,
             snapshot_name_template=args.snapshot_name_template,
             schedule_info=get_schedule_info(get_schedule_monthly(args), args.time_to_live),
             enabled=args.enabled,
+            lock_key_ref=lock_key_ref_from_args(args),
         )
     )
 
 
 class ModifyPolicyCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_modify_policy'
 
@@ -639,47 +772,86 @@
 
         common_parser.add_argument(
             '-i',
             '--id',
             type=int,
             required=True,
             default=SUPPRESS,
-            help='Identifier of the snapshot policy to modify.',
+            help='The identifier of the snapshot policy to modify.',
         )
         parser.set_defaults(id=None)
         common_parser.add_argument(
-            '-n', '--name', type=str_decode, default=SUPPRESS, help='Name of the policy'
+            '-n', '--name', type=str_decode, default=SUPPRESS, help='The name of the policy.'
         )
         parser.set_defaults(name=None)
         common_parser.add_argument(
             '-t', '--time-to-live', type=str_decode, default=SUPPRESS, help=POLICY_TTL_HELP
         )
         parser.set_defaults(time_to_live=None)
         common_parser.add_argument(
             '--snapshot-name-template', type=str_decode, default=SUPPRESS, help=NAME_TEMPLATE_HELP
         )
         parser.set_defaults(snapshot_name_template=None)
 
-        group = common_parser.add_mutually_exclusive_group(required=False)
-        group.add_argument(
+        common_parser.add_argument(
+            '-f',
+            '--force',
+            action='store_true',
+            help='Do not prompt for confirmation. The default setting is "false".',
+        )
+
+        enabled_group = common_parser.add_mutually_exclusive_group(required=False)
+        enabled_group.add_argument(
             '--enabled',
             dest='enabled',
             action='store_true',
             default=SUPPRESS,
-            help='Enable the policy.',
+            help='Enable the speicified policy.',
         )
-        group.add_argument(
+        enabled_group.add_argument(
             '--disabled',
             dest='enabled',
             action='store_false',
             default=SUPPRESS,
-            help='Disable the policy.',
+            help='Disable the specified policy.',
         )
         parser.set_defaults(enabled=None)
 
+        # Set and clear the lock key.
+        lock_key_group = common_parser.add_mutually_exclusive_group(required=False)
+        lock_key_ref_group = lock_key_group.add_mutually_exclusive_group(required=False)
+        lock_key_ref_group.add_argument(
+            '-k',
+            '--lock-key-id',
+            type=int,
+            help=(
+                'The identifier of the key in the file system key store that protects all snapshots'
+                ' created with this policy in the future.'
+            ),
+        )
+        lock_key_ref_group.add_argument(
+            '--lock-key-name',
+            type=str,
+            help=(
+                'The name of the key in the file system key store that protects all snapshots'
+                ' created with this policy in the future.'
+            ),
+        )
+
+        lock_key_group.add_argument(
+            '--clear-lock-key',
+            action='store_true',
+            default=SUPPRESS,
+            help=(
+                'Remove the key from the specified policy. All snapshots created with this policy'
+                ' in the future will no longer be protected.'
+            ),
+        )
+        parser.set_defaults(clear_lock_key=False)
+
         subparsers = parser.add_subparsers(dest='command')
         subparsers.required = True
 
         # Non schedule fields subparser
         modify_non_schedule_fields_parser = subparsers.add_parser(
             'modify_non_schedule_fields', parents=[common_parser]
         )
@@ -712,15 +884,38 @@
         )
         add_monthly_specific_args(monthly_parser)
         add_general_schedule_args(monthly_parser)
         monthly_parser.set_defaults(command=modify_monthly)
 
     @staticmethod
     def main(rest_client: RestClient, args: Namespace) -> None:
-        args.command(rest_client.conninfo, rest_client.credentials, args)
+        def snapshot_policy_is_locked() -> bool:
+            response = snapshot.get_policy(rest_client.conninfo, rest_client.credentials, args.id)
+            return response.data['lock_key_ref'] is not None
+
+        lock_key_ref = lock_key_ref_from_args(args)
+
+        # This giant boolean says: if we're forced, or we're not in a locking scenario, unless the
+        # user has specifically OK'd said locking scenario through locking_prompt_confirmed and
+        # modify_expiration_when_locked_prompt_confirmed.
+        if args.force or not (
+            lock_key_ref
+            and lock_key_ref.ref
+            and not locking_prompt_confirmed(
+                rest_client, lock_key_ref.ref, LockingObject.SNAPSHOT_POLICY, args.id
+            )
+            or (
+                args.time_to_live
+                and snapshot_policy_is_locked()
+                and not modify_expiration_when_locked_prompt_confirmed(
+                    LockingObject.SNAPSHOT_POLICY, args.id
+                )
+            )
+        ):
+            args.command(rest_client.conninfo, rest_client.credentials, args)
 
 
 class ListAllPoliciesCommand(qumulo.lib.opts.Subcommand):
     NAME = 'snapshot_list_policies'
 
     SYNOPSIS = 'List all policies'
 
@@ -923,7 +1118,183 @@
             newer_snap=args.newer_snapshot,
             older_snap=args.older_snapshot,
             path=args.path,
             file_id=args.file_id,
             limit=args.page_size,
         ):
             print(res)
+
+
+def locking_prompt_confirmed(
+    rest_client: RestClient, lock_key_ref: str, object_type: LockingObject, object_id: str
+) -> bool:
+    key_response = fs.security_get_key(rest_client.conninfo, rest_client.credentials, lock_key_ref)
+    key_name = key_response.data['name']
+    key_comment = key_response.data['comment']
+    command = f'{object_type.value} locking'
+    prompt = (
+        f'You are requesting to lock {object_type.value} {object_id} with lock key {lock_key_ref}'
+        f' (name: {key_name}'
+    )
+    if key_comment != '':
+        prompt += f', description: {key_comment}'
+    prompt += (
+        ').\nImportant: Unless you unlock a snapshot first, you cannot modify or delete a locked'
+        ' snapshot before its expiration time.\nLock this snapshot?'
+    )
+
+    return qumulo.lib.opts.ask(command, prompt)
+
+
+class LockSnapshotCommand(qumulo.lib.opts.Subcommand):
+    NAME = 'snapshot_lock_snapshot'
+    SYNOPSIS = 'Lock a snapshot.'
+    DESCRIPTION = textwrap.dedent(
+        f"""
+        {SYNOPSIS}
+
+        A key in the file system key store protects a snapshot from accidental or malicious
+        modification. You cannot delete a locked snapshot or shorten its expiration time.
+
+        Public-private key cryptography secures locked snapshots. To configure public and private
+        keys, use the qq fs_security_add_key, fs_security_delete_key, fs_security_get_key,
+        fs_security_list_key, and fs_security_modify_key commands.
+
+        Important: Unlocking a snapshot requires a cryptographic signature. Before you lock a
+        snapshot, make sure that you have access to your private keys and that you understand the
+        unlocking procedure.
+        """
+    )
+
+    @staticmethod
+    def options(parser: ArgumentParser) -> None:
+        parser.add_argument(
+            '-i', '--id', type=int, required=True, help='The identifier of the snapshot to lock.'
+        )
+        parser.add_argument(
+            '-f',
+            '--force',
+            action='store_true',
+            help='Do not prompt for confirmation. The default setting is "false".',
+        )
+
+        lock_key_ref_group = parser.add_mutually_exclusive_group(required=True)
+        lock_key_ref_group.add_argument(
+            '-k',
+            '--lock-key-id',
+            type=int,
+            help=(
+                'The identifier of the key in the file system key store that protects the snapshot.'
+                ' Important: You must specify either the name or the identifier of the key.'
+            ),
+        )
+        lock_key_ref_group.add_argument(
+            '-n',
+            '--lock-key-name',
+            type=str,
+            help=(
+                'The name of the key in the file system key store that protects the snapshot.'
+                ' Important: You must specify either the name or the identifier of the key.'
+            ),
+        )
+
+    @staticmethod
+    def main(rest_client: RestClient, args: Namespace) -> None:
+        lock_key_ref = args.lock_key_name or str(args.lock_key_id)
+        if args.force or locking_prompt_confirmed(
+            rest_client, lock_key_ref, LockingObject.SNAPSHOT, args.id
+        ):
+            print(
+                snapshot.lock_snapshot(
+                    rest_client.conninfo, rest_client.credentials, args.id, lock_key_ref
+                )
+            )
+
+
+class GetUnlockChallengeSnapshotCommand(qumulo.lib.opts.Subcommand):
+    NAME = 'snapshot_get_unlock_challenge'
+    SYNOPSIS = 'Get a security challenge for unlocking a snapshot.'
+    DESCRIPTION = textwrap.dedent(
+        f"""
+        {SYNOPSIS}
+
+        To produce the input for the qq snapshot_unlock_snapshot command, run the following commands
+         in sequence:
+
+        Note: We recommend creating a directory for the output of the following commands. Delete
+        this directory after you unlock the snapshot.
+
+        qq snapshot_get_unlock_challenge --id <id> | jq -jr .challenge > challenge.out
+
+        openssl dgst -sha256 -r -sign <private key file> -out signature.sha256 challenge.out
+
+        openssl base64 -in signature.sha256 -out signature.b64
+
+        qq snapshot_unlock_snapshot --id <id> --signature $(cat signature.b64 | tr -d '\\n')
+        """
+    )
+
+    @staticmethod
+    def options(parser: ArgumentParser) -> None:
+        parser.add_argument(
+            '-i', '--id', type=int, required=True, help='The identifier of the snapshot to unlock.'
+        )
+
+    @staticmethod
+    def main(rest_client: RestClient, args: Namespace) -> None:
+        print(
+            snapshot.get_unlock_challenge_snapshot(
+                rest_client.conninfo, rest_client.credentials, args.id
+            )
+        )
+
+
+class UnlockSnapshotCommand(qumulo.lib.opts.Subcommand):
+    NAME = 'snapshot_unlock_snapshot'
+    SYNOPSIS = 'Unlock a snapshot.'
+    DESCRIPTION = textwrap.dedent(
+        f"""
+        {SYNOPSIS}
+
+        To unlock a snapshot, you must first create a valid cryptographic signature by using the
+        security challenge that the qq snapshot_get_unlock_challenge command returns.
+
+        If your system has the Python cryptography library, you can use the --private-key-file
+        flag and let the command determine the public key and verification signature to send to
+        Qumulo Core, rather than calculate these elements.
+        """
+    )
+
+    @staticmethod
+    def options(parser: ArgumentParser) -> None:
+        parser.add_argument(
+            '-i', '--id', type=int, required=True, help='The identifier of the snapshot to unlock.'
+        )
+        key_or_signature = parser.add_mutually_exclusive_group(required=True)
+        key_or_signature.add_argument(
+            '-s',
+            '--signature',
+            type=str,
+            help=(
+                'The verification signature of the security challenge from the output of the qq'
+                ' snapshot_get_unlock_challenge command.'
+            ),
+        )
+        key_or_signature.add_argument(
+            '-k',
+            '--private-key-file',
+            type=FileType('r'),
+            help='The location of the private key file that locks the snapshot.',
+        )
+
+    @staticmethod
+    def main(rest_client: RestClient, args: Namespace) -> None:
+        if args.private_key_file:
+            challenge = snapshot.get_unlock_challenge_snapshot(
+                rest_client.conninfo, rest_client.credentials, args.id
+            ).data['challenge']
+            _, args.signature = fs.get_verified_public_key(args.private_key_file.read(), challenge)
+        print(
+            snapshot.unlock_snapshot(
+                rest_client.conninfo, rest_client.credentials, args.id, args.signature
+            )
+        )
```

## qumulo/lib/opts.py

```diff
@@ -213,17 +213,17 @@
 
     return str_decode(password)
 
 
 def ask(command, message, inputter=input):
     # Wrap long lines to make the CLI output more readable
     wrapped_message = '\n'.join(textwrap.fill(line) for line in message.splitlines())
-    f = inputter('%s (yes/no): ' % wrapped_message)
+    f = inputter(f'{wrapped_message} (yes/no): ')
     if f.lower() == 'no':
-        print('Canceling the %s request' % command)
+        print(f'Canceling the {command} request...')
         return False
     elif f.lower() != 'yes':
         raise ValueError("Please enter 'yes' or 'no'")
 
     return True
```

## qumulo/rest/fs.py

```diff
@@ -38,14 +38,21 @@
 from qumulo.lib import log
 from qumulo.lib.auth import Credentials
 from qumulo.lib.identity_util import ApiIdentity, Identity
 from qumulo.lib.opts import str_decode
 from qumulo.lib.request import Connection, RequestError
 from qumulo.lib.uri import UriBuilder
 
+try:
+    from qumulo.lib.keys import KeyOps
+
+    can_load_private_keys = True
+except ImportError:
+    can_load_private_keys = False
+
 
 @request.request
 def read_fs_stats(
     conninfo: Connection, _credentials: Optional[Credentials]
 ) -> request.RestResponse:
     method = 'GET'
     uri = '/v1/file-system'
@@ -1398,15 +1405,15 @@
             self._load_cache()
         if len(self.cache) == 0:
             raise StopIteration
 
         line = self.cache.pop(0)
         if len(line) == 0:
             self._alive = False
-            raise StopIteration('Remote socket closed')
+            raise EOFError('Remote socket closed')
         line = line.rstrip('\n')
         if len(line) == 0:
             return next(self)
 
         data_prefix = 'data: '
         comment_prefix = ': '
         if line.startswith(comment_prefix):
@@ -1492,7 +1499,128 @@
 @request.request
 def set_notify_settings(
     conninfo: Connection, _credentials: Optional[Credentials], recursive_mode: str
 ) -> request.RestResponse:
     return conninfo.send_request(
         'PUT', '/v1/file-system/settings/notify', body={'recursive_mode': recursive_mode}
     )
+
+
+@request.request
+def security_add_key(
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    name: str,
+    public_key_data: str,
+    verification_signature: str,
+    comment: str = '',
+) -> request.RestResponse:
+    uri = '/v1/file-system/security/keys/'
+    body = {
+        'name': name,
+        'public_key': public_key_data,
+        'verification_signature': verification_signature,
+        'comment': comment,
+    }
+
+    method = 'POST'
+    return conninfo.send_request(method, uri, body)
+
+
+@request.request
+def security_get_key(
+    conninfo: request.Connection, _credentials: Optional[Credentials], key_ref: str
+) -> request.RestResponse:
+    method = 'GET'
+    uri = f'/v1/file-system/security/keys/{key_ref}'
+    return conninfo.send_request(method, uri)
+
+
+@request.request
+def security_get_key_usage(
+    conninfo: request.Connection, _credentials: Optional[Credentials], key_ref: str
+) -> request.RestResponse:
+    method = 'GET'
+    uri = f'/v1/file-system/security/keys/{key_ref}/usage'
+    return conninfo.send_request(method, uri)
+
+
+@request.request
+def security_modify_key(
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    key_ref: str,
+    name: Optional[str] = None,
+    comment: Optional[str] = None,
+    disabled: Optional[bool] = None,
+) -> request.RestResponse:
+    method = 'PATCH'
+    uri = f'/v1/file-system/security/keys/{key_ref}'
+
+    body: Dict[str, Union[str, bool]] = {}
+    if name is not None:
+        body['name'] = name
+    if comment is not None:
+        body['comment'] = comment
+    if disabled is not None:
+        body['disabled'] = disabled
+
+    return conninfo.send_request(method, uri, body=body)
+
+
+@request.request
+def security_list_keys(
+    conninfo: request.Connection, _credentials: Optional[Credentials]
+) -> request.RestResponse:
+    method = 'GET'
+    uri = f'/v1/file-system/security/keys/'
+    return conninfo.send_request(method, uri)
+
+
+@request.request
+def security_get_key_replace_challenge(
+    conninfo: request.Connection, _credentials: Optional[Credentials], key_ref: str
+) -> request.RestResponse:
+    method = 'GET'
+    uri = f'/v1/file-system/security/keys/{key_ref}/key-replacement-challenge'
+    return conninfo.send_request(method, uri)
+
+
+@request.request
+def security_replace_key(
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    key_ref: str,
+    replacement_key: str,
+    old_key_verification_signature: str,
+    replacement_key_verification_signature: str,
+) -> request.RestResponse:
+    method = 'POST'
+    uri = f'/v1/file-system/security/keys/{key_ref}/replace'
+
+    body = {
+        'replacement_key': replacement_key,
+        'old_key_verification_signature': old_key_verification_signature,
+        'replacement_key_verification_signature': replacement_key_verification_signature,
+    }
+
+    return conninfo.send_request(method, uri, body)
+
+
+def get_verified_public_key(private_key_data: str, challenge: str) -> Tuple[str, str]:
+    if not can_load_private_keys:
+        raise ImportError(
+            'The cryptography library is required for automatically loading public keys and'
+            ' creating a verification_signature in-line'
+        )
+
+    ops = KeyOps(private_key_data)
+    return ops.public_bytes_as_base64(), ops.sign(challenge)
+
+
+@request.request
+def security_delete_key(
+    conninfo: request.Connection, _credentials: Optional[Credentials], key_ref: str
+) -> request.RestResponse:
+    method = 'DELETE'
+    uri = f'/v1/file-system/security/keys/{key_ref}'
+    return conninfo.send_request(method, uri)
```

## qumulo/rest/multitenancy.py

```diff
@@ -28,21 +28,21 @@
 
 
 @dataclass
 class TenantConfig(DataClassJsonMixin):
     id: int
     name: str
     networks: List[int]
-    ad_domain: Optional[int]
     nfs_enabled: bool
     replication_enabled: bool
     rest_api_enabled: bool
     smb_enabled: bool
     ssh_enabled: bool
     web_ui_enabled: bool
+    ad_domain: Optional[int] = None
 
 
 @dataclass
 class _TenantConfigCreatePatchBase(DataClassJsonMixin):
     nfs_enabled: Optional[bool] = field(default=None, metadata=dc_config(exclude=ExcludeIfNone))
     replication_enabled: Optional[bool] = field(
         default=None, metadata=dc_config(exclude=ExcludeIfNone)
@@ -63,42 +63,28 @@
 
 @dataclass
 class TenantConfigCreate(_TenantConfigCreatePatchBase, _TenantConfigCreateBase):
     networks: Optional[List[int]] = field(default=None, metadata=dc_config(exclude=ExcludeIfNone))
 
 
 @dataclass
-class TenantConfigCreateFirst(_TenantConfigCreateBase):
-    pass
-
-
-@dataclass
 class TenantConfigPatch(_TenantConfigCreatePatchBase):
     name: Optional[str] = field(default=None, metadata=dc_config(exclude=ExcludeIfNone))
     networks: Optional[List[int]] = field(default=None, metadata=dc_config(exclude=ExcludeIfNone))
 
 
 class Multitenancy:
     def __init__(self, client: request.SendRequestObject):
         self.client = client
 
     def create_tenant(self, config: TenantConfigCreate) -> request.ResponseWithEtag[TenantConfig]:
         response = self.client.send_request('POST', MULTITENANCY_TENANTS_URI, body=config.to_dict())
         assert response.etag is not None
         return request.ResponseWithEtag(TenantConfig.schema().load(response.data), response.etag)
 
-    def create_first_tenant(
-        self, config: TenantConfigCreateFirst
-    ) -> request.ResponseWithEtag[TenantConfig]:
-        response = self.client.send_request(
-            'POST', MULTITENANCY_URI + 'enable', body=config.to_dict()
-        )
-        assert response.etag is not None
-        return request.ResponseWithEtag(TenantConfig.schema().load(response.data), response.etag)
-
     def get_tenant(self, tenant_id: int) -> request.ResponseWithEtag[TenantConfig]:
         response = self.client.send_request('GET', MULTITENANCY_TENANTS_URI + str(tenant_id))
         assert response.etag is not None
         return request.ResponseWithEtag(TenantConfig.schema().load(response.data), response.etag)
 
     def list_tenants(self) -> Sequence[TenantConfig]:
         response = self.client.send_request('GET', MULTITENANCY_TENANTS_URI)
@@ -107,17 +93,14 @@
 
     def delete_tenant(self, tenant_id: int, if_match: Optional[str] = None) -> None:
         response = self.client.send_request(
             'DELETE', MULTITENANCY_TENANTS_URI + str(tenant_id), if_match=if_match
         )
         assert response.etag is None
 
-    def delete_last_tenant(self) -> None:
-        self.client.send_request('POST', MULTITENANCY_URI + 'disable')
-
     def set_tenant(
         self, tenant_id: int, config: TenantConfig, if_match: Optional[str] = None
     ) -> request.ResponseWithEtag[TenantConfig]:
         response = self.client.send_request(
             'PUT',
             MULTITENANCY_TENANTS_URI + str(tenant_id),
             body=config.to_dict(),
```

## qumulo/rest/snapshot.py

```diff
@@ -7,30 +7,38 @@
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 # License for the specific language governing permissions and limitations under
 # the License.
 
 
+from dataclasses import dataclass
 from enum import Enum
-from typing import cast, Dict, Mapping, Optional, Sequence
+from typing import cast, Dict, List, Mapping, Optional, Sequence
 
 import qumulo.lib.request as request
 import qumulo.rest.fs
 
 from qumulo.lib.auth import Credentials
 from qumulo.lib.uri import UriBuilder
 
 
 class InDeleteFilter(Enum):
     ALL = 'all'
     EXCLUDE_IN_DELETE = 'exclude_in_delete'
     ONLY_IN_DELETE = 'only_in_delete'
 
 
+class SnapshotStatusFilter(Enum):
+    EXCLUDE_IN_DELETE = 'api_snapshots_exclude_in_delete'
+    ONLY_IN_DELETE = 'api_snapshots_exclude_not_in_delete'
+    EXCLUDE_LOCKED = 'api_snapshots_exclude_locked'
+    ONLY_LOCKED = 'api_snapshots_exclude_not_locked'
+
+
 @request.request
 def list_snapshots(
     conninfo: request.Connection,
     _credentials: Optional[Credentials],
     in_delete_filter: InDeleteFilter = InDeleteFilter.ALL,
 ) -> request.RestResponse:
     method = 'GET'
@@ -114,134 +122,150 @@
     return conninfo.send_request(method, uri.format(snapshot_id))
 
 
 @request.request
 def list_snapshot_statuses(
     conninfo: request.Connection,
     _credentials: Optional[Credentials],
-    in_delete_filter: InDeleteFilter = InDeleteFilter.ALL,
+    snapshot_status_filter: List[SnapshotStatusFilter],
 ) -> request.RestResponse:
     method = 'GET'
-    uri = f'/v3/snapshots/status/?filter={in_delete_filter.value}'
 
-    return conninfo.send_request(method, uri)
+    uri = UriBuilder(path='/v4/snapshots/status/', rstrip_slash=False)
+    if snapshot_status_filter:
+        filters = ','.join([f.value for f in snapshot_status_filter])
+        uri.add_query_param('filter', filters)
+
+    return conninfo.send_request(method, str(uri))
 
 
 @request.request
 def get_snapshot_status(
     conninfo: request.Connection, _credentials: Optional[Credentials], snapshot_id: int
 ) -> request.RestResponse:
     method = 'GET'
     uri = '/v3/snapshots/status/{}'
 
     return conninfo.send_request(method, uri.format(snapshot_id))
 
 
+@dataclass
+class LockKeyRef:
+    ref: Optional[str]
+
+
 @request.request
 def create_policy(
     conninfo: request.Connection,
     credentials: Optional[Credentials],
     policy_name: str,
     schedule_info: Mapping[str, object],
     snapshot_name_template: Optional[str] = None,
     directory_id: Optional[str] = None,
     enabled: Optional[bool] = None,
+    lock_key_ref: Optional[LockKeyRef] = None,
 ) -> request.RestResponse:
     method = 'POST'
-    uri = '/v2/snapshots/policies/'
+    uri = '/v3/snapshots/policies/'
 
     if directory_id == None:
         directory_id = cast(
             str, qumulo.rest.fs.get_file_attr(conninfo, credentials, path='/').lookup('file_number')
         )
 
     policy = {
         'policy_name': policy_name,
         'schedule': schedule_info,
         'source_file_id': directory_id,
         'enabled': enabled if enabled is not None else True,
         'snapshot_name_template': snapshot_name_template,
+        'lock_key_ref': f'{lock_key_ref.ref}' if lock_key_ref is not None else None,
     }
 
     return conninfo.send_request(method, uri, body=policy)
 
 
 @request.request
 def modify_policy(
     conninfo: request.Connection,
     _credentials: Optional[Credentials],
     policy_id: int,
     name: Optional[str] = None,
     snapshot_name_template: Optional[str] = None,
     schedule_info: Optional[Mapping[str, object]] = None,
     enabled: Optional[bool] = None,
+    lock_key_ref: Optional[LockKeyRef] = None,
     if_match: Optional[str] = None,
 ) -> request.RestResponse:
     method = 'PATCH'
-    uri = '/v2/snapshots/policies/{}'
+    uri = '/v3/snapshots/policies/{}'
 
     policy: Dict[str, object] = {}
     if name is not None:
         policy.update({'policy_name': name})
     if snapshot_name_template is not None:
         policy.update({'snapshot_name_template': snapshot_name_template})
     if schedule_info is not None:
         policy.update({'schedule': schedule_info})
     if enabled is not None:
-        policy['enabled'] = enabled
+        policy.update({'enabled': enabled})
+    if lock_key_ref is not None:
+        policy.update(
+            {'lock_key_ref': f'{lock_key_ref.ref}' if lock_key_ref.ref is not None else None}
+        )
 
     return conninfo.send_request(method, uri.format(policy_id), body=policy, if_match=if_match)
 
 
 @request.request
 def list_policies(
     conninfo: request.Connection, _credentials: Optional[Credentials]
 ) -> request.RestResponse:
     method = 'GET'
-    uri = '/v2/snapshots/policies/'
+    uri = '/v3/snapshots/policies/'
 
     return conninfo.send_request(method, uri)
 
 
 @request.request
 def get_policy(
     conninfo: request.Connection, _credentials: Optional[Credentials], policy_id: int
 ) -> request.RestResponse:
     method = 'GET'
-    uri = '/v2/snapshots/policies/{}'
+    uri = '/v3/snapshots/policies/{}'
 
     return conninfo.send_request(method, uri.format(policy_id))
 
 
 @request.request
 def delete_policy(
     conninfo: request.Connection, _credentials: Optional[Credentials], policy_id: int
 ) -> request.RestResponse:
     method = 'DELETE'
-    uri = '/v2/snapshots/policies/{}'
+    uri = '/v3/snapshots/policies/{}'
 
     return conninfo.send_request(method, uri.format(policy_id))
 
 
 @request.request
 def list_policy_statuses(
     conninfo: request.Connection, _credentials: Optional[Credentials]
 ) -> request.RestResponse:
     method = 'GET'
-    uri = '/v2/snapshots/policies/status/'
+    uri = '/v3/snapshots/policies/status/'
 
     return conninfo.send_request(method, uri)
 
 
 @request.request
 def get_policy_status(
     conninfo: request.Connection, _credentials: Optional[Credentials], policy_id: int
 ) -> request.RestResponse:
     method = 'GET'
-    uri = '/v2/snapshots/policies/status/{}'
+    uri = '/v3/snapshots/policies/status/{}'
 
     return conninfo.send_request(method, uri.format(policy_id))
 
 
 @request.request
 def get_total_used_capacity(
     conninfo: request.Connection, _credentials: Optional[Credentials]
@@ -362,7 +386,42 @@
 ) -> request.PagingIterator:
     uri = get_snapshot_file_diff_uri(newer_snap, older_snap, path, file_id)
 
     def get_a_snapshot_file_diff(uri: UriBuilder) -> request.RestResponse:
         return conninfo.send_request('GET', str(uri))
 
     return request.PagingIterator(str(uri), get_a_snapshot_file_diff, page_size=limit)
+
+
+@request.request
+def lock_snapshot(
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    snapshot_id: int,
+    lock_key_ref: str,
+) -> request.RestResponse:
+    method = 'POST'
+    uri = f'/v3/snapshots/{snapshot_id}/lock'
+    body = {'lock_key_ref': f'{lock_key_ref}'}
+    return conninfo.send_request(method, uri, body=body)
+
+
+@request.request
+def unlock_snapshot(
+    conninfo: request.Connection,
+    _credentials: Optional[Credentials],
+    snapshot_id: int,
+    signature: str,
+) -> request.RestResponse:
+    method = 'POST'
+    uri = f'/v3/snapshots/{snapshot_id}/unlock'
+    body = {'signature': f'{signature}'}
+    return conninfo.send_request(method, uri, body=body)
+
+
+@request.request
+def get_unlock_challenge_snapshot(
+    conninfo: request.Connection, _credentials: Optional[Credentials], snapshot_id: int
+) -> request.RestResponse:
+    method = 'GET'
+    uri = f'/v3/snapshots/{snapshot_id}/unlock-challenge'
+    return conninfo.send_request(method, uri, body=None)
```

## Comparing `qumulo_api-6.0.2.dist-info/LICENSE` & `qumulo_api-6.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `qumulo_api-6.0.2.dist-info/METADATA` & `qumulo_api-6.1.0.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: qumulo-api
-Version: 6.0.2
+Version: 6.1.0
 Summary: Qumulo Python SDK
 Home-page: http://www.qumulo.com/
 Author: Qumulo, Inc.
 Author-email: python@qumulo.com
 License: UNKNOWN
 Keywords: Qumulo QFSD
 Platform: UNKNOWN
```

## Comparing `qumulo_api-6.0.2.dist-info/RECORD` & `qumulo_api-6.1.0.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,57 +1,59 @@
-qumulo/__init__.py,sha256=lze97Y7ToUnpENKGAhOoSKx1zlZQe6ZfCSr8M50_K1g,22
+qumulo/__init__.py,sha256=PD5agZ0_DXqsFLMBR0hacZV3LbzGbH8qn-j7MIAm3Xs,22
 qumulo/rest_client.py,sha256=ji0uDqp5RbFbLOng39GFR-3jSTyiOdA3GYVYK3LXaFk,10792
 qumulo/retry.py,sha256=u1hJFtqzIg89ShrWFcbsG1voSNHzbjuQiayb91UdlBE,5463
-qumulo/commands/__init__.py,sha256=MiUrFEN__KtOms9tNeFsAzEhibEk60vPqXNPA67G41U,1163
+qumulo/commands/__init__.py,sha256=JgiD4KhBsFJDY3Q_8l4cVHMBCEMXg20C2aCjhYY7IO0,1178
 qumulo/commands/access_tokens.py,sha256=6yTTZIIFzUrGTJbZBKb6L1icFGu5QML8FXaKNFblUrg,7430
 qumulo/commands/ad.py,sha256=z3ssu2FiIrySPjF6S-PLLk-p9U_O1MyooimPBv8DQbc,15993
 qumulo/commands/analytics.py,sha256=oTV-iupk3n8VqnxXS2HzDxz2TwdWdVLSe50cs21RSCQ,5048
 qumulo/commands/audit.py,sha256=JI4TfZwqQqX88z6bgRi2ZHop0dHVFpmVJQ5bCCU2zJE,6531
 qumulo/commands/auth.py,sha256=vHKm-gNDPBEsU2M4X8fgt7wolrH7fmYLWu6LvY6jiQI,35605
 qumulo/commands/checksumming.py,sha256=3q3pltd1RS22a-PoJWyI6u_rL6H3j5xfY0Wgn2Snnc8,1045
 qumulo/commands/cluster.py,sha256=nZkOMsQ12_eu3tK-uRPPeCsFFLDU717DBFhnc0pXUIQ,18179
 qumulo/commands/dns.py,sha256=iwUEtLkGIIpmm0MLNavXiOtXB1Mmrmio9EwqNcMPXXs,4605
 qumulo/commands/encryption.py,sha256=gYO8SsBDDMPS-OP5pUyZdYfnNS91dJM9Yj9FM9ZY5FA,1506
 qumulo/commands/file_permissions_help.py,sha256=gWzBwYJEXURk2Dz3G-f9u3QDPX9WwK7lAfcOrfu_Gro,2843
-qumulo/commands/fs.py,sha256=b1jAH8F803v3XZzO2xpm1ipDeUdmYRCTFZdauNhz-B0,130311
+qumulo/commands/fs.py,sha256=NaPw8YusdQPyd8czTq0pOAQrByqGDU4hEGHRXXZR9AM,129986
 qumulo/commands/ftp.py,sha256=1rObDBzV_kHIbbNDEH8ZncxHmHy7UfEfLIrX4pEpNf8,3933
 qumulo/commands/kerberos.py,sha256=wv2uuS63B_5pCQqiEWUerwkY8HqvfPwW8TQyBmgr1Mg,3603
+qumulo/commands/key_store.py,sha256=NGdUAzi2Pyi17EcOp1StjhET9W_87Qydt2f5PJOsRHs,21410
 qumulo/commands/ldap.py,sha256=M7TTecZJWHR8-qy2ZIwoCxhRa9t1DrcKTClUsYUcWw0,12310
 qumulo/commands/login.py,sha256=AeBwSfoRTDN6XL-FWO_UONPSYQuglVZH2pG7O7SyA1g,6846
 qumulo/commands/metrics.py,sha256=7gt0OGWfV_hE5ZH2B1i5xxOEIEt1-kIbUGJ9MtYPF9A,1070
-qumulo/commands/multitenancy.py,sha256=LAQYD034Upzxz6RuSduGb1W8lYK_aqHRaTfKn06FCq8,18994
+qumulo/commands/multitenancy.py,sha256=4t4vHFhni7Pk4-0zk4oOY7PUnjI8j9DJQYp8Gm6Voe0,15745
 qumulo/commands/multitenancy_nfs.py,sha256=S4ImwGWT064FNixBTcZDSn7XDLAhel1KgyAqsR78RP0,9981
 qumulo/commands/multitenancy_smb.py,sha256=PUxc-AAa9B_O6KVsnv5PQ8ZQZvwhcpZ4UYXFEdRVk_c,8845
 qumulo/commands/network.py,sha256=ge36fM9ikmnt9S9ayS1IB5OgRFLOc5bBxJA2Ine0VvQ,20655
 qumulo/commands/nfs.py,sha256=QL0BIiJPbxwj9BEpDsmeKfjEVNmMrf9McBu_0NaBEj4,34897
 qumulo/commands/node_state.py,sha256=GoBHhJHY4vYaBJcRDJ9ZLaoUmI7uU7S8s7c8I7xUZq8,1015
 qumulo/commands/object_replication.py,sha256=FhCUaFtt6hcEslHha05lySDR4f-jh4KIhpIqV-qEWWE,10630
 qumulo/commands/quota.py,sha256=0aDTFGXsTV_aQvoQW0dw22MUQdeQ4ntJZOaivfVvlxU,6173
 qumulo/commands/raw.py,sha256=cpIN4WkEIP9Q5-S8av2kwFw-wbhSUycD7iWXB2PHoQw,2531
 qumulo/commands/replication.py,sha256=Es_4-k_XSwaE4xGdWMmwX0Swqfl-O0qoxQhXJbwqVIw,32784
 qumulo/commands/roles.py,sha256=2SJY_TtpyFpyDY3hhGddgVMQWf7JVx2uqfBjVF359Vg,14355
 qumulo/commands/s3.py,sha256=aSrLOy2wTn-CoTbEBlz9nTwJeo-h8gh2w0TksXVqIb0,15644
 qumulo/commands/saml.py,sha256=1KnKaVkucGdhBCfnUEnknChHqif0HSCGLX3rp3Hxezo,5323
 qumulo/commands/shutdown.py,sha256=p30oHkBayaN7mGwCkf_-wLaGmZVtKWprpXBPCRvM_3U,3259
-qumulo/commands/smb.py,sha256=xiIDb-1PVSZs4GX33b6px9vnOGH6tRIpNI1lfkzYa-U,49507
-qumulo/commands/snapshot.py,sha256=xEx6hcy-GwM8lxN1jhZe0goWZy-p3dd-yN_kmDcxqa4,30790
+qumulo/commands/smb.py,sha256=EnBx07TkN2uQoAfpi61zVwc_FsDG8eLLG2EVBJNcQ9Q,50961
+qumulo/commands/snapshot.py,sha256=S1myH22RJYGiekxtuPlAe0vCXBkuHjjLopCPOosWXJU,45290
 qumulo/commands/support.py,sha256=vDruyK8_YmKgvbXMqfbsr9HNnPESM1dCcS61yG2y8aA,7403
 qumulo/commands/time_config.py,sha256=5yEHDjqMepuJUaTHU2bWU7hZNpb50N0ctm6ZuLY3Z8o,2935
 qumulo/commands/tree_delete.py,sha256=466KijoQM9hIyxofPkgFWS8UzNn679LIpc77SvaihC4,4604
 qumulo/commands/unconfigured_node_operations.py,sha256=oM2jVh3GJxkYmOz5DVVCg7CZp1YH_nersk-e3kG8dx4,1403
 qumulo/commands/upgrade.py,sha256=NXTD5w7kitAiTTs9QBFbT_Y-DclELsY6rxReb8DWc5c,21797
 qumulo/commands/version.py,sha256=QjLnP83uaikX7YAGOPenL8S6kOM-JB0DnZaf2zTecaA,976
 qumulo/commands/web_ui.py,sha256=bkewSUbORS2IGiz81F7pf-5Sjug81MPomkhhmHfDJ-4,7374
 qumulo/lib/__init__.py,sha256=DGCGrUjsJi4fACGMXMikmfM56h6uK_ZHUW2aO3hpaoI,669
 qumulo/lib/acl_util.py,sha256=w0ZiKm-n39BNKx3mvFmX9W3QmxYT1BpgawysQxkHR94,12849
 qumulo/lib/auth.py,sha256=SuKI7j51_3-vaRoh5HAa23Dl8Qf22xL0DW3O9-BmuOE,4047
 qumulo/lib/duration.py,sha256=-Wox4gXrCXepQcEjDDT4gReaws_baaThxIL6THAD9tc,1833
 qumulo/lib/identity_util.py,sha256=hvTgijZ3FGCaqX6GD-WpwcplFIAq_luHMah88IyEZlQ,11107
+qumulo/lib/keys.py,sha256=4Bjcm9cPiWkrRuSgLMe8XfuIScWrptRMvQcj5YbKKyo,3551
 qumulo/lib/obj.py,sha256=gJetz-BK9LxtqQADzpmiSUNUZwDu2SUIIf8Ig4vqDDI,2230
-qumulo/lib/opts.py,sha256=gqTnRGRvTBZQqD3a9KcEOGlS4yRTHY9Vp6WeT6PZftA,8874
+qumulo/lib/opts.py,sha256=AJ9bQrwOYWUEcpDJ5EmEyGcnM49Sg7QdVnkqYLqx1bw,8873
 qumulo/lib/qq.py,sha256=rdFvl5QFkGE7MXO7fG6FUToSbM8UyVE0QRTQwWZ1Uu4,6016
 qumulo/lib/request.py,sha256=dHFpNnuc1VrQgFDckfpTkJcZ5T-IZNTgvX_Fe0L8Obo,24972
 qumulo/lib/rest_util.py,sha256=e8jHj2tvJCSljQFtVPw9GJpTuDTT6ECYbFN0K4dcTQQ,1058
 qumulo/lib/rfc3339.py,sha256=nldESt-PcUWaaGJY3yRtD4geTn35h0EvYoNsie2yP0I,926
 qumulo/lib/tenant.py,sha256=uvlW3bAZNT0CRF9CUXdRdwlJf7p14ENJA5cY_wXqqpU,2009
 qumulo/lib/uri.py,sha256=9zWsU20p6phHupk8dTEsbVmUYSwSpx4Kb0B9OZ2VEWQ,3350
 qumulo/lib/util.py,sha256=Ed4zFb2Q7Bl_lisTCopwHh8swnwahd2ijzNcn8ziuZE,14792
@@ -61,45 +63,45 @@
 qumulo/rest/analytics.py,sha256=mh7-xa2HZIMNIn6v5jb7iFZEOquob40dzuiLUKc4Vfg,2204
 qumulo/rest/audit.py,sha256=WNfiXZIP7jGRIgsjfvfYBEeS1TLCdP-n2EY36Tup3v8,5909
 qumulo/rest/auth.py,sha256=5gGOwOmBvdsWNhOAgo9vz8SSGxDINvXvZMMgp8U3KL0,8419
 qumulo/rest/checksumming.py,sha256=kBlck-tQvDQNP-x8L24nxK1j90E_30hiVl6cCuAA0-o,914
 qumulo/rest/cluster.py,sha256=JroZ2QXo71acWsFNmpVj9F_J8n1dy_km7KB71bJEdgk,8793
 qumulo/rest/dns.py,sha256=SrRHt9ZlOezFK0fqpD9x0qcY_cMqaTM-YUWVn1lypUA,3056
 qumulo/rest/encryption.py,sha256=sDBrntJt2FozrOf4aq2gOntzzuxke-k70CZS8sis6h0,1148
-qumulo/rest/fs.py,sha256=sZhC4Y_qEn_Eeu2YeLctfS2hL84yCgDvYSqkS0_oM8w,45742
+qumulo/rest/fs.py,sha256=-U9WEWvMQnbjX-9B-uD5LGmJs6BbnkPLy1kkn_sObMw,49457
 qumulo/rest/ftp.py,sha256=1VxfZDzzvx50uw74m0sk8C-X_52x130bY2fW12IcBdk,4531
 qumulo/rest/groups.py,sha256=n4ZNfSzB7Q8AtQS5ZZqawS489i7X2l8uSUKetylhoaY,4410
 qumulo/rest/kerberos.py,sha256=cd1erooNDanAAq6FmVGeaemqmbloOfqKjy2mHQ9F7no,2897
 qumulo/rest/ldap.py,sha256=FWRVQhQ3mSXSFBWJDiZ9PSGWHfF-hosMcurrD0kROek,4490
 qumulo/rest/metrics.py,sha256=Tom5Y4KMa5d7qBE6dAJ6fqFs5R815No6U47fo_nqlFQ,1251
-qumulo/rest/multitenancy.py,sha256=koboHirJU7nf3Fw4zNsPAIlHdN3E24N9t31difIdtUw,5484
+qumulo/rest/multitenancy.py,sha256=k1liR_k7lPTg1nZGPUNg9aRusFjl_Dx5fLkshj69J6s,4909
 qumulo/rest/multitenancy_nfs.py,sha256=P--8o5jF8JuourLLMat5qAP_RQ79W_Gc2iLlGd1zZ40,5260
 qumulo/rest/multitenancy_smb.py,sha256=XBrwlBpof9UlVAqqesQ2jPw_d5WEdnbLBat6NqG2HKk,3616
 qumulo/rest/network.py,sha256=y2_thKk9kcqJDsAN0Z96VwBfGiKhNMiY7kiHXagJ0uQ,8417
 qumulo/rest/nfs.py,sha256=j3OHQXRD_aJrrP5xlrNV_Iz4YqzL1Q1o_v12U8lqXTI,8467
 qumulo/rest/node_state.py,sha256=MF-hADKq9ZcSWp_5pLzinmV9FmflWHRdbdDyEMTZvTA,910
 qumulo/rest/object_replication.py,sha256=MIdHZ4APNGD2L7O2ucPhNGGLYNtZed7mBytBt1BV2wQ,4468
 qumulo/rest/quota.py,sha256=YjcQ0PSc5QEytqzt6zm3Be3wicqmIYbr70DOnn-sv-0,3426
 qumulo/rest/replication.py,sha256=0uUsjjwIjUz16uvVAXOJuxScHCDSot1bWmjgLn0S7_M,10612
 qumulo/rest/roles.py,sha256=5XlJmpXLzOsvPLYs-G4MNmsiRHgug-6h9QIQkdgjQtQ,6628
 qumulo/rest/s3.py,sha256=NyM2GUN3o9qL-aoY0eKSnwvkiDpMF2iOjdgpsvdDY5o,9857
 qumulo/rest/saml.py,sha256=gSqoD_FO-Jy9mgVMNBCYBTGTYGzUbKnX6c3z5IIXRk0,2687
 qumulo/rest/shutdown.py,sha256=f1rkzEJR1Hjm7hfF46RlowHxWkUW1cgOBLD1O6-1Nyg,1944
 qumulo/rest/smb.py,sha256=lMQvZTCMh4tkI9iSQBmZboRCebQ2kRkqHmGMgpFRrk8,11128
-qumulo/rest/snapshot.py,sha256=uzQThe7ALH9oegGPoNoGCox3bHEWsu0_Z-HCPIOAI4Y,10951
+qumulo/rest/snapshot.py,sha256=JpG6UxoXcASzm9ikrbnBjVBKA_0GdV1tvXmvpWUTzqc,12813
 qumulo/rest/support.py,sha256=-_y13LELb58WG23trCHB_zwuXwEDI_xqIZV9opfUmwc,3265
 qumulo/rest/time_config.py,sha256=Rg_XhzCjFwXTsa02ha8aEIMj9NFVCYYIaH8vC-lQEW0,1972
 qumulo/rest/tree_delete.py,sha256=t84-SU_E-SycSspgoIIO4UDKGySegDQyArAMWvav9P4,2706
 qumulo/rest/unconfigured_node_operations.py,sha256=lBaY05t5qLWrqBFpmL18a9mj12kd9TN_IMPQ6JRnWEE,1780
 qumulo/rest/upgrade.py,sha256=7jcUzT9tWxINn9B4RP4a1KuWB8DLY57RdE5uwWsUP60,1960
 qumulo/rest/upgrade_v2.py,sha256=P4LAIw378E-08SuXcpx0IlMsSMbOjqWY2zg55Zvlu6Q,2968
 qumulo/rest/upgrade_v3.py,sha256=0yqWSG05NZJhOOKwx5IJf4pwseM7V_Qj2E6xxmAtKfI,1234
 qumulo/rest/users.py,sha256=HW3SdpGLdo5DaWZCWTdLA4cgCwe8fBYk3tJwwuhKvlQ,4689
 qumulo/rest/version.py,sha256=0HOGMR9tQUMbXLyt94_cUn3s3ppwliRw9pN82YDJivI,1593
 qumulo/rest/web_ui.py,sha256=TnWXaZ0WDf3DAIo2ybj5kjQIVR0kvQFfbJepTf8_7H4,3679
-qumulo_api-6.0.2.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
-qumulo_api-6.0.2.dist-info/METADATA,sha256=5LYAoX2ZHt1E6RzgJofzZR6XsD8wWunTdDFa8GW4Oqw,3776
-qumulo_api-6.0.2.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
-qumulo_api-6.0.2.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
-qumulo_api-6.0.2.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
-qumulo_api-6.0.2.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
-qumulo_api-6.0.2.dist-info/RECORD,,
+qumulo_api-6.1.0.dist-info/LICENSE,sha256=z8d0m5b2O9McPEK1xHG_dWgUBT6EfBDz6wA0F7xSPTA,11358
+qumulo_api-6.1.0.dist-info/METADATA,sha256=1cl6LKcCu9FwM7Qz1CjVdQPoD8-3uigg5due7sgAOAA,3776
+qumulo_api-6.1.0.dist-info/NOTICE,sha256=2OJiVEfAyPpI5sXj3vRc_xi4T27O9QtT7r1KVRjASXo,290
+qumulo_api-6.1.0.dist-info/WHEEL,sha256=OqRkF0eY5GHssMorFjlbTIq072vpHpF60fIQA6lS9xA,92
+qumulo_api-6.1.0.dist-info/entry_points.txt,sha256=Ygm2HVqVPjLgqJ48XZZSycDnmldDk_zXwCn0RVVQj44,68
+qumulo_api-6.1.0.dist-info/top_level.txt,sha256=ue_iyvfoYhuoCA8JzeMN3s2qu_G1MMtPwVzG6zsv_vE,7
+qumulo_api-6.1.0.dist-info/RECORD,,
```

