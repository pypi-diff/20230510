# Comparing `tmp/partitura-1.2.1.tar.gz` & `tmp/partitura-1.2.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "partitura-1.2.1.tar", last modified: Thu Feb  9 11:41:15 2023, max compression
+gzip compressed data, was "partitura-1.2.2.tar", last modified: Wed May 10 15:57:15 2023, max compression
```

## Comparing `partitura-1.2.1.tar` & `partitura-1.2.2.tar`

### file list

```diff
@@ -1,59 +1,95 @@
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:15.246390 partitura-1.2.1/
--rw-rw-rw-   0        0        0    11630 2022-11-30 17:10:01.000000 partitura-1.2.1/LICENSE
--rw-rw-rw-   0        0        0     9418 2023-02-09 11:41:15.244393 partitura-1.2.1/PKG-INFO
--rw-rw-rw-   0        0        0     8635 2022-12-01 18:14:47.000000 partitura-1.2.1/README.md
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:14.869030 partitura-1.2.1/partitura/
--rw-rw-rw-   0        0        0     2209 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/__init__.py
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:14.948892 partitura-1.2.1/partitura/assets/
--rw-rw-rw-   0        0        0   335762 2021-05-07 09:19:06.000000 partitura-1.2.1/partitura/assets/musicxml.xsd
--rw-rw-rw-   0        0        0      114 2022-09-21 09:24:19.000000 partitura-1.2.1/partitura/assets/score_example.krn
--rw-rw-rw-   0        0        0     2492 2022-09-21 09:24:19.000000 partitura-1.2.1/partitura/assets/score_example.mei
--rw-rw-rw-   0        0        0       56 2021-05-07 09:20:44.000000 partitura-1.2.1/partitura/assets/score_example.mid
--rw-rw-rw-   0        0        0     1654 2022-10-07 10:26:37.000000 partitura-1.2.1/partitura/assets/score_example.musicxml
--rw-rw-rw-   0        0        0    14632 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/directions.py
--rw-rw-rw-   0        0        0     5782 2023-02-09 11:07:15.000000 partitura-1.2.1/partitura/display.py
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:15.121718 partitura-1.2.1/partitura/io/
--rw-rw-rw-   0        0        0     6393 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/__init__.py
--rw-rw-rw-   0        0        0     4081 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/exportaudio.py
--rw-rw-rw-   0        0        0    19405 2022-12-05 08:48:20.000000 partitura-1.2.1/partitura/io/exportmatch.py
--rw-rw-rw-   0        0        0    73946 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/exportmei.py
--rw-rw-rw-   0        0        0    15591 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/exportmidi.py
--rw-rw-rw-   0        0        0    34879 2022-11-30 17:48:35.000000 partitura-1.2.1/partitura/io/exportmusicxml.py
--rw-rw-rw-   0        0        0     9400 2023-02-09 11:07:15.000000 partitura-1.2.1/partitura/io/exportparangonada.py
--rw-rw-rw-   0        0        0    23038 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/importkern.py
--rw-rw-rw-   0        0        0    26317 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/importmatch.py
--rw-rw-rw-   0        0        0    43549 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/importmei.py
--rw-rw-rw-   0        0        0    27274 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/importmidi.py
--rw-rw-rw-   0        0        0    53490 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/importmusicxml.py
--rw-rw-rw-   0        0        0     8704 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/importnakamura.py
--rw-rw-rw-   0        0        0     6137 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/io/importparangonada.py
--rw-rw-rw-   0        0        0    32891 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/matchfile_base.py
--rw-rw-rw-   0        0        0    26815 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/matchfile_utils.py
--rw-rw-rw-   0        0        0    30307 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/matchlines_v0.py
--rw-rw-rw-   0        0        0    41730 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/io/matchlines_v1.py
--rw-rw-rw-   0        0        0     7564 2023-02-09 11:07:15.000000 partitura-1.2.1/partitura/io/musescore.py
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:15.191535 partitura-1.2.1/partitura/musicanalysis/
--rw-rw-rw-   0        0        0     1103 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/__init__.py
--rw-rw-rw-   0        0        0     7226 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/key_identification.py
--rw-rw-rw-   0        0        0    11531 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/musicanalysis/meter.py
--rw-rw-rw-   0        0        0    33704 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/note_features.py
--rw-rw-rw-   0        0        0    20858 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/musicanalysis/performance_codec.py
--rw-rw-rw-   0        0        0     9260 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/pitch_spelling.py
--rw-rw-rw-   0        0        0    17934 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/tonal_tension.py
--rw-rw-rw-   0        0        0    36884 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/musicanalysis/voice_separation.py
--rw-rw-rw-   0        0        0    15501 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/performance.py
--rw-rw-rw-   0        0        0   151774 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/score.py
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:15.242414 partitura-1.2.1/partitura/utils/
--rw-rw-rw-   0        0        0     1970 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/utils/__init__.py
--rw-rw-rw-   0        0        0    18469 2022-12-01 18:14:47.000000 partitura-1.2.1/partitura/utils/generic.py
--rw-rw-rw-   0        0        0     7320 2023-02-09 11:07:15.000000 partitura-1.2.1/partitura/utils/misc.py
--rw-rw-rw-   0        0        0   109613 2023-01-17 17:35:50.000000 partitura-1.2.1/partitura/utils/music.py
--rw-rw-rw-   0        0        0    14212 2022-11-30 17:10:01.000000 partitura-1.2.1/partitura/utils/synth.py
-drwxrwxrwx   0        0        0        0 2023-02-09 11:41:14.897953 partitura-1.2.1/partitura.egg-info/
--rw-rw-rw-   0        0        0     9418 2023-02-09 11:41:14.000000 partitura-1.2.1/partitura.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     1485 2023-02-09 11:41:14.000000 partitura-1.2.1/partitura.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-02-09 11:41:14.000000 partitura-1.2.1/partitura.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       44 2023-02-09 11:41:14.000000 partitura-1.2.1/partitura.egg-info/requires.txt
--rw-rw-rw-   0        0        0       10 2023-02-09 11:41:14.000000 partitura-1.2.1/partitura.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2023-02-09 11:41:15.246390 partitura-1.2.1/setup.cfg
--rw-rw-rw-   0        0        0     2438 2023-02-09 11:07:47.000000 partitura-1.2.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.440728 partitura-1.2.2/
+-rw-r--r--   0 runner    (1001) docker     (123)    11429 2023-05-10 15:57:08.000000 partitura-1.2.2/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     9276 2023-05-10 15:57:15.440728 partitura-1.2.2/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     8512 2023-05-10 15:57:08.000000 partitura-1.2.2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.420727 partitura-1.2.2/partitura/
+-rw-r--r--   0 runner    (1001) docker     (123)     2150 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.424727 partitura-1.2.2/partitura/assets/
+-rw-r--r--   0 runner    (1001) docker     (123)   335762 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/assets/musicxml.xsd
+-rw-r--r--   0 runner    (1001) docker     (123)      104 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/assets/score_example.krn
+-rw-r--r--   0 runner    (1001) docker     (123)     2436 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/assets/score_example.mei
+-rw-r--r--   0 runner    (1001) docker     (123)       56 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/assets/score_example.mid
+-rw-r--r--   0 runner    (1001) docker     (123)     1589 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/assets/score_example.musicxml
+-rw-r--r--   0 runner    (1001) docker     (123)    14091 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/directions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5600 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/display.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.428727 partitura-1.2.2/partitura/io/
+-rw-r--r--   0 runner    (1001) docker     (123)     6230 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3985 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportaudio.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18808 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportmatch.py
+-rw-r--r--   0 runner    (1001) docker     (123)    71850 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportmei.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15155 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportmidi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35404 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportmusicxml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9272 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/exportparangonada.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22428 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importkern.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25482 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importmatch.py
+-rw-r--r--   0 runner    (1001) docker     (123)    42673 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importmei.py
+-rw-r--r--   0 runner    (1001) docker     (123)    26285 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importmidi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    55272 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importmusicxml.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8432 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importnakamura.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5928 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/importparangonada.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31691 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/matchfile_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25861 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/matchfile_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29250 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/matchlines_v0.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40284 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/matchlines_v1.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7277 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/io/musescore.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.428727 partitura-1.2.2/partitura/musicanalysis/
+-rw-r--r--   0 runner    (1001) docker     (123)     1063 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6991 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/key_identification.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11189 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/meter.py
+-rw-r--r--   0 runner    (1001) docker     (123)    32653 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/note_features.py
+-rw-r--r--   0 runner    (1001) docker     (123)    31215 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/performance_codec.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8930 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/pitch_spelling.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17356 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/tonal_tension.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35763 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/musicanalysis/voice_separation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15195 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/performance.py
+-rw-r--r--   0 runner    (1001) docker     (123)   152020 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/score.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.432727 partitura-1.2.2/partitura/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17848 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/utils/generic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7065 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/utils/misc.py
+-rw-r--r--   0 runner    (1001) docker     (123)   113656 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/utils/music.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15576 2023-05-10 15:57:08.000000 partitura-1.2.2/partitura/utils/synth.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.424727 partitura-1.2.2/partitura.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     9276 2023-05-10 15:57:15.000000 partitura-1.2.2/partitura.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     2380 2023-05-10 15:57:15.000000 partitura-1.2.2/partitura.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-10 15:57:15.000000 partitura-1.2.2/partitura.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       44 2023-05-10 15:57:15.000000 partitura-1.2.2/partitura.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       10 2023-05-10 15:57:15.000000 partitura-1.2.2/partitura.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-10 15:57:15.440728 partitura-1.2.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     2359 2023-05-10 15:57:08.000000 partitura-1.2.2/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-10 15:57:15.436727 partitura-1.2.2/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)     1560 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_deprecations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2103 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_display.py
+-rw-r--r--   0 runner    (1001) docker     (123)      840 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_harmony.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1376 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_kern.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2659 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_key_estimation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1055 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_load_performance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1283 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_load_score.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3578 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_match_export.py
+-rw-r--r--   0 runner    (1001) docker     (123)    74764 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_match_import.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11804 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_mei.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4451 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_merge_parts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4244 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_metrical_position.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15993 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_midi_export.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11626 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_midi_import.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1704 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_nakamura.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6168 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_new_divs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5472 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_note_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_note_features.py
+-rw-r--r--   0 runner    (1001) docker     (123)      766 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_octave_shift.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3822 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_parangonada.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1414 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_part_properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4193 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_performance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3847 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_performance_codec.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15604 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_pianoroll.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1291 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_pitch_spelling.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4551 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_quarter_adjust.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1651 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_rest_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8344 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_synth.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2696 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_time_estimation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1613 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_times.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2050 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_tonal_tension.py
+-rw-r--r--   0 runner    (1001) docker     (123)      929 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_transpose.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18369 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1687 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_voice_estimation.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    10275 2023-05-10 15:57:08.000000 partitura-1.2.2/tests/test_xml.py
```

### Comparing `partitura-1.2.1/LICENSE` & `partitura-1.2.2/LICENSE`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright 2022, Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2022, Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
```

### Comparing `partitura-1.2.1/PKG-INFO` & `partitura-1.2.2/PKG-INFO`

 * *Files 24% similar despite different names*

```diff
@@ -1,274 +1,275 @@
-Metadata-Version: 2.1
-Name: partitura
-Version: 1.2.1
-Summary: A package for handling symbolic musical information
-Home-page: https://github.com/CPJKU/partitura
-Author: Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin, Thassilo Gadermaier
-Author-email: partitura-users@googlegroups.com
-License: Apache 2.0
-Keywords: music notation musicxml midi
-Classifier: License :: OSI Approved :: MIT License
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: Implementation :: CPython
-Classifier: Programming Language :: Python :: Implementation :: PyPy
-Requires-Python: >=3.6
-Description-Content-Type: text/markdown
-License-File: LICENSE
-
-
-[//]: # (<p align="center"> )
-
-[//]: # (<img src="./partitura/assets/partitura_logo_final.jpg" height="200">)
-
-[//]: # (</p>)
-<p align="center">
-    <img src="partitura/assets/partitura_logo_black.png#gh-light-mode-only" height="200">
-    <img align="center" src="./partitura/assets/partitura_logo_white.png#gh-dark-mode-only" height="200">
-</p>
-
-[![Latest Release](https://img.shields.io/github/v/release/cpjku/partitura)](https://github.com/cpjku/partitura/releases)
-[![Pypi Package](https://badge.fury.io/py/partitura.svg)](https://badge.fury.io/py/partitura)
-[![Unittest Status](https://github.com/CPJKU/partitura/workflows/Partitura%20Unittests/badge.svg)](https://github.com/CPJKU/partitura/actions?query=workflow%3A%22Partitura+Unittests%22)
-[![CodeCov Status](https://codecov.io/gh/CPJKU/partitura/branch/develop/graph/badge.svg?token=mnZ234sGSA)](https://codecov.io/gh/CPJKU/partitura)
-[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](CODE_OF_CONDUCT.md)
-
-
-
-**Partitura** is a Python package for handling symbolic musical information. It
-supports loading from and exporting to *MusicXML* and *MIDI* files. It also supports loading from _Humdrum *kern*_ and *MEI*.
-
-The full documentation for `partitura` is available online at [readthedocs.org](https://partitura.readthedocs.io/en/latest/index.html).
-
-User Installation
-==========
-
-The easiest way to install the package is via `pip` from the [PyPI (Python
-Package Index)](https://pypi.python.org/pypi>):
-```shell
-pip install partitura
-```
-This will install the latest release of the package and will install all dependencies automatically.
-
-
-Quickstart
-==========
-
-The following code loads the contents of an example MusicXML file included in
-the package:
-```python
-import partitura as pt
-my_xml_file = pt.EXAMPLE_MUSICXML
-score = pt.load_score(my_xml_file)
-```
-The partitura `load_score` function will import any score format, i.e. (Musicxml, Kern, MIDI or MEI) to a `partitura.Score` object.
-The score object will contain all the information in the score, including the score parts.
-The following shows the contents of the first part of the score:
-
-```python
-part = score.parts[0]
-print(part.pretty())
-```
-Output:
-```shell
-Part id="P1" name="Piano"
- │
- ├─ TimePoint t=0 quarter=12
- │   │
- │   └─ starting objects
- │       │
- │       ├─ 0--48 Measure number=1
- │       ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
- │       ├─ 0--48 Page number=1
- │       ├─ 0--24 Rest id=r01 voice=2 staff=1 type=half
- │       ├─ 0--48 System number=1
- │       └─ 0-- TimeSignature 4/4
- │
- ├─ TimePoint t=24 quarter=12
- │   │
- │   ├─ ending objects
- │   │   │
- │   │   └─ 0--24 Rest id=r01 voice=2 staff=1 type=half
- │   │
- │   └─ starting objects
- │       │
- │       ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
- │       └─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
- │
- └─ TimePoint t=48 quarter=12
-     │
-     └─ ending objects
-         │
-         ├─ 0--48 Measure number=1
-         ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
-         ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
-         ├─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
-         ├─ 0--48 Page number=1
-         └─ 0--48 System number=1
-  
-```
-If `lilypond` or `MuseScore` are installed on the system, the following command
-renders the part to an image and displays it:
-
-```python
-pt.render(part)
-```
-![Score example](https://raw.githubusercontent.com/CPJKU/partitura/main/docs/source/images/score_example.png)
-
-
-The notes in this part can be accessed through the property
-`part.notes`:
-
-```python
-part.notes
-> [<partitura.score.Note object at 0x...>, <partitura.score.Note object at 0x...>, 
-> <partitura.score.Note object at 0x...>]
-
-```
-
-
-The following code stores the start, end, and midi pitch of the notes in a numpy
-array:
-
-```python
-import numpy as np
-pianoroll = np.array([(n.start.t, n.end.t, n.midi_pitch) for n in part.notes])
-print(pianoroll)
-> [[ 0 48 69]
->  [24 48 72]
->  [24 48 76]]
-```
-
-
-The note start and end times are in the units specified by the
-`divisions` element of the MusicXML file. This element specifies the
-duration of a quarter note. The `divisions` value can vary within an
-MusicXML file, so it is generally better to work with musical time in
-beats.
-
-The part object has a property :`part.beat_map` that converts timeline
-times into beat times:
-
-```python
-beat_map = part.beat_map
-print(beat_map(pianoroll[:, 0]))
-> [0. 2. 2.]
-print(beat_map(pianoroll[:, 1]))
-> [4. 4. 4.]
-```
-
-
-The following commands save the part to MIDI and MusicXML, or export it as a WAV file (using [additive synthesis](https://en.wikipedia.org/wiki/Additive_synthesis)), respectively:
-
-```python
-# Save Score MIDI to file.
-pt.save_score_midi(part, 'mypart.mid')
-
-# Save Score MusicXML to file.
-pt.save_musicxml(part, 'mypart.musicxml')
-
-# Save as audio file using additive synthesis
-pt.save_wav(part, 'mypart.wav')
-```
-
-
-More elaborate examples can be found in the `documentation
-<https://partitura.readthedocs.io/en/latest/index.html>`_.
-
-Import other formats
-====================
-For **MusicXML** files do:
-
-```python
-import partitura as pt
-my_xml_file = pt.EXAMPLE_MUSICXML
-score = pt.load_musicxml(my_xml_file)
-```
-
-For **Kern** files do:
-
-```python
-import partitura as pt
-my_kern_file = pt.EXAMPLE_KERN
-score = pt.load_kern(my_kern_file)
-```
-
-For **MEI** files do:
-
-```python
-import partitura as pt
-my_mei_file = pt.EXAMPLE_MEI
-score = pt.load_mei(my_mei_file)
-```
-
-
-One can also import any of the above formats by just using:
-
-```python
-import partitura as pt
-any_score_format_path = pt.EXAMPLE_MUSICXML
-score = pt.load_score(any_score_format_path)
-```
-
-
-License
-=======
-
-The code in this package is licensed under the Apache 2.0 License. For details,
-please see the [LICENSE](LICENSE) file.
-
-
-Citing Partitura
-================
-
-If you find Partitura useful, we would appreciate if you could cite us!
-
-```
-@inproceedings{partitura_mec,
-  title={{Partitura: A Python Package for Symbolic Music Processing}},
-  author={Cancino-Chac\'{o}n, Carlos Eduardo and Peter, Silvan David and Karystinaios, Emmanouil and Foscarin, Francesco and Grachten, Maarten and Widmer, Gerhard},
-  booktitle={{Proceedings of the Music Encoding Conference (MEC2022)}},
-  address={Halifax, Canada},
-  year={2022}
-}
-```
-
-[//]: # (    | `Grachten, M. <https://maarten.grachten.eu>`__, `Cancino-Chacón, C. <http://www.carloscancinochacon.com>`__ and `Gadermaier, T. <https://www.jku.at/en/institute-of-computational-perception/about-us/people/thassilo-gadermaier/>`__)
-
-[//]: # (    | "`partitura: A Python Package for Handling Symbolic Musical Data <http://carloscancinochacon.com/documents/extended_abstracts/GrachtenEtAl-ISMIR2019-LBD-ext-abstract.pdf>`__\ ".)
-
-[//]: # (    | Late Breaking/Demo Session at the 20th International Society for)
-
-[//]: # (    Music Information Retrieval Conference, Delft, The Netherlands,)
-
-[//]: # (    2019.)
-
-
-
-Acknowledgments
-===============
-
-This project receives funding from the European Research Council (ERC) under 
-the European Union's Horizon 2020 research and innovation programme under grant 
-agreement No 101019375 ["Whither Music?"](https://www.jku.at/en/institute-of-computational-perception/research/projects/whither-music/).
-
-
-
-This work has received support from the European Research Council (ERC) under
-the European Union’s Horizon 2020 research and innovation programme under grant
-agreement No. 670035 project ["Con Espressione"](https://www.jku.at/en/institute-of-computational-perception/research/projects/con-espressione/)
-and the Austrian Science Fund (FWF) under grant P 29840-G26 (project
-["Computer-assisted Analysis of Herbert von Karajan's Musical Conducting Style"](https://karajan-research.org/programs/musical-interpretation-karajan))
-<p align="center">
-    <img src="docs/source/images/aknowledge_logo.png#gh-light-mode-only" height="200">
-    <img src="docs/source/images/aknowledge_logo_negative.png#gh-dark-mode-only" height="200">
-</p>
-
-[//]: # ()
-[//]: # (.. image:: https://raw.githubusercontent.com/CPJKU/partitura/master/docs/images/erc_fwf_logos.jpg)
-
-[//]: # (   :width: 600 px)
-
-[//]: # (   :scale: 1%)
-
-[//]: # (   :align: center)
+Metadata-Version: 2.1
+Name: partitura
+Version: 1.2.2
+Summary: A package for handling symbolic musical information
+Home-page: https://github.com/CPJKU/partitura
+Author: Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin, Thassilo Gadermaier
+Author-email: partitura-users@googlegroups.com
+License: Apache 2.0
+Keywords: music notation musicxml midi
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+
+[//]: # (<p align="center"> )
+
+[//]: # (<img src="./partitura/assets/partitura_logo_final.jpg" height="200">)
+
+[//]: # (</p>)
+<p align="center">
+    <img src="partitura/assets/partitura_logo_black.png#gh-light-mode-only" height="200">
+    <img align="center" src="./partitura/assets/partitura_logo_white.png#gh-dark-mode-only" height="200">
+</p>
+
+[![Latest Release](https://img.shields.io/github/v/release/cpjku/partitura)](https://github.com/cpjku/partitura/releases)
+[![Pypi Package](https://badge.fury.io/py/partitura.svg)](https://badge.fury.io/py/partitura)
+[![Unittest Status](https://github.com/CPJKU/partitura/workflows/Partitura%20Unittests/badge.svg)](https://github.com/CPJKU/partitura/actions?query=workflow%3A%22Partitura+Unittests%22)
+[![CodeCov Status](https://codecov.io/gh/CPJKU/partitura/branch/develop/graph/badge.svg?token=mnZ234sGSA)](https://codecov.io/gh/CPJKU/partitura)
+[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](CODE_OF_CONDUCT.md)
+
+
+
+**Partitura** is a Python package for handling symbolic musical information. It
+supports loading from and exporting to *MusicXML* and *MIDI* files. It also supports loading from _Humdrum *kern*_ and *MEI*.
+
+The full documentation for `partitura` is available online at [readthedocs.org](https://partitura.readthedocs.io/en/latest/index.html).
+
+User Installation
+==========
+
+The easiest way to install the package is via `pip` from the [PyPI (Python
+Package Index)](https://pypi.python.org/pypi>):
+```shell
+pip install partitura
+```
+This will install the latest release of the package and will install all dependencies automatically.
+
+
+Quickstart
+==========
+A detailed tutorial with some hands-on MIR applications is available [here](https://cpjku.github.io/partitura_tutorial/index.html).
+
+The following code loads the contents of an example MusicXML file included in
+the package:
+```python
+import partitura as pt
+my_xml_file = pt.EXAMPLE_MUSICXML
+score = pt.load_score(my_xml_file)
+```
+The partitura `load_score` function will import any score format, i.e. (Musicxml, Kern, MIDI or MEI) to a `partitura.Score` object.
+The score object will contain all the information in the score, including the score parts.
+The following shows the contents of the first part of the score:
+
+```python
+part = score.parts[0]
+print(part.pretty())
+```
+Output:
+```shell
+Part id="P1" name="Piano"
+ │
+ ├─ TimePoint t=0 quarter=12
+ │   │
+ │   └─ starting objects
+ │       │
+ │       ├─ 0--48 Measure number=1
+ │       ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
+ │       ├─ 0--48 Page number=1
+ │       ├─ 0--24 Rest id=r01 voice=2 staff=1 type=half
+ │       ├─ 0--48 System number=1
+ │       └─ 0-- TimeSignature 4/4
+ │
+ ├─ TimePoint t=24 quarter=12
+ │   │
+ │   ├─ ending objects
+ │   │   │
+ │   │   └─ 0--24 Rest id=r01 voice=2 staff=1 type=half
+ │   │
+ │   └─ starting objects
+ │       │
+ │       ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
+ │       └─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
+ │
+ └─ TimePoint t=48 quarter=12
+     │
+     └─ ending objects
+         │
+         ├─ 0--48 Measure number=1
+         ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
+         ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
+         ├─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
+         ├─ 0--48 Page number=1
+         └─ 0--48 System number=1
+  
+```
+If `lilypond` or `MuseScore` are installed on the system, the following command
+renders the part to an image and displays it:
+
+```python
+pt.render(part)
+```
+![Score example](https://raw.githubusercontent.com/CPJKU/partitura/main/docs/source/images/score_example.png)
+
+
+The notes in this part can be accessed through the property
+`part.notes`:
+
+```python
+part.notes
+> [<partitura.score.Note object at 0x...>, <partitura.score.Note object at 0x...>, 
+> <partitura.score.Note object at 0x...>]
+
+```
+
+
+The following code stores the start, end, and midi pitch of the notes in a numpy
+array:
+
+```python
+import numpy as np
+pianoroll = np.array([(n.start.t, n.end.t, n.midi_pitch) for n in part.notes])
+print(pianoroll)
+> [[ 0 48 69]
+>  [24 48 72]
+>  [24 48 76]]
+```
+
+
+The note start and end times are in the units specified by the
+`divisions` element of the MusicXML file. This element specifies the
+duration of a quarter note. The `divisions` value can vary within an
+MusicXML file, so it is generally better to work with musical time in
+beats.
+
+The part object has a property :`part.beat_map` that converts timeline
+times into beat times:
+
+```python
+beat_map = part.beat_map
+print(beat_map(pianoroll[:, 0]))
+> [0. 2. 2.]
+print(beat_map(pianoroll[:, 1]))
+> [4. 4. 4.]
+```
+
+
+The following commands save the part to MIDI and MusicXML, or export it as a WAV file (using [additive synthesis](https://en.wikipedia.org/wiki/Additive_synthesis)), respectively:
+
+```python
+# Save Score MIDI to file.
+pt.save_score_midi(part, 'mypart.mid')
+
+# Save Score MusicXML to file.
+pt.save_musicxml(part, 'mypart.musicxml')
+
+# Save as audio file using additive synthesis
+pt.save_wav(part, 'mypart.wav')
+```
+
+
+More elaborate examples can be found in the `documentation
+<https://partitura.readthedocs.io/en/latest/index.html>`_.
+
+Import other formats
+====================
+For **MusicXML** files do:
+
+```python
+import partitura as pt
+my_xml_file = pt.EXAMPLE_MUSICXML
+score = pt.load_musicxml(my_xml_file)
+```
+
+For **Kern** files do:
+
+```python
+import partitura as pt
+my_kern_file = pt.EXAMPLE_KERN
+score = pt.load_kern(my_kern_file)
+```
+
+For **MEI** files do:
+
+```python
+import partitura as pt
+my_mei_file = pt.EXAMPLE_MEI
+score = pt.load_mei(my_mei_file)
+```
+
+
+One can also import any of the above formats by just using:
+
+```python
+import partitura as pt
+any_score_format_path = pt.EXAMPLE_MUSICXML
+score = pt.load_score(any_score_format_path)
+```
+
+
+License
+=======
+
+The code in this package is licensed under the Apache 2.0 License. For details,
+please see the [LICENSE](LICENSE) file.
+
+
+Citing Partitura
+================
+
+If you find Partitura useful, we would appreciate if you could cite us!
+
+```
+@inproceedings{partitura_mec,
+  title={{Partitura: A Python Package for Symbolic Music Processing}},
+  author={Cancino-Chac\'{o}n, Carlos Eduardo and Peter, Silvan David and Karystinaios, Emmanouil and Foscarin, Francesco and Grachten, Maarten and Widmer, Gerhard},
+  booktitle={{Proceedings of the Music Encoding Conference (MEC2022)}},
+  address={Halifax, Canada},
+  year={2022}
+}
+```
+
+[//]: # (    | `Grachten, M. <https://maarten.grachten.eu>`__, `Cancino-Chacón, C. <http://www.carloscancinochacon.com>`__ and `Gadermaier, T. <https://www.jku.at/en/institute-of-computational-perception/about-us/people/thassilo-gadermaier/>`__)
+
+[//]: # (    | "`partitura: A Python Package for Handling Symbolic Musical Data <http://carloscancinochacon.com/documents/extended_abstracts/GrachtenEtAl-ISMIR2019-LBD-ext-abstract.pdf>`__\ ".)
+
+[//]: # (    | Late Breaking/Demo Session at the 20th International Society for)
+
+[//]: # (    Music Information Retrieval Conference, Delft, The Netherlands,)
+
+[//]: # (    2019.)
+
+
+
+Acknowledgments
+===============
+
+This project receives funding from the European Research Council (ERC) under 
+the European Union's Horizon 2020 research and innovation programme under grant 
+agreement No 101019375 ["Whither Music?"](https://www.jku.at/en/institute-of-computational-perception/research/projects/whither-music/).
+
+
+
+This work has received support from the European Research Council (ERC) under
+the European Union’s Horizon 2020 research and innovation programme under grant
+agreement No. 670035 project ["Con Espressione"](https://www.jku.at/en/institute-of-computational-perception/research/projects/con-espressione/)
+and the Austrian Science Fund (FWF) under grant P 29840-G26 (project
+["Computer-assisted Analysis of Herbert von Karajan's Musical Conducting Style"](https://karajan-research.org/programs/musical-interpretation-karajan))
+<p align="center">
+    <img src="docs/source/images/aknowledge_logo.png#gh-light-mode-only" height="200">
+    <img src="docs/source/images/aknowledge_logo_negative.png#gh-dark-mode-only" height="200">
+</p>
+
+[//]: # ()
+[//]: # (.. image:: https://raw.githubusercontent.com/CPJKU/partitura/master/docs/images/erc_fwf_logos.jpg)
+
+[//]: # (   :width: 600 px)
+
+[//]: # (   :scale: 1%)
+
+[//]: # (   :align: center)
```

### Comparing `partitura-1.2.1/README.md` & `partitura-1.2.2/partitura.egg-info/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,255 +1,275 @@
-[//]: # (<p align="center"> )
-
-[//]: # (<img src="./partitura/assets/partitura_logo_final.jpg" height="200">)
-
-[//]: # (</p>)
-<p align="center">
-    <img src="partitura/assets/partitura_logo_black.png#gh-light-mode-only" height="200">
-    <img align="center" src="./partitura/assets/partitura_logo_white.png#gh-dark-mode-only" height="200">
-</p>
-
-[![Latest Release](https://img.shields.io/github/v/release/cpjku/partitura)](https://github.com/cpjku/partitura/releases)
-[![Pypi Package](https://badge.fury.io/py/partitura.svg)](https://badge.fury.io/py/partitura)
-[![Unittest Status](https://github.com/CPJKU/partitura/workflows/Partitura%20Unittests/badge.svg)](https://github.com/CPJKU/partitura/actions?query=workflow%3A%22Partitura+Unittests%22)
-[![CodeCov Status](https://codecov.io/gh/CPJKU/partitura/branch/develop/graph/badge.svg?token=mnZ234sGSA)](https://codecov.io/gh/CPJKU/partitura)
-[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](CODE_OF_CONDUCT.md)
-
-
-
-**Partitura** is a Python package for handling symbolic musical information. It
-supports loading from and exporting to *MusicXML* and *MIDI* files. It also supports loading from _Humdrum *kern*_ and *MEI*.
-
-The full documentation for `partitura` is available online at [readthedocs.org](https://partitura.readthedocs.io/en/latest/index.html).
-
-User Installation
-==========
-
-The easiest way to install the package is via `pip` from the [PyPI (Python
-Package Index)](https://pypi.python.org/pypi>):
-```shell
-pip install partitura
-```
-This will install the latest release of the package and will install all dependencies automatically.
-
-
-Quickstart
-==========
-
-The following code loads the contents of an example MusicXML file included in
-the package:
-```python
-import partitura as pt
-my_xml_file = pt.EXAMPLE_MUSICXML
-score = pt.load_score(my_xml_file)
-```
-The partitura `load_score` function will import any score format, i.e. (Musicxml, Kern, MIDI or MEI) to a `partitura.Score` object.
-The score object will contain all the information in the score, including the score parts.
-The following shows the contents of the first part of the score:
-
-```python
-part = score.parts[0]
-print(part.pretty())
-```
-Output:
-```shell
-Part id="P1" name="Piano"
- │
- ├─ TimePoint t=0 quarter=12
- │   │
- │   └─ starting objects
- │       │
- │       ├─ 0--48 Measure number=1
- │       ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
- │       ├─ 0--48 Page number=1
- │       ├─ 0--24 Rest id=r01 voice=2 staff=1 type=half
- │       ├─ 0--48 System number=1
- │       └─ 0-- TimeSignature 4/4
- │
- ├─ TimePoint t=24 quarter=12
- │   │
- │   ├─ ending objects
- │   │   │
- │   │   └─ 0--24 Rest id=r01 voice=2 staff=1 type=half
- │   │
- │   └─ starting objects
- │       │
- │       ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
- │       └─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
- │
- └─ TimePoint t=48 quarter=12
-     │
-     └─ ending objects
-         │
-         ├─ 0--48 Measure number=1
-         ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
-         ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
-         ├─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
-         ├─ 0--48 Page number=1
-         └─ 0--48 System number=1
-  
-```
-If `lilypond` or `MuseScore` are installed on the system, the following command
-renders the part to an image and displays it:
-
-```python
-pt.render(part)
-```
-![Score example](https://raw.githubusercontent.com/CPJKU/partitura/main/docs/source/images/score_example.png)
-
-
-The notes in this part can be accessed through the property
-`part.notes`:
-
-```python
-part.notes
-> [<partitura.score.Note object at 0x...>, <partitura.score.Note object at 0x...>, 
-> <partitura.score.Note object at 0x...>]
-
-```
-
-
-The following code stores the start, end, and midi pitch of the notes in a numpy
-array:
-
-```python
-import numpy as np
-pianoroll = np.array([(n.start.t, n.end.t, n.midi_pitch) for n in part.notes])
-print(pianoroll)
-> [[ 0 48 69]
->  [24 48 72]
->  [24 48 76]]
-```
-
-
-The note start and end times are in the units specified by the
-`divisions` element of the MusicXML file. This element specifies the
-duration of a quarter note. The `divisions` value can vary within an
-MusicXML file, so it is generally better to work with musical time in
-beats.
-
-The part object has a property :`part.beat_map` that converts timeline
-times into beat times:
-
-```python
-beat_map = part.beat_map
-print(beat_map(pianoroll[:, 0]))
-> [0. 2. 2.]
-print(beat_map(pianoroll[:, 1]))
-> [4. 4. 4.]
-```
-
-
-The following commands save the part to MIDI and MusicXML, or export it as a WAV file (using [additive synthesis](https://en.wikipedia.org/wiki/Additive_synthesis)), respectively:
-
-```python
-# Save Score MIDI to file.
-pt.save_score_midi(part, 'mypart.mid')
-
-# Save Score MusicXML to file.
-pt.save_musicxml(part, 'mypart.musicxml')
-
-# Save as audio file using additive synthesis
-pt.save_wav(part, 'mypart.wav')
-```
-
-
-More elaborate examples can be found in the `documentation
-<https://partitura.readthedocs.io/en/latest/index.html>`_.
-
-Import other formats
-====================
-For **MusicXML** files do:
-
-```python
-import partitura as pt
-my_xml_file = pt.EXAMPLE_MUSICXML
-score = pt.load_musicxml(my_xml_file)
-```
-
-For **Kern** files do:
-
-```python
-import partitura as pt
-my_kern_file = pt.EXAMPLE_KERN
-score = pt.load_kern(my_kern_file)
-```
-
-For **MEI** files do:
-
-```python
-import partitura as pt
-my_mei_file = pt.EXAMPLE_MEI
-score = pt.load_mei(my_mei_file)
-```
-
-
-One can also import any of the above formats by just using:
-
-```python
-import partitura as pt
-any_score_format_path = pt.EXAMPLE_MUSICXML
-score = pt.load_score(any_score_format_path)
-```
-
-
-License
-=======
-
-The code in this package is licensed under the Apache 2.0 License. For details,
-please see the [LICENSE](LICENSE) file.
-
-
-Citing Partitura
-================
-
-If you find Partitura useful, we would appreciate if you could cite us!
-
-```
-@inproceedings{partitura_mec,
-  title={{Partitura: A Python Package for Symbolic Music Processing}},
-  author={Cancino-Chac\'{o}n, Carlos Eduardo and Peter, Silvan David and Karystinaios, Emmanouil and Foscarin, Francesco and Grachten, Maarten and Widmer, Gerhard},
-  booktitle={{Proceedings of the Music Encoding Conference (MEC2022)}},
-  address={Halifax, Canada},
-  year={2022}
-}
-```
-
-[//]: # (    | `Grachten, M. <https://maarten.grachten.eu>`__, `Cancino-Chacón, C. <http://www.carloscancinochacon.com>`__ and `Gadermaier, T. <https://www.jku.at/en/institute-of-computational-perception/about-us/people/thassilo-gadermaier/>`__)
-
-[//]: # (    | "`partitura: A Python Package for Handling Symbolic Musical Data <http://carloscancinochacon.com/documents/extended_abstracts/GrachtenEtAl-ISMIR2019-LBD-ext-abstract.pdf>`__\ ".)
-
-[//]: # (    | Late Breaking/Demo Session at the 20th International Society for)
-
-[//]: # (    Music Information Retrieval Conference, Delft, The Netherlands,)
-
-[//]: # (    2019.)
-
-
-
-Acknowledgments
-===============
-
-This project receives funding from the European Research Council (ERC) under 
-the European Union's Horizon 2020 research and innovation programme under grant 
-agreement No 101019375 ["Whither Music?"](https://www.jku.at/en/institute-of-computational-perception/research/projects/whither-music/).
-
-
-
-This work has received support from the European Research Council (ERC) under
-the European Union’s Horizon 2020 research and innovation programme under grant
-agreement No. 670035 project ["Con Espressione"](https://www.jku.at/en/institute-of-computational-perception/research/projects/con-espressione/)
-and the Austrian Science Fund (FWF) under grant P 29840-G26 (project
-["Computer-assisted Analysis of Herbert von Karajan's Musical Conducting Style"](https://karajan-research.org/programs/musical-interpretation-karajan))
-<p align="center">
-    <img src="docs/source/images/aknowledge_logo.png#gh-light-mode-only" height="200">
-    <img src="docs/source/images/aknowledge_logo_negative.png#gh-dark-mode-only" height="200">
-</p>
-
-[//]: # ()
-[//]: # (.. image:: https://raw.githubusercontent.com/CPJKU/partitura/master/docs/images/erc_fwf_logos.jpg)
-
-[//]: # (   :width: 600 px)
-
-[//]: # (   :scale: 1%)
-
-[//]: # (   :align: center)
+Metadata-Version: 2.1
+Name: partitura
+Version: 1.2.2
+Summary: A package for handling symbolic musical information
+Home-page: https://github.com/CPJKU/partitura
+Author: Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin, Thassilo Gadermaier
+Author-email: partitura-users@googlegroups.com
+License: Apache 2.0
+Keywords: music notation musicxml midi
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: Implementation :: CPython
+Classifier: Programming Language :: Python :: Implementation :: PyPy
+Requires-Python: >=3.6
+Description-Content-Type: text/markdown
+License-File: LICENSE
+
+
+[//]: # (<p align="center"> )
+
+[//]: # (<img src="./partitura/assets/partitura_logo_final.jpg" height="200">)
+
+[//]: # (</p>)
+<p align="center">
+    <img src="partitura/assets/partitura_logo_black.png#gh-light-mode-only" height="200">
+    <img align="center" src="./partitura/assets/partitura_logo_white.png#gh-dark-mode-only" height="200">
+</p>
+
+[![Latest Release](https://img.shields.io/github/v/release/cpjku/partitura)](https://github.com/cpjku/partitura/releases)
+[![Pypi Package](https://badge.fury.io/py/partitura.svg)](https://badge.fury.io/py/partitura)
+[![Unittest Status](https://github.com/CPJKU/partitura/workflows/Partitura%20Unittests/badge.svg)](https://github.com/CPJKU/partitura/actions?query=workflow%3A%22Partitura+Unittests%22)
+[![CodeCov Status](https://codecov.io/gh/CPJKU/partitura/branch/develop/graph/badge.svg?token=mnZ234sGSA)](https://codecov.io/gh/CPJKU/partitura)
+[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](CODE_OF_CONDUCT.md)
+
+
+
+**Partitura** is a Python package for handling symbolic musical information. It
+supports loading from and exporting to *MusicXML* and *MIDI* files. It also supports loading from _Humdrum *kern*_ and *MEI*.
+
+The full documentation for `partitura` is available online at [readthedocs.org](https://partitura.readthedocs.io/en/latest/index.html).
+
+User Installation
+==========
+
+The easiest way to install the package is via `pip` from the [PyPI (Python
+Package Index)](https://pypi.python.org/pypi>):
+```shell
+pip install partitura
+```
+This will install the latest release of the package and will install all dependencies automatically.
+
+
+Quickstart
+==========
+A detailed tutorial with some hands-on MIR applications is available [here](https://cpjku.github.io/partitura_tutorial/index.html).
+
+The following code loads the contents of an example MusicXML file included in
+the package:
+```python
+import partitura as pt
+my_xml_file = pt.EXAMPLE_MUSICXML
+score = pt.load_score(my_xml_file)
+```
+The partitura `load_score` function will import any score format, i.e. (Musicxml, Kern, MIDI or MEI) to a `partitura.Score` object.
+The score object will contain all the information in the score, including the score parts.
+The following shows the contents of the first part of the score:
+
+```python
+part = score.parts[0]
+print(part.pretty())
+```
+Output:
+```shell
+Part id="P1" name="Piano"
+ │
+ ├─ TimePoint t=0 quarter=12
+ │   │
+ │   └─ starting objects
+ │       │
+ │       ├─ 0--48 Measure number=1
+ │       ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
+ │       ├─ 0--48 Page number=1
+ │       ├─ 0--24 Rest id=r01 voice=2 staff=1 type=half
+ │       ├─ 0--48 System number=1
+ │       └─ 0-- TimeSignature 4/4
+ │
+ ├─ TimePoint t=24 quarter=12
+ │   │
+ │   ├─ ending objects
+ │   │   │
+ │   │   └─ 0--24 Rest id=r01 voice=2 staff=1 type=half
+ │   │
+ │   └─ starting objects
+ │       │
+ │       ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
+ │       └─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
+ │
+ └─ TimePoint t=48 quarter=12
+     │
+     └─ ending objects
+         │
+         ├─ 0--48 Measure number=1
+         ├─ 0--48 Note id=n01 voice=1 staff=2 type=whole pitch=A4
+         ├─ 24--48 Note id=n02 voice=2 staff=1 type=half pitch=C5
+         ├─ 24--48 Note id=n03 voice=2 staff=1 type=half pitch=E5
+         ├─ 0--48 Page number=1
+         └─ 0--48 System number=1
+  
+```
+If `lilypond` or `MuseScore` are installed on the system, the following command
+renders the part to an image and displays it:
+
+```python
+pt.render(part)
+```
+![Score example](https://raw.githubusercontent.com/CPJKU/partitura/main/docs/source/images/score_example.png)
+
+
+The notes in this part can be accessed through the property
+`part.notes`:
+
+```python
+part.notes
+> [<partitura.score.Note object at 0x...>, <partitura.score.Note object at 0x...>, 
+> <partitura.score.Note object at 0x...>]
+
+```
+
+
+The following code stores the start, end, and midi pitch of the notes in a numpy
+array:
+
+```python
+import numpy as np
+pianoroll = np.array([(n.start.t, n.end.t, n.midi_pitch) for n in part.notes])
+print(pianoroll)
+> [[ 0 48 69]
+>  [24 48 72]
+>  [24 48 76]]
+```
+
+
+The note start and end times are in the units specified by the
+`divisions` element of the MusicXML file. This element specifies the
+duration of a quarter note. The `divisions` value can vary within an
+MusicXML file, so it is generally better to work with musical time in
+beats.
+
+The part object has a property :`part.beat_map` that converts timeline
+times into beat times:
+
+```python
+beat_map = part.beat_map
+print(beat_map(pianoroll[:, 0]))
+> [0. 2. 2.]
+print(beat_map(pianoroll[:, 1]))
+> [4. 4. 4.]
+```
+
+
+The following commands save the part to MIDI and MusicXML, or export it as a WAV file (using [additive synthesis](https://en.wikipedia.org/wiki/Additive_synthesis)), respectively:
+
+```python
+# Save Score MIDI to file.
+pt.save_score_midi(part, 'mypart.mid')
+
+# Save Score MusicXML to file.
+pt.save_musicxml(part, 'mypart.musicxml')
+
+# Save as audio file using additive synthesis
+pt.save_wav(part, 'mypart.wav')
+```
+
+
+More elaborate examples can be found in the `documentation
+<https://partitura.readthedocs.io/en/latest/index.html>`_.
+
+Import other formats
+====================
+For **MusicXML** files do:
+
+```python
+import partitura as pt
+my_xml_file = pt.EXAMPLE_MUSICXML
+score = pt.load_musicxml(my_xml_file)
+```
+
+For **Kern** files do:
+
+```python
+import partitura as pt
+my_kern_file = pt.EXAMPLE_KERN
+score = pt.load_kern(my_kern_file)
+```
+
+For **MEI** files do:
+
+```python
+import partitura as pt
+my_mei_file = pt.EXAMPLE_MEI
+score = pt.load_mei(my_mei_file)
+```
+
+
+One can also import any of the above formats by just using:
+
+```python
+import partitura as pt
+any_score_format_path = pt.EXAMPLE_MUSICXML
+score = pt.load_score(any_score_format_path)
+```
+
+
+License
+=======
+
+The code in this package is licensed under the Apache 2.0 License. For details,
+please see the [LICENSE](LICENSE) file.
+
+
+Citing Partitura
+================
+
+If you find Partitura useful, we would appreciate if you could cite us!
+
+```
+@inproceedings{partitura_mec,
+  title={{Partitura: A Python Package for Symbolic Music Processing}},
+  author={Cancino-Chac\'{o}n, Carlos Eduardo and Peter, Silvan David and Karystinaios, Emmanouil and Foscarin, Francesco and Grachten, Maarten and Widmer, Gerhard},
+  booktitle={{Proceedings of the Music Encoding Conference (MEC2022)}},
+  address={Halifax, Canada},
+  year={2022}
+}
+```
+
+[//]: # (    | `Grachten, M. <https://maarten.grachten.eu>`__, `Cancino-Chacón, C. <http://www.carloscancinochacon.com>`__ and `Gadermaier, T. <https://www.jku.at/en/institute-of-computational-perception/about-us/people/thassilo-gadermaier/>`__)
+
+[//]: # (    | "`partitura: A Python Package for Handling Symbolic Musical Data <http://carloscancinochacon.com/documents/extended_abstracts/GrachtenEtAl-ISMIR2019-LBD-ext-abstract.pdf>`__\ ".)
+
+[//]: # (    | Late Breaking/Demo Session at the 20th International Society for)
+
+[//]: # (    Music Information Retrieval Conference, Delft, The Netherlands,)
+
+[//]: # (    2019.)
+
+
+
+Acknowledgments
+===============
+
+This project receives funding from the European Research Council (ERC) under 
+the European Union's Horizon 2020 research and innovation programme under grant 
+agreement No 101019375 ["Whither Music?"](https://www.jku.at/en/institute-of-computational-perception/research/projects/whither-music/).
+
+
+
+This work has received support from the European Research Council (ERC) under
+the European Union’s Horizon 2020 research and innovation programme under grant
+agreement No. 670035 project ["Con Espressione"](https://www.jku.at/en/institute-of-computational-perception/research/projects/con-espressione/)
+and the Austrian Science Fund (FWF) under grant P 29840-G26 (project
+["Computer-assisted Analysis of Herbert von Karajan's Musical Conducting Style"](https://karajan-research.org/programs/musical-interpretation-karajan))
+<p align="center">
+    <img src="docs/source/images/aknowledge_logo.png#gh-light-mode-only" height="200">
+    <img src="docs/source/images/aknowledge_logo_negative.png#gh-dark-mode-only" height="200">
+</p>
+
+[//]: # ()
+[//]: # (.. image:: https://raw.githubusercontent.com/CPJKU/partitura/master/docs/images/erc_fwf_logos.jpg)
+
+[//]: # (   :width: 600 px)
+
+[//]: # (   :scale: 1%)
+
+[//]: # (   :align: center)
```

### Comparing `partitura-1.2.1/partitura/assets/musicxml.xsd` & `partitura-1.2.2/partitura/assets/musicxml.xsd`

 * *Files identical despite different names*

### Comparing `partitura-1.2.1/partitura/assets/score_example.mei` & `partitura-1.2.2/partitura/assets/score_example.mei`

 * *Format-specific differences are supported for XML files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: XML 1.0 document, Unicode text, UTF-8 (with BOM) text, with CRLF line terminators*

 * *Files 25% similar despite different names*

```diff
@@ -1,156 +1,153 @@
 00000000: efbb bf3c 3f78 6d6c 2076 6572 7369 6f6e  ...<?xml version
 00000010: 3d22 312e 3022 2065 6e63 6f64 696e 673d  ="1.0" encoding=
-00000020: 2255 5446 2d38 223f 3e0d 0a3c 3f78 6d6c  "UTF-8"?>..<?xml
-00000030: 2d6d 6f64 656c 2068 7265 663d 2268 7474  -model href="htt
-00000040: 7073 3a2f 2f6d 7573 6963 2d65 6e63 6f64  ps://music-encod
-00000050: 696e 672e 6f72 672f 7363 6865 6d61 2f34  ing.org/schema/4
-00000060: 2e30 2e30 2f6d 6569 2d61 6c6c 2e72 6e67  .0.0/mei-all.rng
-00000070: 2220 7479 7065 3d22 6170 706c 6963 6174  " type="applicat
-00000080: 696f 6e2f 786d 6c22 2073 6368 656d 6174  ion/xml" schemat
-00000090: 7970 656e 733d 2268 7474 703a 2f2f 7265  ypens="http://re
-000000a0: 6c61 786e 672e 6f72 672f 6e73 2f73 7472  laxng.org/ns/str
-000000b0: 7563 7475 7265 2f31 2e30 223f 3e0d 0a3c  ucture/1.0"?>..<
-000000c0: 3f78 6d6c 2d6d 6f64 656c 2068 7265 663d  ?xml-model href=
-000000d0: 2268 7474 7073 3a2f 2f6d 7573 6963 2d65  "https://music-e
-000000e0: 6e63 6f64 696e 672e 6f72 672f 7363 6865  ncoding.org/sche
-000000f0: 6d61 2f34 2e30 2e30 2f6d 6569 2d61 6c6c  ma/4.0.0/mei-all
-00000100: 2e72 6e67 2220 7479 7065 3d22 6170 706c  .rng" type="appl
-00000110: 6963 6174 696f 6e2f 786d 6c22 2073 6368  ication/xml" sch
-00000120: 656d 6174 7970 656e 733d 2268 7474 703a  ematypens="http:
-00000130: 2f2f 7075 726c 2e6f 636c 632e 6f72 672f  //purl.oclc.org/
-00000140: 6473 646c 2f73 6368 656d 6174 726f 6e22  dsdl/schematron"
-00000150: 3f3e 0d0a 3c6d 6569 2078 6d6c 6e73 3d22  ?>..<mei xmlns="
-00000160: 6874 7470 3a2f 2f77 7777 2e6d 7573 6963  http://www.music
-00000170: 2d65 6e63 6f64 696e 672e 6f72 672f 6e73  -encoding.org/ns
-00000180: 2f6d 6569 2220 6d65 6976 6572 7369 6f6e  /mei" meiversion
-00000190: 3d22 342e 302e 3022 3e0d 0a20 2020 3c6d  ="4.0.0">..   <m
-000001a0: 6569 4865 6164 3e0d 0a20 2020 2020 203c  eiHead>..      <
-000001b0: 6669 6c65 4465 7363 3e0d 0a20 2020 2020  fileDesc>..     
-000001c0: 2020 2020 3c74 6974 6c65 5374 6d74 3e0d      <titleStmt>.
-000001d0: 0a20 2020 2020 2020 2020 2020 203c 7469  .            <ti
-000001e0: 746c 6520 2f3e 0d0a 2020 2020 2020 2020  tle />..        
-000001f0: 2020 2020 3c72 6573 7053 746d 7420 2f3e      <respStmt />
-00000200: 0d0a 2020 2020 2020 2020 203c 2f74 6974  ..         </tit
-00000210: 6c65 5374 6d74 3e0d 0a20 2020 2020 2020  leStmt>..       
-00000220: 2020 3c70 7562 5374 6d74 3e3c 2f70 7562    <pubStmt></pub
-00000230: 5374 6d74 3e0d 0a20 2020 2020 203c 2f66  Stmt>..      </f
-00000240: 696c 6544 6573 633e 0d0a 2020 2020 2020  ileDesc>..      
-00000250: 3c65 6e63 6f64 696e 6744 6573 6320 786d  <encodingDesc xm
-00000260: 6c3a 6964 3d22 656e 636f 6469 6e67 6465  l:id="encodingde
-00000270: 7363 2d32 6f39 6271 6f22 3e0d 0a20 2020  sc-2o9bqo">..   
-00000280: 2020 2020 2020 3c61 7070 496e 666f 2078        <appInfo x
-00000290: 6d6c 3a69 643d 2261 7070 696e 666f 2d6a  ml:id="appinfo-j
-000002a0: 3772 7463 6f22 3e0d 0a20 2020 2020 2020  7rtco">..       
-000002b0: 2020 2020 203c 6170 706c 6963 6174 696f       <applicatio
-000002c0: 6e20 786d 6c3a 6964 3d22 6170 706c 6963  n xml:id="applic
-000002d0: 6174 696f 6e2d 6863 3970 7934 2220 6973  ation-hc9py4" is
-000002e0: 6f64 6174 653d 2232 3032 312d 3132 2d30  odate="2021-12-0
-000002f0: 3954 3131 3a32 373a 3135 2220 7665 7273  9T11:27:15" vers
-00000300: 696f 6e3d 2233 2e38 2e30 2d64 6576 2d34  ion="3.8.0-dev-4
-00000310: 3563 3366 3263 223e 0d0a 2020 2020 2020  5c3f2c">..      
-00000320: 2020 2020 2020 2020 203c 6e61 6d65 2078           <name x
-00000330: 6d6c 3a69 643d 226e 616d 652d 7379 6d62  ml:id="name-symb
-00000340: 6131 223e 5665 726f 7669 6f3c 2f6e 616d  a1">Verovio</nam
-00000350: 653e 0d0a 2020 2020 2020 2020 2020 2020  e>..            
-00000360: 2020 203c 7020 786d 6c3a 6964 3d22 702d     <p xml:id="p-
-00000370: 726f 7570 3274 223e 5472 616e 7363 6f64  roup2t">Transcod
-00000380: 6564 2066 726f 6d20 4d75 7369 6358 4d4c  ed from MusicXML
-00000390: 3c2f 703e 0d0a 2020 2020 2020 2020 2020  </p>..          
-000003a0: 2020 3c2f 6170 706c 6963 6174 696f 6e3e    </application>
-000003b0: 0d0a 2020 2020 2020 2020 203c 2f61 7070  ..         </app
-000003c0: 496e 666f 3e0d 0a20 2020 2020 203c 2f65  Info>..      </e
-000003d0: 6e63 6f64 696e 6744 6573 633e 0d0a 2020  ncodingDesc>..  
-000003e0: 203c 2f6d 6569 4865 6164 3e0d 0a20 2020   </meiHead>..   
-000003f0: 3c6d 7573 6963 3e0d 0a20 2020 2020 203c  <music>..      <
-00000400: 626f 6479 3e0d 0a20 2020 2020 2020 2020  body>..         
-00000410: 3c6d 6469 7620 786d 6c3a 6964 3d22 6d68  <mdiv xml:id="mh
-00000420: 626c 6b72 6c22 3e0d 0a20 2020 2020 2020  blkrl">..       
-00000430: 2020 2020 203c 7363 6f72 6520 786d 6c3a       <score xml:
-00000440: 6964 3d22 7373 6337 3277 7922 3e0d 0a20  id="ssc72wy">.. 
-00000450: 2020 2020 2020 2020 2020 2020 2020 3c73                <s
-00000460: 636f 7265 4465 6620 786d 6c3a 6964 3d22  coreDef xml:id="
-00000470: 7333 7561 6f7a 3522 3e0d 0a20 2020 2020  s3uaoz5">..     
-00000480: 2020 2020 2020 2020 2020 2020 203c 7374               <st
-00000490: 6166 6647 7270 2078 6d6c 3a69 643d 2273  affGrp xml:id="s
-000004a0: 6a63 7a68 7930 223e 0d0a 2020 2020 2020  jczhy0">..      
-000004b0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
-000004c0: 7374 6166 6644 6566 2078 6d6c 3a69 643d  staffDef xml:id=
-000004d0: 2250 3122 206e 3d22 3122 206c 696e 6573  "P1" n="1" lines
-000004e0: 3d22 3522 2070 7071 3d22 3132 223e 0d0a  ="5" ppq="12">..
-000004f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000500: 2020 2020 2020 2020 3c6c 6162 656c 2078          <label x
-00000510: 6d6c 3a69 643d 226c 657a 6663 6f67 223e  ml:id="lezfcog">
-00000520: 5069 616e 6f3c 2f6c 6162 656c 3e0d 0a20  Piano</label>.. 
-00000530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000540: 2020 2020 2020 203c 6d65 7465 7253 6967         <meterSig
-00000550: 2078 6d6c 3a69 643d 226d 6877 3073 7032   xml:id="mhw0sp2
-00000560: 2220 636f 756e 743d 2234 2220 756e 6974  " count="4" unit
-00000570: 3d22 3422 202f 3e0d 0a20 2020 2020 2020  ="4" />..       
+00000020: 2255 5446 2d38 223f 3e0a 3c3f 786d 6c2d  "UTF-8"?>.<?xml-
+00000030: 6d6f 6465 6c20 6872 6566 3d22 6874 7470  model href="http
+00000040: 733a 2f2f 6d75 7369 632d 656e 636f 6469  s://music-encodi
+00000050: 6e67 2e6f 7267 2f73 6368 656d 612f 342e  ng.org/schema/4.
+00000060: 302e 302f 6d65 692d 616c 6c2e 726e 6722  0.0/mei-all.rng"
+00000070: 2074 7970 653d 2261 7070 6c69 6361 7469   type="applicati
+00000080: 6f6e 2f78 6d6c 2220 7363 6865 6d61 7479  on/xml" schematy
+00000090: 7065 6e73 3d22 6874 7470 3a2f 2f72 656c  pens="http://rel
+000000a0: 6178 6e67 2e6f 7267 2f6e 732f 7374 7275  axng.org/ns/stru
+000000b0: 6374 7572 652f 312e 3022 3f3e 0a3c 3f78  cture/1.0"?>.<?x
+000000c0: 6d6c 2d6d 6f64 656c 2068 7265 663d 2268  ml-model href="h
+000000d0: 7474 7073 3a2f 2f6d 7573 6963 2d65 6e63  ttps://music-enc
+000000e0: 6f64 696e 672e 6f72 672f 7363 6865 6d61  oding.org/schema
+000000f0: 2f34 2e30 2e30 2f6d 6569 2d61 6c6c 2e72  /4.0.0/mei-all.r
+00000100: 6e67 2220 7479 7065 3d22 6170 706c 6963  ng" type="applic
+00000110: 6174 696f 6e2f 786d 6c22 2073 6368 656d  ation/xml" schem
+00000120: 6174 7970 656e 733d 2268 7474 703a 2f2f  atypens="http://
+00000130: 7075 726c 2e6f 636c 632e 6f72 672f 6473  purl.oclc.org/ds
+00000140: 646c 2f73 6368 656d 6174 726f 6e22 3f3e  dl/schematron"?>
+00000150: 0a3c 6d65 6920 786d 6c6e 733d 2268 7474  .<mei xmlns="htt
+00000160: 703a 2f2f 7777 772e 6d75 7369 632d 656e  p://www.music-en
+00000170: 636f 6469 6e67 2e6f 7267 2f6e 732f 6d65  coding.org/ns/me
+00000180: 6922 206d 6569 7665 7273 696f 6e3d 2234  i" meiversion="4
+00000190: 2e30 2e30 223e 0a20 2020 3c6d 6569 4865  .0.0">.   <meiHe
+000001a0: 6164 3e0a 2020 2020 2020 3c66 696c 6544  ad>.      <fileD
+000001b0: 6573 633e 0a20 2020 2020 2020 2020 3c74  esc>.         <t
+000001c0: 6974 6c65 5374 6d74 3e0a 2020 2020 2020  itleStmt>.      
+000001d0: 2020 2020 2020 3c74 6974 6c65 202f 3e0a        <title />.
+000001e0: 2020 2020 2020 2020 2020 2020 3c72 6573              <res
+000001f0: 7053 746d 7420 2f3e 0a20 2020 2020 2020  pStmt />.       
+00000200: 2020 3c2f 7469 746c 6553 746d 743e 0a20    </titleStmt>. 
+00000210: 2020 2020 2020 2020 3c70 7562 5374 6d74          <pubStmt
+00000220: 3e3c 2f70 7562 5374 6d74 3e0a 2020 2020  ></pubStmt>.    
+00000230: 2020 3c2f 6669 6c65 4465 7363 3e0a 2020    </fileDesc>.  
+00000240: 2020 2020 3c65 6e63 6f64 696e 6744 6573      <encodingDes
+00000250: 6320 786d 6c3a 6964 3d22 656e 636f 6469  c xml:id="encodi
+00000260: 6e67 6465 7363 2d32 6f39 6271 6f22 3e0a  ngdesc-2o9bqo">.
+00000270: 2020 2020 2020 2020 203c 6170 7049 6e66           <appInf
+00000280: 6f20 786d 6c3a 6964 3d22 6170 7069 6e66  o xml:id="appinf
+00000290: 6f2d 6a37 7274 636f 223e 0a20 2020 2020  o-j7rtco">.     
+000002a0: 2020 2020 2020 203c 6170 706c 6963 6174         <applicat
+000002b0: 696f 6e20 786d 6c3a 6964 3d22 6170 706c  ion xml:id="appl
+000002c0: 6963 6174 696f 6e2d 6863 3970 7934 2220  ication-hc9py4" 
+000002d0: 6973 6f64 6174 653d 2232 3032 312d 3132  isodate="2021-12
+000002e0: 2d30 3954 3131 3a32 373a 3135 2220 7665  -09T11:27:15" ve
+000002f0: 7273 696f 6e3d 2233 2e38 2e30 2d64 6576  rsion="3.8.0-dev
+00000300: 2d34 3563 3366 3263 223e 0a20 2020 2020  -45c3f2c">.     
+00000310: 2020 2020 2020 2020 2020 3c6e 616d 6520            <name 
+00000320: 786d 6c3a 6964 3d22 6e61 6d65 2d73 796d  xml:id="name-sym
+00000330: 6261 3122 3e56 6572 6f76 696f 3c2f 6e61  ba1">Verovio</na
+00000340: 6d65 3e0a 2020 2020 2020 2020 2020 2020  me>.            
+00000350: 2020 203c 7020 786d 6c3a 6964 3d22 702d     <p xml:id="p-
+00000360: 726f 7570 3274 223e 5472 616e 7363 6f64  roup2t">Transcod
+00000370: 6564 2066 726f 6d20 4d75 7369 6358 4d4c  ed from MusicXML
+00000380: 3c2f 703e 0a20 2020 2020 2020 2020 2020  </p>.           
+00000390: 203c 2f61 7070 6c69 6361 7469 6f6e 3e0a   </application>.
+000003a0: 2020 2020 2020 2020 203c 2f61 7070 496e           </appIn
+000003b0: 666f 3e0a 2020 2020 2020 3c2f 656e 636f  fo>.      </enco
+000003c0: 6469 6e67 4465 7363 3e0a 2020 203c 2f6d  dingDesc>.   </m
+000003d0: 6569 4865 6164 3e0a 2020 203c 6d75 7369  eiHead>.   <musi
+000003e0: 633e 0a20 2020 2020 203c 626f 6479 3e0a  c>.      <body>.
+000003f0: 2020 2020 2020 2020 203c 6d64 6976 2078           <mdiv x
+00000400: 6d6c 3a69 643d 226d 6862 6c6b 726c 223e  ml:id="mhblkrl">
+00000410: 0a20 2020 2020 2020 2020 2020 203c 7363  .            <sc
+00000420: 6f72 6520 786d 6c3a 6964 3d22 7373 6337  ore xml:id="ssc7
+00000430: 3277 7922 3e0a 2020 2020 2020 2020 2020  2wy">.          
+00000440: 2020 2020 203c 7363 6f72 6544 6566 2078       <scoreDef x
+00000450: 6d6c 3a69 643d 2273 3375 616f 7a35 223e  ml:id="s3uaoz5">
+00000460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000470: 2020 203c 7374 6166 6647 7270 2078 6d6c     <staffGrp xml
+00000480: 3a69 643d 2273 6a63 7a68 7930 223e 0a20  :id="sjczhy0">. 
+00000490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000004a0: 2020 2020 3c73 7461 6666 4465 6620 786d      <staffDef xm
+000004b0: 6c3a 6964 3d22 5031 2220 6e3d 2231 2220  l:id="P1" n="1" 
+000004c0: 6c69 6e65 733d 2235 2220 7070 713d 2231  lines="5" ppq="1
+000004d0: 3222 3e0a 2020 2020 2020 2020 2020 2020  2">.            
+000004e0: 2020 2020 2020 2020 2020 2020 3c6c 6162              <lab
+000004f0: 656c 2078 6d6c 3a69 643d 226c 657a 6663  el xml:id="lezfc
+00000500: 6f67 223e 5069 616e 6f3c 2f6c 6162 656c  og">Piano</label
+00000510: 3e0a 2020 2020 2020 2020 2020 2020 2020  >.              
+00000520: 2020 2020 2020 2020 2020 3c6d 6574 6572            <meter
+00000530: 5369 6720 786d 6c3a 6964 3d22 6d68 7730  Sig xml:id="mhw0
+00000540: 7370 3222 2063 6f75 6e74 3d22 3422 2075  sp2" count="4" u
+00000550: 6e69 743d 2234 2220 2f3e 0a20 2020 2020  nit="4" />.     
+00000560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000570: 3c2f 7374 6166 6644 6566 3e0a 2020 2020  </staffDef>.    
 00000580: 2020 2020 2020 2020 2020 2020 2020 3c2f                </
-00000590: 7374 6166 6644 6566 3e0d 0a20 2020 2020  staffDef>..     
-000005a0: 2020 2020 2020 2020 2020 2020 203c 2f73               </s
-000005b0: 7461 6666 4772 703e 0d0a 2020 2020 2020  taffGrp>..      
-000005c0: 2020 2020 2020 2020 203c 2f73 636f 7265           </score
-000005d0: 4465 663e 0d0a 2020 2020 2020 2020 2020  Def>..          
-000005e0: 2020 2020 203c 7362 2078 6d6c 3a69 643d       <sb xml:id=
-000005f0: 2273 7431 6770 6877 2220 2f3e 0d0a 2020  "st1gphw" />..  
-00000600: 2020 2020 2020 2020 2020 2020 203c 7365               <se
-00000610: 6374 696f 6e20 786d 6c3a 6964 3d22 7377  ction xml:id="sw
-00000620: 6770 7678 3822 3e0d 0a20 2020 2020 2020  gpvx8">..       
-00000630: 2020 2020 2020 2020 2020 203c 7062 2078             <pb x
-00000640: 6d6c 3a69 643d 2270 6177 3676 3662 2220  ml:id="paw6v6b" 
-00000650: 2f3e 0d0a 2020 2020 2020 2020 2020 2020  />..            
-00000660: 2020 2020 2020 3c6d 6561 7375 7265 2078        <measure x
-00000670: 6d6c 3a69 643d 226d 7a38 3771 7579 2220  ml:id="mz87quy" 
-00000680: 6e3d 2231 223e 0d0a 2020 2020 2020 2020  n="1">..        
-00000690: 2020 2020 2020 2020 2020 2020 203c 7374               <st
-000006a0: 6166 6620 786d 6c3a 6964 3d22 7378 7875  aff xml:id="sxxu
-000006b0: 3261 7122 206e 3d22 3122 3e0d 0a20 2020  2aq" n="1">..   
-000006c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000006d0: 2020 2020 203c 6c61 7965 7220 786d 6c3a       <layer xml:
-000006e0: 6964 3d22 6c6c 6b74 6376 3222 206e 3d22  id="llktcv2" n="
-000006f0: 3122 3e0d 0a20 2020 2020 2020 2020 2020  1">..           
-00000700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000710: 3c6e 6f74 6520 786d 6c3a 6964 3d22 6e30  <note xml:id="n0
-00000720: 3122 2064 7572 2e70 7071 3d22 3438 2220  1" dur.ppq="48" 
-00000730: 6475 723d 2231 2220 7374 6166 663d 2232  dur="1" staff="2
-00000740: 2220 6f63 743d 2234 2220 706e 616d 653d  " oct="4" pname=
-00000750: 2261 2220 2f3e 0d0a 2020 2020 2020 2020  "a" />..        
-00000760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000770: 3c2f 6c61 7965 723e 0d0a 2020 2020 2020  </layer>..      
-00000780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000790: 2020 3c6c 6179 6572 2078 6d6c 3a69 643d    <layer xml:id=
-000007a0: 226c 6761 7035 3970 2220 6e3d 2232 223e  "lgap59p" n="2">
-000007b0: 0d0a 2020 2020 2020 2020 2020 2020 2020  ..              
-000007c0: 2020 2020 2020 2020 2020 2020 203c 7265               <re
-000007d0: 7374 2078 6d6c 3a69 643d 2272 3031 2220  st xml:id="r01" 
-000007e0: 6475 722e 7070 713d 2232 3422 2064 7572  dur.ppq="24" dur
-000007f0: 3d22 3222 202f 3e0d 0a20 2020 2020 2020  ="2" />..       
-00000800: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000810: 2020 2020 3c63 686f 7264 2078 6d6c 3a69      <chord xml:i
-00000820: 643d 2263 6172 6338 616f 2220 6475 722e  d="carc8ao" dur.
-00000830: 7070 713d 2232 3422 2064 7572 3d22 3222  ppq="24" dur="2"
-00000840: 3e0d 0a20 2020 2020 2020 2020 2020 2020  >..             
-00000850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000860: 203c 6e6f 7465 2078 6d6c 3a69 643d 226e   <note xml:id="n
-00000870: 3032 2220 6f63 743d 2235 2220 706e 616d  02" oct="5" pnam
-00000880: 653d 2263 2220 2f3e 0d0a 2020 2020 2020  e="c" />..      
-00000890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000008a0: 2020 2020 2020 2020 3c6e 6f74 6520 786d          <note xm
-000008b0: 6c3a 6964 3d22 6e30 3322 206f 6374 3d22  l:id="n03" oct="
-000008c0: 3522 2070 6e61 6d65 3d22 6522 202f 3e0d  5" pname="e" />.
-000008d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000008e0: 2020 2020 2020 2020 2020 2020 3c2f 6368              </ch
-000008f0: 6f72 643e 0d0a 2020 2020 2020 2020 2020  ord>..          
-00000900: 2020 2020 2020 2020 2020 2020 2020 3c2f                </
-00000910: 6c61 7965 723e 0d0a 2020 2020 2020 2020  layer>..        
-00000920: 2020 2020 2020 2020 2020 2020 203c 2f73               </s
-00000930: 7461 6666 3e0d 0a20 2020 2020 2020 2020  taff>..         
-00000940: 2020 2020 2020 2020 203c 2f6d 6561 7375           </measu
-00000950: 7265 3e0d 0a20 2020 2020 2020 2020 2020  re>..           
-00000960: 2020 2020 3c2f 7365 6374 696f 6e3e 0d0a      </section>..
-00000970: 2020 2020 2020 2020 2020 2020 3c2f 7363              </sc
-00000980: 6f72 653e 0d0a 2020 2020 2020 2020 203c  ore>..         <
-00000990: 2f6d 6469 763e 0d0a 2020 2020 2020 3c2f  /mdiv>..      </
-000009a0: 626f 6479 3e0d 0a20 2020 3c2f 6d75 7369  body>..   </musi
-000009b0: 633e 0d0a 3c2f 6d65 693e 0d0a            c>..</mei>..
+00000590: 7374 6166 6647 7270 3e0a 2020 2020 2020  staffGrp>.      
+000005a0: 2020 2020 2020 2020 203c 2f73 636f 7265           </score
+000005b0: 4465 663e 0a20 2020 2020 2020 2020 2020  Def>.           
+000005c0: 2020 2020 3c73 6220 786d 6c3a 6964 3d22      <sb xml:id="
+000005d0: 7374 3167 7068 7722 202f 3e0a 2020 2020  st1gphw" />.    
+000005e0: 2020 2020 2020 2020 2020 203c 7365 6374             <sect
+000005f0: 696f 6e20 786d 6c3a 6964 3d22 7377 6770  ion xml:id="swgp
+00000600: 7678 3822 3e0a 2020 2020 2020 2020 2020  vx8">.          
+00000610: 2020 2020 2020 2020 3c70 6220 786d 6c3a          <pb xml:
+00000620: 6964 3d22 7061 7736 7636 6222 202f 3e0a  id="paw6v6b" />.
+00000630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000640: 2020 3c6d 6561 7375 7265 2078 6d6c 3a69    <measure xml:i
+00000650: 643d 226d 7a38 3771 7579 2220 6e3d 2231  d="mz87quy" n="1
+00000660: 223e 0a20 2020 2020 2020 2020 2020 2020  ">.             
+00000670: 2020 2020 2020 2020 3c73 7461 6666 2078          <staff x
+00000680: 6d6c 3a69 643d 2273 7878 7532 6171 2220  ml:id="sxxu2aq" 
+00000690: 6e3d 2231 223e 0a20 2020 2020 2020 2020  n="1">.         
+000006a0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
+000006b0: 6c61 7965 7220 786d 6c3a 6964 3d22 6c6c  layer xml:id="ll
+000006c0: 6b74 6376 3222 206e 3d22 3122 3e0a 2020  ktcv2" n="1">.  
+000006d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000006e0: 2020 2020 2020 2020 203c 6e6f 7465 2078           <note x
+000006f0: 6d6c 3a69 643d 226e 3031 2220 6475 722e  ml:id="n01" dur.
+00000700: 7070 713d 2234 3822 2064 7572 3d22 3122  ppq="48" dur="1"
+00000710: 2073 7461 6666 3d22 3222 206f 6374 3d22   staff="2" oct="
+00000720: 3422 2070 6e61 6d65 3d22 6122 202f 3e0a  4" pname="a" />.
+00000730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000740: 2020 2020 2020 2020 3c2f 6c61 7965 723e          </layer>
+00000750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00000760: 2020 2020 2020 2020 203c 6c61 7965 7220           <layer 
+00000770: 786d 6c3a 6964 3d22 6c67 6170 3539 7022  xml:id="lgap59p"
+00000780: 206e 3d22 3222 3e0a 2020 2020 2020 2020   n="2">.        
+00000790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000007a0: 2020 203c 7265 7374 2078 6d6c 3a69 643d     <rest xml:id=
+000007b0: 2272 3031 2220 6475 722e 7070 713d 2232  "r01" dur.ppq="2
+000007c0: 3422 2064 7572 3d22 3222 202f 3e0a 2020  4" dur="2" />.  
+000007d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000007e0: 2020 2020 2020 2020 203c 6368 6f72 6420           <chord 
+000007f0: 786d 6c3a 6964 3d22 6361 7263 3861 6f22  xml:id="carc8ao"
+00000800: 2064 7572 2e70 7071 3d22 3234 2220 6475   dur.ppq="24" du
+00000810: 723d 2232 223e 0a20 2020 2020 2020 2020  r="2">.         
+00000820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000830: 2020 2020 203c 6e6f 7465 2078 6d6c 3a69       <note xml:i
+00000840: 643d 226e 3032 2220 6f63 743d 2235 2220  d="n02" oct="5" 
+00000850: 706e 616d 653d 2263 2220 2f3e 0a20 2020  pname="c" />.   
+00000860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00000870: 2020 2020 2020 2020 2020 203c 6e6f 7465             <note
+00000880: 2078 6d6c 3a69 643d 226e 3033 2220 6f63   xml:id="n03" oc
+00000890: 743d 2235 2220 706e 616d 653d 2265 2220  t="5" pname="e" 
+000008a0: 2f3e 0a20 2020 2020 2020 2020 2020 2020  />.             
+000008b0: 2020 2020 2020 2020 2020 2020 2020 3c2f                </
+000008c0: 6368 6f72 643e 0a20 2020 2020 2020 2020  chord>.         
+000008d0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
+000008e0: 2f6c 6179 6572 3e0a 2020 2020 2020 2020  /layer>.        
+000008f0: 2020 2020 2020 2020 2020 2020 203c 2f73               </s
+00000900: 7461 6666 3e0a 2020 2020 2020 2020 2020  taff>.          
+00000910: 2020 2020 2020 2020 3c2f 6d65 6173 7572          </measur
+00000920: 653e 0a20 2020 2020 2020 2020 2020 2020  e>.             
+00000930: 2020 3c2f 7365 6374 696f 6e3e 0a20 2020    </section>.   
+00000940: 2020 2020 2020 2020 203c 2f73 636f 7265           </score
+00000950: 3e0a 2020 2020 2020 2020 203c 2f6d 6469  >.         </mdi
+00000960: 763e 0a20 2020 2020 203c 2f62 6f64 793e  v>.      </body>
+00000970: 0a20 2020 3c2f 6d75 7369 633e 0a3c 2f6d  .   </music>.</m
+00000980: 6569 3e0a                                ei>.
```

### Comparing `partitura-1.2.1/partitura/assets/score_example.musicxml` & `partitura-1.2.2/partitura/assets/score_example.musicxml`

 * *Format-specific differences are supported for XML files but no file-specific differences were detected; falling back to a binary diff. file(1) reports: XML 1.0 document, ASCII text, with CRLF line terminators*

 * *Files 19% similar despite different names*

```diff
@@ -1,104 +1,100 @@
 00000000: 3c3f 786d 6c20 7665 7273 696f 6e3d 2731  <?xml version='1
 00000010: 2e30 2720 656e 636f 6469 6e67 3d27 5554  .0' encoding='UT
-00000020: 462d 3827 3f3e 0d0a 3c21 444f 4354 5950  F-8'?>..<!DOCTYP
-00000030: 4520 7363 6f72 652d 7061 7274 7769 7365  E score-partwise
-00000040: 2050 5542 4c49 430d 0a20 2022 2d2f 2f52   PUBLIC..  "-//R
-00000050: 6563 6f72 6461 7265 2f2f 4454 4420 4d75  ecordare//DTD Mu
-00000060: 7369 6358 4d4c 2033 2e31 2050 6172 7477  sicXML 3.1 Partw
-00000070: 6973 652f 2f45 4e22 0d0a 2020 2268 7474  ise//EN"..  "htt
-00000080: 703a 2f2f 7777 772e 6d75 7369 6378 6d6c  p://www.musicxml
-00000090: 2e6f 7267 2f64 7464 732f 7061 7274 7769  .org/dtds/partwi
-000000a0: 7365 2e64 7464 223e 0d0a 3c73 636f 7265  se.dtd">..<score
-000000b0: 2d70 6172 7477 6973 653e 0d0a 2020 3c70  -partwise>..  <p
-000000c0: 6172 742d 6c69 7374 3e0d 0a20 2020 203c  art-list>..    <
-000000d0: 7363 6f72 652d 7061 7274 2069 643d 2250  score-part id="P
-000000e0: 3122 3e0d 0a20 2020 2020 203c 7061 7274  1">..      <part
-000000f0: 2d6e 616d 653e 5069 616e 6f3c 2f70 6172  -name>Piano</par
-00000100: 742d 6e61 6d65 3e0d 0a20 2020 203c 2f73  t-name>..    </s
-00000110: 636f 7265 2d70 6172 743e 0d0a 2020 3c2f  core-part>..  </
-00000120: 7061 7274 2d6c 6973 743e 0d0a 2020 3c70  part-list>..  <p
-00000130: 6172 7420 6964 3d22 5031 223e 0d0a 2020  art id="P1">..  
-00000140: 2020 3c21 2d2d 3d3d 3d3d 3d3d 3d3d 3d3d    <!--==========
+00000020: 462d 3827 3f3e 0a3c 2144 4f43 5459 5045  F-8'?>.<!DOCTYPE
+00000030: 2073 636f 7265 2d70 6172 7477 6973 6520   score-partwise 
+00000040: 5055 424c 4943 0a20 2022 2d2f 2f52 6563  PUBLIC.  "-//Rec
+00000050: 6f72 6461 7265 2f2f 4454 4420 4d75 7369  ordare//DTD Musi
+00000060: 6358 4d4c 2033 2e31 2050 6172 7477 6973  cXML 3.1 Partwis
+00000070: 652f 2f45 4e22 0a20 2022 6874 7470 3a2f  e//EN".  "http:/
+00000080: 2f77 7777 2e6d 7573 6963 786d 6c2e 6f72  /www.musicxml.or
+00000090: 672f 6474 6473 2f70 6172 7477 6973 652e  g/dtds/partwise.
+000000a0: 6474 6422 3e0a 3c73 636f 7265 2d70 6172  dtd">.<score-par
+000000b0: 7477 6973 653e 0a20 203c 7061 7274 2d6c  twise>.  <part-l
+000000c0: 6973 743e 0a20 2020 203c 7363 6f72 652d  ist>.    <score-
+000000d0: 7061 7274 2069 643d 2250 3122 3e0a 2020  part id="P1">.  
+000000e0: 2020 2020 3c70 6172 742d 6e61 6d65 3e50      <part-name>P
+000000f0: 6961 6e6f 3c2f 7061 7274 2d6e 616d 653e  iano</part-name>
+00000100: 0a20 2020 203c 2f73 636f 7265 2d70 6172  .    </score-par
+00000110: 743e 0a20 203c 2f70 6172 742d 6c69 7374  t>.  </part-list
+00000120: 3e0a 2020 3c70 6172 7420 6964 3d22 5031  >.  <part id="P1
+00000130: 223e 0a20 2020 203c 212d 2d3d 3d3d 3d3d  ">.    <!--=====
+00000140: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000150: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00000160: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d2d 2d3e  =============-->
-00000180: 0d0a 2020 2020 3c6d 6561 7375 7265 206e  ..    <measure n
-00000190: 756d 6265 723d 2231 223e 0d0a 2020 2020  umber="1">..    
-000001a0: 2020 3c61 7474 7269 6275 7465 733e 0d0a    <attributes>..
-000001b0: 2020 2020 2020 2020 3c64 6976 6973 696f          <divisio
-000001c0: 6e73 3e31 323c 2f64 6976 6973 696f 6e73  ns>12</divisions
-000001d0: 3e0d 0a20 2020 2020 2020 203c 7469 6d65  >..        <time
-000001e0: 3e0d 0a20 2020 2020 2020 2020 203c 6265  >..          <be
-000001f0: 6174 733e 343c 2f62 6561 7473 3e0d 0a20  ats>4</beats>.. 
-00000200: 2020 2020 2020 2020 203c 6265 6174 2d74           <beat-t
-00000210: 7970 653e 343c 2f62 6561 742d 7479 7065  ype>4</beat-type
-00000220: 3e0d 0a20 2020 2020 2020 203c 2f74 696d  >..        </tim
-00000230: 653e 0d0a 2020 2020 2020 3c2f 6174 7472  e>..      </attr
-00000240: 6962 7574 6573 3e0d 0a20 2020 2020 203c  ibutes>..      <
-00000250: 7072 696e 7420 6e65 772d 7061 6765 3d22  print new-page="
-00000260: 7965 7322 206e 6577 2d73 7973 7465 6d3d  yes" new-system=
-00000270: 2279 6573 222f 3e0d 0a20 2020 2020 203c  "yes"/>..      <
-00000280: 6e6f 7465 2069 643d 226e 3031 223e 0d0a  note id="n01">..
-00000290: 2020 2020 2020 2020 3c70 6974 6368 3e0d          <pitch>.
-000002a0: 0a20 2020 2020 2020 2020 203c 7374 6570  .          <step
-000002b0: 3e41 3c2f 7374 6570 3e0d 0a20 2020 2020  >A</step>..     
-000002c0: 2020 2020 203c 6f63 7461 7665 3e34 3c2f       <octave>4</
-000002d0: 6f63 7461 7665 3e0d 0a20 2020 2020 2020  octave>..       
-000002e0: 203c 2f70 6974 6368 3e0d 0a20 2020 2020   </pitch>..     
-000002f0: 2020 203c 6475 7261 7469 6f6e 3e34 383c     <duration>48<
-00000300: 2f64 7572 6174 696f 6e3e 0d0a 2020 2020  /duration>..    
-00000310: 2020 2020 3c76 6f69 6365 3e31 3c2f 766f      <voice>1</vo
-00000320: 6963 653e 0d0a 2020 2020 2020 2020 3c74  ice>..        <t
-00000330: 7970 653e 7768 6f6c 653c 2f74 7970 653e  ype>whole</type>
-00000340: 0d0a 2020 2020 2020 2020 3c73 7461 6666  ..        <staff
-00000350: 3e32 3c2f 7374 6166 663e 0d0a 2020 2020  >2</staff>..    
-00000360: 2020 3c2f 6e6f 7465 3e0d 0a20 2020 2020    </note>..     
-00000370: 203c 6261 636b 7570 3e0d 0a20 2020 2020   <backup>..     
-00000380: 2020 203c 6475 7261 7469 6f6e 3e34 383c     <duration>48<
-00000390: 2f64 7572 6174 696f 6e3e 0d0a 2020 2020  /duration>..    
-000003a0: 2020 3c2f 6261 636b 7570 3e0d 0a20 2020    </backup>..   
-000003b0: 2020 203c 6e6f 7465 2069 643d 2272 3031     <note id="r01
-000003c0: 223e 0d0a 2020 2020 2020 2020 3c72 6573  ">..        <res
-000003d0: 742f 3e0d 0a20 2020 2020 2020 203c 6475  t/>..        <du
-000003e0: 7261 7469 6f6e 3e32 343c 2f64 7572 6174  ration>24</durat
-000003f0: 696f 6e3e 0d0a 2020 2020 2020 2020 3c76  ion>..        <v
-00000400: 6f69 6365 3e32 3c2f 766f 6963 653e 0d0a  oice>2</voice>..
-00000410: 2020 2020 2020 2020 3c74 7970 653e 6861          <type>ha
-00000420: 6c66 3c2f 7479 7065 3e0d 0a20 2020 2020  lf</type>..     
-00000430: 2020 203c 7374 6166 663e 313c 2f73 7461     <staff>1</sta
-00000440: 6666 3e0d 0a20 2020 2020 203c 2f6e 6f74  ff>..      </not
-00000450: 653e 0d0a 2020 2020 2020 3c6e 6f74 6520  e>..      <note 
-00000460: 6964 3d22 6e30 3222 3e0d 0a20 2020 2020  id="n02">..     
-00000470: 2020 203c 7069 7463 683e 0d0a 2020 2020     <pitch>..    
-00000480: 2020 2020 2020 3c73 7465 703e 433c 2f73        <step>C</s
-00000490: 7465 703e 0d0a 2020 2020 2020 2020 2020  tep>..          
-000004a0: 3c6f 6374 6176 653e 353c 2f6f 6374 6176  <octave>5</octav
-000004b0: 653e 0d0a 2020 2020 2020 2020 3c2f 7069  e>..        </pi
-000004c0: 7463 683e 0d0a 2020 2020 2020 2020 3c64  tch>..        <d
-000004d0: 7572 6174 696f 6e3e 3234 3c2f 6475 7261  uration>24</dura
-000004e0: 7469 6f6e 3e0d 0a20 2020 2020 2020 203c  tion>..        <
-000004f0: 766f 6963 653e 323c 2f76 6f69 6365 3e0d  voice>2</voice>.
-00000500: 0a20 2020 2020 2020 203c 7479 7065 3e68  .        <type>h
-00000510: 616c 663c 2f74 7970 653e 0d0a 2020 2020  alf</type>..    
-00000520: 2020 2020 3c73 7461 6666 3e31 3c2f 7374      <staff>1</st
-00000530: 6166 663e 0d0a 2020 2020 2020 3c2f 6e6f  aff>..      </no
-00000540: 7465 3e0d 0a20 2020 2020 203c 6e6f 7465  te>..      <note
-00000550: 2069 643d 226e 3033 223e 0d0a 2020 2020   id="n03">..    
-00000560: 2020 2020 3c63 686f 7264 2f3e 0d0a 2020      <chord/>..  
-00000570: 2020 2020 2020 3c70 6974 6368 3e0d 0a20        <pitch>.. 
-00000580: 2020 2020 2020 2020 203c 7374 6570 3e45           <step>E
-00000590: 3c2f 7374 6570 3e0d 0a20 2020 2020 2020  </step>..       
-000005a0: 2020 203c 6f63 7461 7665 3e35 3c2f 6f63     <octave>5</oc
-000005b0: 7461 7665 3e0d 0a20 2020 2020 2020 203c  tave>..        <
-000005c0: 2f70 6974 6368 3e0d 0a20 2020 2020 2020  /pitch>..       
-000005d0: 203c 6475 7261 7469 6f6e 3e32 343c 2f64   <duration>24</d
-000005e0: 7572 6174 696f 6e3e 0d0a 2020 2020 2020  uration>..      
-000005f0: 2020 3c76 6f69 6365 3e32 3c2f 766f 6963    <voice>2</voic
-00000600: 653e 0d0a 2020 2020 2020 2020 3c74 7970  e>..        <typ
-00000610: 653e 6861 6c66 3c2f 7479 7065 3e0d 0a20  e>half</type>.. 
-00000620: 2020 2020 2020 203c 7374 6166 663e 313c         <staff>1<
-00000630: 2f73 7461 6666 3e0d 0a20 2020 2020 203c  /staff>..      <
-00000640: 2f6e 6f74 653e 0d0a 2020 2020 3c2f 6d65  /note>..    </me
-00000650: 6173 7572 653e 0d0a 2020 3c2f 7061 7274  asure>..  </part
-00000660: 3e0d 0a3c 2f73 636f 7265 2d70 6172 7477  >..</score-partw
-00000670: 6973 653e 0d0a                           ise>..
+00000170: 3d3d 2d2d 3e0a 2020 2020 3c6d 6561 7375  ==-->.    <measu
+00000180: 7265 206e 756d 6265 723d 2231 223e 0a20  re number="1">. 
+00000190: 2020 2020 203c 6174 7472 6962 7574 6573       <attributes
+000001a0: 3e0a 2020 2020 2020 2020 3c64 6976 6973  >.        <divis
+000001b0: 696f 6e73 3e31 323c 2f64 6976 6973 696f  ions>12</divisio
+000001c0: 6e73 3e0a 2020 2020 2020 2020 3c74 696d  ns>.        <tim
+000001d0: 653e 0a20 2020 2020 2020 2020 203c 6265  e>.          <be
+000001e0: 6174 733e 343c 2f62 6561 7473 3e0a 2020  ats>4</beats>.  
+000001f0: 2020 2020 2020 2020 3c62 6561 742d 7479          <beat-ty
+00000200: 7065 3e34 3c2f 6265 6174 2d74 7970 653e  pe>4</beat-type>
+00000210: 0a20 2020 2020 2020 203c 2f74 696d 653e  .        </time>
+00000220: 0a20 2020 2020 203c 2f61 7474 7269 6275  .      </attribu
+00000230: 7465 733e 0a20 2020 2020 203c 7072 696e  tes>.      <prin
+00000240: 7420 6e65 772d 7061 6765 3d22 7965 7322  t new-page="yes"
+00000250: 206e 6577 2d73 7973 7465 6d3d 2279 6573   new-system="yes
+00000260: 222f 3e0a 2020 2020 2020 3c6e 6f74 6520  "/>.      <note 
+00000270: 6964 3d22 6e30 3122 3e0a 2020 2020 2020  id="n01">.      
+00000280: 2020 3c70 6974 6368 3e0a 2020 2020 2020    <pitch>.      
+00000290: 2020 2020 3c73 7465 703e 413c 2f73 7465      <step>A</ste
+000002a0: 703e 0a20 2020 2020 2020 2020 203c 6f63  p>.          <oc
+000002b0: 7461 7665 3e34 3c2f 6f63 7461 7665 3e0a  tave>4</octave>.
+000002c0: 2020 2020 2020 2020 3c2f 7069 7463 683e          </pitch>
+000002d0: 0a20 2020 2020 2020 203c 6475 7261 7469  .        <durati
+000002e0: 6f6e 3e34 383c 2f64 7572 6174 696f 6e3e  on>48</duration>
+000002f0: 0a20 2020 2020 2020 203c 766f 6963 653e  .        <voice>
+00000300: 313c 2f76 6f69 6365 3e0a 2020 2020 2020  1</voice>.      
+00000310: 2020 3c74 7970 653e 7768 6f6c 653c 2f74    <type>whole</t
+00000320: 7970 653e 0a20 2020 2020 2020 203c 7374  ype>.        <st
+00000330: 6166 663e 323c 2f73 7461 6666 3e0a 2020  aff>2</staff>.  
+00000340: 2020 2020 3c2f 6e6f 7465 3e0a 2020 2020      </note>.    
+00000350: 2020 3c62 6163 6b75 703e 0a20 2020 2020    <backup>.     
+00000360: 2020 203c 6475 7261 7469 6f6e 3e34 383c     <duration>48<
+00000370: 2f64 7572 6174 696f 6e3e 0a20 2020 2020  /duration>.     
+00000380: 203c 2f62 6163 6b75 703e 0a20 2020 2020   </backup>.     
+00000390: 203c 6e6f 7465 2069 643d 2272 3031 223e   <note id="r01">
+000003a0: 0a20 2020 2020 2020 203c 7265 7374 2f3e  .        <rest/>
+000003b0: 0a20 2020 2020 2020 203c 6475 7261 7469  .        <durati
+000003c0: 6f6e 3e32 343c 2f64 7572 6174 696f 6e3e  on>24</duration>
+000003d0: 0a20 2020 2020 2020 203c 766f 6963 653e  .        <voice>
+000003e0: 323c 2f76 6f69 6365 3e0a 2020 2020 2020  2</voice>.      
+000003f0: 2020 3c74 7970 653e 6861 6c66 3c2f 7479    <type>half</ty
+00000400: 7065 3e0a 2020 2020 2020 2020 3c73 7461  pe>.        <sta
+00000410: 6666 3e31 3c2f 7374 6166 663e 0a20 2020  ff>1</staff>.   
+00000420: 2020 203c 2f6e 6f74 653e 0a20 2020 2020     </note>.     
+00000430: 203c 6e6f 7465 2069 643d 226e 3032 223e   <note id="n02">
+00000440: 0a20 2020 2020 2020 203c 7069 7463 683e  .        <pitch>
+00000450: 0a20 2020 2020 2020 2020 203c 7374 6570  .          <step
+00000460: 3e43 3c2f 7374 6570 3e0a 2020 2020 2020  >C</step>.      
+00000470: 2020 2020 3c6f 6374 6176 653e 353c 2f6f      <octave>5</o
+00000480: 6374 6176 653e 0a20 2020 2020 2020 203c  ctave>.        <
+00000490: 2f70 6974 6368 3e0a 2020 2020 2020 2020  /pitch>.        
+000004a0: 3c64 7572 6174 696f 6e3e 3234 3c2f 6475  <duration>24</du
+000004b0: 7261 7469 6f6e 3e0a 2020 2020 2020 2020  ration>.        
+000004c0: 3c76 6f69 6365 3e32 3c2f 766f 6963 653e  <voice>2</voice>
+000004d0: 0a20 2020 2020 2020 203c 7479 7065 3e68  .        <type>h
+000004e0: 616c 663c 2f74 7970 653e 0a20 2020 2020  alf</type>.     
+000004f0: 2020 203c 7374 6166 663e 313c 2f73 7461     <staff>1</sta
+00000500: 6666 3e0a 2020 2020 2020 3c2f 6e6f 7465  ff>.      </note
+00000510: 3e0a 2020 2020 2020 3c6e 6f74 6520 6964  >.      <note id
+00000520: 3d22 6e30 3322 3e0a 2020 2020 2020 2020  ="n03">.        
+00000530: 3c63 686f 7264 2f3e 0a20 2020 2020 2020  <chord/>.       
+00000540: 203c 7069 7463 683e 0a20 2020 2020 2020   <pitch>.       
+00000550: 2020 203c 7374 6570 3e45 3c2f 7374 6570     <step>E</step
+00000560: 3e0a 2020 2020 2020 2020 2020 3c6f 6374  >.          <oct
+00000570: 6176 653e 353c 2f6f 6374 6176 653e 0a20  ave>5</octave>. 
+00000580: 2020 2020 2020 203c 2f70 6974 6368 3e0a         </pitch>.
+00000590: 2020 2020 2020 2020 3c64 7572 6174 696f          <duratio
+000005a0: 6e3e 3234 3c2f 6475 7261 7469 6f6e 3e0a  n>24</duration>.
+000005b0: 2020 2020 2020 2020 3c76 6f69 6365 3e32          <voice>2
+000005c0: 3c2f 766f 6963 653e 0a20 2020 2020 2020  </voice>.       
+000005d0: 203c 7479 7065 3e68 616c 663c 2f74 7970   <type>half</typ
+000005e0: 653e 0a20 2020 2020 2020 203c 7374 6166  e>.        <staf
+000005f0: 663e 313c 2f73 7461 6666 3e0a 2020 2020  f>1</staff>.    
+00000600: 2020 3c2f 6e6f 7465 3e0a 2020 2020 3c2f    </note>.    </
+00000610: 6d65 6173 7572 653e 0a20 203c 2f70 6172  measure>.  </par
+00000620: 743e 0a3c 2f73 636f 7265 2d70 6172 7477  t>.</score-partw
+00000630: 6973 653e 0a                             ise>.
```

### Comparing `partitura-1.2.1/partitura/display.py` & `partitura-1.2.2/partitura/display.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,182 +1,182 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module defines a function "show" that creates a rendering of one
-or more parts or partgroups and opens it using the desktop default
-application.
-"""
-
-import platform
-import warnings
-import os
-import subprocess
-import shutil
-from tempfile import NamedTemporaryFile, TemporaryFile
-from typing import Optional
-
-from partitura import save_musicxml
-from partitura.io.musescore import render_musescore
-from partitura.score import ScoreLike
-
-from partitura.utils.misc import PathLike, deprecated_alias
-
-
-__all__ = ["render"]
-
-# def ly_install_msg():
-#     """Issue a platform specific installation suggestion for lilypond
-
-#     """
-#     if platform.system() == 'Linux':
-#         s = ('Is lilypond installed? On debian based '
-#              'installations you can install it using the '
-#              'command "sudo apt install lilypond"')
-#     elif platform.system() == 'Darwin':
-#         s = ('Is lilypond installed? Lilypond can be '
-#              'installed using brew ( https://brew.sh/ ) '
-#              'using the command "brew cask install lilypond"')
-#     elif platform.system() == 'Windows':
-#         s = ('Is lilypond installed? It can be downloaded from '
-#              'http://lilypond.org/')
-#     return s
-
-
-@deprecated_alias(out_fn="out", part="score_data")
-def render(
-    score_data: ScoreLike,
-    fmt: str = "png",
-    dpi: int = 90,
-    out: Optional[PathLike] = None,
-) -> None:
-    """Create a rendering of one or more parts or partgroups.
-
-    The function can save the rendered image to a file (when
-    `out_fn` is specified), or shown in the default image viewer
-    application.
-
-    Rendering is first attempted through musecore, and if that
-    fails through lilypond. If that also fails the function returns
-    without raising an exception.
-
-    Parameters
-    ----------
-    score_data : ScoreLike
-        The score content to be displayed
-    fmt : {'png', 'pdf'}, optional
-        The image format of the rendered material
-    out_fn : str or None, optional
-        The path of the image output file. If None, the rendering will
-        be displayed in a viewer.
-    """
-
-    img_fn = render_musescore(score_data, fmt, out, dpi)
-
-    if img_fn is None or not os.path.exists(img_fn):
-        img_fn = render_lilypond(score_data, fmt)
-        if img_fn is None or not os.path.exists(img_fn):
-            return
-
-    if not out:
-        # NOTE: the temporary image file will not be deleted.
-        if platform.system() == "Linux":
-            subprocess.call(["xdg-open", img_fn])
-        elif platform.system() == "Darwin":
-            subprocess.call(["open", img_fn])
-        elif platform.system() == "Windows":
-            os.startfile(img_fn)
-
-
-@deprecated_alias(part="score_data")
-def render_lilypond(
-    score_data,
-    fmt="png",
-    out=None,
-) -> Optional[PathLike]:
-    """
-    Render a score-like object using Lilypond
-
-    Parameters
-    ----------
-    score_data : ScoreLike
-        Score-like object to be rendered
-    fmt : {'png', 'pdf'}
-        Output image format
-    out : str or None, optional
-        The path of the image output file, if not specified, the
-        rendering will be saved to a temporary filename. Defaults to
-        None.
-
-    Returns
-    -------
-    out : PathLike
-        Path of the generated output image (or None if no image was generated).
-    """
-    if fmt not in ("png", "pdf"):
-        warnings.warn("warning: unsupported output format")
-        return None
-
-    prvw_sfx = ".preview.{}".format(fmt)
-
-    with TemporaryFile() as xml_fh, NamedTemporaryFile(
-        suffix=prvw_sfx, delete=False
-    ) as img_fh:
-
-        # save part to musicxml in file handle xml_fh
-        save_musicxml(score_data, xml_fh)
-        # rewind read pointer of file handle before we pass it to musicxml2ly
-        xml_fh.seek(0)
-
-        img_stem = img_fh.name[: -len(prvw_sfx)]
-
-        # convert musicxml to lilypond format (use stdout pipe)
-        cmd1 = ["musicxml2ly", "-o-", "-"]
-        try:
-            ps1 = subprocess.run(
-                cmd1, stdin=xml_fh, stdout=subprocess.PIPE, check=False
-            )
-            if ps1.returncode != 0:
-                warnings.warn(
-                    "Command {} failed with code {}".format(cmd1, ps1.returncode),
-                    stacklevel=2,
-                )
-                return None
-        except FileNotFoundError as f:
-            warnings.warn(
-                'Executing "{}" returned  {}.'.format(" ".join(cmd1), f),
-                ImportWarning,
-                stacklevel=2,
-            )
-            return None
-
-        # convert lilypond format (read from pipe of ps1) to image, and save to
-        # temporary filename
-        cmd2 = [
-            "lilypond",
-            "--{}".format(fmt),
-            "-dno-print-pages",
-            "-dpreview",
-            "-o{}".format(img_stem),
-            "-",
-        ]
-        try:
-            ps2 = subprocess.run(cmd2, input=ps1.stdout, check=False)
-            if ps2.returncode != 0:
-                warnings.warn(
-                    "Command {} failed with code {}".format(cmd2, ps2.returncode),
-                    stacklevel=2,
-                )
-                return None
-        except FileNotFoundError as f:
-            warnings.warn(
-                'Executing "{}" returned {}.'.format(" ".join(cmd2), f),
-                ImportWarning,
-                stacklevel=2,
-            )
-            return
-
-        if out is not None:
-            shutil.copy(img_fh.name, out)
-        else:
-            out = img_fh.name
-
-        return out
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module defines a function "show" that creates a rendering of one
+or more parts or partgroups and opens it using the desktop default
+application.
+"""
+
+import platform
+import warnings
+import os
+import subprocess
+import shutil
+from tempfile import NamedTemporaryFile, TemporaryFile
+from typing import Optional
+
+from partitura import save_musicxml
+from partitura.io.musescore import render_musescore
+from partitura.score import ScoreLike
+
+from partitura.utils.misc import PathLike, deprecated_alias
+
+
+__all__ = ["render"]
+
+# def ly_install_msg():
+#     """Issue a platform specific installation suggestion for lilypond
+
+#     """
+#     if platform.system() == 'Linux':
+#         s = ('Is lilypond installed? On debian based '
+#              'installations you can install it using the '
+#              'command "sudo apt install lilypond"')
+#     elif platform.system() == 'Darwin':
+#         s = ('Is lilypond installed? Lilypond can be '
+#              'installed using brew ( https://brew.sh/ ) '
+#              'using the command "brew cask install lilypond"')
+#     elif platform.system() == 'Windows':
+#         s = ('Is lilypond installed? It can be downloaded from '
+#              'http://lilypond.org/')
+#     return s
+
+
+@deprecated_alias(out_fn="out", part="score_data")
+def render(
+    score_data: ScoreLike,
+    fmt: str = "png",
+    dpi: int = 90,
+    out: Optional[PathLike] = None,
+) -> None:
+    """Create a rendering of one or more parts or partgroups.
+
+    The function can save the rendered image to a file (when
+    `out_fn` is specified), or shown in the default image viewer
+    application.
+
+    Rendering is first attempted through musecore, and if that
+    fails through lilypond. If that also fails the function returns
+    without raising an exception.
+
+    Parameters
+    ----------
+    score_data : ScoreLike
+        The score content to be displayed
+    fmt : {'png', 'pdf'}, optional
+        The image format of the rendered material
+    out_fn : str or None, optional
+        The path of the image output file. If None, the rendering will
+        be displayed in a viewer.
+    """
+
+    img_fn = render_musescore(score_data, fmt, out, dpi)
+
+    if img_fn is None or not os.path.exists(img_fn):
+        img_fn = render_lilypond(score_data, fmt)
+        if img_fn is None or not os.path.exists(img_fn):
+            return
+
+    if not out:
+        # NOTE: the temporary image file will not be deleted.
+        if platform.system() == "Linux":
+            subprocess.call(["xdg-open", img_fn])
+        elif platform.system() == "Darwin":
+            subprocess.call(["open", img_fn])
+        elif platform.system() == "Windows":
+            os.startfile(img_fn)
+
+
+@deprecated_alias(part="score_data")
+def render_lilypond(
+    score_data,
+    fmt="png",
+    out=None,
+) -> Optional[PathLike]:
+    """
+    Render a score-like object using Lilypond
+
+    Parameters
+    ----------
+    score_data : ScoreLike
+        Score-like object to be rendered
+    fmt : {'png', 'pdf'}
+        Output image format
+    out : str or None, optional
+        The path of the image output file, if not specified, the
+        rendering will be saved to a temporary filename. Defaults to
+        None.
+
+    Returns
+    -------
+    out : PathLike
+        Path of the generated output image (or None if no image was generated).
+    """
+    if fmt not in ("png", "pdf"):
+        warnings.warn("warning: unsupported output format")
+        return None
+
+    prvw_sfx = ".preview.{}".format(fmt)
+
+    with TemporaryFile() as xml_fh, NamedTemporaryFile(
+        suffix=prvw_sfx, delete=False
+    ) as img_fh:
+
+        # save part to musicxml in file handle xml_fh
+        save_musicxml(score_data, xml_fh)
+        # rewind read pointer of file handle before we pass it to musicxml2ly
+        xml_fh.seek(0)
+
+        img_stem = img_fh.name[: -len(prvw_sfx)]
+
+        # convert musicxml to lilypond format (use stdout pipe)
+        cmd1 = ["musicxml2ly", "-o-", "-"]
+        try:
+            ps1 = subprocess.run(
+                cmd1, stdin=xml_fh, stdout=subprocess.PIPE, check=False
+            )
+            if ps1.returncode != 0:
+                warnings.warn(
+                    "Command {} failed with code {}".format(cmd1, ps1.returncode),
+                    stacklevel=2,
+                )
+                return None
+        except FileNotFoundError as f:
+            warnings.warn(
+                'Executing "{}" returned  {}.'.format(" ".join(cmd1), f),
+                ImportWarning,
+                stacklevel=2,
+            )
+            return None
+
+        # convert lilypond format (read from pipe of ps1) to image, and save to
+        # temporary filename
+        cmd2 = [
+            "lilypond",
+            "--{}".format(fmt),
+            "-dno-print-pages",
+            "-dpreview",
+            "-o{}".format(img_stem),
+            "-",
+        ]
+        try:
+            ps2 = subprocess.run(cmd2, input=ps1.stdout, check=False)
+            if ps2.returncode != 0:
+                warnings.warn(
+                    "Command {} failed with code {}".format(cmd2, ps2.returncode),
+                    stacklevel=2,
+                )
+                return None
+        except FileNotFoundError as f:
+            warnings.warn(
+                'Executing "{}" returned {}.'.format(" ".join(cmd2), f),
+                ImportWarning,
+                stacklevel=2,
+            )
+            return
+
+        if out is not None:
+            shutil.copy(img_fh.name, out)
+        else:
+            out = img_fh.name
+
+        return out
```

### Comparing `partitura-1.2.1/partitura/io/__init__.py` & `partitura-1.2.2/partitura/io/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,215 +1,216 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for importing and exporting symbolic music formats.
-"""
-from typing import Union
-
-from .importmusicxml import load_musicxml
-from .importmidi import load_score_midi, load_performance_midi
-from .musescore import load_via_musescore
-from .importmatch import load_match
-from .importmei import load_mei
-from .importkern import load_kern
-from .importparangonada import load_parangonada_csv
-
-from partitura.utils.misc import (
-    deprecated_alias,
-    deprecated_parameter,
-    PathLike,
-)
-
-from partitura.score import Score, Part, merge_parts
-from partitura.performance import Performance
-
-
-class NotSupportedFormatError(Exception):
-    pass
-
-
-@deprecated_alias(score_fn="filename")
-@deprecated_parameter("ensure_list")
-def load_score(filename: PathLike, force_note_ids="keep") -> Score:
-    """
-    Load a score format supported by partitura. Currently the accepted formats
-    are MusicXML, MIDI, Kern and MEI, plus all formats for which
-    MuseScore has support import-support (requires MuseScore 3).
-
-    Parameters
-    ----------
-    filename : str or file-like  object
-        Filename of the score to parse, or a file-like object
-    force_note_ids : (None, bool or "keep")
-        When True each Note in the returned Part(s) will have a newly
-        assigned unique id attribute. Existing note id attributes in
-        the input file will be discarded. If 'keep', only notes without
-        a note id will be assigned one. If None or False, the notes in the
-        resulting Part(s) will have an id only if the input file has ids for
-        the notes.
-
-    Returns
-    -------
-    scr: :class:`partitura.score.Score`
-        A score instance.
-    """
-    part = None
-
-    # Catch exceptions
-    exception_dictionary = dict()
-    # Load MusicXML
-    try:
-        return load_musicxml(
-            filename=filename,
-            force_note_ids=force_note_ids,
-        )
-    except Exception as e:
-        exception_dictionary["MusicXML"] = e
-    # Load MIDI
-    try:
-        if (force_note_ids is None) or (not force_note_ids):
-            assign_note_ids = False
-        else:
-            assign_note_ids = True
-        return load_score_midi(
-            filename=filename,
-            assign_note_ids=assign_note_ids,
-        )
-    except Exception as e:
-        exception_dictionary["MIDI"] = e
-    # Load MEI
-    try:
-        return load_mei(filename=filename)
-    except Exception as e:
-        exception_dictionary["MEI"] = e
-    # Load Kern
-    try:
-        return load_kern(
-            filename=filename,
-            force_note_ids=force_note_ids,
-        )
-    except Exception as e:
-        exception_dictionary["Kern"] = e
-    # Load MuseScore
-    try:
-        return load_via_musescore(
-            filename=filename,
-            force_note_ids=force_note_ids,
-        )
-    except Exception as e:
-        exception_dictionary["MuseScore"] = e
-    try:
-        # Load the score information from a Matchfile
-        _, _, part = load_match(
-            filename=filename,
-            create_score=True,
-        )
-
-    except Exception as e:
-        exception_dictionary["matchfile"] = e
-    if part is None:
-        for score_format, exception in exception_dictionary.items():
-            print(f"Error loading score as {score_format}:")
-            print(exception)
-
-        raise NotSupportedFormatError
-
-
-def load_score_as_part(filename: PathLike) -> Part:
-    """
-    load part helper function:
-    Load a score format supported by partitura and
-    merge the result in a single part
-
-    Parameters
-    ----------
-    filename : str or file-like  object
-        Filename of the score to parse, or a file-like object
-
-    Returns
-    -------
-    part: :class:`partitura.score.Part`
-        A part instance.
-    """
-    scr = load_score(filename)
-    part = merge_parts(scr.parts)
-    return part
-
-
-# alias
-lp = load_score_as_part
-
-
-@deprecated_alias(performance_fn="filename")
-def load_performance(
-    filename: PathLike,
-    default_bpm: Union[float, int] = 120,
-    merge_tracks: bool = False,
-    first_note_at_zero: bool = False,
-    pedal_threshold: int = 64,
-) -> Performance:
-    """
-    Load a performance format supported by partitura. Currently the accepted formats
-    are MIDI and matchfiles.
-
-    Parameters
-    ----------
-    filename: str or file-like  object
-        Filename of the score to parse, or a file-like object
-    default_bpm : number, optional
-        Tempo to use wherever the MIDI does not specify a tempo.
-        Defaults to 120.
-    merge_tracks: bool, optional
-        For MIDI files, merges all tracks into a single track.
-    first_note_at_zero: bool, optional
-        Remove silence at the beginning, so that the first note (or
-        first MIDI message, e.g., pedal) starts at time 0.
-    pedal_threshold: int
-        Threshold for the sustain pedal.
-
-    Returns
-    -------
-    performance: :class:`partitura.performance.Performance`
-        A `Performance` instance.
-
-    TODO
-    ----
-    * Force loading scores as PerformedParts?
-    """
-    from partitura.utils.music import remove_silence_from_performed_part
-
-    performance = None
-
-    # Catch exceptions
-    exception_dictionary = dict()
-    try:
-        performance = load_performance_midi(
-            filename=filename,
-            default_bpm=default_bpm,
-            merge_tracks=merge_tracks,
-        )
-
-        # set threshold for sustain pedal
-        performance[0].sustain_pedal_threshold = pedal_threshold
-
-        if first_note_at_zero:
-            remove_silence_from_performed_part(performance[0])
-
-    except Exception as e:
-        exception_dictionary["midi"] = e
-
-    try:
-        performance, _ = load_match(
-            filename=filename,
-            first_note_at_zero=first_note_at_zero,
-            pedal_threshold=pedal_threshold,
-        )
-    except Exception as e:
-        exception_dictionary["match"] = e
-
-    if performance is None:
-        for file_format, exception in exception_dictionary.items():
-            print(f"Error loading score as {file_format}:")
-            print(exception)
-        raise NotSupportedFormatError
-
-    return performance
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for importing and exporting symbolic music formats.
+"""
+from typing import Union
+
+from .importmusicxml import load_musicxml
+from .importmidi import load_score_midi, load_performance_midi
+from .musescore import load_via_musescore
+from .importmatch import load_match
+from .importmei import load_mei
+from .importkern import load_kern
+from .importparangonada import load_parangonada_csv
+from .exportparangonada import save_parangonada_csv
+
+from partitura.utils.misc import (
+    deprecated_alias,
+    deprecated_parameter,
+    PathLike,
+)
+
+from partitura.score import Score, Part, merge_parts
+from partitura.performance import Performance
+
+
+class NotSupportedFormatError(Exception):
+    pass
+
+
+@deprecated_alias(score_fn="filename")
+@deprecated_parameter("ensure_list")
+def load_score(filename: PathLike, force_note_ids="keep") -> Score:
+    """
+    Load a score format supported by partitura. Currently the accepted formats
+    are MusicXML, MIDI, Kern and MEI, plus all formats for which
+    MuseScore has support import-support (requires MuseScore 3).
+
+    Parameters
+    ----------
+    filename : str or file-like  object
+        Filename of the score to parse, or a file-like object
+    force_note_ids : (None, bool or "keep")
+        When True each Note in the returned Part(s) will have a newly
+        assigned unique id attribute. Existing note id attributes in
+        the input file will be discarded. If 'keep', only notes without
+        a note id will be assigned one. If None or False, the notes in the
+        resulting Part(s) will have an id only if the input file has ids for
+        the notes.
+
+    Returns
+    -------
+    scr: :class:`partitura.score.Score`
+        A score instance.
+    """
+    part = None
+
+    # Catch exceptions
+    exception_dictionary = dict()
+    # Load MusicXML
+    try:
+        return load_musicxml(
+            filename=filename,
+            force_note_ids=force_note_ids,
+        )
+    except Exception as e:
+        exception_dictionary["MusicXML"] = e
+    # Load MIDI
+    try:
+        if (force_note_ids is None) or (not force_note_ids):
+            assign_note_ids = False
+        else:
+            assign_note_ids = True
+        return load_score_midi(
+            filename=filename,
+            assign_note_ids=assign_note_ids,
+        )
+    except Exception as e:
+        exception_dictionary["MIDI"] = e
+    # Load MEI
+    try:
+        return load_mei(filename=filename)
+    except Exception as e:
+        exception_dictionary["MEI"] = e
+    # Load Kern
+    try:
+        return load_kern(
+            filename=filename,
+            force_note_ids=force_note_ids,
+        )
+    except Exception as e:
+        exception_dictionary["Kern"] = e
+    # Load MuseScore
+    try:
+        return load_via_musescore(
+            filename=filename,
+            force_note_ids=force_note_ids,
+        )
+    except Exception as e:
+        exception_dictionary["MuseScore"] = e
+    try:
+        # Load the score information from a Matchfile
+        _, _, part = load_match(
+            filename=filename,
+            create_score=True,
+        )
+
+    except Exception as e:
+        exception_dictionary["matchfile"] = e
+    if part is None:
+        for score_format, exception in exception_dictionary.items():
+            print(f"Error loading score as {score_format}:")
+            print(exception)
+
+        raise NotSupportedFormatError
+
+
+def load_score_as_part(filename: PathLike) -> Part:
+    """
+    load part helper function:
+    Load a score format supported by partitura and
+    merge the result in a single part
+
+    Parameters
+    ----------
+    filename : str or file-like  object
+        Filename of the score to parse, or a file-like object
+
+    Returns
+    -------
+    part: :class:`partitura.score.Part`
+        A part instance.
+    """
+    scr = load_score(filename)
+    part = merge_parts(scr.parts)
+    return part
+
+
+# alias
+lp = load_score_as_part
+
+
+@deprecated_alias(performance_fn="filename")
+def load_performance(
+    filename: PathLike,
+    default_bpm: Union[float, int] = 120,
+    merge_tracks: bool = False,
+    first_note_at_zero: bool = False,
+    pedal_threshold: int = 64,
+) -> Performance:
+    """
+    Load a performance format supported by partitura. Currently the accepted formats
+    are MIDI and matchfiles.
+
+    Parameters
+    ----------
+    filename: str or file-like  object
+        Filename of the score to parse, or a file-like object
+    default_bpm : number, optional
+        Tempo to use wherever the MIDI does not specify a tempo.
+        Defaults to 120.
+    merge_tracks: bool, optional
+        For MIDI files, merges all tracks into a single track.
+    first_note_at_zero: bool, optional
+        Remove silence at the beginning, so that the first note (or
+        first MIDI message, e.g., pedal) starts at time 0.
+    pedal_threshold: int
+        Threshold for the sustain pedal.
+
+    Returns
+    -------
+    performance: :class:`partitura.performance.Performance`
+        A `Performance` instance.
+
+    TODO
+    ----
+    * Force loading scores as PerformedParts?
+    """
+    from partitura.utils.music import remove_silence_from_performed_part
+
+    performance = None
+
+    # Catch exceptions
+    exception_dictionary = dict()
+    try:
+        performance = load_performance_midi(
+            filename=filename,
+            default_bpm=default_bpm,
+            merge_tracks=merge_tracks,
+        )
+
+        # set threshold for sustain pedal
+        performance[0].sustain_pedal_threshold = pedal_threshold
+
+        if first_note_at_zero:
+            remove_silence_from_performed_part(performance[0])
+
+    except Exception as e:
+        exception_dictionary["midi"] = e
+
+    try:
+        performance, _ = load_match(
+            filename=filename,
+            first_note_at_zero=first_note_at_zero,
+            pedal_threshold=pedal_threshold,
+        )
+    except Exception as e:
+        exception_dictionary["match"] = e
+
+    if performance is None:
+        for file_format, exception in exception_dictionary.items():
+            print(f"Error loading score as {file_format}:")
+            print(exception)
+        raise NotSupportedFormatError
+
+    return performance
```

### Comparing `partitura-1.2.1/partitura/io/exportaudio.py` & `partitura-1.2.2/partitura/io/exportaudio.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,96 +1,96 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods to synthesize Partitura object to wav using
-additive synthesis
-"""
-from typing import Union, Optional, Callable, Dict, Any
-import numpy as np
-from scipy.io import wavfile
-
-
-from partitura.score import ScoreLike
-from partitura.performance import PerformanceLike
-
-from partitura.utils.synth import synthesize, SAMPLE_RATE, A4
-
-from partitura.utils.misc import PathLike
-
-__all__ = ["save_wav"]
-
-
-def save_wav(
-    input_data: Union[ScoreLike, PerformanceLike, np.ndarray],
-    out: Optional[PathLike] = None,
-    samplerate: int = SAMPLE_RATE,
-    envelope_fun: Union[str, Callable] = "linear",
-    tuning: Union[str, Callable] = "equal_temperament",
-    tuning_kwargs: Dict[str, Any] = {"a4": A4},
-    harmonic_dist: Optional[Union[str, int]] = None,
-    bpm: Union[float, np.ndarray, Callable] = 60,
-) -> Optional[np.ndarray]:
-    """
-    Export a score (a `Score`, `Part`, `PartGroup` or list of `Part` instances),
-    a performance (`Performance`, `PerformedPart` or list of `PerformedPart` instances)
-    as a WAV file using additive synthesis
-
-
-    Parameters
-    ----------
-    input_data : ScoreLike, PerformanceLike or np.ndarray
-        A partitura object with note information.
-    out : PathLike or None
-        Path of the output Wave file. If None, the method outputs
-        the audio signal as an array (see `audio_signal` below).
-    samplerate: int
-        The sample rate of the audio file in Hz. The default is 44100Hz.
-    envelope_fun: {"linear", "exp" } or callable
-        The type of envelop to apply to the individual sine waves.
-        If "linear" or "exp", the methods `lin_in_lin_out` and `exp_in_exp_out`
-        in `partitura.utils.synth` will be used. Otherwise this argument should
-        be a callable. See `lin_in_lin_out` for more details.
-    tuning: {"equal_temperament", "natural"} or callable.
-        The tuning system to use. If the value is "equal_temperament",
-        12 tone equal temperament implemented in
-        `partitura.utils.music.midi_pitch_to_frequency` will be used. If the value is
-        "natural", the function `partitura.utils.synth.midi_pitch_to_tempered_frequency`
-        will be used. Note that `midi_pitch_to_tempered_frequency` computes
-        intervals (and thus, frequencies) with respect to a reference note
-        (A4 by default) and uses the interval ratios specified by
-        `partitura.utils.synth.FIVE_LIMIT_INTERVAL_RATIOS`. See the documentation of
-        these functions for more information. If a callable is provided, function should
-        get MIDI pitch as input and return frequency in Hz as output.
-    tuning_kwargs : dict
-        Dictionary of keyword arguments to be passed to the tuning function
-        specified in  `tuning`. See `midi_pitch_to_tempered_frequency` and
-       `midi_pitch_to_frequency` for more information on their keyword arguments.
-    harmonic_dist : int,  "shepard" or None (optional)
-        Distribution of harmonics. If an integer, it is the number
-        of harmonics to be considered. If "shepard", it uses Shepard tones.
-        Default is None (i.e., only consider the fundamental frequency)
-    bpm : float, np.ndarray, callable
-        The bpm to render the output (if the input is a score-like object).
-        See `partitura.utils.music.performance_notearray_from_score_notearray`
-        for more information on this parameter.
-
-    Returns
-    -------
-    audio_signal : np.ndarray
-       Audio signal as a 1D array. Only returned if `out` is None.
-    """
-    # synthesize audio signal
-    audio_signal = synthesize(
-        note_info=input_data,
-        samplerate=samplerate,
-        envelope_fun=envelope_fun,
-        tuning=tuning,
-        tuning_kwargs=tuning_kwargs,
-        harmonic_dist=harmonic_dist,
-        bpm=bpm,
-    )
-
-    if out is not None:
-        # Write audio signal
-        wavfile.write(out, samplerate, audio_signal)
-    else:
-        return audio_signal
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods to synthesize Partitura object to wav using
+additive synthesis
+"""
+from typing import Union, Optional, Callable, Dict, Any
+import numpy as np
+from scipy.io import wavfile
+
+
+from partitura.score import ScoreLike
+from partitura.performance import PerformanceLike
+
+from partitura.utils.synth import synthesize, SAMPLE_RATE, A4
+
+from partitura.utils.misc import PathLike
+
+__all__ = ["save_wav"]
+
+
+def save_wav(
+    input_data: Union[ScoreLike, PerformanceLike, np.ndarray],
+    out: Optional[PathLike] = None,
+    samplerate: int = SAMPLE_RATE,
+    envelope_fun: Union[str, Callable] = "linear",
+    tuning: Union[str, Callable] = "equal_temperament",
+    tuning_kwargs: Dict[str, Any] = {"a4": A4},
+    harmonic_dist: Optional[Union[str, int]] = None,
+    bpm: Union[float, np.ndarray, Callable] = 60,
+) -> Optional[np.ndarray]:
+    """
+    Export a score (a `Score`, `Part`, `PartGroup` or list of `Part` instances),
+    a performance (`Performance`, `PerformedPart` or list of `PerformedPart` instances)
+    as a WAV file using additive synthesis
+
+
+    Parameters
+    ----------
+    input_data : ScoreLike, PerformanceLike or np.ndarray
+        A partitura object with note information.
+    out : PathLike or None
+        Path of the output Wave file. If None, the method outputs
+        the audio signal as an array (see `audio_signal` below).
+    samplerate: int
+        The sample rate of the audio file in Hz. The default is 44100Hz.
+    envelope_fun: {"linear", "exp" } or callable
+        The type of envelop to apply to the individual sine waves.
+        If "linear" or "exp", the methods `lin_in_lin_out` and `exp_in_exp_out`
+        in `partitura.utils.synth` will be used. Otherwise this argument should
+        be a callable. See `lin_in_lin_out` for more details.
+    tuning: {"equal_temperament", "natural"} or callable.
+        The tuning system to use. If the value is "equal_temperament",
+        12 tone equal temperament implemented in
+        `partitura.utils.music.midi_pitch_to_frequency` will be used. If the value is
+        "natural", the function `partitura.utils.synth.midi_pitch_to_tempered_frequency`
+        will be used. Note that `midi_pitch_to_tempered_frequency` computes
+        intervals (and thus, frequencies) with respect to a reference note
+        (A4 by default) and uses the interval ratios specified by
+        `partitura.utils.synth.FIVE_LIMIT_INTERVAL_RATIOS`. See the documentation of
+        these functions for more information. If a callable is provided, function should
+        get MIDI pitch as input and return frequency in Hz as output.
+    tuning_kwargs : dict
+        Dictionary of keyword arguments to be passed to the tuning function
+        specified in  `tuning`. See `midi_pitch_to_tempered_frequency` and
+       `midi_pitch_to_frequency` for more information on their keyword arguments.
+    harmonic_dist : int,  "shepard" or None (optional)
+        Distribution of harmonics. If an integer, it is the number
+        of harmonics to be considered. If "shepard", it uses Shepard tones.
+        Default is None (i.e., only consider the fundamental frequency)
+    bpm : float, np.ndarray, callable
+        The bpm to render the output (if the input is a score-like object).
+        See `partitura.utils.music.performance_notearray_from_score_notearray`
+        for more information on this parameter.
+
+    Returns
+    -------
+    audio_signal : np.ndarray
+       Audio signal as a 1D array. Only returned if `out` is None.
+    """
+    # synthesize audio signal
+    audio_signal = synthesize(
+        note_info=input_data,
+        samplerate=samplerate,
+        envelope_fun=envelope_fun,
+        tuning=tuning,
+        tuning_kwargs=tuning_kwargs,
+        harmonic_dist=harmonic_dist,
+        bpm=bpm,
+    )
+
+    if out is not None:
+        # Write audio signal
+        wavfile.write(out, samplerate, audio_signal)
+    else:
+        return audio_signal
```

### Comparing `partitura-1.2.1/partitura/io/exportmatch.py` & `partitura-1.2.2/partitura/io/exportmatch.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,567 +1,565 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for exporting matchfiles.
-
-Notes
------
-* The methods only export matchfiles version 1.0.0.
-"""
-import numpy as np
-
-from typing import List, Optional, Iterable
-
-from collections import defaultdict
-
-from fractions import Fraction
-
-from partitura.score import Score, Part, ScoreLike
-from partitura.performance import Performance, PerformedPart, PerformanceLike
-
-from partitura.io.matchlines_v1 import (
-    make_info,
-    make_scoreprop,
-    make_section,
-    MatchSnote,
-    MatchNote,
-    MatchSnoteNote,
-    MatchSnoteDeletion,
-    MatchInsertionNote,
-    MatchSustainPedal,
-    MatchSoftPedal,
-    MatchOrnamentNote,
-    LATEST_VERSION,
-)
-
-from partitura.io.matchfile_utils import (
-    FractionalSymbolicDuration,
-    MatchKeySignature,
-    MatchTimeSignature,
-    Version,
-)
-
-from partitura import score
-from partitura.io.matchfile_base import MatchFile
-
-from partitura.utils.music import (
-    seconds_to_midi_ticks,
-    get_time_maps_from_alignment,
-)
-
-from partitura.utils.misc import (
-    PathLike,
-    deprecated_alias,
-    deprecated_parameter,
-)
-
-__all__ = ["save_match"]
-
-
-@deprecated_parameter("magaloff_zeilinger_quirk")
-def matchfile_from_alignment(
-    alignment: List[dict],
-    ppart: PerformedPart,
-    spart: Part,
-    mpq: int = 500000,
-    ppq: int = 480,
-    performer: Optional[str] = None,
-    composer: Optional[str] = None,
-    piece: Optional[str] = None,
-    score_filename: Optional[PathLike] = None,
-    performance_filename: Optional[PathLike] = None,
-    assume_part_unfolded: bool = False,
-    version: Version = LATEST_VERSION,
-    debug: bool = False,
-) -> MatchFile:
-    """
-    Generate a MatchFile object from an Alignment, a PerformedPart and
-    a Part
-
-    Parameters
-    ----------
-    alignment : list
-        A list of dictionaries containing alignment information.
-        See `partitura.io.importmatch.alignment_from_matchfile`.
-    ppart : partitura.performance.PerformedPart
-        An instance of `PerformedPart` containing performance information.
-    spart : partitura.score.Part
-        An instance of `Part` containing score information.
-    mpq : int
-        Microseconds per quarter note.
-    ppq: int
-        Parts per quarter note.
-    performer : str or None
-        Name(s) of the performer(s) of the `PerformedPart`.
-    composer : str or None
-        Name(s) of the composer(s) of the piece represented by `Part`.
-    piece : str or None:
-        Name of the piece represented by `Part`.
-    score_filename: PathLike
-        Name of the file containing the score.
-    performance_filename: PathLike
-        Name of the (MIDI) file containing the performance.
-    assume_part_unfolded: bool
-        Whether to assume that the part has been unfolded according to the
-        repetitions in the alignment. If False, the part will be automatically
-        unfolded to have maximal coverage of the notes in the alignment.
-        See `partitura.score.unfold_part_alignment`.
-    version: Version
-        Version of the match file. For now only 1.0.0 is supported.
-    Returns
-    -------
-    matchfile : MatchFile
-        An instance of `partitura.io.importmatch.MatchFile`.
-    """
-    if version < Version(1, 0, 0):
-        raise ValueError("Version should >= 1.0.0")
-
-    if not assume_part_unfolded:
-        # unfold score according to alignment
-        spart = score.unfold_part_alignment(spart, alignment)
-
-    # Info Header Lines
-    header_lines = dict()
-
-    header_lines["version"] = make_info(
-        version=version,
-        attribute="matchFileVersion",
-        value=version,
-    )
-
-    header_lines["performer"] = make_info(
-        version=version,
-        attribute="performer",
-        value="-" if performer is None else performer,
-    )
-
-    header_lines["piece"] = make_info(
-        version=version,
-        attribute="piece",
-        value="-" if piece is None else piece,
-    )
-
-    header_lines["composer"] = make_info(
-        version=version,
-        attribute="composer",
-        value="-" if composer is None else composer,
-    )
-
-    header_lines["score_filename"] = make_info(
-        version=version,
-        attribute="scoreFileName",
-        value="-" if score_filename is None else score_filename,
-    )
-
-    header_lines["performance_filename"] = make_info(
-        version=version,
-        attribute="midiFileName",
-        value="-" if performance_filename is None else performance_filename,
-    )
-
-    header_lines["clock_units"] = make_info(
-        version=version,
-        attribute="midiClockUnits",
-        value=int(ppq),
-    )
-
-    header_lines["clock_rate"] = make_info(
-        version=version,
-        attribute="midiClockRate",
-        value=int(mpq),
-    )
-
-    # Measure map (which measure corresponds to which time point in divs)
-    beat_map = spart.beat_map
-
-    ptime_to_stime_map, _ = get_time_maps_from_alignment(
-        ppart_or_note_array=ppart.note_array(),
-        spart_or_note_array=spart.note_array(),
-        alignment=alignment,
-        remove_ornaments=True,
-    )
-
-    measures = np.array(list(spart.iter_all(score.Measure)))
-    measure_starts_divs = np.array([m.start.t for m in measures])
-    measure_starts_beats = beat_map(measure_starts_divs)
-    measure_sorting_idx = measure_starts_divs.argsort()
-    measure_starts_divs = measure_starts_divs[measure_sorting_idx]
-    measures = measures[measure_sorting_idx]
-
-    start_measure_num = 0 if measure_starts_beats.min() < 0 else 1
-    measure_starts = np.column_stack(
-        (
-            np.arange(start_measure_num, start_measure_num + len(measure_starts_divs)),
-            measure_starts_divs,
-            measure_starts_beats,
-        )
-    )
-
-    # Score prop header lines
-    scoreprop_lines = defaultdict(list)
-
-    # For score notes
-    score_info = dict()
-    # Info for sorting lines
-    snote_sort_info = dict()
-    for (mnum, msd, msb), m in zip(measure_starts, measures):
-
-        time_signatures = spart.iter_all(score.TimeSignature, m.start, m.end)
-
-        for tsig in time_signatures:
-
-            time_divs = int(tsig.start.t)
-            time_beats = float(beat_map(time_divs))
-            dpq = int(spart.quarter_duration_map(time_divs))
-            beat = int((time_beats - msb) // 1)
-
-            ts_num, ts_den, _ = spart.time_signature_map(tsig.start.t)
-
-            moffset_divs = Fraction(
-                int(time_divs - msd - beat * dpq), (int(ts_den) * dpq)
-            )
-
-            scoreprop_lines["time_signatures"].append(
-                make_scoreprop(
-                    version=version,
-                    attribute="timeSignature",
-                    value=MatchTimeSignature(
-                        numerator=int(ts_num),
-                        denominator=int(ts_den),
-                        other_components=None,
-                        is_list=False,
-                    ),
-                    measure=int(mnum),
-                    beat=beat + 1,
-                    offset=FractionalSymbolicDuration(
-                        numerator=moffset_divs.numerator,
-                        denominator=moffset_divs.denominator,
-                    ),
-                    time_in_beats=time_beats,
-                )
-            )
-
-        key_signatures = spart.iter_all(score.KeySignature, m.start, m.end)
-
-        for ksig in key_signatures:
-            time_divs = int(tsig.start.t)
-            time_beats = float(beat_map(time_divs))
-            dpq = int(spart.quarter_duration_map(time_divs))
-            beat = int((time_beats - msb) // 1)
-
-            ts_num, ts_den, _ = spart.time_signature_map(tsig.start.t)
-
-            moffset_divs = Fraction(
-                int(time_divs - msd - beat * dpq), (int(ts_den) * dpq)
-            )
-
-            scoreprop_lines["key_signatures"].append(
-                make_scoreprop(
-                    version=version,
-                    attribute="keySignature",
-                    value=MatchKeySignature(
-                        fifths=int(ksig.fifths),
-                        mode=ksig.mode,
-                        is_list=False,
-                        fmt="v1.0.0",
-                    ),
-                    measure=int(mnum),
-                    beat=beat + 1,
-                    offset=FractionalSymbolicDuration(
-                        numerator=moffset_divs.numerator,
-                        denominator=moffset_divs.denominator,
-                    ),
-                    time_in_beats=time_beats,
-                )
-            )
-
-        # Get all notes in the measure
-        snotes = spart.iter_all(score.Note, m.start, m.end, include_subclasses=True)
-        # Beginning of each measure
-
-        for snote in snotes:
-
-            onset_divs, offset_divs = snote.start.t, snote.start.t + snote.duration_tied
-            duration_divs = offset_divs - onset_divs
-
-            onset_beats, offset_beats = beat_map([onset_divs, offset_divs])
-
-            dpq = int(spart.quarter_duration_map(onset_divs))
-
-            beat = int((onset_beats - msb) // 1)
-
-            ts_num, ts_den, _ = spart.time_signature_map(snote.start.t)
-
-            duration_symb = Fraction(duration_divs, dpq * 4)
-
-            beat = int((onset_divs - msd) // dpq)
-
-            moffset_divs = Fraction(
-                int(onset_divs - msd - beat * dpq), (dpq * 4)
-            )
-
-            if debug:
-                duration_beats = offset_beats - onset_beats
-                moffset_beat = (onset_beats - msb - beat) / ts_den
-                assert np.isclose(float(duration_symb), duration_beats)
-                assert np.isclose(moffset_beat, float(moffset_divs))
-
-            score_attributes_list = []
-
-            articulations = getattr(snote, "articulations", None)
-            voice = getattr(snote, "voice", None)
-            staff = getattr(snote, "staff", None)
-            ornaments = getattr(snote, "ornaments", None)
-            fermata = getattr(snote, "fermata", None)
-
-            if voice is not None:
-                score_attributes_list.append(f"v{voice}")
-
-            if staff is not None:
-                score_attributes_list.append(f"staff{staff}")
-
-            if articulations is not None:
-                score_attributes_list += list(articulations)
-
-            if ornaments is not None:
-                score_attributes_list += list(ornaments)
-
-            if fermata is not None:
-                score_attributes_list.append("fermata")
-
-            score_info[snote.id] = MatchSnote(
-                version=version,
-                anchor=str(snote.id),
-                note_name=str(snote.step).upper(),
-                modifier=snote.alter if snote.alter is not None else 0,
-                octave=int(snote.octave),
-                measure=int(mnum),
-                beat=beat + 1,
-                offset=FractionalSymbolicDuration(
-                    numerator=moffset_divs.numerator,
-                    denominator=moffset_divs.denominator,
-                ),
-                duration=FractionalSymbolicDuration(
-                    numerator=duration_symb.numerator,
-                    denominator=duration_symb.denominator,
-                ),
-                onset_in_beats=onset_beats,
-                offset_in_beats=offset_beats,
-                score_attributes_list=score_attributes_list,
-            )
-            snote_sort_info[snote.id] = (onset_beats, snote.doc_order)
-
-    perf_info = dict()
-    pnote_sort_info = dict()
-    for pnote in ppart.notes:
-        onset = seconds_to_midi_ticks(pnote["note_on"], mpq=mpq, ppq=ppq)
-        offset = seconds_to_midi_ticks(pnote["note_off"], mpq=mpq, ppq=ppq)
-        perf_info[pnote["id"]] = MatchNote(
-            version=version,
-            id=(
-                f"n{pnote['id']}"
-                if not str(pnote["id"]).startswith("n")
-                else str(pnote["id"])
-            ),
-            midi_pitch=int(pnote["midi_pitch"]),
-            onset=onset,
-            offset=offset,
-            velocity=pnote["velocity"],
-            channel=pnote.get("channel", 1),
-            track=pnote.get("track", 0),
-        )
-        pnote_sort_info[pnote["id"]] = (
-            float(ptime_to_stime_map(pnote["note_on"])),
-            pnote["midi_pitch"],
-        )
-
-    sort_stime = []
-    note_lines = []
-    for al_note in alignment:
-
-        label = al_note["label"]
-
-        if label == "match":
-            snote = score_info[al_note["score_id"]]
-            pnote = perf_info[al_note["performance_id"]]
-            snote_note_line = MatchSnoteNote(version=version, snote=snote, note=pnote)
-            note_lines.append(snote_note_line)
-            sort_stime.append(snote_sort_info[al_note["score_id"]])
-
-        elif label == "deletion":
-            snote = score_info[al_note["score_id"]]
-            deletion_line = MatchSnoteDeletion(version=version, snote=snote)
-            note_lines.append(deletion_line)
-            sort_stime.append(snote_sort_info[al_note["score_id"]])
-
-        elif label == "insertion":
-            note = perf_info[al_note["performance_id"]]
-            insertion_line = MatchInsertionNote(version=version, note=note)
-            note_lines.append(insertion_line)
-            sort_stime.append(pnote_sort_info[al_note["performance_id"]])
-
-        elif label == "ornament":
-            ornament_type = al_note["type"]
-            snote = score_info[al_note["score_id"]]
-            note = perf_info[al_note["performance_id"]]
-            ornament_line = MatchOrnamentNote(
-                version=version,
-                anchor=snote.Anchor,
-                note=note,
-                ornament_type=[ornament_type],
-            )
-
-            note_lines.append(ornament_line)
-            sort_stime.append(pnote_sort_info[al_note["performance_id"]])
-
-    # sort notes by score onset (performed insertions are sorted
-    # according to the interpolation map
-    sort_stime = np.array(sort_stime)
-    sort_stime_idx = np.lexsort((sort_stime[:, 1], sort_stime[:, 0]))
-    note_lines = np.array(note_lines)[sort_stime_idx]
-
-    # Create match lines for pedal information
-    pedal_lines = []
-    for c in ppart.controls:
-        t = seconds_to_midi_ticks(c["time"], mpq=mpq, ppq=ppq)
-        value = int(c["value"])
-        if c["number"] == 64:  # c['type'] == 'sustain_pedal':
-            sustain_pedal = MatchSustainPedal(version=version, time=t, value=value)
-            pedal_lines.append(sustain_pedal)
-
-        if c["number"] == 67:  # c['type'] == 'soft_pedal':
-            soft_pedal = MatchSoftPedal(version=version, time=t, value=value)
-            pedal_lines.append(soft_pedal)
-
-    pedal_lines.sort(key=lambda x: x.Time)
-
-    # Construct header of match file
-    header_order = [
-        "version",
-        "piece",
-        "score_filename",
-        "performance_filename",
-        "composer",
-        "performer",
-        "clock_units",
-        "clock_rate",
-        "key_signatures",
-        "time_signatures",
-    ]
-    all_match_lines = []
-    for h in header_order:
-        if h in header_lines:
-            all_match_lines.append(header_lines[h])
-
-        if h in scoreprop_lines:
-            all_match_lines += scoreprop_lines[h]
-
-    # Concatenate all lines
-    all_match_lines += list(note_lines) + pedal_lines
-
-    matchfile = MatchFile(lines=all_match_lines)
-
-    return matchfile
-
-
-@deprecated_alias(spart="score_data", ppart="performance_data")
-def save_match(
-    alignment: List[dict],
-    performance_data: PerformanceLike,
-    score_data: ScoreLike,
-    out: PathLike = None,
-    mpq: int = 500000,
-    ppq: int = 480,
-    performer: Optional[str] = None,
-    composer: Optional[str] = None,
-    piece: Optional[str] = None,
-    score_filename: Optional[PathLike] = None,
-    performance_filename: Optional[PathLike] = None,
-    assume_unfolded: bool = False,
-) -> Optional[MatchFile]:
-    """
-    Save an Alignment of a PerformedPart to a Part in a match file.
-
-    Parameters
-    ----------
-    alignment : list
-        A list of dictionaries containing alignment information.
-        See `partitura.io.importmatch.alignment_from_matchfile`.
-    performance_data : `PerformanceLike
-        The performance information as a `Performance`
-    score_data : `ScoreLike`
-        The musical score. A :class:`partitura.score.Score` object,
-        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
-        a list of these.
-    out : str
-        Out to export the matchfile.
-    mpq : int
-        Milliseconds per quarter note.
-    ppq: int
-        Parts per quarter note.
-    performer : str or None
-        Name(s) of the performer(s) of the `PerformedPart`.
-    composer : str or None
-        Name(s) of the composer(s) of the piece represented by `Part`.
-    piece : str or None:
-        Name of the piece represented by `Part`.
-    score_filename: PathLike
-        Name of the file containing the score.
-    performance_filename: PathLike
-        Name of the (MIDI) file containing the performance.
-    assume_part_unfolded: bool
-        Whether to assume that the part has been unfolded according to the
-        repetitions in the alignment. If False, the part will be automatically
-        unfolded to have maximal coverage of the notes in the alignment.
-        See `partitura.score.unfold_part_alignment`.
-
-    Returns
-    -------
-    matchfile: MatchFile
-        If no output is specified using `out`, the function returns
-        a `MatchFile` object. Otherwise, the function returns None.
-    """
-
-    # For now, we assume that we align only one Part and a PerformedPart
-
-    if isinstance(score_data, (Score, Iterable)):
-        spart = score_data[0]
-    elif isinstance(score_data, Part):
-        spart = score_data
-    elif isinstance(score_data, score.PartGroup):
-        spart = score_data.children[0]
-    else:
-        raise ValueError(
-            "`score_data` should be a `Score`, a `Part`, a `PartGroup` or a "
-            f"list of `Part` objects, but is {type(score_data)}"
-        )
-
-    if isinstance(performance_data, (Performance, Iterable)):
-        ppart = performance_data[0]
-    elif isinstance(performance_data, PerformedPart):
-        ppart = performance_data
-    else:
-        raise ValueError(
-            "`performance_data` should be a `Performance`, a `PerformedPart`, or a "
-            f"list of `PerformedPart` objects, but is {type(score_data)}"
-        )
-
-    # Get matchfile
-    matchfile = matchfile_from_alignment(
-        alignment=alignment,
-        ppart=ppart,
-        spart=spart,
-        mpq=mpq,
-        ppq=ppq,
-        performer=performer,
-        composer=composer,
-        piece=piece,
-        score_filename=score_filename,
-        performance_filename=performance_filename,
-        assume_part_unfolded=assume_unfolded,
-    )
-
-    if out is not None:
-        # write matchfile
-        matchfile.write(out)
-    else:
-        return matchfile
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for exporting matchfiles.
+
+Notes
+-----
+* The methods only export matchfiles version 1.0.0.
+"""
+import numpy as np
+
+from typing import List, Optional, Iterable
+
+from collections import defaultdict
+
+from fractions import Fraction
+
+from partitura.score import Score, Part, ScoreLike
+from partitura.performance import Performance, PerformedPart, PerformanceLike
+
+from partitura.io.matchlines_v1 import (
+    make_info,
+    make_scoreprop,
+    make_section,
+    MatchSnote,
+    MatchNote,
+    MatchSnoteNote,
+    MatchSnoteDeletion,
+    MatchInsertionNote,
+    MatchSustainPedal,
+    MatchSoftPedal,
+    MatchOrnamentNote,
+    LATEST_VERSION,
+)
+
+from partitura.io.matchfile_utils import (
+    FractionalSymbolicDuration,
+    MatchKeySignature,
+    MatchTimeSignature,
+    Version,
+)
+
+from partitura import score
+from partitura.io.matchfile_base import MatchFile
+
+from partitura.utils.music import (
+    seconds_to_midi_ticks,
+    get_time_maps_from_alignment,
+)
+
+from partitura.utils.misc import (
+    PathLike,
+    deprecated_alias,
+    deprecated_parameter,
+)
+
+__all__ = ["save_match"]
+
+
+@deprecated_parameter("magaloff_zeilinger_quirk")
+def matchfile_from_alignment(
+    alignment: List[dict],
+    ppart: PerformedPart,
+    spart: Part,
+    mpq: int = 500000,
+    ppq: int = 480,
+    performer: Optional[str] = None,
+    composer: Optional[str] = None,
+    piece: Optional[str] = None,
+    score_filename: Optional[PathLike] = None,
+    performance_filename: Optional[PathLike] = None,
+    assume_part_unfolded: bool = False,
+    version: Version = LATEST_VERSION,
+    debug: bool = False,
+) -> MatchFile:
+    """
+    Generate a MatchFile object from an Alignment, a PerformedPart and
+    a Part
+
+    Parameters
+    ----------
+    alignment : list
+        A list of dictionaries containing alignment information.
+        See `partitura.io.importmatch.alignment_from_matchfile`.
+    ppart : partitura.performance.PerformedPart
+        An instance of `PerformedPart` containing performance information.
+    spart : partitura.score.Part
+        An instance of `Part` containing score information.
+    mpq : int
+        Microseconds per quarter note.
+    ppq: int
+        Parts per quarter note.
+    performer : str or None
+        Name(s) of the performer(s) of the `PerformedPart`.
+    composer : str or None
+        Name(s) of the composer(s) of the piece represented by `Part`.
+    piece : str or None:
+        Name of the piece represented by `Part`.
+    score_filename: PathLike
+        Name of the file containing the score.
+    performance_filename: PathLike
+        Name of the (MIDI) file containing the performance.
+    assume_part_unfolded: bool
+        Whether to assume that the part has been unfolded according to the
+        repetitions in the alignment. If False, the part will be automatically
+        unfolded to have maximal coverage of the notes in the alignment.
+        See `partitura.score.unfold_part_alignment`.
+    version: Version
+        Version of the match file. For now only 1.0.0 is supported.
+    Returns
+    -------
+    matchfile : MatchFile
+        An instance of `partitura.io.importmatch.MatchFile`.
+    """
+    if version < Version(1, 0, 0):
+        raise ValueError("Version should >= 1.0.0")
+
+    if not assume_part_unfolded:
+        # unfold score according to alignment
+        spart = score.unfold_part_alignment(spart, alignment)
+
+    # Info Header Lines
+    header_lines = dict()
+
+    header_lines["version"] = make_info(
+        version=version,
+        attribute="matchFileVersion",
+        value=version,
+    )
+
+    header_lines["performer"] = make_info(
+        version=version,
+        attribute="performer",
+        value="-" if performer is None else performer,
+    )
+
+    header_lines["piece"] = make_info(
+        version=version,
+        attribute="piece",
+        value="-" if piece is None else piece,
+    )
+
+    header_lines["composer"] = make_info(
+        version=version,
+        attribute="composer",
+        value="-" if composer is None else composer,
+    )
+
+    header_lines["score_filename"] = make_info(
+        version=version,
+        attribute="scoreFileName",
+        value="-" if score_filename is None else score_filename,
+    )
+
+    header_lines["performance_filename"] = make_info(
+        version=version,
+        attribute="midiFileName",
+        value="-" if performance_filename is None else performance_filename,
+    )
+
+    header_lines["clock_units"] = make_info(
+        version=version,
+        attribute="midiClockUnits",
+        value=int(ppq),
+    )
+
+    header_lines["clock_rate"] = make_info(
+        version=version,
+        attribute="midiClockRate",
+        value=int(mpq),
+    )
+
+    # Measure map (which measure corresponds to which time point in divs)
+    beat_map = spart.beat_map
+
+    ptime_to_stime_map, _ = get_time_maps_from_alignment(
+        ppart_or_note_array=ppart.note_array(),
+        spart_or_note_array=spart.note_array(),
+        alignment=alignment,
+        remove_ornaments=True,
+    )
+
+    measures = np.array(list(spart.iter_all(score.Measure)))
+    measure_starts_divs = np.array([m.start.t for m in measures])
+    measure_starts_beats = beat_map(measure_starts_divs)
+    measure_sorting_idx = measure_starts_divs.argsort()
+    measure_starts_divs = measure_starts_divs[measure_sorting_idx]
+    measures = measures[measure_sorting_idx]
+
+    start_measure_num = 0 if measure_starts_beats.min() < 0 else 1
+    measure_starts = np.column_stack(
+        (
+            np.arange(start_measure_num, start_measure_num + len(measure_starts_divs)),
+            measure_starts_divs,
+            measure_starts_beats,
+        )
+    )
+
+    # Score prop header lines
+    scoreprop_lines = defaultdict(list)
+
+    # For score notes
+    score_info = dict()
+    # Info for sorting lines
+    snote_sort_info = dict()
+    for (mnum, msd, msb), m in zip(measure_starts, measures):
+
+        time_signatures = spart.iter_all(score.TimeSignature, m.start, m.end)
+
+        for tsig in time_signatures:
+
+            time_divs = int(tsig.start.t)
+            time_beats = float(beat_map(time_divs))
+            dpq = int(spart.quarter_duration_map(time_divs))
+            beat = int((time_beats - msb) // 1)
+
+            ts_num, ts_den, _ = spart.time_signature_map(tsig.start.t)
+
+            moffset_divs = Fraction(
+                int(time_divs - msd - beat * dpq), (int(ts_den) * dpq)
+            )
+
+            scoreprop_lines["time_signatures"].append(
+                make_scoreprop(
+                    version=version,
+                    attribute="timeSignature",
+                    value=MatchTimeSignature(
+                        numerator=int(ts_num),
+                        denominator=int(ts_den),
+                        other_components=None,
+                        is_list=False,
+                    ),
+                    measure=int(mnum),
+                    beat=beat + 1,
+                    offset=FractionalSymbolicDuration(
+                        numerator=moffset_divs.numerator,
+                        denominator=moffset_divs.denominator,
+                    ),
+                    time_in_beats=time_beats,
+                )
+            )
+
+        key_signatures = spart.iter_all(score.KeySignature, m.start, m.end)
+
+        for ksig in key_signatures:
+            time_divs = int(tsig.start.t)
+            time_beats = float(beat_map(time_divs))
+            dpq = int(spart.quarter_duration_map(time_divs))
+            beat = int((time_beats - msb) // 1)
+
+            ts_num, ts_den, _ = spart.time_signature_map(tsig.start.t)
+
+            moffset_divs = Fraction(
+                int(time_divs - msd - beat * dpq), (int(ts_den) * dpq)
+            )
+
+            scoreprop_lines["key_signatures"].append(
+                make_scoreprop(
+                    version=version,
+                    attribute="keySignature",
+                    value=MatchKeySignature(
+                        fifths=int(ksig.fifths),
+                        mode=ksig.mode,
+                        is_list=False,
+                        fmt="v1.0.0",
+                    ),
+                    measure=int(mnum),
+                    beat=beat + 1,
+                    offset=FractionalSymbolicDuration(
+                        numerator=moffset_divs.numerator,
+                        denominator=moffset_divs.denominator,
+                    ),
+                    time_in_beats=time_beats,
+                )
+            )
+
+        # Get all notes in the measure
+        snotes = spart.iter_all(score.Note, m.start, m.end, include_subclasses=True)
+        # Beginning of each measure
+
+        for snote in snotes:
+
+            onset_divs, offset_divs = snote.start.t, snote.start.t + snote.duration_tied
+            duration_divs = offset_divs - onset_divs
+
+            onset_beats, offset_beats = beat_map([onset_divs, offset_divs])
+
+            dpq = int(spart.quarter_duration_map(onset_divs))
+
+            beat = int((onset_beats - msb) // 1)
+
+            ts_num, ts_den, _ = spart.time_signature_map(snote.start.t)
+
+            duration_symb = Fraction(duration_divs, dpq * 4)
+
+            beat = int((onset_divs - msd) // dpq)
+
+            moffset_divs = Fraction(int(onset_divs - msd - beat * dpq), (dpq * 4))
+
+            if debug:
+                duration_beats = offset_beats - onset_beats
+                moffset_beat = (onset_beats - msb - beat) / ts_den
+                assert np.isclose(float(duration_symb), duration_beats)
+                assert np.isclose(moffset_beat, float(moffset_divs))
+
+            score_attributes_list = []
+
+            articulations = getattr(snote, "articulations", None)
+            voice = getattr(snote, "voice", None)
+            staff = getattr(snote, "staff", None)
+            ornaments = getattr(snote, "ornaments", None)
+            fermata = getattr(snote, "fermata", None)
+
+            if voice is not None:
+                score_attributes_list.append(f"v{voice}")
+
+            if staff is not None:
+                score_attributes_list.append(f"staff{staff}")
+
+            if articulations is not None:
+                score_attributes_list += list(articulations)
+
+            if ornaments is not None:
+                score_attributes_list += list(ornaments)
+
+            if fermata is not None:
+                score_attributes_list.append("fermata")
+
+            score_info[snote.id] = MatchSnote(
+                version=version,
+                anchor=str(snote.id),
+                note_name=str(snote.step).upper(),
+                modifier=snote.alter if snote.alter is not None else 0,
+                octave=int(snote.octave),
+                measure=int(mnum),
+                beat=beat + 1,
+                offset=FractionalSymbolicDuration(
+                    numerator=moffset_divs.numerator,
+                    denominator=moffset_divs.denominator,
+                ),
+                duration=FractionalSymbolicDuration(
+                    numerator=duration_symb.numerator,
+                    denominator=duration_symb.denominator,
+                ),
+                onset_in_beats=onset_beats,
+                offset_in_beats=offset_beats,
+                score_attributes_list=score_attributes_list,
+            )
+            snote_sort_info[snote.id] = (onset_beats, snote.doc_order)
+
+    perf_info = dict()
+    pnote_sort_info = dict()
+    for pnote in ppart.notes:
+        onset = seconds_to_midi_ticks(pnote["note_on"], mpq=mpq, ppq=ppq)
+        offset = seconds_to_midi_ticks(pnote["note_off"], mpq=mpq, ppq=ppq)
+        perf_info[pnote["id"]] = MatchNote(
+            version=version,
+            id=(
+                f"n{pnote['id']}"
+                if not str(pnote["id"]).startswith("n")
+                else str(pnote["id"])
+            ),
+            midi_pitch=int(pnote["midi_pitch"]),
+            onset=onset,
+            offset=offset,
+            velocity=pnote["velocity"],
+            channel=pnote.get("channel", 1),
+            track=pnote.get("track", 0),
+        )
+        pnote_sort_info[pnote["id"]] = (
+            float(ptime_to_stime_map(pnote["note_on"])),
+            pnote["midi_pitch"],
+        )
+
+    sort_stime = []
+    note_lines = []
+    for al_note in alignment:
+
+        label = al_note["label"]
+
+        if label == "match":
+            snote = score_info[al_note["score_id"]]
+            pnote = perf_info[al_note["performance_id"]]
+            snote_note_line = MatchSnoteNote(version=version, snote=snote, note=pnote)
+            note_lines.append(snote_note_line)
+            sort_stime.append(snote_sort_info[al_note["score_id"]])
+
+        elif label == "deletion":
+            snote = score_info[al_note["score_id"]]
+            deletion_line = MatchSnoteDeletion(version=version, snote=snote)
+            note_lines.append(deletion_line)
+            sort_stime.append(snote_sort_info[al_note["score_id"]])
+
+        elif label == "insertion":
+            note = perf_info[al_note["performance_id"]]
+            insertion_line = MatchInsertionNote(version=version, note=note)
+            note_lines.append(insertion_line)
+            sort_stime.append(pnote_sort_info[al_note["performance_id"]])
+
+        elif label == "ornament":
+            ornament_type = al_note["type"]
+            snote = score_info[al_note["score_id"]]
+            note = perf_info[al_note["performance_id"]]
+            ornament_line = MatchOrnamentNote(
+                version=version,
+                anchor=snote.Anchor,
+                note=note,
+                ornament_type=[ornament_type],
+            )
+
+            note_lines.append(ornament_line)
+            sort_stime.append(pnote_sort_info[al_note["performance_id"]])
+
+    # sort notes by score onset (performed insertions are sorted
+    # according to the interpolation map
+    sort_stime = np.array(sort_stime)
+    sort_stime_idx = np.lexsort((sort_stime[:, 1], sort_stime[:, 0]))
+    note_lines = np.array(note_lines)[sort_stime_idx]
+
+    # Create match lines for pedal information
+    pedal_lines = []
+    for c in ppart.controls:
+        t = seconds_to_midi_ticks(c["time"], mpq=mpq, ppq=ppq)
+        value = int(c["value"])
+        if c["number"] == 64:  # c['type'] == 'sustain_pedal':
+            sustain_pedal = MatchSustainPedal(version=version, time=t, value=value)
+            pedal_lines.append(sustain_pedal)
+
+        if c["number"] == 67:  # c['type'] == 'soft_pedal':
+            soft_pedal = MatchSoftPedal(version=version, time=t, value=value)
+            pedal_lines.append(soft_pedal)
+
+    pedal_lines.sort(key=lambda x: x.Time)
+
+    # Construct header of match file
+    header_order = [
+        "version",
+        "piece",
+        "score_filename",
+        "performance_filename",
+        "composer",
+        "performer",
+        "clock_units",
+        "clock_rate",
+        "key_signatures",
+        "time_signatures",
+    ]
+    all_match_lines = []
+    for h in header_order:
+        if h in header_lines:
+            all_match_lines.append(header_lines[h])
+
+        if h in scoreprop_lines:
+            all_match_lines += scoreprop_lines[h]
+
+    # Concatenate all lines
+    all_match_lines += list(note_lines) + pedal_lines
+
+    matchfile = MatchFile(lines=all_match_lines)
+
+    return matchfile
+
+
+@deprecated_alias(spart="score_data", ppart="performance_data")
+def save_match(
+    alignment: List[dict],
+    performance_data: PerformanceLike,
+    score_data: ScoreLike,
+    out: PathLike = None,
+    mpq: int = 500000,
+    ppq: int = 480,
+    performer: Optional[str] = None,
+    composer: Optional[str] = None,
+    piece: Optional[str] = None,
+    score_filename: Optional[PathLike] = None,
+    performance_filename: Optional[PathLike] = None,
+    assume_unfolded: bool = False,
+) -> Optional[MatchFile]:
+    """
+    Save an Alignment of a PerformedPart to a Part in a match file.
+
+    Parameters
+    ----------
+    alignment : list
+        A list of dictionaries containing alignment information.
+        See `partitura.io.importmatch.alignment_from_matchfile`.
+    performance_data : `PerformanceLike
+        The performance information as a `Performance`
+    score_data : `ScoreLike`
+        The musical score. A :class:`partitura.score.Score` object,
+        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
+        a list of these.
+    out : str
+        Out to export the matchfile.
+    mpq : int
+        Milliseconds per quarter note.
+    ppq: int
+        Parts per quarter note.
+    performer : str or None
+        Name(s) of the performer(s) of the `PerformedPart`.
+    composer : str or None
+        Name(s) of the composer(s) of the piece represented by `Part`.
+    piece : str or None:
+        Name of the piece represented by `Part`.
+    score_filename: PathLike
+        Name of the file containing the score.
+    performance_filename: PathLike
+        Name of the (MIDI) file containing the performance.
+    assume_part_unfolded: bool
+        Whether to assume that the part has been unfolded according to the
+        repetitions in the alignment. If False, the part will be automatically
+        unfolded to have maximal coverage of the notes in the alignment.
+        See `partitura.score.unfold_part_alignment`.
+
+    Returns
+    -------
+    matchfile: MatchFile
+        If no output is specified using `out`, the function returns
+        a `MatchFile` object. Otherwise, the function returns None.
+    """
+
+    # For now, we assume that we align only one Part and a PerformedPart
+
+    if isinstance(score_data, (Score, Iterable)):
+        spart = score_data[0]
+    elif isinstance(score_data, Part):
+        spart = score_data
+    elif isinstance(score_data, score.PartGroup):
+        spart = score_data.children[0]
+    else:
+        raise ValueError(
+            "`score_data` should be a `Score`, a `Part`, a `PartGroup` or a "
+            f"list of `Part` objects, but is {type(score_data)}"
+        )
+
+    if isinstance(performance_data, (Performance, Iterable)):
+        ppart = performance_data[0]
+    elif isinstance(performance_data, PerformedPart):
+        ppart = performance_data
+    else:
+        raise ValueError(
+            "`performance_data` should be a `Performance`, a `PerformedPart`, or a "
+            f"list of `PerformedPart` objects, but is {type(score_data)}"
+        )
+
+    # Get matchfile
+    matchfile = matchfile_from_alignment(
+        alignment=alignment,
+        ppart=ppart,
+        spart=spart,
+        mpq=mpq,
+        ppq=ppq,
+        performer=performer,
+        composer=composer,
+        piece=piece,
+        score_filename=score_filename,
+        performance_filename=performance_filename,
+        assume_part_unfolded=assume_unfolded,
+    )
+
+    if out is not None:
+        # write matchfile
+        matchfile.write(out)
+    else:
+        return matchfile
```

### Comparing `partitura-1.2.1/partitura/io/exportmei.py` & `partitura-1.2.2/partitura/io/exportmei.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,2096 +1,2096 @@
-# import partitura
-# import partitura.score as score
-# from lxml import etree
-# from partitura.utils.generic import partition
-# from partitura.utils.music import estimate_symbolic_duration
-# from copy import copy
-
-
-# name_space = "http://www.music-encoding.org/ns/mei"
-
-# xml_id_string = "{http://www.w3.org/XML/1998/namespace}id"
-
-
-# def extend_key(dict_of_lists, key, value):
-#     """extend or create a list at the given key in the given dictionary
-
-#     Parameters
-#     ----------
-#     dict_of_lists:    dictionary
-#         where all values are lists
-#     key:            self explanatory
-#     value:          self explanatory
-
-#     """
-
-#     if key in dict_of_lists.keys():
-#         if isinstance(value, list):
-#             dict_of_lists[key].extend(value)
-#         else:
-#             dict_of_lists[key].append(value)
-#     else:
-#         dict_of_lists[key] = value if isinstance(value, list) else [value]
-
-
-# def calc_dur_dots_split_notes_first_temp_dur(note, measure, num_to_numbase_ratio=1):
-#     """
-#     Notes have to be represented as a string of elemental notes (there is no notation for arbitrary durations)
-#     This function calculates this string (the durations of the elemental notes and their dot counts),
-#     whether the note crosses the measure and the temporal duration of the first elemental note
-
-#     Parameters
-#     ----------
-#     note:               score.GenericNote
-#         The note whose representation as a string of elemental notes is calculated
-#     measure:            score.Measure
-#         The measure which contains note
-#     num_to_numbase_ratio: float, optional
-#         scales the duration of note according to whether or not it belongs to a tuplet and which one
-
-
-#     Returns
-#     -------
-#     dur_dots:       list of int pairs
-#         this describes the string of elemental notes that represent the note notationally
-#         every pair in the list contains the duration and the dot count of an elemental note and
-#         the list is ordered by duration in decreasing order
-#     split_notes:     list or None
-#         an empty list if note crosses measure
-#         None if it doesn't
-#     first_temp_dur:   int or None
-#         duration of first elemental note in partitura time
-#     """
-
-#     if measure == "pad":
-#         return [], None, None
-
-#     if isinstance(note, score.GraceNote):
-#         main_note = note.main_note
-#         # HACK: main note should actually be always not None for a proper GraceNote
-#         if main_note != None:
-#             dur_dots, _, _ = calc_dur_dots_split_notes_first_temp_dur(
-#                 main_note, measure
-#             )
-#             dur_dots = [(2 * dur_dots[0][0], dur_dots[0][1])]
-#         else:
-#             dur_dots = [(8, 0)]
-#             note.id += "_missing_main_note"
-#         return dur_dots, None, None
-
-#     note_duration = note.duration
-
-#     split_notes = None
-
-#     if note.start.t + note.duration > measure.end.t:
-#         note_duration = measure.end.t - note.start.t
-#         split_notes = []
-
-#     quarter_dur = measure.start.quarter
-#     fraction = num_to_numbase_ratio * note_duration / quarter_dur
-
-#     int_part = int(fraction)
-#     frac_part = fraction - int_part
-
-#     # calc digits of fraction in base2
-#     untied_durations = []
-#     pow_of_2 = 1
-
-#     while int_part > 0:
-#         bit = int_part % 2
-#         untied_durations.insert(0, bit * pow_of_2)
-#         int_part = int_part // 2
-#         pow_of_2 *= 2
-
-#     pow_of_2 = 1 / 2
-
-#     while frac_part > 0:
-#         frac_part *= 2
-#         bit = int(frac_part)
-#         frac_part -= bit
-#         untied_durations.append(bit * pow_of_2)
-#         pow_of_2 /= 2
-
-#     dur_dots = []
-
-#     curr_dur = 0
-#     curr_dots = 0
-
-#     def add_dd(dur_dots, dur, dots):
-#         dur_dots.append((int(4 / dur), dots))
-
-#     for untied_dur in untied_durations:
-#         if curr_dur != 0:
-#             if untied_dur == 0:
-#                 add_dd(dur_dots, curr_dur, curr_dots)
-#                 curr_dots = 0
-#                 curr_dur = 0
-#             else:
-#                 curr_dots += 1
-#         else:
-#             curr_dur = untied_dur
-
-#     if curr_dur != 0:
-#         add_dd(dur_dots, curr_dur, curr_dots)
-
-#     first_temp_dur = int(untied_durations[0] * quarter_dur)
-
-#     return dur_dots, split_notes, first_temp_dur
-
-
-# def insert_elem_check(t, inbetween_notes_elems):
-#     """Check if something like a clef etc appears before time t
-
-#     Parameters
-#     ----------
-#     t:                      int
-#         time from a Timepoint
-#     inbetween_notes_elems:    list of InbetweenNotesElements
-#         a list of objects describing things like clefs etc
-
-#     Returns
-#     -------
-#     True if something like a clef etc appears before time t
-#     """
-
-#     for ine in inbetween_notes_elems:
-#         if ine.elem != None and ine.elem.start.t <= t:
-#             return True
-
-#     return False
-
-
-# def partition_handle_none(func, iter, partition_attrib):
-#     p = partition(func, iter)
-#     newKey = None
-
-#     if None in p.keys():
-#         raise KeyError(
-#             'PARTITION ERROR: some elements of set do not have partition attribute "'
-#             + partition_attrib
-#             + '"'
-#         )
-
-#     return p
-
-
-# def add_child(parent, child_name):
-#     return etree.SubElement(parent, child_name)
-
-
-# def set_attributes(elem, *list_attrib_val):
-#     for attrib_val in list_attrib_val:
-#         elem.set(attrib_val[0], str(attrib_val[1]))
-
-
-# def attribs_of_key_sig(ks):
-#     """
-#     Returns values of a score.KeySignature object necessary for a MEI document
-
-#     Parameters
-#     ----------
-#     ks: score.KeySignature
-
-#     Returns
-#     -------
-#     fifths: string
-#         describes the circle of fifths
-#     mode:   string
-#         "major" or "minor"
-#     pname:  string
-#         pitch letter
-#     """
-
-#     key = ks.name
-#     pname = key[0].lower()
-#     mode = "major"
-
-#     if len(key) == 2:
-#         mode = "minor"
-
-#     fifths = str(abs(ks.fifths))
-
-#     if ks.fifths < 0:
-#         fifths += "f"
-#     elif ks.fifths > 0:
-#         fifths += "s"
-
-#     return fifths, mode, pname
-
-
-# def first_instances_per_part(
-#     cls, parts, start=score.TimePoint(0), end=score.TimePoint(1)
-# ):
-#     """
-#     Returns the first instances of a class (multiple objects with same start time are possible) in each part
-
-#     Parameters
-#     ----------
-#     cls:    class
-#     parts:  list of score.Part
-#     start:  score.TimePoint, optional
-#         start of the range to search in
-#     end:    score.TimePoint, optional
-#         end of the range to search in
-
-#     Returns
-#     -------
-#     instances_per_part: list of list of instances of cls
-#         sublists might be empty
-#         if all sublists are empty, instances_per_part is empty
-#     """
-#     if not isinstance(start, list):
-#         start = [start] * len(parts)
-#     elif not len(parts) == len(start):
-#         raise ValueError(
-#             "ERROR at first_instances_per_part: start times are given as list with different size to parts list"
-#         )
-
-#     if not isinstance(end, list):
-#         end = [end] * len(parts)
-#     elif not len(parts) == len(end):
-#         raise ValueError(
-#             "ERROR at first_instances_per_part: end times are given as list with different size to parts list"
-#         )
-
-#     for i in range(len(parts)):
-#         if start[i] == None and end[i] != None or start[i] != None and end[i] == None:
-#             raise ValueError(
-#                 "ERROR at first_instances_per_part: (start==None) != (end==None) (None elements in start have to be at same position as in end and vice versa)"
-#             )
-
-#     instances_per_part = []
-
-#     non_empty = False
-
-#     for i, p in enumerate(parts):
-#         s = start[i]
-#         e = end[i]
-
-#         if s == None:
-#             instances_per_part.append([])
-#             continue
-
-#         instances = list(p.iter_all(cls, s, e))
-
-#         if len(instances) == 0:
-#             instances_per_part.append([])
-#             continue
-
-#         non_empty = True
-#         t = min(instances, key=lambda i: i.start.t).start.t
-#         instances_per_part.append([i for i in instances if t == i.start.t])
-
-#     if non_empty:
-#         return instances_per_part
-
-#     return []
-
-
-# def first_instance_per_part(
-#     cls, parts, start=score.TimePoint(0), end=score.TimePoint(1)
-# ):
-#     """
-#     Reduce the result of first_instances_per_part, a 2D list, to a 1D list
-#     If there are multiple first instances then program aborts with error message
-
-#     Parameters
-#     ----------
-#     cls:    class
-#     parts:  list of score.Part
-#     start:  score.TimePoint, optional
-#         start of the range to search in
-#     end:    score.TimePoint, optional
-#         end of the range to search in
-
-#     Returns
-#     -------
-#     fipp: list of instances of cls
-#         elements might be None
-#     """
-#     fispp = first_instances_per_part(cls, parts, start, end)
-
-#     fipp = []
-
-#     for i, fis in enumerate(fispp):
-#         if len(fis) == 0:
-#             fipp.append(None)
-#         elif len(fis) == 1:
-#             fipp.append(fis[0])
-#         else:
-#             raise ValueError(
-#                 "Part " + parts[i].name,
-#                 "ID " + parts[i].id,
-#                 "has more than one instance of "
-#                 + str(cls)
-#                 + " at beginning t=0, but there should only be a single one",
-#             )
-
-#     return fipp
-
-
-# def first_instances(cls, part, start=score.TimePoint(0), end=score.TimePoint(1)):
-#     """
-#     Returns the first instances of a class (multiple objects with same start time are possible) in the part
-
-#     Parameters
-#     ----------
-#     cls:    class
-#     part:   score.Part
-#     start:  score.TimePoint, optional
-#         start of the range to search in
-#     end:    score.TimePoint, optional
-#         end of the range to search in
-
-#     Returns
-#     -------
-#     fis: list of instances of cls
-#         might be empty
-#     """
-#     fis = first_instances_per_part(cls, [part], start, end)
-
-#     if len(fis) == 0:
-#         return []
-
-#     return fis[0]
-
-
-# def first_instance(cls, part, start=score.TimePoint(0), end=score.TimePoint(1)):
-#     """
-#     Reduce the result of first_instance_per_part, a 1D list, to an element
-#     If there are multiple first instances then program aborts with error message
-
-#     Parameters
-#     ----------
-#     cls:    class
-#     part:   score.Part
-#     start:  score.TimePoint, optional
-#         start of the range to search in
-#     end:    score.TimePoint, optional
-#         end of the range to search in
-
-#     Returns
-#     -------
-#     fi: instance of cls or None
-#     """
-#     fi = first_instance_per_part(cls, [part], start, end)
-
-#     if len(fi) == 0:
-#         return None
-
-#     return fi[0]
-
-
-# def common_signature(cls, sig_eql, parts, current_measures=None):
-#     """
-#     Calculate whether a list of parts has a common signature (as in key or time signature)
-
-#     Parameters
-#     ----------
-#     cls:                score.KeySignature or score.TimeSignature
-#     sig_eql:            function
-#         takes 2 signature objects as input and returns whether they are equivalent (in some sense)
-#     parts:              list of score.Part
-#     current_measures:    list of score.Measure, optional
-#         current as in the measures of the parts that are played at the same time and are processed
-
-#     Returns
-#     -------
-#     common_sig:  instance of cls
-#         might be None if there is no commonality between parts
-#     """
-#     sigs = None
-#     if current_measures != None:
-#         # HACK:  measures should probably not contain "pad" at this point, but an actual dummy measure with start and end times?
-#         sigs = first_instance_per_part(
-#             cls,
-#             parts,
-#             start=[cm.start if cm != "pad" else None for cm in current_measures],
-#             end=[cm.end if cm != "pad" else None for cm in current_measures],
-#         )
-#     else:
-#         sigs = first_instance_per_part(cls, parts)
-
-#     if sigs == None or len(sigs) == 0 or None in sigs:
-#         return None
-
-#     common_sig = sigs.pop()
-
-#     for sig in sigs:
-#         if sig.start.t != common_sig.start.t or not sig_eql(sig, common_sig):
-#             return None
-
-#     return common_sig
-
-
-# def vertical_slice(list_2d, index):
-#     """
-#     Returns elements of the sublists at index in a 1D list
-#     all sublists of list_2d have to have len > index
-#     """
-#     vslice = []
-
-#     for list_1d in list_2d:
-#         vslice.append(list_1d[index])
-
-#     return vslice
-
-
-# def time_sig_eql(ts1, ts2):
-#     """
-#     equivalence function for score.TimeSignature objects
-#     """
-#     return ts1.beats == ts2.beats and ts1.beat_type == ts2.beat_type
-
-
-# def key_sig_eql(ks1, ks2):
-#     """
-#     equivalence function for score.KeySignature objects
-#     """
-#     return ks1.name == ks2.name and ks1.fifths == ks2.fifths
-
-
-# def idx(len_obj):
-#     return range(len(len_obj))
-
-
-# def attribs_of_clef(clef):
-#     """
-#     Returns values of a score.Clef object necessary for a MEI document
-
-#     Parameters
-#     ----------
-#     clef: score.Clef
-
-#     Returns
-#     -------
-#     sign: string
-#         shape of clef (F,G, etc)
-#     line:
-#         which line to place clef on
-#     """
-#     sign = clef.sign
-
-#     if sign == "percussion":
-#         sign = "perc"
-
-#     if clef.octave_change != None and clef.octave_change != 0:
-#         place = "above"
-
-#         if clef.octave_change < 0:
-#             place = "below"
-
-#         return sign, clef.line, 1 + 7 * abs(clef.octave_change), place
-
-#     return sign, clef.line
-
-
-# def create_staff_def(staff_grp, clef):
-#     """
-
-#     Parameters
-#     ----------
-#     staff_grp:   etree.SubElement
-#     clef:       score.Clef
-#     """
-#     staff_def = add_child(staff_grp, "staffDef")
-
-#     attribs = attribs_of_clef(clef)
-#     set_attributes(
-#         staff_def,
-#         ("n", clef.number),
-#         ("lines", 5),
-#         ("clef.shape", attribs[0]),
-#         ("clef.line", attribs[1]),
-#     )
-#     if len(attribs) == 4:
-#         set_attributes(
-#             staff_def, ("clef.dis", attribs[2]), ("clef.dis.place", attribs[3])
-#         )
-
-
-# def pad_measure(s, measure_per_staff, notes_within_measure_per_staff, auto_rest_count):
-#     """
-#     Adds a fake measure ("pad") to the measures of the staff s and a score.Rest object to the notes
-
-#     Parameters
-#     ----------
-#     s:                              int
-#         staff number
-#     measure_per_staff:               dict of score.Measure objects
-#     notes_within_measure_per_staff:   dict of lists of score.GenericNote objects
-#     auto_rest_count:                  int
-#         a counter for all the score.Rest objects that are created automatically
-
-#     Returns
-#     -------
-#     incremented auto rest counter
-#     """
-
-#     measure_per_staff[s] = "pad"
-#     r = score.Rest(id="pR" + str(auto_rest_count), voice=1)
-#     r.start = score.TimePoint(0)
-#     r.end = r.start
-
-#     extend_key(notes_within_measure_per_staff, s, r)
-#     return auto_rest_count + 1
-
-
-# class InbetweenNotesElement:
-#     """
-#     InbetweenNotesElements contain information on objects like clefs, keysignatures, etc
-#     within the score and how to process them
-
-#     Parameters
-#     ----------
-#     name:           string
-#         name of the element used in MEI
-#     attrib_names:    list of strings
-#         names of the attributes of the MEI element
-#     attrib_vals_of:   function
-#         a function that returns the attribute values of elem
-#     container_dict: dict of lists of partitura objects
-#         the container containing the required elements is at staff
-#     staff:          int
-#         staff number
-#     skip_index:      int
-#         init value for the cursor i (might skip 0)
-
-#     Attributes
-#     ----------
-#     name:           string
-#         name of the element used in MEI
-#     attrib_names:    list of strings
-#         names of the attributes of the MEI element
-#     elem:           instance of partitura object
-#     attrib_vals_of:   function
-#         a function that returns the attribute values of elem
-#     container:      list of partitura objects
-#         the container where elem gets its values from
-#     i:              int
-#         cursor that keeps track of position in container
-#     """
-
-#     __slots__ = ["name", "attrib_names", "attrib_vals_of", "container", "i", "elem"]
-
-#     def __init__(
-#         self, name, attrib_names, attrib_vals_of, container_dict, staff, skip_index
-#     ):
-#         self.name = name
-#         self.attrib_names = attrib_names
-#         self.attrib_vals_of = attrib_vals_of
-
-#         self.i = 0
-#         self.elem = None
-
-#         if staff in container_dict.keys():
-#             self.container = container_dict[staff]
-#             if len(self.container) > skip_index:
-#                 self.elem = self.container[skip_index]
-#                 self.i = skip_index
-#         else:
-#             self.container = []
-
-
-# def chord_rep(chords, chord_i):
-#     return chords[chord_i][0]
-
-
-# def handle_beam(open_up, parents):
-#     """
-#     Using a stack of MEI elements, opens and closes beams
-
-#     Parameters
-#     ----------
-#     open_up:     boolean
-#         flag that indicates whether to open or close recent beam
-#     parents:    list of etree.SubElement
-#         stack of MEI elements that contain the beam element
-
-#     Returns
-#     -------
-#     unchanged open_up value
-#     """
-#     if open_up:
-#         parents.append(add_child(parents[-1], "beam"))
-#     else:
-#         parents.pop()
-
-#     return open_up
-
-
-# def is_chord_in_tuplet(chord_i, tuplet_indices):
-#     """
-#     check if chord falls in the range of a tuplet
-
-#     Parameters
-#     ----------
-#     chord_i:        int
-#         index of chord within chords array
-#     tuplet_indices:  list of int pairs
-#         contains the index ranges of all the tuplets in a measure of a staff
-
-#     Returns
-#     -------
-#     whether chord falls in the range of a tuplet
-#     """
-#     for start, stop in tuplet_indices:
-#         if start <= chord_i and chord_i <= stop:
-#             return True
-
-#     return False
-
-
-# def calc_num_to_numbase_ratio(chord_i, chords, tuplet_indices):
-#     """
-#     calculates how to scale a notes duration with regard to the tuplet it is in
-
-#     Parameters
-#     ----------
-#     chord_i:        int
-#         index of chord within chords array
-#     chords:         list of list of score.GenericNote
-#         array of chords (which are lists of notes)
-#     tuplet_indices:  list of int pairs
-#         contains the index ranges of all the tuplets in a measure of a staff
-
-#     Returns
-#     -------
-#     the num to numbase ratio of a tuplet (eg. 3 in 2 tuplet is 1.5)
-#     """
-#     rep = chords[chord_i][0]
-#     if not isinstance(rep, score.GraceNote) and is_chord_in_tuplet(
-#         chord_i, tuplet_indices
-#     ):
-#         return (
-#             rep.symbolic_duration["actual_notes"]
-#             / rep.symbolic_duration["normal_notes"]
-#         )
-#     return 1
-
-
-# def process_chord(
-#     chord_i,
-#     chords,
-#     inbetween_notes_elements,
-#     open_beam,
-#     auto_beaming,
-#     parents,
-#     dur_dots,
-#     split_notes,
-#     first_temp_dur,
-#     tuplet_indices,
-#     ties,
-#     measure,
-#     layer,
-#     tuplet_id_counter,
-#     open_tuplet,
-#     last_key_sig,
-#     note_alterations,
-#     notes_next_measure_per_staff,
-#     next_dur_dots=None,
-# ):
-#     """
-#     creates <note>, <chord>, <rest>, etc elements from chords
-#     also creates <beam>, <tuplet>, etc elements if necessary for chords objects
-#     also creates <clef>, <keySig>, etc elements before chord objects from inbetween_notes_elements
-
-#     Parameters
-#     ----------
-#     chord_i:                    int
-#         index of chord within chords array
-#     chords:                     list of list of score.GenericNote
-#         chord array
-#     inbetween_notes_elements:     list of InbetweenNotesElements
-#         check this to see if something like clef needs to get inserted before chord
-#     open_beam:                   boolean
-#         flag that indicates whether a beam is currently open
-#     auto_beaming:                boolean
-#         flag that determines if automatic beams should be created or if it is kept manual
-#     parents:                    list of etree.SubElement
-#         stack of MEI elements that contain the most recent beam element
-#     dur_dots:                   list of int pairs
-#         describes how the chord actually gets notated via tied notes, each pair contains the duration of the notated note and its dot count
-#     split_notes:                 list
-#         this is either empty or None
-#         if None, nothing is done with this
-#         if an empty list, that means this chord crosses into the next measure and a chord is created for the next measure which is tied to this one
-#     first_temp_dur:               int
-#         amount of ticks (as in partitura) of the first notated note
-#     tuplet_indices:              list of int pairs
-#         the ranges of tuplets within the chords array
-#     ties:                       dict
-#         out parameter, contains pairs of IDs which need to be connected via ties
-#         this function also adds to that
-#     measure:                    score.Measure
-
-#     layer:                      etree.SubElement
-#         the parent element of the elements created here
-#     tuplet_id_counter:           int
-
-#     open_tuplet:                 boolean
-#         describes if a tuplet is open or not
-#     last_key_sig:                 score.KeySignature
-#         the key signature this chord should be interpeted in
-#     note_alterations:            dict
-#         contains the alterations of staff positions (notes) that are relevant for this chord
-#     notes_next_measure_per_staff: dict of lists of score.GenericNote
-#         out parameter, add the result of split_notes into this
-#     next_dur_dots:              list of int pairs, optional
-#         needed for proper beaming
-
-#     Returns
-#     -------
-#     tuplet_id_counter:    int
-#         incremented if tuplet created
-#     open_beam:           boolean
-#         eventually modified if beam opened or closed
-#     open_tuplet:         boolean
-#         eventually modified if tuplet opened or closed
-#     """
-
-#     chord_notes = chords[chord_i]
-#     rep = chord_notes[0]
-
-#     for ine in inbetween_notes_elements:
-#         if insert_elem_check(rep.start.t, [ine]):
-#             # note should maybe be split according to keysig or clef etc insertion time, right now only beaming is disrupted
-#             if open_beam and auto_beaming:
-#                 open_beam = handle_beam(False, parents)
-
-#             xml_elem = add_child(parents[-1], ine.name)
-#             attrib_vals = ine.attrib_vals_of(ine.elem)
-
-#             if ine.name == "keySig":
-#                 last_key_sig = ine.elem
-
-#             if len(ine.attrib_names) < len(attrib_vals):
-#                 raise ValueError(
-#                     "ERROR at insertion of inbetween_notes_elements: there are more attribute values than there are attribute names for xml element "
-#                     + ine.name
-#                 )
-
-#             for nv in zip(ine.attrib_names[: len(attrib_vals)], attrib_vals):
-#                 set_attributes(xml_elem, nv)
-
-#             if ine.i + 1 >= len(ine.container):
-#                 ine.elem = None
-#             else:
-#                 ine.i += 1
-#                 ine.elem = ine.container[ine.i]
-
-#     if is_chord_in_tuplet(chord_i, tuplet_indices):
-#         if not open_tuplet:
-#             parents.append(add_child(parents[-1], "tuplet"))
-#             num = rep.symbolic_duration["actual_notes"]
-#             numbase = rep.symbolic_duration["normal_notes"]
-#             set_attributes(
-#                 parents[-1],
-#                 (xml_id_string, "t" + str(tuplet_id_counter)),
-#                 ("num", num),
-#                 ("numbase", numbase),
-#             )
-#             tuplet_id_counter += 1
-#             open_tuplet = True
-#     elif open_tuplet:
-#         parents.pop()
-#         open_tuplet = False
-
-#     def set_dur_dots(elem, dur_dots):
-#         dur, dots = dur_dots
-#         set_attributes(elem, ("dur", dur))
-
-#         if dots > 0:
-#             set_attributes(elem, ("dots", dots))
-
-#     if isinstance(rep, score.Note):
-#         if auto_beaming:
-#             # for now all notes are beamed, however some rules should be obeyed there, see Note Beaming and Grouping
-
-#             # check to close beam
-#             if open_beam and (
-#                 dur_dots[0][0] < 8
-#                 or chord_i - 1 >= 0
-#                 and type(rep) != type(chord_rep(chords, chord_i - 1))
-#             ):
-#                 open_beam = handle_beam(False, parents)
-
-#             # check to open beam (maybe again)
-#             if not open_beam and dur_dots[0][0] >= 8:
-#                 # open beam if there are multiple "consecutive notes" which don't get interrupted by some element
-#                 if len(dur_dots) > 1 and not insert_elem_check(
-#                     rep.start.t + first_temp_dur, inbetween_notes_elements
-#                 ):
-#                     open_beam = handle_beam(True, parents)
-
-#                 # open beam if there is just a single note that is not the last one in measure and next note in measure is of same type and fits in beam as well, without getting interrupted by some element
-#                 elif (
-#                     len(dur_dots) <= 1
-#                     and chord_i + 1 < len(chords)
-#                     and next_dur_dots[0][0] >= 8
-#                     and type(rep) == type(chord_rep(chords, chord_i + 1))
-#                     and not insert_elem_check(
-#                         chord_rep(chords, chord_i + 1).start.t, inbetween_notes_elements
-#                     )
-#                 ):
-#                     open_beam = handle_beam(True, parents)
-#         elif (
-#             open_beam
-#             and chord_i > 0
-#             and rep.beam != chord_rep(chords, chord_i - 1).beam
-#         ):
-#             open_beam = handle_beam(False, parents)
-
-#         if not auto_beaming and not open_beam and rep.beam != None:
-#             open_beam = handle_beam(True, parents)
-
-#         def conditional_gracify(elem, rep, chord_i, chords):
-#             if isinstance(rep, score.GraceNote):
-#                 grace = "unacc"
-
-#                 if rep.grace_type == "appoggiatura":
-#                     grace = "acc"
-
-#                 set_attributes(elem, ("grace", grace))
-
-#                 if rep.steal_proportion != None:
-#                     set_attributes(
-#                         elem, ("grace.time", str(rep.steal_proportion * 100) + "%")
-#                     )
-
-#                 if chord_i == 0 or not isinstance(
-#                     chord_rep(chords, chord_i - 1), score.GraceNote
-#                 ):
-#                     chords[chord_i] = [copy(n) for n in chords[chord_i]]
-
-#                     for n in chords[chord_i]:
-#                         n.tie_next = n.main_note
-
-#         def create_note(parent, n, id, last_key_sig, note_alterations):
-#             note = add_child(parent, "note")
-
-#             step = n.step.lower()
-#             set_attributes(
-#                 note, (xml_id_string, id), ("pname", step), ("oct", n.octave)
-#             )
-
-#             if n.articulations != None and len(n.articulations) > 0:
-#                 artics = []
-
-#                 translation = {
-#                     "accent": "acc",
-#                     "staccato": "stacc",
-#                     "tenuto": "ten",
-#                     "staccatissimo": "stacciss",
-#                     "spiccato": "spicc",
-#                     "scoop": "scoop",
-#                     "plop": "plop",
-#                     "doit": "doit",
-#                 }
-
-#                 for a in n.articulations:
-#                     if a in translation.keys():
-#                         artics.append(translation[a])
-#                 set_attributes(note, ("artic", " ".join(artics)))
-
-#             sharps = ["f", "c", "g", "d", "a", "e", "b"]
-#             flats = list(reversed(sharps))
-
-#             staff_pos = step + str(n.octave)
-
-#             alter = n.alter or 0
-
-#             def set_accid(note, acc, note_alterations, staff_pos, alter):
-#                 if (
-#                     staff_pos in note_alterations.keys()
-#                     and alter == note_alterations[staff_pos]
-#                 ):
-#                     return
-#                 set_attributes(note, ("accid", acc))
-#                 note_alterations[staff_pos] = alter
-
-#             # sharpen note if: is sharp, is not sharpened by key or prev alt
-#             # flatten note if: is flat, is not flattened by key or prev alt
-#             # neutralize note if: is neutral, is sharpened/flattened by key or prev alt
-
-#             # check if note is sharpened/flattened by prev alt or key
-#             if (
-#                 staff_pos in note_alterations.keys()
-#                 and note_alterations[staff_pos] != 0
-#                 or last_key_sig.fifths > 0
-#                 and step in sharps[: last_key_sig.fifths]
-#                 or last_key_sig.fifths < 0
-#                 and step in flats[: -last_key_sig.fifths]
-#             ):
-#                 if alter == 0:
-#                     set_accid(note, "n", note_alterations, staff_pos, alter)
-#             elif alter > 0:
-#                 set_accid(note, "s", note_alterations, staff_pos, alter)
-#             elif alter < 0:
-#                 set_accid(note, "f", note_alterations, staff_pos, alter)
-
-#             return note
-
-#         if len(chord_notes) > 1:
-#             chord = add_child(parents[-1], "chord")
-
-#             set_dur_dots(chord, dur_dots[0])
-
-#             conditional_gracify(chord, rep, chord_i, chords)
-
-#             for n in chord_notes:
-#                 create_note(chord, n, n.id, last_key_sig, note_alterations)
-
-#         else:
-#             note = create_note(parents[-1], rep, rep.id, last_key_sig, note_alterations)
-#             set_dur_dots(note, dur_dots[0])
-
-#             conditional_gracify(note, rep, chord_i, chords)
-
-#         if len(dur_dots) > 1:
-#             for n in chord_notes:
-#                 ties[n.id] = [n.id]
-
-#             def create_split_up_notes(chord_notes, i, parents, dur_dots, ties, rep):
-#                 if len(chord_notes) > 1:
-#                     chord = add_child(parents[-1], "chord")
-#                     set_dur_dots(chord, dur_dots[i])
-
-#                     for n in chord_notes:
-#                         id = n.id + "-" + str(i)
-
-#                         ties[n.id].append(id)
-#                         create_note(chord, n, id, last_key_sig, note_alterations)
-#                 else:
-#                     id = rep.id + "-" + str(i)
-
-#                     ties[rep.id].append(id)
-
-#                     note = create_note(
-#                         parents[-1], rep, id, last_key_sig, note_alterations
-#                     )
-
-#                     set_dur_dots(note, dur_dots[i])
-
-#             for i in range(1, len(dur_dots) - 1):
-#                 if not open_beam and dur_dots[i][0] >= 8:
-#                     open_beam = handle_beam(True, parents)
-
-#                 create_split_up_notes(chord_notes, i, parents, dur_dots, ties, rep)
-
-#             create_split_up_notes(
-#                 chord_notes, len(dur_dots) - 1, parents, dur_dots, ties, rep
-#             )
-
-#         if split_notes != None:
-
-#             for n in chord_notes:
-#                 split_notes.append(score.Note(n.step, n.octave, id=n.id + "s"))
-
-#             if len(dur_dots) > 1:
-#                 for n in chord_notes:
-#                     ties[n.id].append(n.id + "s")
-#             else:
-#                 for n in chord_notes:
-#                     ties[n.id] = [n.id, n.id + "s"]
-
-#         for n in chord_notes:
-#             if n.tie_next != None:
-#                 if n.id in ties.keys():
-#                     ties[n.id].append(n.tie_next.id)
-#                 else:
-#                     ties[n.id] = [n.id, n.tie_next.id]
-
-#     elif isinstance(rep, score.Rest):
-#         if split_notes != None:
-#             split_notes.append(score.Rest(id=rep.id + "s"))
-
-#         if (
-#             measure == "pad"
-#             or measure.start.t == rep.start.t
-#             and measure.end.t == rep.end.t
-#         ):
-#             rest = add_child(layer, "mRest")
-
-#             set_attributes(rest, (xml_id_string, rep.id))
-#         else:
-#             rest = add_child(layer, "rest")
-
-#             set_attributes(rest, (xml_id_string, rep.id))
-
-#             set_dur_dots(rest, dur_dots[0])
-
-#             for i in range(1, len(dur_dots)):
-#                 rest = add_child(layer, "rest")
-
-#                 id = rep.id + str(i)
-
-#                 set_attributes(rest, (xml_id_string, id))
-#                 set_dur_dots(rest, dur_dots[i])
-
-#     if split_notes != None:
-#         for sn in split_notes:
-#             sn.voice = rep.voice
-#             sn.start = measure.end
-#             sn.end = score.TimePoint(rep.start.t + rep.duration)
-
-#             extend_key(notes_next_measure_per_staff, s, sn)
-
-#     return tuplet_id_counter, open_beam, open_tuplet
-
-
-# def create_score_def(measures, measure_i, parts, parent):
-#     """
-#     creates <score_def>
-
-#     Parameters
-#     ----------
-#     measures:   list of score.Measure
-#     measure_i:  int
-#         index of measure currently processed within measures
-#     parts:      list of score.Part
-#     parent:     etree.SubElement
-#         parent of <score_def>
-#     """
-#     reference_measures = vertical_slice(measures, measure_i)
-
-#     common_key_sig = common_signature(
-#         score.KeySignature, key_sig_eql, parts, reference_measures
-#     )
-#     common_time_sig = common_signature(
-#         score.TimeSignature, time_sig_eql, parts, reference_measures
-#     )
-
-#     score_def = None
-
-#     if common_key_sig != None or common_time_sig != None:
-#         score_def = add_child(parent, "scoreDef")
-
-#     if common_key_sig != None:
-#         fifths, mode, pname = attribs_of_key_sig(common_key_sig)
-
-#         set_attributes(
-#             score_def, ("key.sig", fifths), ("key.mode", mode), ("key.pname", pname)
-#         )
-
-#     if common_time_sig != None:
-#         set_attributes(
-#             score_def,
-#             ("meter.count", common_time_sig.beats),
-#             ("meter.unit", common_time_sig.beat_type),
-#         )
-
-#     return score_def
-
-
-# class MeasureContent:
-#     """
-#     Simply a bundle for all the data of a measure that needs to be processed for a MEI document
-
-#     Attributes
-#     ----------
-#     ties_per_staff:      dict of lists
-#     clefs_per_staff:     dict of lists
-#     key_sigs_per_staff:   dict of lists
-#     time_sigs_per_staff:  dict of lists
-#     measure_per_staff:   dict of lists
-#     tuplets_per_staff:   dict of lists
-#     slurs:              list
-#     dirs:               list
-#     dynams:             list
-#     tempii:             list
-#     fermatas:           list
-#     """
-
-#     __slots__ = [
-#         "ties_per_staff",
-#         "clefs_per_staff",
-#         "key_sigs_per_staff",
-#         "time_sigs_per_staff",
-#         "measure_per_staff",
-#         "tuplets_per_staff",
-#         "slurs",
-#         "dirs",
-#         "dynams",
-#         "tempii",
-#         "fermatas",
-#     ]
-
-#     def __init__(self):
-#         self.ties_per_staff = {}
-#         self.clefs_per_staff = {}
-#         self.key_sigs_per_staff = {}
-#         self.time_sigs_per_staff = {}
-#         self.measure_per_staff = {}
-#         self.tuplets_per_staff = {}
-
-#         self.slurs = []
-#         self.dirs = []
-#         self.dynams = []
-#         self.tempii = []
-#         self.fermatas = []
-
-
-# def extract_from_measures(
-#     parts,
-#     measures,
-#     measure_i,
-#     staves_per_part,
-#     auto_rest_count,
-#     notes_within_measure_per_staff,
-# ):
-#     """
-#     Returns a bundle of data regarding the measure currently processed, things like notes, key signatures, etc
-#     Also creates padding measures, necessary for example, for staves of instruments which do not play in the current measure
-
-#     Parameters
-#     ----------
-#     parts:                          list of score.Part
-#     measures:                       list of score.Measure
-#     measure_i:                      int
-#         index of current measure within measures
-#     staves_per_part:                 dict of list of ints
-#         staff enumeration partitioned by part
-#     auto_rest_count:                  int
-#         counter for the IDs of automatically generated rests
-#     notes_within_measure_per_staff:   dict of lists of score.GenericNote
-#         in and out parameter, might contain note objects that have crossed from previous measure into current one
-
-#     Returns
-#     -------
-#     auto_rest_count:                  int
-#         incremented if score.Rest created
-#     current_measure_content:          MeasureContent
-#         bundle for all the data that is extracted from the currently processed measure
-#     """
-#     current_measure_content = MeasureContent()
-
-#     for part_i, part in enumerate(parts):
-#         m = measures[part_i][measure_i]
-
-#         if m == "pad":
-#             for s in staves_per_part[part_i]:
-#                 auto_rest_count = pad_measure(
-#                     s,
-#                     current_measure_content.measure_per_staff,
-#                     notes_within_measure_per_staff,
-#                     auto_rest_count,
-#                 )
-
-#             continue
-
-#         def cls_within_measure(part, cls, measure, incl_subcls=False):
-#             return part.iter_all(
-#                 cls, measure.start, measure.end, include_subclasses=incl_subcls
-#             )
-
-#         def cls_within_measure_list(part, cls, measure, incl_subcls=False):
-#             return list(cls_within_measure(part, cls, measure, incl_subcls))
-
-#         clefs_within_measure_per_staff_per_part = partition_handle_none(
-#             lambda c: c.number, cls_within_measure(part, score.Clef, m), "number"
-#         )
-#         key_sigs_within_measure = cls_within_measure_list(part, score.KeySignature, m)
-#         time_sigs_within_measure = cls_within_measure_list(part, score.TimeSignature, m)
-#         current_measure_content.slurs.extend(cls_within_measure(part, score.Slur, m))
-#         tuplets_within_measure = cls_within_measure_list(part, score.Tuplet, m)
-
-#         beat_map = part.beat_map
-
-#         def calc_tstamp(beat_map, t, measure):
-#             return beat_map(t) - beat_map(measure.start.t) + 1
-
-#         for w in cls_within_measure(part, score.Words, m):
-#             tstamp = calc_tstamp(beat_map, w.start.t, m)
-#             current_measure_content.dirs.append((tstamp, w))
-
-#         for tempo in cls_within_measure(part, score.Tempo, m):
-#             tstamp = calc_tstamp(beat_map, tempo.start.t, m)
-#             current_measure_content.tempii.append(
-#                 (tstamp, staves_per_part[part_i][0], tempo)
-#             )
-
-#         for fermata in cls_within_measure(part, score.Fermata, m):
-#             tstamp = calc_tstamp(beat_map, fermata.start.t, m)
-#             current_measure_content.fermatas.append((tstamp, fermata.ref.staff))
-
-#         for dynam in cls_within_measure(part, score.Direction, m, True):
-#             tstamp = calc_tstamp(beat_map, dynam.start.t, m)
-#             tstamp2 = None
-
-#             if dynam.end != None:
-#                 measure_counter = measure_i
-#                 while True:
-#                     if dynam.end.t <= measures[part_i][measure_counter].end.t:
-#                         tstamp2 = calc_tstamp(
-#                             beat_map, dynam.end.t, measures[part_i][measure_counter]
-#                         )
-
-#                         tstamp2 = str(measure_counter - measure_i) + "m+" + str(tstamp2)
-
-#                         break
-#                     elif (
-#                         measure_counter + 1 >= len(measures[part_i])
-#                         or measures[part_i][measure_counter + 1] == "pad"
-#                     ):
-#                         raise ValueError(
-#                             "A score.Direction instance has an end time that exceeds actual non-padded measures"
-#                         )
-#                     else:
-#                         measure_counter += 1
-
-#             current_measure_content.dynams.append((tstamp, tstamp2, dynam))
-
-#         notes_within_measure_per_staff_per_part = partition_handle_none(
-#             lambda n: n.staff,
-#             cls_within_measure(part, score.GenericNote, m, True),
-#             "staff",
-#         )
-
-#         for s in staves_per_part[part_i]:
-#             current_measure_content.key_sigs_per_staff[s] = key_sigs_within_measure
-#             current_measure_content.time_sigs_per_staff[s] = time_sigs_within_measure
-#             current_measure_content.tuplets_per_staff[s] = tuplets_within_measure
-
-#             if s not in notes_within_measure_per_staff_per_part.keys():
-#                 auto_rest_count = pad_measure(
-#                     s,
-#                     current_measure_content.measure_per_staff,
-#                     notes_within_measure_per_staff,
-#                     auto_rest_count,
-#                 )
-
-#         for s, nwp in notes_within_measure_per_staff_per_part.items():
-#             extend_key(notes_within_measure_per_staff, s, nwp)
-#             current_measure_content.measure_per_staff[s] = m
-
-#         for s, cwp in clefs_within_measure_per_staff_per_part.items():
-#             current_measure_content.clefs_per_staff[s] = cwp
-
-#     return auto_rest_count, current_measure_content
-
-
-# def create_measure(
-#     section,
-#     measure_i,
-#     staves_sorted,
-#     notes_within_measure_per_staff,
-#     score_def,
-#     tuplet_id_counter,
-#     auto_beaming,
-#     last_key_sig_per_staff,
-#     current_measure_content,
-# ):
-#     """
-#     creates a <measure> element within <section>
-#     also returns an updated id counter for tuplets and a dictionary of notes that cross into the next measure
-
-#     Parameters
-#     ----------
-#     section:                        etree.SubElement
-#     measure_i:                      int
-#         index of the measure created
-#     staves_sorted:                  list of ints
-#         a sorted list of the proper staff enumeration of the score
-#     notes_within_measure_per_staff:   dict of lists of score.GenericNote
-#         contains score.Note, score.Rest, etc objects of the current measure, partitioned by staff enumeration
-#         will be further partitioned and sorted by voice, time and type (score.GraceNote) and eventually gathered into
-#         a list of equivalence classes called chords
-#     score_def:                       etree.SubElement
-#     tuplet_id_counter:               int
-#         tuplets usually don't come with IDs, so an automatic counter takes care of that
-#     auto_beaming:                    boolean
-#         enables automatic beaming
-#     last_key_sig_per_staff:            dict of score.KeySignature
-#         keeps track of the keysignature each staff is currently in
-#     current_measure_content:          MeasureContent
-#         contains all sorts of data for the measure like tuplets, slurs, etc
-
-#     Returns
-#     -------
-#     tuplet_id_counter:               int
-#         incremented if tuplet created
-#     notes_next_measure_per_staff:     dict of lists of score.GenericNote
-#         score.GenericNote objects that cross into the next measure
-#     """
-#     measure = add_child(section, "measure")
-#     set_attributes(measure, ("n", measure_i + 1))
-
-#     ties_per_staff = {}
-
-#     for s in staves_sorted:
-#         note_alterations = {}
-
-#         staff = add_child(measure, "staff")
-
-#         set_attributes(staff, ("n", s))
-
-#         notes_within_measure_per_staff_per_voice = partition_handle_none(
-#             lambda n: n.voice, notes_within_measure_per_staff[s], "voice"
-#         )
-
-#         ties_per_staff_per_voice = {}
-
-#         m = current_measure_content.measure_per_staff[s]
-
-#         tuplets = []
-#         if s in current_measure_content.tuplets_per_staff.keys():
-#             tuplets = current_measure_content.tuplets_per_staff[s]
-
-#         last_key_sig = last_key_sig_per_staff[s]
-
-#         for voice, notes in notes_within_measure_per_staff_per_voice.items():
-#             layer = add_child(staff, "layer")
-
-#             set_attributes(layer, ("n", voice))
-
-#             ties = {}
-
-#             notes_partition = partition_handle_none(
-#                 lambda n: n.start.t, notes, "start.t"
-#             )
-
-#             chords = []
-
-#             for t in sorted(notes_partition.keys()):
-#                 ns = notes_partition[t]
-
-#                 if len(ns) > 1:
-#                     type_partition = partition_handle_none(
-#                         lambda n: isinstance(n, score.GraceNote), ns, "isGraceNote"
-#                     )
-
-#                     if True in type_partition.keys():
-#                         gns = type_partition[True]
-
-#                         gn_chords = []
-
-#                         def scan_backwards(gns):
-#                             start = gns[0]
-
-#                             while isinstance(start.grace_prev, score.GraceNote):
-#                                 start = start.grace_prev
-
-#                             return start
-
-#                         start = scan_backwards(gns)
-
-#                         def process_grace_note(n, gns):
-#                             if not n in gns:
-#                                 raise ValueError(
-#                                     "Error at forward scan of GraceNotes: a grace_next has either different staff, voice or starting time than GraceNote chain"
-#                                 )
-#                             gns.remove(n)
-#                             return n.grace_next
-
-#                         while isinstance(start, score.GraceNote):
-#                             gn_chords.append([start])
-#                             start = process_grace_note(start, gns)
-
-#                         while len(gns) > 0:
-#                             start = scan_backwards(gns)
-
-#                             i = 0
-#                             while isinstance(start, score.GraceNote):
-#                                 if i >= len(gn_chords):
-#                                     raise IndexError(
-#                                         "ERROR at GraceNote-forward scanning: Difference in lengths of grace note sequences for different chord notes"
-#                                     )
-#                                 gn_chords[i].append(start)
-#                                 start = process_grace_note(start, gns)
-#                                 i += 1
-
-#                             if not i == len(gn_chords):
-#                                 raise IndexError(
-#                                     "ERROR at GraceNote-forward scanning: Difference in lengths of grace note sequences for different chord notes"
-#                                 )
-
-#                         for gnc in gn_chords:
-#                             chords.append(gnc)
-
-#                     if not False in type_partition.keys():
-#                         raise KeyError(
-#                             "ERROR at ChordNotes-grouping: GraceNotes detected without additional regular Notes at same time; staff "
-#                             + str(s)
-#                         )
-
-#                     reg_notes = type_partition[False]
-
-#                     rep = reg_notes[0]
-
-#                     for i in range(1, len(reg_notes)):
-#                         n = reg_notes[i]
-
-#                         if n.duration != rep.duration:
-#                             raise ValueError(
-#                                 "In staff " + str(s) + ",",
-#                                 "in measure " + str(m.number) + ",",
-#                                 "for voice " + str(voice) + ",",
-#                                 "2 notes start at time " + str(n.start.t) + ",",
-#                                 "but have different durations, namely "
-#                                 + n.id
-#                                 + " has duration "
-#                                 + str(n.duration)
-#                                 + " and "
-#                                 + rep.id
-#                                 + " has duration "
-#                                 + str(rep.duration),
-#                                 "change to same duration for a chord or change voice of one of the notes for something else",
-#                             )
-#                         # HACK: unpitched notes are treated as Rests right now
-#                         elif not isinstance(rep, score.Rest) and not isinstance(
-#                             n, score.Rest
-#                         ):
-#                             if rep.beam != n.beam:
-#                                 print(
-#                                     "WARNING: notes within chords don't share the same beam",
-#                                     "specifically note "
-#                                     + str(rep)
-#                                     + " has beam "
-#                                     + str(rep.beam),
-#                                     "and note " + str(n) + " has beam " + str(n.beam),
-#                                     "export still continues though",
-#                                 )
-#                             elif set(rep.tuplet_starts) != set(n.tuplet_starts) and set(
-#                                 rep.tuplet_stops
-#                             ) != set(n.tuplet_stops):
-#                                 print(
-#                                     "WARNING: notes within chords don't share same tuplets, export still continues though"
-#                                 )
-#                     chords.append(reg_notes)
-#                 else:
-#                     chords.append(ns)
-
-#             tuplet_indices = []
-#             for tuplet in tuplets:
-#                 ci = 0
-#                 start = -1
-#                 stop = -1
-#                 while ci < len(chords):
-#                     for n in chords[ci]:
-#                         if tuplet in n.tuplet_starts:
-#                             start = ci
-#                             break
-#                     for n in chords[ci]:
-#                         if tuplet in n.tuplet_stops:
-#                             stop = ci
-#                             break
-
-#                     if start >= 0 and stop >= 0:
-#                         if not start <= stop:
-#                             raise ValueError(
-#                                 "In measure " + str(measure_i + 1) + ",",
-#                                 "in staff " + str(s) + ",",
-#                                 "[" + str(tuplet) + "] stops before it starts?",
-#                                 "start=" + str(start + 1) + "; stop=" + str(stop + 1),
-#                             )
-#                         tuplet_indices.append((start, stop))
-#                         break
-
-#                     ci += 1
-
-#             parents = [layer]
-#             open_beam = False
-
-#             (
-#                 next_dur_dots,
-#                 next_split_notes,
-#                 next_first_temp_dur,
-#             ) = calc_dur_dots_split_notes_first_temp_dur(
-#                 chords[0][0], m, calc_num_to_numbase_ratio(0, chords, tuplet_indices)
-#             )
-
-#             inbetween_notes_elements = [
-#                 InbetweenNotesElement(
-#                     "clef",
-#                     ["shape", "line", "dis", "dis.place"],
-#                     attribs_of_clef,
-#                     current_measure_content.clefs_per_staff,
-#                     s,
-#                     int(measure_i == 0),
-#                 ),
-#                 InbetweenNotesElement(
-#                     "keySig",
-#                     ["sig", "mode", "pname", "sig.showchange"],
-#                     (lambda ks: attribs_of_key_sig(ks) + ("true",)),
-#                     current_measure_content.key_sigs_per_staff,
-#                     s,
-#                     int(score_def != None),
-#                 ),
-#                 InbetweenNotesElement(
-#                     "meterSig",
-#                     ["count", "unit"],
-#                     lambda ts: (ts.beats, ts.beat_type),
-#                     current_measure_content.time_sigs_per_staff,
-#                     s,
-#                     int(score_def != None),
-#                 ),
-#             ]
-
-#             open_tuplet = False
-
-#             notes_next_measure_per_staff = {}
-
-#             for chord_i in range(len(chords) - 1):
-#                 dur_dots, split_notes, first_temp_dur = (
-#                     next_dur_dots,
-#                     next_split_notes,
-#                     next_first_temp_dur,
-#                 )
-#                 (
-#                     next_dur_dots,
-#                     next_split_notes,
-#                     next_first_temp_dur,
-#                 ) = calc_dur_dots_split_notes_first_temp_dur(
-#                     chord_rep(chords, chord_i + 1),
-#                     m,
-#                     calc_num_to_numbase_ratio(chord_i + 1, chords, tuplet_indices),
-#                 )
-#                 tuplet_id_counter, open_beam, open_tuplet = process_chord(
-#                     chord_i,
-#                     chords,
-#                     inbetween_notes_elements,
-#                     open_beam,
-#                     auto_beaming,
-#                     parents,
-#                     dur_dots,
-#                     split_notes,
-#                     first_temp_dur,
-#                     tuplet_indices,
-#                     ties,
-#                     m,
-#                     layer,
-#                     tuplet_id_counter,
-#                     open_tuplet,
-#                     last_key_sig,
-#                     note_alterations,
-#                     notes_next_measure_per_staff,
-#                     next_dur_dots,
-#                 )
-
-#             tuplet_id_counter, _, _ = process_chord(
-#                 len(chords) - 1,
-#                 chords,
-#                 inbetween_notes_elements,
-#                 open_beam,
-#                 auto_beaming,
-#                 parents,
-#                 next_dur_dots,
-#                 next_split_notes,
-#                 next_first_temp_dur,
-#                 tuplet_indices,
-#                 ties,
-#                 m,
-#                 layer,
-#                 tuplet_id_counter,
-#                 open_tuplet,
-#                 last_key_sig,
-#                 note_alterations,
-#                 notes_next_measure_per_staff,
-#             )
-
-#             ties_per_staff_per_voice[voice] = ties
-
-#         ties_per_staff[s] = ties_per_staff_per_voice
-
-#     for fermata in current_measure_content.fermatas:
-#         tstamp = fermata[0]
-#         fermata_staff = fermata[1]
-
-#         f = add_child(measure, "fermata")
-#         set_attributes(f, ("staff", fermata_staff), ("tstamp", tstamp))
-
-#     for slur in current_measure_content.slurs:
-#         s = add_child(measure, "slur")
-#         if slur.start_note == None or slur.end_note == None:
-#             raise ValueError("Slur is missing start or end")
-#         set_attributes(
-#             s,
-#             ("staff", slur.start_note.staff),
-#             ("startid", "#" + slur.start_note.id),
-#             ("endid", "#" + slur.end_note.id),
-#         )
-
-#     for tstamp, word in current_measure_content.dirs:
-#         d = add_child(measure, "dir")
-#         set_attributes(d, ("staff", word.staff), ("tstamp", tstamp))
-#         d.text = word.text
-
-#     # smufl individual notes start with E1
-#     # these are the last 2 digits of the codes
-#     metronome_codes = {
-#         "breve": "D0",
-#         "whole": "D2",
-#         "half": "D3",
-#         "h": "D3",
-#         "quarter": "D5",
-#         "q": "D5",
-#         "eighth": "D7",
-#         "e": "D5",
-#         "16th": "D9",
-#         "32nd": "DB",
-#         "64th": "DD",
-#         "128th": "DF",
-#         "256th": "E1",
-#     }
-
-#     for tstamp, staff, tempo in current_measure_content.tempii:
-#         t = add_child(measure, "tempo")
-#         set_attributes(t, ("staff", staff), ("tstamp", tstamp))
-
-#         unit = str(tempo.unit)
-
-#         dots = unit.count(".")
-
-#         unit = unit[:-dots]
-
-#         string_to_build = [
-#             ' <rend fontname="VerovioText">&#xE1',
-#             metronome_codes[unit or "q"],
-#             ";",
-#         ]
-
-#         for i in range(dots):
-#             string_to_build.append("&#xE1E7;")
-
-#         string_to_build.append("</rend> = ")
-#         string_to_build.append(str(tempo.bpm))
-
-#         t.text = "".join(string_to_build)
-
-#     for tstamp, tstamp2, dynam in current_measure_content.dynams:
-#         if isinstance(dynam, score.DynamicLoudnessDirection):
-#             d = add_child(measure, "hairpin")
-#             form = (
-#                 "cres"
-#                 if isinstance(dynam, score.IncreasingLoudnessDirection)
-#                 else "dim"
-#             )
-#             set_attributes(d, ("form", form))
-
-#             # duration can also matter for other dynamics, might want to move this out of branch
-#             if tstamp2 != None:
-#                 set_attributes(d, ("tstamp2", tstamp2))
-#         else:
-#             d = add_child(measure, "dynam")
-#             d.text = dynam.text
-
-#         set_attributes(d, ("staff", dynam.staff), ("tstamp", tstamp))
-
-#     for s, tps in ties_per_staff.items():
-
-#         for v, tpspv in tps.items():
-
-#             for ties in tpspv.values():
-
-#                 for i in range(len(ties) - 1):
-#                     tie = add_child(measure, "tie")
-
-#                     set_attributes(
-#                         tie,
-#                         ("staff", s),
-#                         ("startid", "#" + ties[i]),
-#                         ("endid", "#" + ties[i + 1]),
-#                     )
-
-#     for s, k in current_measure_content.key_sigs_per_staff.items():
-#         if len(k) > 0:
-#             last_key_sig_per_staff[s] = max(k, key=lambda k: k.start.t)
-
-#     return tuplet_id_counter, notes_next_measure_per_staff
-
-
-# def unpack_part_group(part_grp, parts=[]):
-#     """
-#     Recursively gather individual parts into a list, flattening the tree of parts so to say
-
-#     Parameters
-#     ----------
-#     part_grp:    score.PartGroup
-#     parts:      list of score.Part, optional
-
-#     Returns
-#     -------
-#     parts:      list of score.Part
-#     """
-#     for c in part_grp.children:
-#         if isinstance(c, score.PartGroup):
-#             unpack_part_group(c, parts)
-#         else:
-#             parts.append(c)
-
-#     return parts
-
-
-# def save_mei(
-#     parts,
-#     auto_beaming=True,
-#     file_name="testResult",
-#     title_text=None,
-#     proper_staff_grp=False,
-# ):
-#     """
-#     creates an MEI document based on the parts provided
-#     So far only <score> is used and not <part> which means all the parts are gathered in one whole score and
-#     no individual scores are defined for individual parts
-
-#     Parameters
-#     ----------
-#     parts:              score.Part, score.PartGroup or list of score.Part
-#     auto_beaming:       boolean, optional
-#         if all beaming has been done manually then set to False
-#         otherwise this flag can be used to enable automatic beaming (beaming rules are still in progess)
-#     file_name:          string, optional
-#         should not contain file extension, .mei will be added automatically
-#     title_text:         string, optional
-#         name of the piece, e.g. "Klaviersonate Nr. 14" or "WAP"
-#         if not provided, a title will be derived from file_name
-#     proper_staff_grp:   boolean, optional
-#         if true,    group staves per part
-#         else        group all staves together
-#         default is false because Verovio doesn't seem to render multiple staff groups correctly (but that just might be because multiple staff groups are not generated correctly in this function)
-#     """
-
-#     if isinstance(parts, score.PartGroup):
-#         parts = unpack_part_group(parts)
-#     elif isinstance(parts, score.Part):
-#         parts = [parts]
-
-#     for p in parts:
-#         score.sanitize_part(p)
-
-#     mei = etree.Element("mei")
-
-#     mei_head = add_child(mei, "meiHead")
-#     music = add_child(mei, "music")
-
-#     mei_head.set("xmlns", name_space)
-#     file_desc = add_child(mei_head, "fileDesc")
-#     title_stmt = add_child(file_desc, "titleStmt")
-#     pub_stmt = add_child(file_desc, "pubStmt")
-#     title = add_child(title_stmt, "title")
-#     title.set("type", "main")
-
-#     # derive a title for the piece from the file_name
-#     if title_text == None:
-#         cursor = len(file_name) - 1
-#         while cursor >= 0 and file_name[cursor] != "/":
-#             cursor -= 1
-
-#         tmp = file_name[cursor + 1 :].split("_")
-#         tmp = [s[:1].upper() + s[1:] for s in tmp]
-#         title.text = " ".join(tmp)
-#     else:
-#         title.text = title_text
-
-#     body = add_child(music, "body")
-#     mdiv = add_child(body, "mdiv")
-#     mei_score = add_child(mdiv, "score")
-
-#     classes_with_staff = [score.GenericNote, score.Words, score.Direction]
-
-#     staves_per_part = []
-
-#     staves_are_valid = True
-
-#     for p in parts:
-#         tmp = {
-#             staffed_obj.staff
-#             for cls in classes_with_staff
-#             for staffed_obj in p.iter_all(cls, include_subclasses=True)
-#         }
-#         tmp = tmp.union({clef.number for clef in p.iter_all(score.Clef)})
-#         staves_per_part.append(list(tmp))
-
-#         if None in staves_per_part[-1]:
-#             staves_are_valid = False
-#             staves_per_part[-1].remove(None)
-
-#             staves_per_part[-1].append(
-#                 (max(staves_per_part[-1]) if len(staves_per_part[-1]) > 0 else 0) + 1
-#             )
-
-#         staves_per_part[-1].sort()
-
-#     if staves_are_valid:
-#         staves_sorted = sorted([s for staves in staves_per_part for s in staves])
-
-#         i = 0
-
-#         while i + 1 < len(staves_sorted):
-#             if staves_sorted[i] == staves_sorted[i + 1]:
-#                 staves_are_valid = False
-#                 break
-
-#             i += 1
-
-#     if not staves_are_valid:
-#         staves_per_part_backup = staves_per_part
-
-#         staves_sorted = []
-#         staves_per_part = []
-
-#         # ASSUMPTION: staves are >0
-#         max_staff = 0
-#         for staves in staves_per_part_backup:
-#             if len(staves) == 0:
-#                 staves_per_part.append([])
-#             else:
-#                 shift = [s + max_staff for s in staves]
-
-#                 max_staff += max(staves)
-
-#                 staves_sorted.extend(shift)
-#                 staves_per_part.append(shift)
-
-#         # staves_sorted.sort()
-
-#         max_staff = 0
-#         for i, p in enumerate(parts):
-#             for cls in classes_with_staff:
-#                 for staff_obj in p.iter_all(cls, include_subclasses=True):
-#                     staff_obj.staff = max_staff + (
-#                         staff_obj.staff
-#                         if staff_obj.staff != None
-#                         else max(staves_per_part_backup[i])
-#                     )
-
-#             for clef in p.iter_all(score.Clef):
-#                 clef.number = max_staff + (
-#                     clef.number
-#                     if clef.number != None
-#                     else max(staves_per_part_backup[i])
-#                 )
-
-#             max_staff += (
-#                 max(staves_per_part_backup[i])
-#                 if len(staves_per_part_backup[i]) > 0
-#                 else 0
-#             )
-
-#     measures = [list(parts[0].iter_all(score.Measure))]
-#     padding_required = False
-#     max_length = len(measures[0])
-#     for i in range(1, len(parts)):
-#         m = list(parts[i].iter_all(score.Measure))
-
-#         if len(m) > max_length:
-#             max_length = len(m)
-
-#         if not padding_required:
-#             padding_required = len(m) != len(measures[0])
-
-#         measures.append(m)
-
-#     score_def = create_score_def(measures, 0, parts, mei_score)
-
-#     score_def_setup = score_def
-
-#     if score_def == None:
-#         score_def_setup = add_child(mei_score, "scoreDef")
-
-#     clefs_per_part = first_instances_per_part(score.Clef, parts)
-
-#     for i in idx(clefs_per_part):
-#         clefs_per_part[i] = partition_handle_none(
-#             lambda c: c.number, clefs_per_part[i], "number"
-#         )
-
-#     if len(clefs_per_part) == 0:
-#         create_staff_def(
-#             staff_grp, score.Clef(sign="G", line=2, number=1, octave_change=0)
-#         )
-#     else:
-#         staff_grp = add_child(score_def_setup, "staffGrp")
-#         for staves in staves_per_part:
-#             if proper_staff_grp:
-#                 staff_grp = add_child(score_def_setup, "staffGrp")
-
-#             for s in staves:
-#                 clefs = None
-
-#                 for clefs_per_staff in clefs_per_part:
-#                     if s in clefs_per_staff.keys():
-#                         clefs = clefs_per_staff[s]
-#                         break
-
-#                 if clefs != None:
-#                     clef = clefs[0]
-#                     if len(clefs) != 1:
-#                         raise ValueError(
-#                             "ERROR at staff_def creation: Staff "
-#                             + str(clef.number)
-#                             + " starts with more than 1 clef at t=0"
-#                         )
-#                     create_staff_def(staff_grp, clef)
-#                 else:
-#                     create_staff_def(
-#                         staff_grp,
-#                         score.Clef(sign="G", line=2, number=s, octave_change=0),
-#                     )
-
-#     section = add_child(mei_score, "section")
-
-#     measures_are_aligned = True
-#     if padding_required:
-#         cursors = [0] * len(measures)
-#         tempii = [None] * len(measures)
-
-#         while measures_are_aligned:
-#             compare_measures = {}
-#             for i, m in enumerate(measures):
-#                 if cursors[i] < len(m):
-#                     compare_measures[i] = m[cursors[i]]
-#                     cursors[i] += 1
-
-#             if len(compare_measures) == 0:
-#                 break
-
-#             compm_keys = list(compare_measures.keys())
-
-#             new_tempii = first_instance_per_part(
-#                 score.Tempo,
-#                 [p for i, p in enumerate(parts) if i in compm_keys],
-#                 start=[cm.start for cm in compare_measures.values()],
-#                 end=[cm.end for cm in compare_measures.values()],
-#             )
-
-#             if len(new_tempii) == 0:
-#                 for k in compm_keys:
-#                     new_tempii.append(tempii[k])
-#             else:
-#                 for i, nt in enumerate(new_tempii):
-#                     if nt == None:
-#                         new_tempii[i] = tempii[compm_keys[i]]
-#                     else:
-#                         tempii[compm_keys[i]] = nt
-
-#             def norm_dur(m):
-#                 return (m.end.t - m.start.t) // m.start.quarter
-
-#             rep_i = 0
-#             while rep_i < len(new_tempii) and new_tempii[rep_i] == None:
-#                 rep_i += 1
-
-#             if rep_i == len(new_tempii):
-#                 continue
-
-#             rep_dur = (
-#                 norm_dur(compare_measures[compm_keys[rep_i]]) * new_tempii[rep_i].bpm
-#             )
-
-#             for i in range(rep_i + 1, len(compm_keys)):
-#                 nt = new_tempii[i]
-
-#                 if nt == None:
-#                     continue
-
-#                 m = compare_measures[compm_keys[i]]
-#                 dur = norm_dur(m) * new_tempii[i].bpm
-
-#                 if dur != rep_dur:
-#                     measures_are_aligned = False
-#                     break
-
-#     tuplet_id_counter = 0
-
-#     if measures_are_aligned:
-#         time_offset = [0] * len(measures)
-
-#         if padding_required:
-#             for i, mp in enumerate(measures):
-#                 ii = len(mp)
-#                 time_offset[i] = mp[ii - 1].end.t
-#                 while ii < max_length:
-#                     mp.append("pad")
-#                     ii += 1
-
-#         notes_last_measure_per_staff = {}
-#         auto_rest_count = 0
-
-#         notes_within_measure_per_staff = notes_last_measure_per_staff
-
-#         auto_rest_count, current_measure_content = extract_from_measures(
-#             parts,
-#             measures,
-#             0,
-#             staves_per_part,
-#             auto_rest_count,
-#             notes_within_measure_per_staff,
-#         )
-
-#         last_key_sig_per_staff = {}
-
-#         for s, k in current_measure_content.key_sigs_per_staff.items():
-#             last_key_sig_per_staff[s] = (
-#                 min(k, key=lambda k: k.start.t) if len(k) > 0 else None
-#             )
-
-#         tuplet_id_counter, notes_last_measure_per_staff = create_measure(
-#             section,
-#             0,
-#             staves_sorted,
-#             notes_within_measure_per_staff,
-#             score_def,
-#             tuplet_id_counter,
-#             auto_beaming,
-#             last_key_sig_per_staff,
-#             current_measure_content,
-#         )
-
-#         for measure_i in range(1, len(measures[0])):
-#             notes_within_measure_per_staff = notes_last_measure_per_staff
-
-#             auto_rest_count, current_measure_content = extract_from_measures(
-#                 parts,
-#                 measures,
-#                 measure_i,
-#                 staves_per_part,
-#                 auto_rest_count,
-#                 notes_within_measure_per_staff,
-#             )
-
-#             score_def = create_score_def(measures, measure_i, parts, section)
-
-#             tuplet_id_counter, notes_last_measure_per_staff = create_measure(
-#                 section,
-#                 measure_i,
-#                 staves_sorted,
-#                 notes_within_measure_per_staff,
-#                 score_def,
-#                 tuplet_id_counter,
-#                 auto_beaming,
-#                 last_key_sig_per_staff,
-#                 current_measure_content,
-#             )
-
-#     (etree.ElementTree(mei)).write(file_name + ".mei", pretty_print=True)
-
-#     # post processing step necessary
-#     # etree won't write <,> and & into an element's text
-#     with open(file_name + ".mei") as result:
-#         text = list(result.read())
-#         new_text = []
-
-#         i = 0
-#         while i < len(text):
-#             ch = text[i]
-#             if ch == "&":
-#                 if text[i + 1 : i + 4] == ["l", "t", ";"]:
-#                     ch = "<"
-#                     i += 4
-#                 elif text[i + 1 : i + 4] == ["g", "t", ";"]:
-#                     ch = ">"
-#                     i += 4
-#                 elif text[i + 1 : i + 5] == ["a", "m", "p", ";"]:
-#                     i += 5
-#                 else:
-#                     i += 1
-#             else:
-#                 i += 1
-
-#             new_text.append(ch)
-
-#         new_text = "".join(new_text)
-
-#     with open(file_name + ".mei", "w") as result:
-#         result.write(new_text)
+# import partitura
+# import partitura.score as score
+# from lxml import etree
+# from partitura.utils.generic import partition
+# from partitura.utils.music import estimate_symbolic_duration
+# from copy import copy
+
+
+# name_space = "http://www.music-encoding.org/ns/mei"
+
+# xml_id_string = "{http://www.w3.org/XML/1998/namespace}id"
+
+
+# def extend_key(dict_of_lists, key, value):
+#     """extend or create a list at the given key in the given dictionary
+
+#     Parameters
+#     ----------
+#     dict_of_lists:    dictionary
+#         where all values are lists
+#     key:            self explanatory
+#     value:          self explanatory
+
+#     """
+
+#     if key in dict_of_lists.keys():
+#         if isinstance(value, list):
+#             dict_of_lists[key].extend(value)
+#         else:
+#             dict_of_lists[key].append(value)
+#     else:
+#         dict_of_lists[key] = value if isinstance(value, list) else [value]
+
+
+# def calc_dur_dots_split_notes_first_temp_dur(note, measure, num_to_numbase_ratio=1):
+#     """
+#     Notes have to be represented as a string of elemental notes (there is no notation for arbitrary durations)
+#     This function calculates this string (the durations of the elemental notes and their dot counts),
+#     whether the note crosses the measure and the temporal duration of the first elemental note
+
+#     Parameters
+#     ----------
+#     note:               score.GenericNote
+#         The note whose representation as a string of elemental notes is calculated
+#     measure:            score.Measure
+#         The measure which contains note
+#     num_to_numbase_ratio: float, optional
+#         scales the duration of note according to whether or not it belongs to a tuplet and which one
+
+
+#     Returns
+#     -------
+#     dur_dots:       list of int pairs
+#         this describes the string of elemental notes that represent the note notationally
+#         every pair in the list contains the duration and the dot count of an elemental note and
+#         the list is ordered by duration in decreasing order
+#     split_notes:     list or None
+#         an empty list if note crosses measure
+#         None if it doesn't
+#     first_temp_dur:   int or None
+#         duration of first elemental note in partitura time
+#     """
+
+#     if measure == "pad":
+#         return [], None, None
+
+#     if isinstance(note, score.GraceNote):
+#         main_note = note.main_note
+#         # HACK: main note should actually be always not None for a proper GraceNote
+#         if main_note != None:
+#             dur_dots, _, _ = calc_dur_dots_split_notes_first_temp_dur(
+#                 main_note, measure
+#             )
+#             dur_dots = [(2 * dur_dots[0][0], dur_dots[0][1])]
+#         else:
+#             dur_dots = [(8, 0)]
+#             note.id += "_missing_main_note"
+#         return dur_dots, None, None
+
+#     note_duration = note.duration
+
+#     split_notes = None
+
+#     if note.start.t + note.duration > measure.end.t:
+#         note_duration = measure.end.t - note.start.t
+#         split_notes = []
+
+#     quarter_dur = measure.start.quarter
+#     fraction = num_to_numbase_ratio * note_duration / quarter_dur
+
+#     int_part = int(fraction)
+#     frac_part = fraction - int_part
+
+#     # calc digits of fraction in base2
+#     untied_durations = []
+#     pow_of_2 = 1
+
+#     while int_part > 0:
+#         bit = int_part % 2
+#         untied_durations.insert(0, bit * pow_of_2)
+#         int_part = int_part // 2
+#         pow_of_2 *= 2
+
+#     pow_of_2 = 1 / 2
+
+#     while frac_part > 0:
+#         frac_part *= 2
+#         bit = int(frac_part)
+#         frac_part -= bit
+#         untied_durations.append(bit * pow_of_2)
+#         pow_of_2 /= 2
+
+#     dur_dots = []
+
+#     curr_dur = 0
+#     curr_dots = 0
+
+#     def add_dd(dur_dots, dur, dots):
+#         dur_dots.append((int(4 / dur), dots))
+
+#     for untied_dur in untied_durations:
+#         if curr_dur != 0:
+#             if untied_dur == 0:
+#                 add_dd(dur_dots, curr_dur, curr_dots)
+#                 curr_dots = 0
+#                 curr_dur = 0
+#             else:
+#                 curr_dots += 1
+#         else:
+#             curr_dur = untied_dur
+
+#     if curr_dur != 0:
+#         add_dd(dur_dots, curr_dur, curr_dots)
+
+#     first_temp_dur = int(untied_durations[0] * quarter_dur)
+
+#     return dur_dots, split_notes, first_temp_dur
+
+
+# def insert_elem_check(t, inbetween_notes_elems):
+#     """Check if something like a clef etc appears before time t
+
+#     Parameters
+#     ----------
+#     t:                      int
+#         time from a Timepoint
+#     inbetween_notes_elems:    list of InbetweenNotesElements
+#         a list of objects describing things like clefs etc
+
+#     Returns
+#     -------
+#     True if something like a clef etc appears before time t
+#     """
+
+#     for ine in inbetween_notes_elems:
+#         if ine.elem != None and ine.elem.start.t <= t:
+#             return True
+
+#     return False
+
+
+# def partition_handle_none(func, iter, partition_attrib):
+#     p = partition(func, iter)
+#     newKey = None
+
+#     if None in p.keys():
+#         raise KeyError(
+#             'PARTITION ERROR: some elements of set do not have partition attribute "'
+#             + partition_attrib
+#             + '"'
+#         )
+
+#     return p
+
+
+# def add_child(parent, child_name):
+#     return etree.SubElement(parent, child_name)
+
+
+# def set_attributes(elem, *list_attrib_val):
+#     for attrib_val in list_attrib_val:
+#         elem.set(attrib_val[0], str(attrib_val[1]))
+
+
+# def attribs_of_key_sig(ks):
+#     """
+#     Returns values of a score.KeySignature object necessary for a MEI document
+
+#     Parameters
+#     ----------
+#     ks: score.KeySignature
+
+#     Returns
+#     -------
+#     fifths: string
+#         describes the circle of fifths
+#     mode:   string
+#         "major" or "minor"
+#     pname:  string
+#         pitch letter
+#     """
+
+#     key = ks.name
+#     pname = key[0].lower()
+#     mode = "major"
+
+#     if len(key) == 2:
+#         mode = "minor"
+
+#     fifths = str(abs(ks.fifths))
+
+#     if ks.fifths < 0:
+#         fifths += "f"
+#     elif ks.fifths > 0:
+#         fifths += "s"
+
+#     return fifths, mode, pname
+
+
+# def first_instances_per_part(
+#     cls, parts, start=score.TimePoint(0), end=score.TimePoint(1)
+# ):
+#     """
+#     Returns the first instances of a class (multiple objects with same start time are possible) in each part
+
+#     Parameters
+#     ----------
+#     cls:    class
+#     parts:  list of score.Part
+#     start:  score.TimePoint, optional
+#         start of the range to search in
+#     end:    score.TimePoint, optional
+#         end of the range to search in
+
+#     Returns
+#     -------
+#     instances_per_part: list of list of instances of cls
+#         sublists might be empty
+#         if all sublists are empty, instances_per_part is empty
+#     """
+#     if not isinstance(start, list):
+#         start = [start] * len(parts)
+#     elif not len(parts) == len(start):
+#         raise ValueError(
+#             "ERROR at first_instances_per_part: start times are given as list with different size to parts list"
+#         )
+
+#     if not isinstance(end, list):
+#         end = [end] * len(parts)
+#     elif not len(parts) == len(end):
+#         raise ValueError(
+#             "ERROR at first_instances_per_part: end times are given as list with different size to parts list"
+#         )
+
+#     for i in range(len(parts)):
+#         if start[i] == None and end[i] != None or start[i] != None and end[i] == None:
+#             raise ValueError(
+#                 "ERROR at first_instances_per_part: (start==None) != (end==None) (None elements in start have to be at same position as in end and vice versa)"
+#             )
+
+#     instances_per_part = []
+
+#     non_empty = False
+
+#     for i, p in enumerate(parts):
+#         s = start[i]
+#         e = end[i]
+
+#         if s == None:
+#             instances_per_part.append([])
+#             continue
+
+#         instances = list(p.iter_all(cls, s, e))
+
+#         if len(instances) == 0:
+#             instances_per_part.append([])
+#             continue
+
+#         non_empty = True
+#         t = min(instances, key=lambda i: i.start.t).start.t
+#         instances_per_part.append([i for i in instances if t == i.start.t])
+
+#     if non_empty:
+#         return instances_per_part
+
+#     return []
+
+
+# def first_instance_per_part(
+#     cls, parts, start=score.TimePoint(0), end=score.TimePoint(1)
+# ):
+#     """
+#     Reduce the result of first_instances_per_part, a 2D list, to a 1D list
+#     If there are multiple first instances then program aborts with error message
+
+#     Parameters
+#     ----------
+#     cls:    class
+#     parts:  list of score.Part
+#     start:  score.TimePoint, optional
+#         start of the range to search in
+#     end:    score.TimePoint, optional
+#         end of the range to search in
+
+#     Returns
+#     -------
+#     fipp: list of instances of cls
+#         elements might be None
+#     """
+#     fispp = first_instances_per_part(cls, parts, start, end)
+
+#     fipp = []
+
+#     for i, fis in enumerate(fispp):
+#         if len(fis) == 0:
+#             fipp.append(None)
+#         elif len(fis) == 1:
+#             fipp.append(fis[0])
+#         else:
+#             raise ValueError(
+#                 "Part " + parts[i].name,
+#                 "ID " + parts[i].id,
+#                 "has more than one instance of "
+#                 + str(cls)
+#                 + " at beginning t=0, but there should only be a single one",
+#             )
+
+#     return fipp
+
+
+# def first_instances(cls, part, start=score.TimePoint(0), end=score.TimePoint(1)):
+#     """
+#     Returns the first instances of a class (multiple objects with same start time are possible) in the part
+
+#     Parameters
+#     ----------
+#     cls:    class
+#     part:   score.Part
+#     start:  score.TimePoint, optional
+#         start of the range to search in
+#     end:    score.TimePoint, optional
+#         end of the range to search in
+
+#     Returns
+#     -------
+#     fis: list of instances of cls
+#         might be empty
+#     """
+#     fis = first_instances_per_part(cls, [part], start, end)
+
+#     if len(fis) == 0:
+#         return []
+
+#     return fis[0]
+
+
+# def first_instance(cls, part, start=score.TimePoint(0), end=score.TimePoint(1)):
+#     """
+#     Reduce the result of first_instance_per_part, a 1D list, to an element
+#     If there are multiple first instances then program aborts with error message
+
+#     Parameters
+#     ----------
+#     cls:    class
+#     part:   score.Part
+#     start:  score.TimePoint, optional
+#         start of the range to search in
+#     end:    score.TimePoint, optional
+#         end of the range to search in
+
+#     Returns
+#     -------
+#     fi: instance of cls or None
+#     """
+#     fi = first_instance_per_part(cls, [part], start, end)
+
+#     if len(fi) == 0:
+#         return None
+
+#     return fi[0]
+
+
+# def common_signature(cls, sig_eql, parts, current_measures=None):
+#     """
+#     Calculate whether a list of parts has a common signature (as in key or time signature)
+
+#     Parameters
+#     ----------
+#     cls:                score.KeySignature or score.TimeSignature
+#     sig_eql:            function
+#         takes 2 signature objects as input and returns whether they are equivalent (in some sense)
+#     parts:              list of score.Part
+#     current_measures:    list of score.Measure, optional
+#         current as in the measures of the parts that are played at the same time and are processed
+
+#     Returns
+#     -------
+#     common_sig:  instance of cls
+#         might be None if there is no commonality between parts
+#     """
+#     sigs = None
+#     if current_measures != None:
+#         # HACK:  measures should probably not contain "pad" at this point, but an actual dummy measure with start and end times?
+#         sigs = first_instance_per_part(
+#             cls,
+#             parts,
+#             start=[cm.start if cm != "pad" else None for cm in current_measures],
+#             end=[cm.end if cm != "pad" else None for cm in current_measures],
+#         )
+#     else:
+#         sigs = first_instance_per_part(cls, parts)
+
+#     if sigs == None or len(sigs) == 0 or None in sigs:
+#         return None
+
+#     common_sig = sigs.pop()
+
+#     for sig in sigs:
+#         if sig.start.t != common_sig.start.t or not sig_eql(sig, common_sig):
+#             return None
+
+#     return common_sig
+
+
+# def vertical_slice(list_2d, index):
+#     """
+#     Returns elements of the sublists at index in a 1D list
+#     all sublists of list_2d have to have len > index
+#     """
+#     vslice = []
+
+#     for list_1d in list_2d:
+#         vslice.append(list_1d[index])
+
+#     return vslice
+
+
+# def time_sig_eql(ts1, ts2):
+#     """
+#     equivalence function for score.TimeSignature objects
+#     """
+#     return ts1.beats == ts2.beats and ts1.beat_type == ts2.beat_type
+
+
+# def key_sig_eql(ks1, ks2):
+#     """
+#     equivalence function for score.KeySignature objects
+#     """
+#     return ks1.name == ks2.name and ks1.fifths == ks2.fifths
+
+
+# def idx(len_obj):
+#     return range(len(len_obj))
+
+
+# def attribs_of_clef(clef):
+#     """
+#     Returns values of a score.Clef object necessary for a MEI document
+
+#     Parameters
+#     ----------
+#     clef: score.Clef
+
+#     Returns
+#     -------
+#     sign: string
+#         shape of clef (F,G, etc)
+#     line:
+#         which line to place clef on
+#     """
+#     sign = clef.sign
+
+#     if sign == "percussion":
+#         sign = "perc"
+
+#     if clef.octave_change != None and clef.octave_change != 0:
+#         place = "above"
+
+#         if clef.octave_change < 0:
+#             place = "below"
+
+#         return sign, clef.line, 1 + 7 * abs(clef.octave_change), place
+
+#     return sign, clef.line
+
+
+# def create_staff_def(staff_grp, clef):
+#     """
+
+#     Parameters
+#     ----------
+#     staff_grp:   etree.SubElement
+#     clef:       score.Clef
+#     """
+#     staff_def = add_child(staff_grp, "staffDef")
+
+#     attribs = attribs_of_clef(clef)
+#     set_attributes(
+#         staff_def,
+#         ("n", clef.number),
+#         ("lines", 5),
+#         ("clef.shape", attribs[0]),
+#         ("clef.line", attribs[1]),
+#     )
+#     if len(attribs) == 4:
+#         set_attributes(
+#             staff_def, ("clef.dis", attribs[2]), ("clef.dis.place", attribs[3])
+#         )
+
+
+# def pad_measure(s, measure_per_staff, notes_within_measure_per_staff, auto_rest_count):
+#     """
+#     Adds a fake measure ("pad") to the measures of the staff s and a score.Rest object to the notes
+
+#     Parameters
+#     ----------
+#     s:                              int
+#         staff number
+#     measure_per_staff:               dict of score.Measure objects
+#     notes_within_measure_per_staff:   dict of lists of score.GenericNote objects
+#     auto_rest_count:                  int
+#         a counter for all the score.Rest objects that are created automatically
+
+#     Returns
+#     -------
+#     incremented auto rest counter
+#     """
+
+#     measure_per_staff[s] = "pad"
+#     r = score.Rest(id="pR" + str(auto_rest_count), voice=1)
+#     r.start = score.TimePoint(0)
+#     r.end = r.start
+
+#     extend_key(notes_within_measure_per_staff, s, r)
+#     return auto_rest_count + 1
+
+
+# class InbetweenNotesElement:
+#     """
+#     InbetweenNotesElements contain information on objects like clefs, keysignatures, etc
+#     within the score and how to process them
+
+#     Parameters
+#     ----------
+#     name:           string
+#         name of the element used in MEI
+#     attrib_names:    list of strings
+#         names of the attributes of the MEI element
+#     attrib_vals_of:   function
+#         a function that returns the attribute values of elem
+#     container_dict: dict of lists of partitura objects
+#         the container containing the required elements is at staff
+#     staff:          int
+#         staff number
+#     skip_index:      int
+#         init value for the cursor i (might skip 0)
+
+#     Attributes
+#     ----------
+#     name:           string
+#         name of the element used in MEI
+#     attrib_names:    list of strings
+#         names of the attributes of the MEI element
+#     elem:           instance of partitura object
+#     attrib_vals_of:   function
+#         a function that returns the attribute values of elem
+#     container:      list of partitura objects
+#         the container where elem gets its values from
+#     i:              int
+#         cursor that keeps track of position in container
+#     """
+
+#     __slots__ = ["name", "attrib_names", "attrib_vals_of", "container", "i", "elem"]
+
+#     def __init__(
+#         self, name, attrib_names, attrib_vals_of, container_dict, staff, skip_index
+#     ):
+#         self.name = name
+#         self.attrib_names = attrib_names
+#         self.attrib_vals_of = attrib_vals_of
+
+#         self.i = 0
+#         self.elem = None
+
+#         if staff in container_dict.keys():
+#             self.container = container_dict[staff]
+#             if len(self.container) > skip_index:
+#                 self.elem = self.container[skip_index]
+#                 self.i = skip_index
+#         else:
+#             self.container = []
+
+
+# def chord_rep(chords, chord_i):
+#     return chords[chord_i][0]
+
+
+# def handle_beam(open_up, parents):
+#     """
+#     Using a stack of MEI elements, opens and closes beams
+
+#     Parameters
+#     ----------
+#     open_up:     boolean
+#         flag that indicates whether to open or close recent beam
+#     parents:    list of etree.SubElement
+#         stack of MEI elements that contain the beam element
+
+#     Returns
+#     -------
+#     unchanged open_up value
+#     """
+#     if open_up:
+#         parents.append(add_child(parents[-1], "beam"))
+#     else:
+#         parents.pop()
+
+#     return open_up
+
+
+# def is_chord_in_tuplet(chord_i, tuplet_indices):
+#     """
+#     check if chord falls in the range of a tuplet
+
+#     Parameters
+#     ----------
+#     chord_i:        int
+#         index of chord within chords array
+#     tuplet_indices:  list of int pairs
+#         contains the index ranges of all the tuplets in a measure of a staff
+
+#     Returns
+#     -------
+#     whether chord falls in the range of a tuplet
+#     """
+#     for start, stop in tuplet_indices:
+#         if start <= chord_i and chord_i <= stop:
+#             return True
+
+#     return False
+
+
+# def calc_num_to_numbase_ratio(chord_i, chords, tuplet_indices):
+#     """
+#     calculates how to scale a notes duration with regard to the tuplet it is in
+
+#     Parameters
+#     ----------
+#     chord_i:        int
+#         index of chord within chords array
+#     chords:         list of list of score.GenericNote
+#         array of chords (which are lists of notes)
+#     tuplet_indices:  list of int pairs
+#         contains the index ranges of all the tuplets in a measure of a staff
+
+#     Returns
+#     -------
+#     the num to numbase ratio of a tuplet (eg. 3 in 2 tuplet is 1.5)
+#     """
+#     rep = chords[chord_i][0]
+#     if not isinstance(rep, score.GraceNote) and is_chord_in_tuplet(
+#         chord_i, tuplet_indices
+#     ):
+#         return (
+#             rep.symbolic_duration["actual_notes"]
+#             / rep.symbolic_duration["normal_notes"]
+#         )
+#     return 1
+
+
+# def process_chord(
+#     chord_i,
+#     chords,
+#     inbetween_notes_elements,
+#     open_beam,
+#     auto_beaming,
+#     parents,
+#     dur_dots,
+#     split_notes,
+#     first_temp_dur,
+#     tuplet_indices,
+#     ties,
+#     measure,
+#     layer,
+#     tuplet_id_counter,
+#     open_tuplet,
+#     last_key_sig,
+#     note_alterations,
+#     notes_next_measure_per_staff,
+#     next_dur_dots=None,
+# ):
+#     """
+#     creates <note>, <chord>, <rest>, etc elements from chords
+#     also creates <beam>, <tuplet>, etc elements if necessary for chords objects
+#     also creates <clef>, <keySig>, etc elements before chord objects from inbetween_notes_elements
+
+#     Parameters
+#     ----------
+#     chord_i:                    int
+#         index of chord within chords array
+#     chords:                     list of list of score.GenericNote
+#         chord array
+#     inbetween_notes_elements:     list of InbetweenNotesElements
+#         check this to see if something like clef needs to get inserted before chord
+#     open_beam:                   boolean
+#         flag that indicates whether a beam is currently open
+#     auto_beaming:                boolean
+#         flag that determines if automatic beams should be created or if it is kept manual
+#     parents:                    list of etree.SubElement
+#         stack of MEI elements that contain the most recent beam element
+#     dur_dots:                   list of int pairs
+#         describes how the chord actually gets notated via tied notes, each pair contains the duration of the notated note and its dot count
+#     split_notes:                 list
+#         this is either empty or None
+#         if None, nothing is done with this
+#         if an empty list, that means this chord crosses into the next measure and a chord is created for the next measure which is tied to this one
+#     first_temp_dur:               int
+#         amount of ticks (as in partitura) of the first notated note
+#     tuplet_indices:              list of int pairs
+#         the ranges of tuplets within the chords array
+#     ties:                       dict
+#         out parameter, contains pairs of IDs which need to be connected via ties
+#         this function also adds to that
+#     measure:                    score.Measure
+
+#     layer:                      etree.SubElement
+#         the parent element of the elements created here
+#     tuplet_id_counter:           int
+
+#     open_tuplet:                 boolean
+#         describes if a tuplet is open or not
+#     last_key_sig:                 score.KeySignature
+#         the key signature this chord should be interpeted in
+#     note_alterations:            dict
+#         contains the alterations of staff positions (notes) that are relevant for this chord
+#     notes_next_measure_per_staff: dict of lists of score.GenericNote
+#         out parameter, add the result of split_notes into this
+#     next_dur_dots:              list of int pairs, optional
+#         needed for proper beaming
+
+#     Returns
+#     -------
+#     tuplet_id_counter:    int
+#         incremented if tuplet created
+#     open_beam:           boolean
+#         eventually modified if beam opened or closed
+#     open_tuplet:         boolean
+#         eventually modified if tuplet opened or closed
+#     """
+
+#     chord_notes = chords[chord_i]
+#     rep = chord_notes[0]
+
+#     for ine in inbetween_notes_elements:
+#         if insert_elem_check(rep.start.t, [ine]):
+#             # note should maybe be split according to keysig or clef etc insertion time, right now only beaming is disrupted
+#             if open_beam and auto_beaming:
+#                 open_beam = handle_beam(False, parents)
+
+#             xml_elem = add_child(parents[-1], ine.name)
+#             attrib_vals = ine.attrib_vals_of(ine.elem)
+
+#             if ine.name == "keySig":
+#                 last_key_sig = ine.elem
+
+#             if len(ine.attrib_names) < len(attrib_vals):
+#                 raise ValueError(
+#                     "ERROR at insertion of inbetween_notes_elements: there are more attribute values than there are attribute names for xml element "
+#                     + ine.name
+#                 )
+
+#             for nv in zip(ine.attrib_names[: len(attrib_vals)], attrib_vals):
+#                 set_attributes(xml_elem, nv)
+
+#             if ine.i + 1 >= len(ine.container):
+#                 ine.elem = None
+#             else:
+#                 ine.i += 1
+#                 ine.elem = ine.container[ine.i]
+
+#     if is_chord_in_tuplet(chord_i, tuplet_indices):
+#         if not open_tuplet:
+#             parents.append(add_child(parents[-1], "tuplet"))
+#             num = rep.symbolic_duration["actual_notes"]
+#             numbase = rep.symbolic_duration["normal_notes"]
+#             set_attributes(
+#                 parents[-1],
+#                 (xml_id_string, "t" + str(tuplet_id_counter)),
+#                 ("num", num),
+#                 ("numbase", numbase),
+#             )
+#             tuplet_id_counter += 1
+#             open_tuplet = True
+#     elif open_tuplet:
+#         parents.pop()
+#         open_tuplet = False
+
+#     def set_dur_dots(elem, dur_dots):
+#         dur, dots = dur_dots
+#         set_attributes(elem, ("dur", dur))
+
+#         if dots > 0:
+#             set_attributes(elem, ("dots", dots))
+
+#     if isinstance(rep, score.Note):
+#         if auto_beaming:
+#             # for now all notes are beamed, however some rules should be obeyed there, see Note Beaming and Grouping
+
+#             # check to close beam
+#             if open_beam and (
+#                 dur_dots[0][0] < 8
+#                 or chord_i - 1 >= 0
+#                 and type(rep) != type(chord_rep(chords, chord_i - 1))
+#             ):
+#                 open_beam = handle_beam(False, parents)
+
+#             # check to open beam (maybe again)
+#             if not open_beam and dur_dots[0][0] >= 8:
+#                 # open beam if there are multiple "consecutive notes" which don't get interrupted by some element
+#                 if len(dur_dots) > 1 and not insert_elem_check(
+#                     rep.start.t + first_temp_dur, inbetween_notes_elements
+#                 ):
+#                     open_beam = handle_beam(True, parents)
+
+#                 # open beam if there is just a single note that is not the last one in measure and next note in measure is of same type and fits in beam as well, without getting interrupted by some element
+#                 elif (
+#                     len(dur_dots) <= 1
+#                     and chord_i + 1 < len(chords)
+#                     and next_dur_dots[0][0] >= 8
+#                     and type(rep) == type(chord_rep(chords, chord_i + 1))
+#                     and not insert_elem_check(
+#                         chord_rep(chords, chord_i + 1).start.t, inbetween_notes_elements
+#                     )
+#                 ):
+#                     open_beam = handle_beam(True, parents)
+#         elif (
+#             open_beam
+#             and chord_i > 0
+#             and rep.beam != chord_rep(chords, chord_i - 1).beam
+#         ):
+#             open_beam = handle_beam(False, parents)
+
+#         if not auto_beaming and not open_beam and rep.beam != None:
+#             open_beam = handle_beam(True, parents)
+
+#         def conditional_gracify(elem, rep, chord_i, chords):
+#             if isinstance(rep, score.GraceNote):
+#                 grace = "unacc"
+
+#                 if rep.grace_type == "appoggiatura":
+#                     grace = "acc"
+
+#                 set_attributes(elem, ("grace", grace))
+
+#                 if rep.steal_proportion != None:
+#                     set_attributes(
+#                         elem, ("grace.time", str(rep.steal_proportion * 100) + "%")
+#                     )
+
+#                 if chord_i == 0 or not isinstance(
+#                     chord_rep(chords, chord_i - 1), score.GraceNote
+#                 ):
+#                     chords[chord_i] = [copy(n) for n in chords[chord_i]]
+
+#                     for n in chords[chord_i]:
+#                         n.tie_next = n.main_note
+
+#         def create_note(parent, n, id, last_key_sig, note_alterations):
+#             note = add_child(parent, "note")
+
+#             step = n.step.lower()
+#             set_attributes(
+#                 note, (xml_id_string, id), ("pname", step), ("oct", n.octave)
+#             )
+
+#             if n.articulations != None and len(n.articulations) > 0:
+#                 artics = []
+
+#                 translation = {
+#                     "accent": "acc",
+#                     "staccato": "stacc",
+#                     "tenuto": "ten",
+#                     "staccatissimo": "stacciss",
+#                     "spiccato": "spicc",
+#                     "scoop": "scoop",
+#                     "plop": "plop",
+#                     "doit": "doit",
+#                 }
+
+#                 for a in n.articulations:
+#                     if a in translation.keys():
+#                         artics.append(translation[a])
+#                 set_attributes(note, ("artic", " ".join(artics)))
+
+#             sharps = ["f", "c", "g", "d", "a", "e", "b"]
+#             flats = list(reversed(sharps))
+
+#             staff_pos = step + str(n.octave)
+
+#             alter = n.alter or 0
+
+#             def set_accid(note, acc, note_alterations, staff_pos, alter):
+#                 if (
+#                     staff_pos in note_alterations.keys()
+#                     and alter == note_alterations[staff_pos]
+#                 ):
+#                     return
+#                 set_attributes(note, ("accid", acc))
+#                 note_alterations[staff_pos] = alter
+
+#             # sharpen note if: is sharp, is not sharpened by key or prev alt
+#             # flatten note if: is flat, is not flattened by key or prev alt
+#             # neutralize note if: is neutral, is sharpened/flattened by key or prev alt
+
+#             # check if note is sharpened/flattened by prev alt or key
+#             if (
+#                 staff_pos in note_alterations.keys()
+#                 and note_alterations[staff_pos] != 0
+#                 or last_key_sig.fifths > 0
+#                 and step in sharps[: last_key_sig.fifths]
+#                 or last_key_sig.fifths < 0
+#                 and step in flats[: -last_key_sig.fifths]
+#             ):
+#                 if alter == 0:
+#                     set_accid(note, "n", note_alterations, staff_pos, alter)
+#             elif alter > 0:
+#                 set_accid(note, "s", note_alterations, staff_pos, alter)
+#             elif alter < 0:
+#                 set_accid(note, "f", note_alterations, staff_pos, alter)
+
+#             return note
+
+#         if len(chord_notes) > 1:
+#             chord = add_child(parents[-1], "chord")
+
+#             set_dur_dots(chord, dur_dots[0])
+
+#             conditional_gracify(chord, rep, chord_i, chords)
+
+#             for n in chord_notes:
+#                 create_note(chord, n, n.id, last_key_sig, note_alterations)
+
+#         else:
+#             note = create_note(parents[-1], rep, rep.id, last_key_sig, note_alterations)
+#             set_dur_dots(note, dur_dots[0])
+
+#             conditional_gracify(note, rep, chord_i, chords)
+
+#         if len(dur_dots) > 1:
+#             for n in chord_notes:
+#                 ties[n.id] = [n.id]
+
+#             def create_split_up_notes(chord_notes, i, parents, dur_dots, ties, rep):
+#                 if len(chord_notes) > 1:
+#                     chord = add_child(parents[-1], "chord")
+#                     set_dur_dots(chord, dur_dots[i])
+
+#                     for n in chord_notes:
+#                         id = n.id + "-" + str(i)
+
+#                         ties[n.id].append(id)
+#                         create_note(chord, n, id, last_key_sig, note_alterations)
+#                 else:
+#                     id = rep.id + "-" + str(i)
+
+#                     ties[rep.id].append(id)
+
+#                     note = create_note(
+#                         parents[-1], rep, id, last_key_sig, note_alterations
+#                     )
+
+#                     set_dur_dots(note, dur_dots[i])
+
+#             for i in range(1, len(dur_dots) - 1):
+#                 if not open_beam and dur_dots[i][0] >= 8:
+#                     open_beam = handle_beam(True, parents)
+
+#                 create_split_up_notes(chord_notes, i, parents, dur_dots, ties, rep)
+
+#             create_split_up_notes(
+#                 chord_notes, len(dur_dots) - 1, parents, dur_dots, ties, rep
+#             )
+
+#         if split_notes != None:
+
+#             for n in chord_notes:
+#                 split_notes.append(score.Note(n.step, n.octave, id=n.id + "s"))
+
+#             if len(dur_dots) > 1:
+#                 for n in chord_notes:
+#                     ties[n.id].append(n.id + "s")
+#             else:
+#                 for n in chord_notes:
+#                     ties[n.id] = [n.id, n.id + "s"]
+
+#         for n in chord_notes:
+#             if n.tie_next != None:
+#                 if n.id in ties.keys():
+#                     ties[n.id].append(n.tie_next.id)
+#                 else:
+#                     ties[n.id] = [n.id, n.tie_next.id]
+
+#     elif isinstance(rep, score.Rest):
+#         if split_notes != None:
+#             split_notes.append(score.Rest(id=rep.id + "s"))
+
+#         if (
+#             measure == "pad"
+#             or measure.start.t == rep.start.t
+#             and measure.end.t == rep.end.t
+#         ):
+#             rest = add_child(layer, "mRest")
+
+#             set_attributes(rest, (xml_id_string, rep.id))
+#         else:
+#             rest = add_child(layer, "rest")
+
+#             set_attributes(rest, (xml_id_string, rep.id))
+
+#             set_dur_dots(rest, dur_dots[0])
+
+#             for i in range(1, len(dur_dots)):
+#                 rest = add_child(layer, "rest")
+
+#                 id = rep.id + str(i)
+
+#                 set_attributes(rest, (xml_id_string, id))
+#                 set_dur_dots(rest, dur_dots[i])
+
+#     if split_notes != None:
+#         for sn in split_notes:
+#             sn.voice = rep.voice
+#             sn.start = measure.end
+#             sn.end = score.TimePoint(rep.start.t + rep.duration)
+
+#             extend_key(notes_next_measure_per_staff, s, sn)
+
+#     return tuplet_id_counter, open_beam, open_tuplet
+
+
+# def create_score_def(measures, measure_i, parts, parent):
+#     """
+#     creates <score_def>
+
+#     Parameters
+#     ----------
+#     measures:   list of score.Measure
+#     measure_i:  int
+#         index of measure currently processed within measures
+#     parts:      list of score.Part
+#     parent:     etree.SubElement
+#         parent of <score_def>
+#     """
+#     reference_measures = vertical_slice(measures, measure_i)
+
+#     common_key_sig = common_signature(
+#         score.KeySignature, key_sig_eql, parts, reference_measures
+#     )
+#     common_time_sig = common_signature(
+#         score.TimeSignature, time_sig_eql, parts, reference_measures
+#     )
+
+#     score_def = None
+
+#     if common_key_sig != None or common_time_sig != None:
+#         score_def = add_child(parent, "scoreDef")
+
+#     if common_key_sig != None:
+#         fifths, mode, pname = attribs_of_key_sig(common_key_sig)
+
+#         set_attributes(
+#             score_def, ("key.sig", fifths), ("key.mode", mode), ("key.pname", pname)
+#         )
+
+#     if common_time_sig != None:
+#         set_attributes(
+#             score_def,
+#             ("meter.count", common_time_sig.beats),
+#             ("meter.unit", common_time_sig.beat_type),
+#         )
+
+#     return score_def
+
+
+# class MeasureContent:
+#     """
+#     Simply a bundle for all the data of a measure that needs to be processed for a MEI document
+
+#     Attributes
+#     ----------
+#     ties_per_staff:      dict of lists
+#     clefs_per_staff:     dict of lists
+#     key_sigs_per_staff:   dict of lists
+#     time_sigs_per_staff:  dict of lists
+#     measure_per_staff:   dict of lists
+#     tuplets_per_staff:   dict of lists
+#     slurs:              list
+#     dirs:               list
+#     dynams:             list
+#     tempii:             list
+#     fermatas:           list
+#     """
+
+#     __slots__ = [
+#         "ties_per_staff",
+#         "clefs_per_staff",
+#         "key_sigs_per_staff",
+#         "time_sigs_per_staff",
+#         "measure_per_staff",
+#         "tuplets_per_staff",
+#         "slurs",
+#         "dirs",
+#         "dynams",
+#         "tempii",
+#         "fermatas",
+#     ]
+
+#     def __init__(self):
+#         self.ties_per_staff = {}
+#         self.clefs_per_staff = {}
+#         self.key_sigs_per_staff = {}
+#         self.time_sigs_per_staff = {}
+#         self.measure_per_staff = {}
+#         self.tuplets_per_staff = {}
+
+#         self.slurs = []
+#         self.dirs = []
+#         self.dynams = []
+#         self.tempii = []
+#         self.fermatas = []
+
+
+# def extract_from_measures(
+#     parts,
+#     measures,
+#     measure_i,
+#     staves_per_part,
+#     auto_rest_count,
+#     notes_within_measure_per_staff,
+# ):
+#     """
+#     Returns a bundle of data regarding the measure currently processed, things like notes, key signatures, etc
+#     Also creates padding measures, necessary for example, for staves of instruments which do not play in the current measure
+
+#     Parameters
+#     ----------
+#     parts:                          list of score.Part
+#     measures:                       list of score.Measure
+#     measure_i:                      int
+#         index of current measure within measures
+#     staves_per_part:                 dict of list of ints
+#         staff enumeration partitioned by part
+#     auto_rest_count:                  int
+#         counter for the IDs of automatically generated rests
+#     notes_within_measure_per_staff:   dict of lists of score.GenericNote
+#         in and out parameter, might contain note objects that have crossed from previous measure into current one
+
+#     Returns
+#     -------
+#     auto_rest_count:                  int
+#         incremented if score.Rest created
+#     current_measure_content:          MeasureContent
+#         bundle for all the data that is extracted from the currently processed measure
+#     """
+#     current_measure_content = MeasureContent()
+
+#     for part_i, part in enumerate(parts):
+#         m = measures[part_i][measure_i]
+
+#         if m == "pad":
+#             for s in staves_per_part[part_i]:
+#                 auto_rest_count = pad_measure(
+#                     s,
+#                     current_measure_content.measure_per_staff,
+#                     notes_within_measure_per_staff,
+#                     auto_rest_count,
+#                 )
+
+#             continue
+
+#         def cls_within_measure(part, cls, measure, incl_subcls=False):
+#             return part.iter_all(
+#                 cls, measure.start, measure.end, include_subclasses=incl_subcls
+#             )
+
+#         def cls_within_measure_list(part, cls, measure, incl_subcls=False):
+#             return list(cls_within_measure(part, cls, measure, incl_subcls))
+
+#         clefs_within_measure_per_staff_per_part = partition_handle_none(
+#             lambda c: c.number, cls_within_measure(part, score.Clef, m), "number"
+#         )
+#         key_sigs_within_measure = cls_within_measure_list(part, score.KeySignature, m)
+#         time_sigs_within_measure = cls_within_measure_list(part, score.TimeSignature, m)
+#         current_measure_content.slurs.extend(cls_within_measure(part, score.Slur, m))
+#         tuplets_within_measure = cls_within_measure_list(part, score.Tuplet, m)
+
+#         beat_map = part.beat_map
+
+#         def calc_tstamp(beat_map, t, measure):
+#             return beat_map(t) - beat_map(measure.start.t) + 1
+
+#         for w in cls_within_measure(part, score.Words, m):
+#             tstamp = calc_tstamp(beat_map, w.start.t, m)
+#             current_measure_content.dirs.append((tstamp, w))
+
+#         for tempo in cls_within_measure(part, score.Tempo, m):
+#             tstamp = calc_tstamp(beat_map, tempo.start.t, m)
+#             current_measure_content.tempii.append(
+#                 (tstamp, staves_per_part[part_i][0], tempo)
+#             )
+
+#         for fermata in cls_within_measure(part, score.Fermata, m):
+#             tstamp = calc_tstamp(beat_map, fermata.start.t, m)
+#             current_measure_content.fermatas.append((tstamp, fermata.ref.staff))
+
+#         for dynam in cls_within_measure(part, score.Direction, m, True):
+#             tstamp = calc_tstamp(beat_map, dynam.start.t, m)
+#             tstamp2 = None
+
+#             if dynam.end != None:
+#                 measure_counter = measure_i
+#                 while True:
+#                     if dynam.end.t <= measures[part_i][measure_counter].end.t:
+#                         tstamp2 = calc_tstamp(
+#                             beat_map, dynam.end.t, measures[part_i][measure_counter]
+#                         )
+
+#                         tstamp2 = str(measure_counter - measure_i) + "m+" + str(tstamp2)
+
+#                         break
+#                     elif (
+#                         measure_counter + 1 >= len(measures[part_i])
+#                         or measures[part_i][measure_counter + 1] == "pad"
+#                     ):
+#                         raise ValueError(
+#                             "A score.Direction instance has an end time that exceeds actual non-padded measures"
+#                         )
+#                     else:
+#                         measure_counter += 1
+
+#             current_measure_content.dynams.append((tstamp, tstamp2, dynam))
+
+#         notes_within_measure_per_staff_per_part = partition_handle_none(
+#             lambda n: n.staff,
+#             cls_within_measure(part, score.GenericNote, m, True),
+#             "staff",
+#         )
+
+#         for s in staves_per_part[part_i]:
+#             current_measure_content.key_sigs_per_staff[s] = key_sigs_within_measure
+#             current_measure_content.time_sigs_per_staff[s] = time_sigs_within_measure
+#             current_measure_content.tuplets_per_staff[s] = tuplets_within_measure
+
+#             if s not in notes_within_measure_per_staff_per_part.keys():
+#                 auto_rest_count = pad_measure(
+#                     s,
+#                     current_measure_content.measure_per_staff,
+#                     notes_within_measure_per_staff,
+#                     auto_rest_count,
+#                 )
+
+#         for s, nwp in notes_within_measure_per_staff_per_part.items():
+#             extend_key(notes_within_measure_per_staff, s, nwp)
+#             current_measure_content.measure_per_staff[s] = m
+
+#         for s, cwp in clefs_within_measure_per_staff_per_part.items():
+#             current_measure_content.clefs_per_staff[s] = cwp
+
+#     return auto_rest_count, current_measure_content
+
+
+# def create_measure(
+#     section,
+#     measure_i,
+#     staves_sorted,
+#     notes_within_measure_per_staff,
+#     score_def,
+#     tuplet_id_counter,
+#     auto_beaming,
+#     last_key_sig_per_staff,
+#     current_measure_content,
+# ):
+#     """
+#     creates a <measure> element within <section>
+#     also returns an updated id counter for tuplets and a dictionary of notes that cross into the next measure
+
+#     Parameters
+#     ----------
+#     section:                        etree.SubElement
+#     measure_i:                      int
+#         index of the measure created
+#     staves_sorted:                  list of ints
+#         a sorted list of the proper staff enumeration of the score
+#     notes_within_measure_per_staff:   dict of lists of score.GenericNote
+#         contains score.Note, score.Rest, etc objects of the current measure, partitioned by staff enumeration
+#         will be further partitioned and sorted by voice, time and type (score.GraceNote) and eventually gathered into
+#         a list of equivalence classes called chords
+#     score_def:                       etree.SubElement
+#     tuplet_id_counter:               int
+#         tuplets usually don't come with IDs, so an automatic counter takes care of that
+#     auto_beaming:                    boolean
+#         enables automatic beaming
+#     last_key_sig_per_staff:            dict of score.KeySignature
+#         keeps track of the keysignature each staff is currently in
+#     current_measure_content:          MeasureContent
+#         contains all sorts of data for the measure like tuplets, slurs, etc
+
+#     Returns
+#     -------
+#     tuplet_id_counter:               int
+#         incremented if tuplet created
+#     notes_next_measure_per_staff:     dict of lists of score.GenericNote
+#         score.GenericNote objects that cross into the next measure
+#     """
+#     measure = add_child(section, "measure")
+#     set_attributes(measure, ("n", measure_i + 1))
+
+#     ties_per_staff = {}
+
+#     for s in staves_sorted:
+#         note_alterations = {}
+
+#         staff = add_child(measure, "staff")
+
+#         set_attributes(staff, ("n", s))
+
+#         notes_within_measure_per_staff_per_voice = partition_handle_none(
+#             lambda n: n.voice, notes_within_measure_per_staff[s], "voice"
+#         )
+
+#         ties_per_staff_per_voice = {}
+
+#         m = current_measure_content.measure_per_staff[s]
+
+#         tuplets = []
+#         if s in current_measure_content.tuplets_per_staff.keys():
+#             tuplets = current_measure_content.tuplets_per_staff[s]
+
+#         last_key_sig = last_key_sig_per_staff[s]
+
+#         for voice, notes in notes_within_measure_per_staff_per_voice.items():
+#             layer = add_child(staff, "layer")
+
+#             set_attributes(layer, ("n", voice))
+
+#             ties = {}
+
+#             notes_partition = partition_handle_none(
+#                 lambda n: n.start.t, notes, "start.t"
+#             )
+
+#             chords = []
+
+#             for t in sorted(notes_partition.keys()):
+#                 ns = notes_partition[t]
+
+#                 if len(ns) > 1:
+#                     type_partition = partition_handle_none(
+#                         lambda n: isinstance(n, score.GraceNote), ns, "isGraceNote"
+#                     )
+
+#                     if True in type_partition.keys():
+#                         gns = type_partition[True]
+
+#                         gn_chords = []
+
+#                         def scan_backwards(gns):
+#                             start = gns[0]
+
+#                             while isinstance(start.grace_prev, score.GraceNote):
+#                                 start = start.grace_prev
+
+#                             return start
+
+#                         start = scan_backwards(gns)
+
+#                         def process_grace_note(n, gns):
+#                             if not n in gns:
+#                                 raise ValueError(
+#                                     "Error at forward scan of GraceNotes: a grace_next has either different staff, voice or starting time than GraceNote chain"
+#                                 )
+#                             gns.remove(n)
+#                             return n.grace_next
+
+#                         while isinstance(start, score.GraceNote):
+#                             gn_chords.append([start])
+#                             start = process_grace_note(start, gns)
+
+#                         while len(gns) > 0:
+#                             start = scan_backwards(gns)
+
+#                             i = 0
+#                             while isinstance(start, score.GraceNote):
+#                                 if i >= len(gn_chords):
+#                                     raise IndexError(
+#                                         "ERROR at GraceNote-forward scanning: Difference in lengths of grace note sequences for different chord notes"
+#                                     )
+#                                 gn_chords[i].append(start)
+#                                 start = process_grace_note(start, gns)
+#                                 i += 1
+
+#                             if not i == len(gn_chords):
+#                                 raise IndexError(
+#                                     "ERROR at GraceNote-forward scanning: Difference in lengths of grace note sequences for different chord notes"
+#                                 )
+
+#                         for gnc in gn_chords:
+#                             chords.append(gnc)
+
+#                     if not False in type_partition.keys():
+#                         raise KeyError(
+#                             "ERROR at ChordNotes-grouping: GraceNotes detected without additional regular Notes at same time; staff "
+#                             + str(s)
+#                         )
+
+#                     reg_notes = type_partition[False]
+
+#                     rep = reg_notes[0]
+
+#                     for i in range(1, len(reg_notes)):
+#                         n = reg_notes[i]
+
+#                         if n.duration != rep.duration:
+#                             raise ValueError(
+#                                 "In staff " + str(s) + ",",
+#                                 "in measure " + str(m.number) + ",",
+#                                 "for voice " + str(voice) + ",",
+#                                 "2 notes start at time " + str(n.start.t) + ",",
+#                                 "but have different durations, namely "
+#                                 + n.id
+#                                 + " has duration "
+#                                 + str(n.duration)
+#                                 + " and "
+#                                 + rep.id
+#                                 + " has duration "
+#                                 + str(rep.duration),
+#                                 "change to same duration for a chord or change voice of one of the notes for something else",
+#                             )
+#                         # HACK: unpitched notes are treated as Rests right now
+#                         elif not isinstance(rep, score.Rest) and not isinstance(
+#                             n, score.Rest
+#                         ):
+#                             if rep.beam != n.beam:
+#                                 print(
+#                                     "WARNING: notes within chords don't share the same beam",
+#                                     "specifically note "
+#                                     + str(rep)
+#                                     + " has beam "
+#                                     + str(rep.beam),
+#                                     "and note " + str(n) + " has beam " + str(n.beam),
+#                                     "export still continues though",
+#                                 )
+#                             elif set(rep.tuplet_starts) != set(n.tuplet_starts) and set(
+#                                 rep.tuplet_stops
+#                             ) != set(n.tuplet_stops):
+#                                 print(
+#                                     "WARNING: notes within chords don't share same tuplets, export still continues though"
+#                                 )
+#                     chords.append(reg_notes)
+#                 else:
+#                     chords.append(ns)
+
+#             tuplet_indices = []
+#             for tuplet in tuplets:
+#                 ci = 0
+#                 start = -1
+#                 stop = -1
+#                 while ci < len(chords):
+#                     for n in chords[ci]:
+#                         if tuplet in n.tuplet_starts:
+#                             start = ci
+#                             break
+#                     for n in chords[ci]:
+#                         if tuplet in n.tuplet_stops:
+#                             stop = ci
+#                             break
+
+#                     if start >= 0 and stop >= 0:
+#                         if not start <= stop:
+#                             raise ValueError(
+#                                 "In measure " + str(measure_i + 1) + ",",
+#                                 "in staff " + str(s) + ",",
+#                                 "[" + str(tuplet) + "] stops before it starts?",
+#                                 "start=" + str(start + 1) + "; stop=" + str(stop + 1),
+#                             )
+#                         tuplet_indices.append((start, stop))
+#                         break
+
+#                     ci += 1
+
+#             parents = [layer]
+#             open_beam = False
+
+#             (
+#                 next_dur_dots,
+#                 next_split_notes,
+#                 next_first_temp_dur,
+#             ) = calc_dur_dots_split_notes_first_temp_dur(
+#                 chords[0][0], m, calc_num_to_numbase_ratio(0, chords, tuplet_indices)
+#             )
+
+#             inbetween_notes_elements = [
+#                 InbetweenNotesElement(
+#                     "clef",
+#                     ["shape", "line", "dis", "dis.place"],
+#                     attribs_of_clef,
+#                     current_measure_content.clefs_per_staff,
+#                     s,
+#                     int(measure_i == 0),
+#                 ),
+#                 InbetweenNotesElement(
+#                     "keySig",
+#                     ["sig", "mode", "pname", "sig.showchange"],
+#                     (lambda ks: attribs_of_key_sig(ks) + ("true",)),
+#                     current_measure_content.key_sigs_per_staff,
+#                     s,
+#                     int(score_def != None),
+#                 ),
+#                 InbetweenNotesElement(
+#                     "meterSig",
+#                     ["count", "unit"],
+#                     lambda ts: (ts.beats, ts.beat_type),
+#                     current_measure_content.time_sigs_per_staff,
+#                     s,
+#                     int(score_def != None),
+#                 ),
+#             ]
+
+#             open_tuplet = False
+
+#             notes_next_measure_per_staff = {}
+
+#             for chord_i in range(len(chords) - 1):
+#                 dur_dots, split_notes, first_temp_dur = (
+#                     next_dur_dots,
+#                     next_split_notes,
+#                     next_first_temp_dur,
+#                 )
+#                 (
+#                     next_dur_dots,
+#                     next_split_notes,
+#                     next_first_temp_dur,
+#                 ) = calc_dur_dots_split_notes_first_temp_dur(
+#                     chord_rep(chords, chord_i + 1),
+#                     m,
+#                     calc_num_to_numbase_ratio(chord_i + 1, chords, tuplet_indices),
+#                 )
+#                 tuplet_id_counter, open_beam, open_tuplet = process_chord(
+#                     chord_i,
+#                     chords,
+#                     inbetween_notes_elements,
+#                     open_beam,
+#                     auto_beaming,
+#                     parents,
+#                     dur_dots,
+#                     split_notes,
+#                     first_temp_dur,
+#                     tuplet_indices,
+#                     ties,
+#                     m,
+#                     layer,
+#                     tuplet_id_counter,
+#                     open_tuplet,
+#                     last_key_sig,
+#                     note_alterations,
+#                     notes_next_measure_per_staff,
+#                     next_dur_dots,
+#                 )
+
+#             tuplet_id_counter, _, _ = process_chord(
+#                 len(chords) - 1,
+#                 chords,
+#                 inbetween_notes_elements,
+#                 open_beam,
+#                 auto_beaming,
+#                 parents,
+#                 next_dur_dots,
+#                 next_split_notes,
+#                 next_first_temp_dur,
+#                 tuplet_indices,
+#                 ties,
+#                 m,
+#                 layer,
+#                 tuplet_id_counter,
+#                 open_tuplet,
+#                 last_key_sig,
+#                 note_alterations,
+#                 notes_next_measure_per_staff,
+#             )
+
+#             ties_per_staff_per_voice[voice] = ties
+
+#         ties_per_staff[s] = ties_per_staff_per_voice
+
+#     for fermata in current_measure_content.fermatas:
+#         tstamp = fermata[0]
+#         fermata_staff = fermata[1]
+
+#         f = add_child(measure, "fermata")
+#         set_attributes(f, ("staff", fermata_staff), ("tstamp", tstamp))
+
+#     for slur in current_measure_content.slurs:
+#         s = add_child(measure, "slur")
+#         if slur.start_note == None or slur.end_note == None:
+#             raise ValueError("Slur is missing start or end")
+#         set_attributes(
+#             s,
+#             ("staff", slur.start_note.staff),
+#             ("startid", "#" + slur.start_note.id),
+#             ("endid", "#" + slur.end_note.id),
+#         )
+
+#     for tstamp, word in current_measure_content.dirs:
+#         d = add_child(measure, "dir")
+#         set_attributes(d, ("staff", word.staff), ("tstamp", tstamp))
+#         d.text = word.text
+
+#     # smufl individual notes start with E1
+#     # these are the last 2 digits of the codes
+#     metronome_codes = {
+#         "breve": "D0",
+#         "whole": "D2",
+#         "half": "D3",
+#         "h": "D3",
+#         "quarter": "D5",
+#         "q": "D5",
+#         "eighth": "D7",
+#         "e": "D5",
+#         "16th": "D9",
+#         "32nd": "DB",
+#         "64th": "DD",
+#         "128th": "DF",
+#         "256th": "E1",
+#     }
+
+#     for tstamp, staff, tempo in current_measure_content.tempii:
+#         t = add_child(measure, "tempo")
+#         set_attributes(t, ("staff", staff), ("tstamp", tstamp))
+
+#         unit = str(tempo.unit)
+
+#         dots = unit.count(".")
+
+#         unit = unit[:-dots]
+
+#         string_to_build = [
+#             ' <rend fontname="VerovioText">&#xE1',
+#             metronome_codes[unit or "q"],
+#             ";",
+#         ]
+
+#         for i in range(dots):
+#             string_to_build.append("&#xE1E7;")
+
+#         string_to_build.append("</rend> = ")
+#         string_to_build.append(str(tempo.bpm))
+
+#         t.text = "".join(string_to_build)
+
+#     for tstamp, tstamp2, dynam in current_measure_content.dynams:
+#         if isinstance(dynam, score.DynamicLoudnessDirection):
+#             d = add_child(measure, "hairpin")
+#             form = (
+#                 "cres"
+#                 if isinstance(dynam, score.IncreasingLoudnessDirection)
+#                 else "dim"
+#             )
+#             set_attributes(d, ("form", form))
+
+#             # duration can also matter for other dynamics, might want to move this out of branch
+#             if tstamp2 != None:
+#                 set_attributes(d, ("tstamp2", tstamp2))
+#         else:
+#             d = add_child(measure, "dynam")
+#             d.text = dynam.text
+
+#         set_attributes(d, ("staff", dynam.staff), ("tstamp", tstamp))
+
+#     for s, tps in ties_per_staff.items():
+
+#         for v, tpspv in tps.items():
+
+#             for ties in tpspv.values():
+
+#                 for i in range(len(ties) - 1):
+#                     tie = add_child(measure, "tie")
+
+#                     set_attributes(
+#                         tie,
+#                         ("staff", s),
+#                         ("startid", "#" + ties[i]),
+#                         ("endid", "#" + ties[i + 1]),
+#                     )
+
+#     for s, k in current_measure_content.key_sigs_per_staff.items():
+#         if len(k) > 0:
+#             last_key_sig_per_staff[s] = max(k, key=lambda k: k.start.t)
+
+#     return tuplet_id_counter, notes_next_measure_per_staff
+
+
+# def unpack_part_group(part_grp, parts=[]):
+#     """
+#     Recursively gather individual parts into a list, flattening the tree of parts so to say
+
+#     Parameters
+#     ----------
+#     part_grp:    score.PartGroup
+#     parts:      list of score.Part, optional
+
+#     Returns
+#     -------
+#     parts:      list of score.Part
+#     """
+#     for c in part_grp.children:
+#         if isinstance(c, score.PartGroup):
+#             unpack_part_group(c, parts)
+#         else:
+#             parts.append(c)
+
+#     return parts
+
+
+# def save_mei(
+#     parts,
+#     auto_beaming=True,
+#     file_name="testResult",
+#     title_text=None,
+#     proper_staff_grp=False,
+# ):
+#     """
+#     creates an MEI document based on the parts provided
+#     So far only <score> is used and not <part> which means all the parts are gathered in one whole score and
+#     no individual scores are defined for individual parts
+
+#     Parameters
+#     ----------
+#     parts:              score.Part, score.PartGroup or list of score.Part
+#     auto_beaming:       boolean, optional
+#         if all beaming has been done manually then set to False
+#         otherwise this flag can be used to enable automatic beaming (beaming rules are still in progess)
+#     file_name:          string, optional
+#         should not contain file extension, .mei will be added automatically
+#     title_text:         string, optional
+#         name of the piece, e.g. "Klaviersonate Nr. 14" or "WAP"
+#         if not provided, a title will be derived from file_name
+#     proper_staff_grp:   boolean, optional
+#         if true,    group staves per part
+#         else        group all staves together
+#         default is false because Verovio doesn't seem to render multiple staff groups correctly (but that just might be because multiple staff groups are not generated correctly in this function)
+#     """
+
+#     if isinstance(parts, score.PartGroup):
+#         parts = unpack_part_group(parts)
+#     elif isinstance(parts, score.Part):
+#         parts = [parts]
+
+#     for p in parts:
+#         score.sanitize_part(p)
+
+#     mei = etree.Element("mei")
+
+#     mei_head = add_child(mei, "meiHead")
+#     music = add_child(mei, "music")
+
+#     mei_head.set("xmlns", name_space)
+#     file_desc = add_child(mei_head, "fileDesc")
+#     title_stmt = add_child(file_desc, "titleStmt")
+#     pub_stmt = add_child(file_desc, "pubStmt")
+#     title = add_child(title_stmt, "title")
+#     title.set("type", "main")
+
+#     # derive a title for the piece from the file_name
+#     if title_text == None:
+#         cursor = len(file_name) - 1
+#         while cursor >= 0 and file_name[cursor] != "/":
+#             cursor -= 1
+
+#         tmp = file_name[cursor + 1 :].split("_")
+#         tmp = [s[:1].upper() + s[1:] for s in tmp]
+#         title.text = " ".join(tmp)
+#     else:
+#         title.text = title_text
+
+#     body = add_child(music, "body")
+#     mdiv = add_child(body, "mdiv")
+#     mei_score = add_child(mdiv, "score")
+
+#     classes_with_staff = [score.GenericNote, score.Words, score.Direction]
+
+#     staves_per_part = []
+
+#     staves_are_valid = True
+
+#     for p in parts:
+#         tmp = {
+#             staffed_obj.staff
+#             for cls in classes_with_staff
+#             for staffed_obj in p.iter_all(cls, include_subclasses=True)
+#         }
+#         tmp = tmp.union({clef.number for clef in p.iter_all(score.Clef)})
+#         staves_per_part.append(list(tmp))
+
+#         if None in staves_per_part[-1]:
+#             staves_are_valid = False
+#             staves_per_part[-1].remove(None)
+
+#             staves_per_part[-1].append(
+#                 (max(staves_per_part[-1]) if len(staves_per_part[-1]) > 0 else 0) + 1
+#             )
+
+#         staves_per_part[-1].sort()
+
+#     if staves_are_valid:
+#         staves_sorted = sorted([s for staves in staves_per_part for s in staves])
+
+#         i = 0
+
+#         while i + 1 < len(staves_sorted):
+#             if staves_sorted[i] == staves_sorted[i + 1]:
+#                 staves_are_valid = False
+#                 break
+
+#             i += 1
+
+#     if not staves_are_valid:
+#         staves_per_part_backup = staves_per_part
+
+#         staves_sorted = []
+#         staves_per_part = []
+
+#         # ASSUMPTION: staves are >0
+#         max_staff = 0
+#         for staves in staves_per_part_backup:
+#             if len(staves) == 0:
+#                 staves_per_part.append([])
+#             else:
+#                 shift = [s + max_staff for s in staves]
+
+#                 max_staff += max(staves)
+
+#                 staves_sorted.extend(shift)
+#                 staves_per_part.append(shift)
+
+#         # staves_sorted.sort()
+
+#         max_staff = 0
+#         for i, p in enumerate(parts):
+#             for cls in classes_with_staff:
+#                 for staff_obj in p.iter_all(cls, include_subclasses=True):
+#                     staff_obj.staff = max_staff + (
+#                         staff_obj.staff
+#                         if staff_obj.staff != None
+#                         else max(staves_per_part_backup[i])
+#                     )
+
+#             for clef in p.iter_all(score.Clef):
+#                 clef.number = max_staff + (
+#                     clef.number
+#                     if clef.number != None
+#                     else max(staves_per_part_backup[i])
+#                 )
+
+#             max_staff += (
+#                 max(staves_per_part_backup[i])
+#                 if len(staves_per_part_backup[i]) > 0
+#                 else 0
+#             )
+
+#     measures = [list(parts[0].iter_all(score.Measure))]
+#     padding_required = False
+#     max_length = len(measures[0])
+#     for i in range(1, len(parts)):
+#         m = list(parts[i].iter_all(score.Measure))
+
+#         if len(m) > max_length:
+#             max_length = len(m)
+
+#         if not padding_required:
+#             padding_required = len(m) != len(measures[0])
+
+#         measures.append(m)
+
+#     score_def = create_score_def(measures, 0, parts, mei_score)
+
+#     score_def_setup = score_def
+
+#     if score_def == None:
+#         score_def_setup = add_child(mei_score, "scoreDef")
+
+#     clefs_per_part = first_instances_per_part(score.Clef, parts)
+
+#     for i in idx(clefs_per_part):
+#         clefs_per_part[i] = partition_handle_none(
+#             lambda c: c.number, clefs_per_part[i], "number"
+#         )
+
+#     if len(clefs_per_part) == 0:
+#         create_staff_def(
+#             staff_grp, score.Clef(sign="G", line=2, number=1, octave_change=0)
+#         )
+#     else:
+#         staff_grp = add_child(score_def_setup, "staffGrp")
+#         for staves in staves_per_part:
+#             if proper_staff_grp:
+#                 staff_grp = add_child(score_def_setup, "staffGrp")
+
+#             for s in staves:
+#                 clefs = None
+
+#                 for clefs_per_staff in clefs_per_part:
+#                     if s in clefs_per_staff.keys():
+#                         clefs = clefs_per_staff[s]
+#                         break
+
+#                 if clefs != None:
+#                     clef = clefs[0]
+#                     if len(clefs) != 1:
+#                         raise ValueError(
+#                             "ERROR at staff_def creation: Staff "
+#                             + str(clef.number)
+#                             + " starts with more than 1 clef at t=0"
+#                         )
+#                     create_staff_def(staff_grp, clef)
+#                 else:
+#                     create_staff_def(
+#                         staff_grp,
+#                         score.Clef(sign="G", line=2, number=s, octave_change=0),
+#                     )
+
+#     section = add_child(mei_score, "section")
+
+#     measures_are_aligned = True
+#     if padding_required:
+#         cursors = [0] * len(measures)
+#         tempii = [None] * len(measures)
+
+#         while measures_are_aligned:
+#             compare_measures = {}
+#             for i, m in enumerate(measures):
+#                 if cursors[i] < len(m):
+#                     compare_measures[i] = m[cursors[i]]
+#                     cursors[i] += 1
+
+#             if len(compare_measures) == 0:
+#                 break
+
+#             compm_keys = list(compare_measures.keys())
+
+#             new_tempii = first_instance_per_part(
+#                 score.Tempo,
+#                 [p for i, p in enumerate(parts) if i in compm_keys],
+#                 start=[cm.start for cm in compare_measures.values()],
+#                 end=[cm.end for cm in compare_measures.values()],
+#             )
+
+#             if len(new_tempii) == 0:
+#                 for k in compm_keys:
+#                     new_tempii.append(tempii[k])
+#             else:
+#                 for i, nt in enumerate(new_tempii):
+#                     if nt == None:
+#                         new_tempii[i] = tempii[compm_keys[i]]
+#                     else:
+#                         tempii[compm_keys[i]] = nt
+
+#             def norm_dur(m):
+#                 return (m.end.t - m.start.t) // m.start.quarter
+
+#             rep_i = 0
+#             while rep_i < len(new_tempii) and new_tempii[rep_i] == None:
+#                 rep_i += 1
+
+#             if rep_i == len(new_tempii):
+#                 continue
+
+#             rep_dur = (
+#                 norm_dur(compare_measures[compm_keys[rep_i]]) * new_tempii[rep_i].bpm
+#             )
+
+#             for i in range(rep_i + 1, len(compm_keys)):
+#                 nt = new_tempii[i]
+
+#                 if nt == None:
+#                     continue
+
+#                 m = compare_measures[compm_keys[i]]
+#                 dur = norm_dur(m) * new_tempii[i].bpm
+
+#                 if dur != rep_dur:
+#                     measures_are_aligned = False
+#                     break
+
+#     tuplet_id_counter = 0
+
+#     if measures_are_aligned:
+#         time_offset = [0] * len(measures)
+
+#         if padding_required:
+#             for i, mp in enumerate(measures):
+#                 ii = len(mp)
+#                 time_offset[i] = mp[ii - 1].end.t
+#                 while ii < max_length:
+#                     mp.append("pad")
+#                     ii += 1
+
+#         notes_last_measure_per_staff = {}
+#         auto_rest_count = 0
+
+#         notes_within_measure_per_staff = notes_last_measure_per_staff
+
+#         auto_rest_count, current_measure_content = extract_from_measures(
+#             parts,
+#             measures,
+#             0,
+#             staves_per_part,
+#             auto_rest_count,
+#             notes_within_measure_per_staff,
+#         )
+
+#         last_key_sig_per_staff = {}
+
+#         for s, k in current_measure_content.key_sigs_per_staff.items():
+#             last_key_sig_per_staff[s] = (
+#                 min(k, key=lambda k: k.start.t) if len(k) > 0 else None
+#             )
+
+#         tuplet_id_counter, notes_last_measure_per_staff = create_measure(
+#             section,
+#             0,
+#             staves_sorted,
+#             notes_within_measure_per_staff,
+#             score_def,
+#             tuplet_id_counter,
+#             auto_beaming,
+#             last_key_sig_per_staff,
+#             current_measure_content,
+#         )
+
+#         for measure_i in range(1, len(measures[0])):
+#             notes_within_measure_per_staff = notes_last_measure_per_staff
+
+#             auto_rest_count, current_measure_content = extract_from_measures(
+#                 parts,
+#                 measures,
+#                 measure_i,
+#                 staves_per_part,
+#                 auto_rest_count,
+#                 notes_within_measure_per_staff,
+#             )
+
+#             score_def = create_score_def(measures, measure_i, parts, section)
+
+#             tuplet_id_counter, notes_last_measure_per_staff = create_measure(
+#                 section,
+#                 measure_i,
+#                 staves_sorted,
+#                 notes_within_measure_per_staff,
+#                 score_def,
+#                 tuplet_id_counter,
+#                 auto_beaming,
+#                 last_key_sig_per_staff,
+#                 current_measure_content,
+#             )
+
+#     (etree.ElementTree(mei)).write(file_name + ".mei", pretty_print=True)
+
+#     # post processing step necessary
+#     # etree won't write <,> and & into an element's text
+#     with open(file_name + ".mei") as result:
+#         text = list(result.read())
+#         new_text = []
+
+#         i = 0
+#         while i < len(text):
+#             ch = text[i]
+#             if ch == "&":
+#                 if text[i + 1 : i + 4] == ["l", "t", ";"]:
+#                     ch = "<"
+#                     i += 4
+#                 elif text[i + 1 : i + 4] == ["g", "t", ";"]:
+#                     ch = ">"
+#                     i += 4
+#                 elif text[i + 1 : i + 5] == ["a", "m", "p", ";"]:
+#                     i += 5
+#                 else:
+#                     i += 1
+#             else:
+#                 i += 1
+
+#             new_text.append(ch)
+
+#         new_text = "".join(new_text)
+
+#     with open(file_name + ".mei", "w") as result:
+#         result.write(new_text)
```

### Comparing `partitura-1.2.1/partitura/io/exportmidi.py` & `partitura-1.2.2/partitura/io/exportmidi.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,428 +1,428 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for exporting MIDI files
-"""
-import numpy as np
-
-from collections import defaultdict, OrderedDict
-from typing import Optional, Iterable
-
-from mido import MidiFile, MidiTrack, Message, MetaMessage
-
-import partitura.score as score
-from partitura.score import Score, Part, PartGroup, ScoreLike
-from partitura.performance import Performance, PerformedPart, PerformanceLike
-from partitura.utils import partition
-
-from partitura.utils.misc import deprecated_alias, PathLike
-
-__all__ = ["save_score_midi", "save_performance_midi"]
-
-
-def get_partgroup(part):
-    parent = part
-    while parent.parent:
-        parent = parent.parent
-    return parent
-
-
-def map_to_track_channel(note_keys, mode):
-    ch_helper = {}
-    tr_helper = {}
-    track = {}
-    channel = {}
-    for (pg, p, v) in note_keys:
-        if mode == 0:
-            trk = tr_helper.setdefault(p, len(tr_helper))
-            ch1 = ch_helper.setdefault(p, {})
-            ch2 = ch1.setdefault(v, len(ch1) + 1)
-            track[(pg, p, v)] = trk
-            channel[(pg, p, v)] = ch2
-        elif mode == 1:
-            trk = tr_helper.setdefault(pg, len(tr_helper))
-            ch1 = ch_helper.setdefault(pg, {})
-            ch2 = ch1.setdefault(p, len(ch1) + 1)
-            track[(pg, p, v)] = trk
-            channel[(pg, p, v)] = ch2
-        elif mode == 2:
-            track[(pg, p, v)] = 0
-            ch = ch_helper.setdefault(p, len(ch_helper) + 1)
-            channel[(pg, p, v)] = ch
-        elif mode == 3:
-            trk = tr_helper.setdefault(p, len(tr_helper))
-            track[(pg, p, v)] = trk
-            channel[(pg, p, v)] = 1
-        elif mode == 4:
-            track[(pg, p, v)] = 0
-            channel[(pg, p, v)] = 1
-        elif mode == 5:
-            trk = tr_helper.setdefault((p, v), len(tr_helper))
-            track[(pg, p, v)] = trk
-            channel[(pg, p, v)] = 1
-        else:
-            raise Exception("unsupported part/voice assign mode {}".format(mode))
-
-    result = dict((k, (track.get(k, 0), channel.get(k, 1))) for k in note_keys)
-    # for (pg, p, voice), v in result.items():
-    #     pgn = pg.group_name if hasattr(pg, 'group_name') else pg.id
-    #     print(pgn, p.id, voice)
-    #     print(v)
-    #     print()
-    return result
-
-
-def get_ppq(parts):
-    ppqs = np.concatenate(
-        [part.quarter_durations()[:, 1] for part in score.iter_parts(parts)]
-    )
-    ppq = np.lcm.reduce(ppqs)
-    return ppq
-
-
-@deprecated_alias(performed_part="performance_data")
-def save_performance_midi(
-    performance_data: PerformanceLike,
-    out: Optional[PathLike],
-    mpq: int = 500000,
-    ppq: int = 480,
-    default_velocity: int = 64,
-) -> Optional[MidiFile]:
-    """Save a :class:`~partitura.performance.PerformedPart` or
-    a :class:`~partitura.performance.Performance` as a MIDI file
-
-    Parameters
-    ----------
-    performance_data : PerformanceLike
-        The performance to be saved.
-    out : str or file-like object
-        Either a filename or a file-like object to write the MIDI data
-        to.
-    mpq : int, optional
-        Microseconds per quarter note. This is known in MIDI parlance
-        as the "tempo" value. Defaults to 500000 (i.e. 120 BPM).
-    ppq : int, optional
-        Parts per quarter, also known as ticks per beat. Defaults to
-        480.
-    default_velocity : int, optional
-        A default velocity value (between 0 and 127) to be used for
-        notes without a specified velocity. Defaults to 64.
-
-    Returns
-    -------
-    None or MidiFile
-        If no output is specified using `out`, the function returns
-        a `MidiFile` object. Otherwise, the function returns None.
-    """
-
-    if isinstance(performance_data, Performance):
-        performed_parts = performance_data.performedparts
-    elif isinstance(performance_data, PerformedPart):
-        performed_parts = [performance_data]
-    elif isinstance(performance_data, Iterable):
-        if not all(isinstance(pp, PerformedPart) for pp in performance_data):
-            raise ValueError(
-                "`performance_data` should be a `Performance`, a `PerformedPart`,"
-                " or a list of  `PerformedPart` instances"
-            )
-        performed_parts = performed_parts
-
-    else:
-        raise ValueError(
-            "`performance_data` should be a `Performance`, a `PerformedPart`,"
-            f" or a list of  `PerformedPart` instances but is {type(performance_data)}"
-        )
-
-    track_events = defaultdict(lambda: defaultdict(list))
-
-    for performed_part in performed_parts:
-        for c in performed_part.controls:
-            track = c.get("track", 0)
-            ch = c.get("channel", 1)
-            t = int(np.round(10 ** 6 * ppq * c["time"] / mpq))
-            track_events[track][t].append(
-                Message(
-                    "control_change",
-                    control=c["number"],
-                    value=c["value"],
-                    channel=ch,
-                )
-            )
-
-        for n in performed_part.notes:
-            track = n.get("track", 0)
-            ch = n.get("channel", 1)
-            t_on = int(np.round(10 ** 6 * ppq * n["note_on"] / mpq))
-            t_off = int(np.round(10 ** 6 * ppq * n["note_off"] / mpq))
-            vel = n.get("velocity", default_velocity)
-            track_events[track][t_on].append(
-                Message("note_on", note=n["midi_pitch"], velocity=vel, channel=ch)
-            )
-            track_events[track][t_off].append(
-                Message("note_off", note=n["midi_pitch"], velocity=0, channel=ch)
-            )
-
-        for p in performed_part.programs:
-            track = p.get("track", 0)
-            ch = p.get("channel", 1)
-            t = int(np.round(10 ** 6 * ppq * p["time"] / mpq))
-            track_events[track][t].append(
-                Message("program_change", program=int(p["program"]), channel=ch)
-            )
-
-        if len(performed_part.programs) == 0:
-            # Add default program (to each track/channel)
-            channels_and_tracks = np.array(
-                list(
-                    set(
-                        [
-                            (c.get("channel", 1), c.get("track", 0))
-                            for c in performed_part.controls
-                        ]
-                        + [
-                            (n.get("channel", 1), n.get("track", 0))
-                            for n in performed_part.notes
-                        ]
-                    )
-                ),
-                dtype=int,
-            )
-
-            timepoints = []
-            for tr in track_events.keys():
-                timepoints += list(track_events[tr].keys())
-            timepoints = list(set(timepoints))
-
-            for tr in np.unique(channels_and_tracks[:, 1]):
-                channel_idxs = np.where(channels_and_tracks[:, 1] == tr)[0]
-                track_channels = np.unique(channels_and_tracks[channel_idxs, 0])
-                for ch in track_channels:
-                    track_events[tr][min(timepoints)].append(
-                        Message("program_change", program=0, channel=ch)
-                    )
-
-    midi_type = 0 if len(track_events) == 1 else 1
-
-    mf = MidiFile(type=midi_type, ticks_per_beat=ppq)
-
-    for j, i in enumerate(sorted(track_events.keys())):
-        track = MidiTrack()
-        mf.tracks.append(track)
-        if j == 0:
-            track.append(MetaMessage("set_tempo", tempo=mpq, time=0))
-        t = 0
-        for t_msg in sorted(track_events[i].keys()):
-            t_delta = t_msg - t
-            for msg in track_events[i][t_msg]:
-                track.append(msg.copy(time=t_delta))
-                t_delta = 0
-            t = t_msg
-    if out is not None:
-        if hasattr(out, "write"):
-            mf.save(file=out)
-        else:
-            mf.save(out)
-    else:
-        return mf
-
-
-@deprecated_alias(parts="score_data")
-def save_score_midi(
-    score_data: ScoreLike,
-    out: Optional[PathLike],
-    part_voice_assign_mode: int = 0,
-    velocity: int = 64,
-    anacrusis_behavior: str = "shift",
-) -> Optional[MidiFile]:
-    """Write data from Part objects to a MIDI file
-
-    Parameters
-    ----------
-    score_data : Score, list, Part, or PartGroup
-        The musical score to be saved. A :class:`partitura.score.Score` object,
-        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
-        a list of these.
-    out : str or file-like object
-        Either a filename or a file-like object to write the MIDI data
-        to.
-    part_voice_assign_mode : {0, 1, 2, 3, 4, 5}, optional
-        This keyword controls how part and voice information is
-        associated to track and channel information in the MIDI file.
-        The semantics of the modes is as follows:
-
-        0
-            Write one track for each Part, with channels assigned by
-            voices
-        1
-            Write one track for each PartGroup, with channels assigned by
-            Parts (voice info is lost) (There can be multiple levels of
-            partgroups, I suggest using the highest level of
-            partgroup/part) [note: this will e.g. lead to all strings into
-            the same track] Each part not in a PartGroup will be assigned
-            its own track
-        2
-            Write a single track with channels assigned by Part (voice
-            info is lost)
-        3
-            Write one track per Part, and a single channel for all voices
-            (voice info is lost)
-        4
-            Write a single track with a single channel (Part and voice
-            info is lost)
-        5
-            Return one track per <Part, voice> combination, each track
-            having a single channel.
-
-        The default mode is 0.
-    velocity : int, optional
-        Default velocity for all MIDI notes. Defaults to 64.
-    anacrusis_behavior : {"shift", "pad_bar"}, optional
-        Strategy to deal with anacrusis. If "shift", all
-        time points are shifted by the anacrusis (i.e., the first
-        note starts at 0). If "pad_bar", the "incomplete" bar  of
-        the anacrusis is padded with silence. Defaults to 'shift'.
-
-    Returns
-    -------
-    None or MidiFile
-        If no output is specified using `out`, the function returns
-        a `MidiFile` object. Otherwise, the function returns None.
-    """
-
-    if isinstance(score_data, Score):
-        parts = score_data.parts
-    elif isinstance(score_data, (Part, PartGroup)):
-        parts = [score_data]
-    elif isinstance(score_data, Iterable):
-        parts = score_data
-
-    else:
-        raise ValueError(
-            "`score_data` should be a `Score`, a `Part`, a `PartGroup"
-            f" or a list of  `Part` instances but is {type(score_data)}"
-        )
-    ppq = get_ppq(parts)
-
-    events = defaultdict(lambda: defaultdict(list))
-    meta_events = defaultdict(lambda: defaultdict(list))
-
-    event_keys = OrderedDict()
-    tempos = {}
-
-    quarter_maps = [part.quarter_map for part in score.iter_parts(parts)]
-
-    first_time_point = min(qm(0) for qm in quarter_maps)
-
-    ftp = 0
-    # Deal with anacrusis
-    if first_time_point < 0:
-        if anacrusis_behavior == "shift":
-            ftp = first_time_point
-        elif anacrusis_behavior == "pad_bar":
-            time_signatures = []
-            for qm, part in zip(quarter_maps, score.iter_parts(parts)):
-                ts_beats, ts_beat_type, ts_mus_beats = part.time_signature_map(0)
-                time_signatures.append((ts_beats, ts_beat_type, qm(0)))
-            # sort ts according to time
-            time_signatures.sort(key=lambda x: x[2])
-            ftp = -time_signatures[0][0] / (time_signatures[0][1] / 4)
-        else:
-            raise Exception(
-                'Invalid anacrusis_behavior value, must be one of ("shift", "pad_bar")'
-            )
-
-    for qm, part in zip(quarter_maps, score.iter_parts(parts)):
-
-        pg = get_partgroup(part)
-
-        notes = part.notes_tied
-
-        def to_ppq(t):
-            # convert div times to new ppq
-            return int(ppq * (qm(t) - ftp))
-
-        for tp in part.iter_all(score.Tempo):
-            tempos[to_ppq(tp.start.t)] = MetaMessage(
-                "set_tempo", tempo=tp.microseconds_per_quarter
-            )
-
-        for ts in part.iter_all(score.TimeSignature):
-            meta_events[part][to_ppq(ts.start.t)].append(
-                MetaMessage(
-                    "time_signature", numerator=ts.beats, denominator=ts.beat_type
-                )
-            )
-
-        for ks in part.iter_all(score.KeySignature):
-            meta_events[part][to_ppq(ks.start.t)].append(
-                MetaMessage("key_signature", key=ks.name)
-            )
-
-        for note in notes:
-
-            # key is a tuple (part_group, part, voice) that will be
-            # converted into a (track, channel) pair.
-            key = (pg, part, note.voice)
-            events[key][to_ppq(note.start.t)].append(
-                Message("note_on", note=note.midi_pitch)
-            )
-            events[key][to_ppq(note.start.t + note.duration_tied)].append(
-                Message("note_off", note=note.midi_pitch)
-            )
-            event_keys[key] = True
-
-    tr_ch_map = map_to_track_channel(list(event_keys.keys()), part_voice_assign_mode)
-
-    # replace original event keys (partgroup, part, voice) by (track, ch) keys:
-    for key in list(events.keys()):
-        evs_by_time = events[key]
-        del events[key]
-        tr, ch = tr_ch_map[key]
-        for t, evs in evs_by_time.items():
-            events[tr][t].extend((ev.copy(channel=ch) for ev in evs))
-
-    # figure out in which tracks to replicate the time/key signatures of each part
-    part_track_map = partition(lambda x: x[0][1], tr_ch_map.items())
-    for part, rest in part_track_map.items():
-        part_track_map[part] = set(x[1][0] for x in rest)
-
-    # add the time/key sigs to their corresponding tracks
-    for part, m_events in meta_events.items():
-        tracks = part_track_map[part]
-        for tr in tracks:
-            for t, me in m_events.items():
-                events[tr][t] = me + events[tr][t]
-
-    n_tracks = max(tr for tr, _ in tr_ch_map.values()) + 1
-    tracks = [MidiTrack() for _ in range(n_tracks)]
-
-    # tempo events are handled differently from key/time sigs because the have a
-    # global effect. Instead of adding to each relevant track, like the key/time
-    # sig events, we add them only to the first track
-    for t, tp in tempos.items():
-        events[0][t].insert(0, tp)
-
-    for tr, events_by_time in events.items():
-        t_prev = 0
-        for t in sorted(events_by_time.keys()):
-            evs = events_by_time[t]
-            delta = t - t_prev
-            for ev in evs:
-                tracks[tr].append(ev.copy(time=delta))
-                delta = 0
-            t_prev = t
-
-    midi_type = 0 if n_tracks == 1 else 1
-
-    mf = MidiFile(type=midi_type, ticks_per_beat=ppq)
-
-    for track in tracks:
-        mf.tracks.append(track)
-
-    if out:
-        if hasattr(out, "write"):
-            mf.save(file=out)
-        else:
-            mf.save(out)
-    else:
-        return mf
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for exporting MIDI files
+"""
+import numpy as np
+
+from collections import defaultdict, OrderedDict
+from typing import Optional, Iterable
+
+from mido import MidiFile, MidiTrack, Message, MetaMessage
+
+import partitura.score as score
+from partitura.score import Score, Part, PartGroup, ScoreLike
+from partitura.performance import Performance, PerformedPart, PerformanceLike
+from partitura.utils import partition
+
+from partitura.utils.misc import deprecated_alias, PathLike
+
+__all__ = ["save_score_midi", "save_performance_midi"]
+
+
+def get_partgroup(part):
+    parent = part
+    while parent.parent:
+        parent = parent.parent
+    return parent
+
+
+def map_to_track_channel(note_keys, mode):
+    ch_helper = {}
+    tr_helper = {}
+    track = {}
+    channel = {}
+    for (pg, p, v) in note_keys:
+        if mode == 0:
+            trk = tr_helper.setdefault(p, len(tr_helper))
+            ch1 = ch_helper.setdefault(p, {})
+            ch2 = ch1.setdefault(v, len(ch1) + 1)
+            track[(pg, p, v)] = trk
+            channel[(pg, p, v)] = ch2
+        elif mode == 1:
+            trk = tr_helper.setdefault(pg, len(tr_helper))
+            ch1 = ch_helper.setdefault(pg, {})
+            ch2 = ch1.setdefault(p, len(ch1) + 1)
+            track[(pg, p, v)] = trk
+            channel[(pg, p, v)] = ch2
+        elif mode == 2:
+            track[(pg, p, v)] = 0
+            ch = ch_helper.setdefault(p, len(ch_helper) + 1)
+            channel[(pg, p, v)] = ch
+        elif mode == 3:
+            trk = tr_helper.setdefault(p, len(tr_helper))
+            track[(pg, p, v)] = trk
+            channel[(pg, p, v)] = 1
+        elif mode == 4:
+            track[(pg, p, v)] = 0
+            channel[(pg, p, v)] = 1
+        elif mode == 5:
+            trk = tr_helper.setdefault((p, v), len(tr_helper))
+            track[(pg, p, v)] = trk
+            channel[(pg, p, v)] = 1
+        else:
+            raise Exception("unsupported part/voice assign mode {}".format(mode))
+
+    result = dict((k, (track.get(k, 0), channel.get(k, 1))) for k in note_keys)
+    # for (pg, p, voice), v in result.items():
+    #     pgn = pg.group_name if hasattr(pg, 'group_name') else pg.id
+    #     print(pgn, p.id, voice)
+    #     print(v)
+    #     print()
+    return result
+
+
+def get_ppq(parts):
+    ppqs = np.concatenate(
+        [part.quarter_durations()[:, 1] for part in score.iter_parts(parts)]
+    )
+    ppq = np.lcm.reduce(ppqs)
+    return ppq
+
+
+@deprecated_alias(performed_part="performance_data")
+def save_performance_midi(
+    performance_data: PerformanceLike,
+    out: Optional[PathLike],
+    mpq: int = 500000,
+    ppq: int = 480,
+    default_velocity: int = 64,
+) -> Optional[MidiFile]:
+    """Save a :class:`~partitura.performance.PerformedPart` or
+    a :class:`~partitura.performance.Performance` as a MIDI file
+
+    Parameters
+    ----------
+    performance_data : PerformanceLike
+        The performance to be saved.
+    out : str or file-like object
+        Either a filename or a file-like object to write the MIDI data
+        to.
+    mpq : int, optional
+        Microseconds per quarter note. This is known in MIDI parlance
+        as the "tempo" value. Defaults to 500000 (i.e. 120 BPM).
+    ppq : int, optional
+        Parts per quarter, also known as ticks per beat. Defaults to
+        480.
+    default_velocity : int, optional
+        A default velocity value (between 0 and 127) to be used for
+        notes without a specified velocity. Defaults to 64.
+
+    Returns
+    -------
+    None or MidiFile
+        If no output is specified using `out`, the function returns
+        a `MidiFile` object. Otherwise, the function returns None.
+    """
+
+    if isinstance(performance_data, Performance):
+        performed_parts = performance_data.performedparts
+    elif isinstance(performance_data, PerformedPart):
+        performed_parts = [performance_data]
+    elif isinstance(performance_data, Iterable):
+        if not all(isinstance(pp, PerformedPart) for pp in performance_data):
+            raise ValueError(
+                "`performance_data` should be a `Performance`, a `PerformedPart`,"
+                " or a list of  `PerformedPart` instances"
+            )
+        performed_parts = performed_parts
+
+    else:
+        raise ValueError(
+            "`performance_data` should be a `Performance`, a `PerformedPart`,"
+            f" or a list of  `PerformedPart` instances but is {type(performance_data)}"
+        )
+
+    track_events = defaultdict(lambda: defaultdict(list))
+
+    for performed_part in performed_parts:
+        for c in performed_part.controls:
+            track = c.get("track", 0)
+            ch = c.get("channel", 1)
+            t = int(np.round(10**6 * ppq * c["time"] / mpq))
+            track_events[track][t].append(
+                Message(
+                    "control_change",
+                    control=c["number"],
+                    value=c["value"],
+                    channel=ch,
+                )
+            )
+
+        for n in performed_part.notes:
+            track = n.get("track", 0)
+            ch = n.get("channel", 1)
+            t_on = int(np.round(10**6 * ppq * n["note_on"] / mpq))
+            t_off = int(np.round(10**6 * ppq * n["note_off"] / mpq))
+            vel = n.get("velocity", default_velocity)
+            track_events[track][t_on].append(
+                Message("note_on", note=n["midi_pitch"], velocity=vel, channel=ch)
+            )
+            track_events[track][t_off].append(
+                Message("note_off", note=n["midi_pitch"], velocity=0, channel=ch)
+            )
+
+        for p in performed_part.programs:
+            track = p.get("track", 0)
+            ch = p.get("channel", 1)
+            t = int(np.round(10**6 * ppq * p["time"] / mpq))
+            track_events[track][t].append(
+                Message("program_change", program=int(p["program"]), channel=ch)
+            )
+
+        if len(performed_part.programs) == 0:
+            # Add default program (to each track/channel)
+            channels_and_tracks = np.array(
+                list(
+                    set(
+                        [
+                            (c.get("channel", 1), c.get("track", 0))
+                            for c in performed_part.controls
+                        ]
+                        + [
+                            (n.get("channel", 1), n.get("track", 0))
+                            for n in performed_part.notes
+                        ]
+                    )
+                ),
+                dtype=int,
+            )
+
+            timepoints = []
+            for tr in track_events.keys():
+                timepoints += list(track_events[tr].keys())
+            timepoints = list(set(timepoints))
+
+            for tr in np.unique(channels_and_tracks[:, 1]):
+                channel_idxs = np.where(channels_and_tracks[:, 1] == tr)[0]
+                track_channels = np.unique(channels_and_tracks[channel_idxs, 0])
+                for ch in track_channels:
+                    track_events[tr][min(timepoints)].append(
+                        Message("program_change", program=0, channel=ch)
+                    )
+
+    midi_type = 0 if len(track_events) == 1 else 1
+
+    mf = MidiFile(type=midi_type, ticks_per_beat=ppq)
+
+    for j, i in enumerate(sorted(track_events.keys())):
+        track = MidiTrack()
+        mf.tracks.append(track)
+        if j == 0:
+            track.append(MetaMessage("set_tempo", tempo=mpq, time=0))
+        t = 0
+        for t_msg in sorted(track_events[i].keys()):
+            t_delta = t_msg - t
+            for msg in track_events[i][t_msg]:
+                track.append(msg.copy(time=t_delta))
+                t_delta = 0
+            t = t_msg
+    if out is not None:
+        if hasattr(out, "write"):
+            mf.save(file=out)
+        else:
+            mf.save(out)
+    else:
+        return mf
+
+
+@deprecated_alias(parts="score_data")
+def save_score_midi(
+    score_data: ScoreLike,
+    out: Optional[PathLike],
+    part_voice_assign_mode: int = 0,
+    velocity: int = 64,
+    anacrusis_behavior: str = "shift",
+) -> Optional[MidiFile]:
+    """Write data from Part objects to a MIDI file
+
+    Parameters
+    ----------
+    score_data : Score, list, Part, or PartGroup
+        The musical score to be saved. A :class:`partitura.score.Score` object,
+        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
+        a list of these.
+    out : str or file-like object
+        Either a filename or a file-like object to write the MIDI data
+        to.
+    part_voice_assign_mode : {0, 1, 2, 3, 4, 5}, optional
+        This keyword controls how part and voice information is
+        associated to track and channel information in the MIDI file.
+        The semantics of the modes is as follows:
+
+        0
+            Write one track for each Part, with channels assigned by
+            voices
+        1
+            Write one track for each PartGroup, with channels assigned by
+            Parts (voice info is lost) (There can be multiple levels of
+            partgroups, I suggest using the highest level of
+            partgroup/part) [note: this will e.g. lead to all strings into
+            the same track] Each part not in a PartGroup will be assigned
+            its own track
+        2
+            Write a single track with channels assigned by Part (voice
+            info is lost)
+        3
+            Write one track per Part, and a single channel for all voices
+            (voice info is lost)
+        4
+            Write a single track with a single channel (Part and voice
+            info is lost)
+        5
+            Return one track per <Part, voice> combination, each track
+            having a single channel.
+
+        The default mode is 0.
+    velocity : int, optional
+        Default velocity for all MIDI notes. Defaults to 64.
+    anacrusis_behavior : {"shift", "pad_bar"}, optional
+        Strategy to deal with anacrusis. If "shift", all
+        time points are shifted by the anacrusis (i.e., the first
+        note starts at 0). If "pad_bar", the "incomplete" bar  of
+        the anacrusis is padded with silence. Defaults to 'shift'.
+
+    Returns
+    -------
+    None or MidiFile
+        If no output is specified using `out`, the function returns
+        a `MidiFile` object. Otherwise, the function returns None.
+    """
+
+    if isinstance(score_data, Score):
+        parts = score_data.parts
+    elif isinstance(score_data, (Part, PartGroup)):
+        parts = [score_data]
+    elif isinstance(score_data, Iterable):
+        parts = score_data
+
+    else:
+        raise ValueError(
+            "`score_data` should be a `Score`, a `Part`, a `PartGroup"
+            f" or a list of  `Part` instances but is {type(score_data)}"
+        )
+    ppq = get_ppq(parts)
+
+    events = defaultdict(lambda: defaultdict(list))
+    meta_events = defaultdict(lambda: defaultdict(list))
+
+    event_keys = OrderedDict()
+    tempos = {}
+
+    quarter_maps = [part.quarter_map for part in score.iter_parts(parts)]
+
+    first_time_point = min(qm(0) for qm in quarter_maps)
+
+    ftp = 0
+    # Deal with anacrusis
+    if first_time_point < 0:
+        if anacrusis_behavior == "shift":
+            ftp = first_time_point
+        elif anacrusis_behavior == "pad_bar":
+            time_signatures = []
+            for qm, part in zip(quarter_maps, score.iter_parts(parts)):
+                ts_beats, ts_beat_type, ts_mus_beats = part.time_signature_map(0)
+                time_signatures.append((ts_beats, ts_beat_type, qm(0)))
+            # sort ts according to time
+            time_signatures.sort(key=lambda x: x[2])
+            ftp = -time_signatures[0][0] / (time_signatures[0][1] / 4)
+        else:
+            raise Exception(
+                'Invalid anacrusis_behavior value, must be one of ("shift", "pad_bar")'
+            )
+
+    for qm, part in zip(quarter_maps, score.iter_parts(parts)):
+
+        pg = get_partgroup(part)
+
+        notes = part.notes_tied
+
+        def to_ppq(t):
+            # convert div times to new ppq
+            return int(ppq * (qm(t) - ftp))
+
+        for tp in part.iter_all(score.Tempo):
+            tempos[to_ppq(tp.start.t)] = MetaMessage(
+                "set_tempo", tempo=tp.microseconds_per_quarter
+            )
+
+        for ts in part.iter_all(score.TimeSignature):
+            meta_events[part][to_ppq(ts.start.t)].append(
+                MetaMessage(
+                    "time_signature", numerator=ts.beats, denominator=ts.beat_type
+                )
+            )
+
+        for ks in part.iter_all(score.KeySignature):
+            meta_events[part][to_ppq(ks.start.t)].append(
+                MetaMessage("key_signature", key=ks.name)
+            )
+
+        for note in notes:
+
+            # key is a tuple (part_group, part, voice) that will be
+            # converted into a (track, channel) pair.
+            key = (pg, part, note.voice)
+            events[key][to_ppq(note.start.t)].append(
+                Message("note_on", note=note.midi_pitch)
+            )
+            events[key][to_ppq(note.start.t + note.duration_tied)].append(
+                Message("note_off", note=note.midi_pitch)
+            )
+            event_keys[key] = True
+
+    tr_ch_map = map_to_track_channel(list(event_keys.keys()), part_voice_assign_mode)
+
+    # replace original event keys (partgroup, part, voice) by (track, ch) keys:
+    for key in list(events.keys()):
+        evs_by_time = events[key]
+        del events[key]
+        tr, ch = tr_ch_map[key]
+        for t, evs in evs_by_time.items():
+            events[tr][t].extend((ev.copy(channel=ch) for ev in evs))
+
+    # figure out in which tracks to replicate the time/key signatures of each part
+    part_track_map = partition(lambda x: x[0][1], tr_ch_map.items())
+    for part, rest in part_track_map.items():
+        part_track_map[part] = set(x[1][0] for x in rest)
+
+    # add the time/key sigs to their corresponding tracks
+    for part, m_events in meta_events.items():
+        tracks = part_track_map[part]
+        for tr in tracks:
+            for t, me in m_events.items():
+                events[tr][t] = me + events[tr][t]
+
+    n_tracks = max(tr for tr, _ in tr_ch_map.values()) + 1
+    tracks = [MidiTrack() for _ in range(n_tracks)]
+
+    # tempo events are handled differently from key/time sigs because the have a
+    # global effect. Instead of adding to each relevant track, like the key/time
+    # sig events, we add them only to the first track
+    for t, tp in tempos.items():
+        events[0][t].insert(0, tp)
+
+    for tr, events_by_time in events.items():
+        t_prev = 0
+        for t in sorted(events_by_time.keys()):
+            evs = events_by_time[t]
+            delta = t - t_prev
+            for ev in evs:
+                tracks[tr].append(ev.copy(time=delta))
+                delta = 0
+            t_prev = t
+
+    midi_type = 0 if n_tracks == 1 else 1
+
+    mf = MidiFile(type=midi_type, ticks_per_beat=ppq)
+
+    for track in tracks:
+        mf.tracks.append(track)
+
+    if out:
+        if hasattr(out, "write"):
+            mf.save(file=out)
+        else:
+            mf.save(out)
+    else:
+        return mf
```

### Comparing `partitura-1.2.1/partitura/io/exportmusicxml.py` & `partitura-1.2.2/partitura/io/exportmusicxml.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,1134 +1,1173 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for exporting MusicXML files.
-"""
-import math
-from collections import defaultdict
-from lxml import etree
-import partitura.score as score
-from operator import itemgetter
-from typing import Optional
-
-from .importmusicxml import DYN_DIRECTIONS, PEDAL_DIRECTIONS
-from partitura.utils import partition, iter_current_next, to_quarter_tempo
-
-from partitura.utils.misc import deprecated_alias, PathLike
-
-__all__ = ["save_musicxml"]
-
-DOCTYPE = """<!DOCTYPE score-partwise PUBLIC\n  "-//Recordare//DTD MusicXML 3.1 Partwise//EN"\n  "http://www.musicxml.org/dtds/partwise.dtd">"""  # noqa: E501
-MEASURE_SEP_COMMENT = "======================================================="
-ARTICULATIONS = [
-    "accent",
-    "breath-mark",
-    "caesura",
-    "detached-legato",
-    "doit",
-    "falloff",
-    "plop",
-    "scoop",
-    "spiccato",
-    "staccatissimo",
-    "staccato",
-    "stress",
-    "strong-accent",
-    "tenuto",
-    "unstress",
-]
-
-
-def range_number_from_counter(e, label, counter):
-    key = (label, e)
-    number = counter.get(key, None)
-
-    if number is None:
-
-        number = 1 + sum(1 for o in counter.keys() if o[0] == label)
-        assert number is not None
-        counter[key] = number
-
-    else:
-
-        del counter[key]
-
-    return number
-
-
-def filter_string(s):
-    """
-    Make (unicode) string fit for passing it to lxml, which means (at least)
-    removing null characters.
-    """
-    return s.replace("\x00", "")
-
-
-def make_note_el(note, dur, voice, counter, n_of_staves):
-    # child order
-    # <grace> | <chord> | <cue>
-    # <pitch>
-    # <duration>
-    # <tie type="stop"/>
-    # <voice>
-    # <type>
-    # <notations>
-
-    note_e = etree.Element("note")
-
-    if note.id is not None:
-
-        note_id = note.id
-        # make sure note_id is unique by appending _x to the note_id for the
-        # x-th repetition of the id
-        counter[note_id] = counter.get(note_id, 0) + 1
-
-        if counter[note_id] > 1:
-
-            note_id += "_{}".format(counter[note_id])
-
-        note_e.attrib["id"] = filter_string(note_id)
-
-    if isinstance(note, score.Note):
-
-        if isinstance(note, score.GraceNote):
-
-            if note.grace_type == "acciaccatura":
-
-                etree.SubElement(note_e, "grace", slash="yes")
-
-            else:
-
-                etree.SubElement(note_e, "grace")
-
-        pitch_e = etree.SubElement(note_e, "pitch")
-
-        etree.SubElement(pitch_e, "step").text = "{}".format(note.step)
-
-        if note.alter not in (None, 0):
-            etree.SubElement(pitch_e, "alter").text = "{}".format(note.alter)
-
-        etree.SubElement(pitch_e, "octave").text = "{}".format(note.octave)
-
-    elif isinstance(note, score.UnpitchedNote):
-
-        unpitch_e = etree.SubElement(note_e, "unpitched")
-
-        etree.SubElement(unpitch_e, "display-step").text = "{}".format(note.step)
-
-        etree.SubElement(unpitch_e, "display-octave").text = "{}".format(note.octave)
-
-        if note.notehead is not None:
-            nh_e = etree.SubElement(note_e, "notehead")
-            nh_e.text = "{}".format(note.notehead)
-            if note.noteheadstyle:
-                nh_e.attrib["filled"] = "yes"
-            else:
-                nh_e.attrib["filled"] = "no"
-
-    elif isinstance(note, score.Rest):
-        if not note.hidden:
-            etree.SubElement(note_e, "rest")
-
-    if not isinstance(note, score.GraceNote):
-
-        duration_e = etree.SubElement(note_e, "duration")
-        duration_e.text = "{:d}".format(int(dur))
-
-    notations = []
-
-    if note.tie_prev is not None:
-
-        etree.SubElement(note_e, "tie", type="stop")
-        notations.append(etree.Element("tied", type="stop"))
-
-    if note.tie_next is not None:
-
-        etree.SubElement(note_e, "tie", type="start")
-        notations.append(etree.Element("tied", type="start"))
-
-    if voice not in (None, 0):
-
-        etree.SubElement(note_e, "voice").text = "{}".format(voice)
-
-    if note.fermata is not None:
-
-        notations.append(etree.Element("fermata"))
-
-    if note.articulations:
-        articulations = []
-        for articulation in note.articulations:
-            if articulation in ARTICULATIONS:
-                articulations.append(etree.Element(articulation))
-        if articulations:
-            articulations_e = etree.Element("articulations")
-            articulations_e.extend(articulations)
-            notations.append(articulations_e)
-
-    sym_dur = note.symbolic_duration or {}
-
-    if sym_dur.get("type") is not None:
-
-        etree.SubElement(note_e, "type").text = sym_dur["type"]
-
-    for i in range(sym_dur.get("dots", 0)):
-
-        etree.SubElement(note_e, "dot")
-
-    if (
-        sym_dur.get("actual_notes") is not None
-        and sym_dur.get("normal_notes") is not None
-    ):
-        time_mod_e = etree.SubElement(note_e, "time-modification")
-        actual_e = etree.SubElement(time_mod_e, "actual-notes")
-        actual_e.text = str(sym_dur["actual_notes"])
-        normal_e = etree.SubElement(time_mod_e, "normal-notes")
-        normal_e.text = str(sym_dur["normal_notes"])
-
-    if note.staff is not None:
-        if note.staff != 1 or n_of_staves > 1:
-            etree.SubElement(note_e, "staff").text = "{}".format(note.staff)
-
-    for slur in note.slur_stops:
-
-        number = range_number_from_counter(slur, "slur", counter)
-
-        notations.append(etree.Element("slur", number="{}".format(number), type="stop"))
-
-    for slur in note.slur_starts:
-
-        number = range_number_from_counter(slur, "slur", counter)
-
-        notations.append(
-            etree.Element("slur", number="{}".format(number), type="start")
-        )
-
-    for tuplet in note.tuplet_stops:
-        tuplet_key = ("tuplet", tuplet)
-        number = counter.get(tuplet_key, None)
-
-        if number is None:
-
-            number = 1
-            counter[tuplet_key] = number
-
-        else:
-
-            del counter[tuplet_key]
-
-        notations.append(
-            etree.Element("tuplet", number="{}".format(number), type="stop")
-        )
-
-    for tuplet in note.tuplet_starts:
-        tuplet_key = ("tuplet", tuplet)
-        number = counter.get(tuplet_key, None)
-
-        if number is None:
-
-            number = 1 + sum(1 for o in counter.keys() if o[0] == "tuplet")
-            counter[tuplet_key] = number
-
-        else:
-
-            del counter[tuplet_key]
-
-        notations.append(
-            etree.Element("tuplet", number="{}".format(number), type="start")
-        )
-
-    if notations:
-
-        notations_e = etree.SubElement(note_e, "notations")
-        notations_e.extend(notations)
-
-    return note_e
-
-
-def do_note(note, measure_end, part, voice, counter, n_of_staves):
-    if isinstance(note, score.GraceNote):
-
-        dur_divs = 0
-
-    else:
-
-        dur_divs = note.end.t - note.start.t
-
-    note_e = make_note_el(note, dur_divs, voice, counter, n_of_staves)
-
-    return (note.start.t, dur_divs, note_e)
-
-
-def linearize_measure_contents(part, start, end, state):
-    """
-    Determine the document order of events starting between `start` (inclusive)
-    and `end` (exlusive).  (notes, directions, divisions, time signatures). This
-    function finds any mid-measure attribute/divisions and splits up the measure
-    into segments by divisions, to be linearized separately and
-    concatenated. The actual linearization is done by
-    the `linearize_segment_contents` function.
-
-    Parameters
-    ----------
-    start: score.TimePoint
-        start
-    end: score.TimePoint
-        end
-    part: score.Part
-
-    Returns
-    -------
-    list
-        The contents of measure in document order
-    """
-    splits = [start]
-    q_times = part.quarter_durations(start.t, end.t)
-    if len(q_times) > 0:
-        quarter = start.quarter
-        tp = start.next
-        while tp and tp != end:
-            if tp.quarter != quarter:
-                splits.append(tp)
-                quarter = tp.quarter
-            tp = tp.next
-
-    splits.append(end)
-    contents = []
-
-    for i in range(1, len(splits)):
-        contents.extend(
-            linearize_segment_contents(part, splits[i - 1], splits[i], state)
-        )
-
-    return contents
-
-
-def remove_voice_polyphony_single(notes, voice_spans):
-    """
-    Test wether a list of notes satisfies the MusicXML constraints on voices that:
-    - all notes starting at the same time have the same duration
-    - no <backup> is required to specify the voice in document order
-    whenever a note violates the constraints change its voice
-    (choosing a new voice that is not currently in use)
-
-    Parameters
-    ----------
-    notes: list
-        List of notes in a voice
-
-    Returns
-    -------
-    type
-        Description of return value
-    """
-
-    extraneous = defaultdict(list)
-
-    by_onset = defaultdict(list)
-    for note in notes:
-        if not isinstance(note, score.GraceNote):
-            by_onset[note.start.t].append(note)
-    onsets = sorted(by_onset.keys())
-
-    for o in onsets:
-
-        chord_dur = min(n.duration for n in by_onset[o])
-
-        for n in by_onset[o]:
-
-            if n.duration > chord_dur:
-
-                voice = find_free_voice(voice_spans, n.start.t, n.end.t)
-                voice_spans.append((n.start.t, n.end.t, voice))
-                extraneous[voice].append(n)
-                notes.remove(n)
-
-    # now remove any notes that exceed next onset
-    by_onset = defaultdict(list)
-    for note in notes:
-        by_onset[note.start.t].append(note)
-    onsets = sorted(by_onset.keys())
-
-    for o1, o2 in iter_current_next(onsets):
-
-        for n in by_onset[o1]:
-
-            if o1 + n.duration > o2:
-
-                voice = find_free_voice(voice_spans, n.start.t, n.end.t)
-                voice_spans.append((n.start.t, n.end.t, voice))
-                extraneous[voice].append(n)
-                notes.remove(n)
-
-    return extraneous
-
-
-def find_free_voice(voice_spans, start, end):
-    free_voice = min(voice for _, _, voice in voice_spans) + 1
-
-    for vstart, vend, voice in voice_spans:
-
-        if (end > vstart) and (start < vend):
-
-            free_voice = max(free_voice, voice + 1)
-
-    return free_voice
-
-
-def remove_voice_polyphony(notes_by_voice):
-    voice_spans = [(-math.inf, math.inf, max(notes_by_voice.keys()))]
-    extraneous = defaultdict(list)
-    # n_orig = sum(len(nn) for nn in notes_by_voice.values())
-
-    for voice, vnotes in notes_by_voice.items():
-
-        v_extr = remove_voice_polyphony_single(vnotes, voice_spans)
-
-        for new_voice, new_vnotes in v_extr.items():
-            extraneous[new_voice].extend(new_vnotes)
-
-    # n_1 = sum(len(nn) for nn in notes_by_voice.values())
-    # n_2 = sum(len(nn) for nn in extraneous.values())
-    # n_new = n_1 + n_2
-    # assert n_orig == n_new
-    # assert len(set(notes_by_voice.keys()).intersection(set(extraneous.keys()))) == 0
-    for v, vnotes in extraneous.items():
-        notes_by_voice[v] = vnotes
-
-
-# def fill_gaps_with_rests(notes_by_voice, start, end, part):
-#     for voice, notes in notes_by_voice.items():
-#         if len(notes) == 0:
-#             rest = score.Rest(voice=voice or None)
-#             part.add(rest, start.t, end.t)
-#         else:
-#             t = start.t
-#             for note in notes:
-#                 if note.start.t > t:
-#                     rest = score.Rest(voice=voice or None)
-#                     part.add(rest, t, note.start.t)
-#                 t = note.end.t
-#             if note.end.t < end.t:
-#                 rest = score.Rest(voice=voice or None)
-#                 part.add(rest, note.end.t, end.t)
-
-
-def linearize_segment_contents(part, start, end, state):
-    """
-    Determine the document order of events starting between `start` (inclusive)
-    and `end` (exlusive).
-    (notes, directions, divisions, time signatures).
-    """
-
-    notes = part.iter_all(
-        score.GenericNote, start=start, end=end, include_subclasses=True
-    )
-
-    notes_by_voice = partition(lambda n: n.voice or 0, notes)
-    if len(notes_by_voice) == 0:
-        # if there are no notes in this segment, we add a rest
-        # NOTE: altering the part instance while exporting is bad!
-        # rest = score.Rest()
-        # part.add(start.t, rest, end.t)
-        # notes_by_voice = {0: [rest]}
-        notes_by_voice[None] = []
-
-    # make sure there is no polyphony within voices by assigning any violating
-    # notes to a new (free) voice.
-    remove_voice_polyphony(notes_by_voice)
-
-    # fill_gaps_with_rests(notes_by_voice, start, end, part)
-    # # redo
-    # notes = part.iter_all(score.GenericNote,
-    #                               start=start, end=end,
-    #                               include_subclasses=True)
-    # notes_by_voice = partition(lambda n: n.voice or 0, notes)
-
-    voices_e = defaultdict(list)
-
-    for voice in sorted(notes_by_voice.keys()):
-
-        voice_notes = notes_by_voice[voice]
-        # sort by pitch
-        voice_notes.sort(
-            key=lambda n: n.midi_pitch if hasattr(n, "midi_pitch") else -1, reverse=True
-        )
-        # grace notes should precede other notes at the same onset
-        voice_notes.sort(key=lambda n: not isinstance(n, score.GraceNote))
-        # voice_notes.sort(key=lambda n: -n.duration)
-        voice_notes.sort(key=lambda n: n.start.t)
-
-        n_of_staves = part.number_of_staves
-
-        for n in voice_notes:
-            if isinstance(n, score.GraceNote):
-                # check if it is the first in its sequence
-                if not n.grace_prev:
-                    # if so we add the whole grace sequence at once to ensure
-                    # the correct order
-                    for m in n.iter_grace_seq():
-                        note_e = do_note(
-                            m, end.t, part, voice, state["note_id_counter"], n_of_staves
-                        )
-                        voices_e[voice].append(note_e)
-            else:
-                note_e = do_note(
-                    n, end.t, part, voice, state["note_id_counter"], n_of_staves
-                )
-                voices_e[voice].append(note_e)
-
-        add_chord_tags(voices_e[voice])
-
-    attributes_e = do_attributes(part, start, end)
-    directions_e = do_directions(part, start, end, state["range_counter"])
-    prints_e = do_prints(part, start, end)
-    barline_e = do_barlines(part, start, end)
-
-    other_e = attributes_e + directions_e + barline_e + prints_e
-
-    contents = merge_measure_contents(voices_e, other_e, start.t)
-
-    return contents
-
-
-def do_prints(part, start, end):
-    pages = part.iter_all(score.Page, start, end)
-    systems = part.iter_all(score.System, start, end)
-    by_onset = defaultdict(dict)
-    for page in pages:
-        by_onset[page.start.t]["new-page"] = "yes"
-    for system in systems:
-        by_onset[system.start.t]["new-system"] = "yes"
-    result = []
-    for onset, attrs in by_onset.items():
-        result.append((onset, None, etree.Element("print", **attrs)))
-    return result
-
-
-def do_barlines(part, start, end):
-    # all fermata that are not linked to a note (fermata at time end may be part
-    # of the current or the next measure, depending on the location attribute
-    # (which is stored in fermata.ref)).
-    fermata = [
-        ferm
-        for ferm in part.iter_all(score.Fermata, start, end)
-        if ferm.ref in (None, "left", "middle", "right")
-    ] + [
-        ferm
-        for ferm in part.iter_all(score.Fermata, end, end.next)
-        if ferm.ref in (None, "right")
-    ]
-    repeat_start = part.iter_all(score.Repeat, start, end)
-    repeat_end = part.iter_all(score.Repeat, start.next, end.next, mode="ending")
-    ending_start = part.iter_all(score.Ending, start, end)
-    ending_end = part.iter_all(score.Ending, start.next, end.next, mode="ending")
-    by_onset = defaultdict(list)
-
-    for obj in fermata:
-
-        by_onset[obj.start.t].append(etree.Element("fermata"))
-
-    for obj in repeat_start:
-
-        if obj.start is not None:
-
-            by_onset[obj.start.t].append(etree.Element("repeat", direction="forward"))
-
-    for obj in ending_start:
-
-        if obj.start is not None:
-
-            by_onset[obj.start.t].append(
-                etree.Element("ending", type="start", number=str(obj.number))
-            )
-
-    for obj in repeat_end:
-
-        if obj.end is not None:
-
-            by_onset[obj.end.t].append(etree.Element("repeat", direction="backward"))
-
-    for obj in ending_end:
-
-        if obj.end is not None:
-
-            by_onset[obj.end.t].append(
-                etree.Element("ending", type="stop", number=str(obj.number))
-            )
-
-    result = []
-
-    for onset in sorted(by_onset.keys()):
-
-        attrib = {}
-
-        if onset == start.t:
-
-            attrib["location"] = "left"
-
-        elif onset == end.t:
-
-            attrib["location"] = "right"
-
-        else:
-
-            attrib["location"] = "middle"
-
-        barline_e = etree.Element("barline", **attrib)
-
-        barline_e.extend(by_onset[onset])
-        result.append((onset, None, barline_e))
-
-    return result
-
-
-def add_chord_tags(notes):
-    prev_dur = None
-    prev = None
-    for onset, dur, note in notes:
-        if onset == prev:
-            if dur == prev_dur:
-                note.insert(0, etree.Element("chord"))
-
-        if any(e.tag == "grace" for e in note):
-            # if note is a grace note we don't want to trigger a chord for the
-            # next note
-            prev = None
-        else:
-            prev = onset
-            prev_dur = dur
-
-
-def forward_backup_if_needed(t, t_prev):
-    result = []
-    gap = 0
-
-    if t > t_prev:
-
-        gap = t - t_prev
-        e = etree.Element("forward")
-        ee = etree.SubElement(e, "duration")
-        ee.text = "{:d}".format(int(gap))
-        result.append((t_prev, gap, e))
-
-    elif t < t_prev:
-
-        gap = t_prev - t
-        e = etree.Element("backup")
-        ee = etree.SubElement(e, "duration")
-        ee.text = "{:d}".format(int(gap))
-        result.append((t_prev, -gap, e))
-
-    return result, gap
-
-
-def merge_with_voice(notes, other, measure_start):
-    by_onset = defaultdict(list)
-
-    for onset, dur, el in notes:
-
-        by_onset[onset].append((dur, el))
-
-    for onset, dur, el in other:
-
-        by_onset[onset].append((dur, el))
-
-    result = []
-    last_t = measure_start
-    fb_cost = 0
-    # order to insert simultaneously starting elements; it is important to put
-    # notes last, since they update the position, and thus would lead to
-    # needless backup/forward insertions
-    order = {
-        "barline": 0,
-        "attributes": 1,
-        "direction": 2,
-        "print": 3,
-        "sound": 4,
-        "note": 5,
-    }
-    last_note_onset = measure_start
-
-    for onset in sorted(by_onset.keys()):
-
-        elems = by_onset[onset]
-        elems.sort(key=lambda x: order.get(x[1].tag, len(order)))
-
-        for dur, el in elems:
-
-            if el.tag == "note":
-
-                if el.find("chord") is not None:
-
-                    last_t = last_note_onset
-
-                last_note_onset = onset
-
-            els, cost = forward_backup_if_needed(onset, last_t)
-            fb_cost += cost
-            result.extend(els)
-            result.append((onset, dur, el))
-            last_t = onset + (dur or 0)
-
-    return result, fb_cost
-
-
-def merge_measure_contents(notes, other, measure_start):
-    merged = {}
-    # cost (measured as the total forward/backup jumps needed to merge) all
-    # elements in `other` into each voice
-    cost = {}
-
-    for voice in sorted(notes.keys()):
-        # merge `other` with each voice, and keep track of the cost
-        merged[voice], cost[voice] = merge_with_voice(
-            notes[voice], other, measure_start
-        )
-
-    if not merged:
-        merged[0] = []
-        cost[0] = 0
-
-    # get the voice for which merging notes and other has lowest cost
-    merge_voice = sorted(cost.items(), key=itemgetter(1))[0][0]
-    result = []
-    pos = measure_start
-    for i, voice in enumerate(sorted(notes.keys())):
-
-        if voice == merge_voice:
-
-            elements = merged[voice]
-
-        else:
-
-            elements = notes[voice]
-
-        # backup/forward when switching voices if necessary
-        if elements:
-
-            gap = elements[0][0] - pos
-
-            if gap < 0:
-
-                e = etree.Element("backup")
-                ee = etree.SubElement(e, "duration")
-                ee.text = "{:d}".format(-int(gap))
-                result.append(e)
-
-            elif gap > 0:
-
-                e = etree.Element("forward")
-                ee = etree.SubElement(e, "duration")
-                ee.text = "{:d}".format(gap)
-                result.append(e)
-
-        result.extend([e for _, _, e in elements])
-
-        # update current position
-        if elements:
-            pos = elements[-1][0] + (elements[-1][1] or 0)
-
-    return result
-
-
-def do_directions(part, start, end, counter):
-    result = []
-
-    # ending directions
-    directions = part.iter_all(
-        score.DynamicDirection,
-        start.next,
-        end.next,
-        include_subclasses=True,
-        mode="ending",
-    )
-
-    for direction in directions:
-        text = direction.raw_text or direction.text
-        e0 = etree.Element("direction")
-        e1 = etree.SubElement(e0, "direction-type")
-
-        if getattr(direction, "wedge", False):
-
-            number = range_number_from_counter(direction, "wedge", counter)
-            e2 = etree.SubElement(e1, "wedge", number="{}".format(number), type="stop")
-
-        else:
-
-            number = range_number_from_counter(direction, "wedge", counter)
-            etree.SubElement(e1, "dashes", number="{}".format(number), type="stop")
-
-        elem = (direction.end.t, None, e0)
-        result.append(elem)
-
-    tempos = part.iter_all(score.Tempo, start, end)
-    directions = part.iter_all(score.Direction, start, end, include_subclasses=True)
-
-    for tempo in tempos:
-        # e0 = etree.Element('direction')
-        # e1 = etree.SubElement(e0, 'direction-type')
-        # e2 = etree.SubElement(e1, 'words')
-        unit = "q" if tempo.unit is None else tempo.unit
-        # e2.text = '{}={}'.format(unit, tempo.bpm)
-        # result.append((tempo.start.t, None, e0))
-        e3 = etree.Element(
-            "sound", tempo="{}".format(int(to_quarter_tempo(unit, tempo.bpm)))
-        )
-        result.append((tempo.start.t, None, e3))
-
-    for direction in directions:
-
-        text = direction.raw_text or direction.text
-
-        if text in PEDAL_DIRECTIONS:
-            # Pedal directions create an element for start
-            # and an element for ending
-
-            # Use end of the segment as ending of the pedal sign
-            ped_end = end if direction.end is None else direction.end
-
-            # Create a pedal start element
-            if direction.start.t >= start.t:
-                e0s = etree.Element("direction", placement="below")
-                e1s = etree.SubElement(e0s, "direction-type")
-                # For sustain pedals
-                if isinstance(direction, score.SustainPedalDirection):
-                    pedal_kwargs = {}
-                    if direction.line:
-                        pedal_kwargs["line"] = "yes"
-                    # For Flake8 (ignore unused variable), since
-                    # etree.SubElement adds e2s to e1s
-                    e2s = etree.SubElement(  # noqa: F841
-                        e1s, "pedal", type="start", **pedal_kwargs
-                    )
-                if direction.staff is not None and direction.staff != 1:
-                    e3s = etree.SubElement(e0s, "staff")
-                    e3s.text = str(direction.staff)
-                elem = (direction.start.t, None, e0s)
-                result.append(elem)
-            if ped_end.t <= end.t:
-                e0e = etree.Element("direction", placement="below")
-                e1e = etree.SubElement(e0e, "direction-type")
-                if isinstance(direction, score.SustainPedalDirection):
-                    pedal_kwargs = {}
-                    if direction.line:
-                        pedal_kwargs["line"] = "yes"
-                    else:
-                        pedal_kwargs["sign"] = "yes"
-                    # For Flake8 (ignore unused variable), since
-                    # etree.SubElement adds e2e to e1e
-                    e2e = etree.SubElement(  # noqa: F841
-                        e1e, "pedal", type="end", **pedal_kwargs
-                    )
-                if direction.staff is not None and direction.staff != 1:
-                    e3e = etree.SubElement(e0e, "staff")
-                    e3e.text = str(direction.staff)
-                elem = (ped_end.t, None, e0e)
-                result.append(elem)
-        else:
-            e0 = etree.Element("direction")
-            e1 = etree.SubElement(e0, "direction-type")
-
-            if text in DYN_DIRECTIONS:
-
-                e2 = etree.SubElement(e1, "dynamics")
-                etree.SubElement(e2, text)
-
-            elif getattr(direction, "wedge", False):
-
-                if isinstance(direction, score.IncreasingLoudnessDirection):
-                    wtype = "crescendo"
-                else:
-                    wtype = "diminuendo"
-
-                number = range_number_from_counter(direction, "wedge", counter)
-                e2 = etree.SubElement(
-                    e1, "wedge", number="{}".format(number), type=wtype
-                )
-
-            else:
-
-                e2 = etree.SubElement(e1, "words")
-                e2.text = filter_string(text)
-
-                if (
-                    isinstance(direction, score.DynamicDirection)
-                    and direction.end is not None
-                ):
-                    e3 = etree.SubElement(e0, "direction-type")
-                    number = range_number_from_counter(direction, "dashes", counter)
-                    etree.SubElement(
-                        e3, "dashes", number="{}".format(number), type="start"
-                    )
-
-            if direction.staff is not None and direction.staff != 1:
-
-                e5 = etree.SubElement(e0, "staff")
-                e5.text = str(direction.staff)
-
-            elem = (direction.start.t, None, e0)
-            result.append(elem)
-
-    return result
-
-
-def do_attributes(part, start, end):
-    """
-    Produce xml objects for non-note measure content
-
-    Parameters
-    ----------
-    others: type
-        Description of `others`
-
-    Returns
-    -------
-    type
-        Description of return value
-    """
-
-    by_start = defaultdict(list)
-
-    # for o in part.iter_all(score.Divisions, start, end):
-    #     by_start[o.start.t].append(o)
-    for t, quarter in part.quarter_durations(start.t, end.t):
-        by_start[t].append(int(quarter))
-    for o in part.iter_all(score.KeySignature, start, end):
-        by_start[o.start.t].append(o)
-    for o in part.iter_all(score.TimeSignature, start, end):
-        by_start[o.start.t].append(o)
-
-    # sort clefs by number before adding them to by_start
-    clefs_by_start = defaultdict(list)
-
-    for o in part.iter_all(score.Clef, start, end):
-
-        clefs_by_start[o.start.t].append(o)
-
-    for t, clefs in clefs_by_start.items():
-
-        clefs.sort(key=lambda clef: getattr(clef, "number", 0))
-        by_start[t].extend(clefs)
-
-    result = []
-
-    # hacky: flag to include staves element before the first clef
-    staves_included = False
-
-    for t in sorted(by_start.keys()):
-
-        attr_e = etree.Element("attributes")
-
-        for o in by_start[t]:
-
-            if isinstance(o, int):
-
-                etree.SubElement(attr_e, "divisions").text = "{}".format(o)
-
-            elif isinstance(o, score.KeySignature):
-
-                ks_e = etree.SubElement(attr_e, "key")
-                etree.SubElement(ks_e, "fifths").text = "{}".format(o.fifths)
-
-                if o.mode:
-
-                    etree.SubElement(ks_e, "mode").text = "{}".format(o.mode)
-
-            elif isinstance(o, score.TimeSignature):
-
-                ts_e = etree.SubElement(attr_e, "time")
-                etree.SubElement(ts_e, "beats").text = "{}".format(o.beats)
-                etree.SubElement(ts_e, "beat-type").text = "{}".format(o.beat_type)
-
-            elif isinstance(o, score.Clef):
-
-                if not staves_included:
-                    staves_e = etree.SubElement(attr_e, "staves")
-                    staves_e.text = "{}".format(len(clefs))
-                    staves_included = True
-
-                clef_e = etree.SubElement(attr_e, "clef")
-
-                if o.staff and o.staff != 1:
-
-                    clef_e.set("number", "{}".format(o.staff))
-
-                etree.SubElement(clef_e, "sign").text = "{}".format(o.sign)
-                etree.SubElement(clef_e, "line").text = "{}".format(o.line)
-
-                if o.octave_change:
-
-                    etree.SubElement(clef_e, "clef-octave-change").text = "{}".format(
-                        o.octave_change
-                    )
-
-        result.append((t, None, attr_e))
-
-    return result
-
-
-@deprecated_alias(parts="score_data")
-def save_musicxml(
-        score_data: score.ScoreLike,
-        out: Optional[PathLike] = None,
-) -> Optional[str]:
-    """
-    Save a one or more Part or PartGroup instances in MusicXML format.
-
-    Parameters
-    ----------
-    score_data : Score, list, Part, or PartGroup
-        The musical score to be saved. A :class:`partitura.score.Score` object,
-        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
-        a list of these.
-    out: str, file-like object, or None, optional
-        Output file
-
-    Returns
-    -------
-    None or str
-        If no output file is specified using `out` the function returns the
-        MusicXML data as a string. Otherwise the function returns None.
-    """
-
-    if not isinstance(score_data, score.Score):
-        score_data = score.Score(
-            id=None,
-            partlist=score_data,
-        )
-
-    root = etree.Element("score-partwise")
-
-    partlist_e = etree.SubElement(root, "part-list")
-    state = {
-        "note_id_counter": {},
-        "range_counter": {},
-    }
-
-    group_stack = []
-
-    def close_group_stack():
-        while group_stack:
-            # close group
-            etree.SubElement(
-                partlist_e,
-                "part-group",
-                number="{}".format(group_stack[-1].number),
-                type="stop",
-            )
-            # remove from stack
-            group_stack.pop()
-
-    def handle_parents(part):
-        # 1. get deepest parent that is in group_stack (keep track of parents to
-        # add)
-        pg = part.parent
-        to_add = []
-        while pg:
-            if pg in group_stack:
-                break
-            to_add.append(pg)
-            pg = pg.parent
-
-        # close groups while not equal to pg
-        while group_stack:
-            if pg == group_stack[-1]:
-                break
-            else:
-                # close group
-                etree.SubElement(
-                    partlist_e,
-                    "part-group",
-                    number="{}".format(group_stack[-1].number),
-                    type="stop",
-                )
-                # remove from stack
-                group_stack.pop()
-
-        # start all parents in to_add
-        for pg in reversed(to_add):
-            # start group
-            pg_e = etree.SubElement(
-                partlist_e, "part-group", number="{}".format(pg.number), type="start"
-            )
-            if pg.group_symbol is not None:
-                symb_e = etree.SubElement(pg_e, "group-symbol")
-                symb_e.text = pg.group_symbol
-            if pg.group_name is not None:
-                name_e = etree.SubElement(pg_e, "group-name")
-                name_e.text = pg.group_name
-
-            group_stack.append(pg)
-
-    for part in score_data:
-
-        handle_parents(part)
-
-        # handle part list entry
-        scorepart_e = etree.SubElement(partlist_e, "score-part", id=part.id)
-
-        partname_e = etree.SubElement(scorepart_e, "part-name")
-        if part.part_name:
-            partname_e.text = filter_string(part.part_name)
-
-        if part.part_abbreviation:
-            partabbrev_e = etree.SubElement(scorepart_e, "part-abbreviation")
-            partabbrev_e.text = filter_string(part.part_abbreviation)
-
-        # write the part itself
-
-        part_e = etree.SubElement(root, "part", id=part.id)
-
-        for measure in part.iter_all(score.Measure):
-
-            part_e.append(etree.Comment(MEASURE_SEP_COMMENT))
-            attrib = {}
-
-            if measure.number is not None:
-
-                attrib["number"] = str(measure.number)
-
-            measure_e = etree.SubElement(part_e, "measure", **attrib)
-            contents = linearize_measure_contents(
-                part, measure.start, measure.end, state
-            )
-            measure_e.extend(contents)
-
-    close_group_stack()
-
-    if out:
-
-        if hasattr(out, "write"):
-
-            out.write(
-                etree.tostring(
-                    root.getroottree(),
-                    encoding="UTF-8",
-                    xml_declaration=True,
-                    pretty_print=True,
-                    doctype=DOCTYPE,
-                )
-            )
-
-        else:
-
-            with open(out, "wb") as f:
-
-                f.write(
-                    etree.tostring(
-                        root.getroottree(),
-                        encoding="UTF-8",
-                        xml_declaration=True,
-                        pretty_print=True,
-                        doctype=DOCTYPE,
-                    )
-                )
-
-    else:
-
-        return etree.tostring(
-            root.getroottree(),
-            encoding="UTF-8",
-            xml_declaration=True,
-            pretty_print=True,
-            doctype=DOCTYPE,
-        )
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for exporting MusicXML files.
+"""
+import math
+from collections import defaultdict
+from lxml import etree
+import partitura.score as score
+from operator import itemgetter
+from typing import Optional
+
+from .importmusicxml import DYN_DIRECTIONS, PEDAL_DIRECTIONS
+from partitura.utils import partition, iter_current_next, to_quarter_tempo
+
+from partitura.utils.misc import deprecated_alias, PathLike
+
+__all__ = ["save_musicxml"]
+
+DOCTYPE = """<!DOCTYPE score-partwise PUBLIC\n  "-//Recordare//DTD MusicXML 3.1 Partwise//EN"\n  "http://www.musicxml.org/dtds/partwise.dtd">"""  # noqa: E501
+MEASURE_SEP_COMMENT = "======================================================="
+ARTICULATIONS = [
+    "accent",
+    "breath-mark",
+    "caesura",
+    "detached-legato",
+    "doit",
+    "falloff",
+    "plop",
+    "scoop",
+    "spiccato",
+    "staccatissimo",
+    "staccato",
+    "stress",
+    "strong-accent",
+    "tenuto",
+    "unstress",
+]
+
+
+def range_number_from_counter(e, label, counter):
+    key = (label, e)
+    number = counter.get(key, None)
+
+    if number is None:
+
+        number = 1 + sum(1 for o in counter.keys() if o[0] == label)
+        assert number is not None
+        counter[key] = number
+
+    else:
+
+        del counter[key]
+
+    return number
+
+
+def filter_string(s):
+    """
+    Make (unicode) string fit for passing it to lxml, which means (at least)
+    removing null characters.
+    """
+    return s.replace("\x00", "")
+
+
+def make_note_el(note, dur, voice, counter, n_of_staves):
+    # child order
+    # <grace> | <chord> | <cue>
+    # <pitch>
+    # <duration>
+    # <tie type="stop"/>
+    # <voice>
+    # <type>
+    # <notations>
+
+    note_e = etree.Element("note")
+
+    if note.id is not None:
+
+        note_id = note.id
+        # make sure note_id is unique by appending _x to the note_id for the
+        # x-th repetition of the id
+        counter[note_id] = counter.get(note_id, 0) + 1
+
+        if counter[note_id] > 1:
+
+            note_id += "_{}".format(counter[note_id])
+
+        note_e.attrib["id"] = filter_string(note_id)
+
+    if isinstance(note, score.Note):
+
+        if isinstance(note, score.GraceNote):
+
+            if note.grace_type == "acciaccatura":
+
+                etree.SubElement(note_e, "grace", slash="yes")
+
+            else:
+
+                etree.SubElement(note_e, "grace")
+
+        pitch_e = etree.SubElement(note_e, "pitch")
+
+        etree.SubElement(pitch_e, "step").text = "{}".format(note.step)
+
+        if note.alter not in (None, 0):
+            etree.SubElement(pitch_e, "alter").text = "{}".format(note.alter)
+
+        etree.SubElement(pitch_e, "octave").text = "{}".format(note.octave)
+
+    elif isinstance(note, score.UnpitchedNote):
+
+        unpitch_e = etree.SubElement(note_e, "unpitched")
+
+        etree.SubElement(unpitch_e, "display-step").text = "{}".format(note.step)
+
+        etree.SubElement(unpitch_e, "display-octave").text = "{}".format(note.octave)
+
+        if note.notehead is not None:
+            nh_e = etree.SubElement(note_e, "notehead")
+            nh_e.text = "{}".format(note.notehead)
+            if note.noteheadstyle:
+                nh_e.attrib["filled"] = "yes"
+            else:
+                nh_e.attrib["filled"] = "no"
+
+    elif isinstance(note, score.Rest):
+        if not note.hidden:
+            etree.SubElement(note_e, "rest")
+
+    if not isinstance(note, score.GraceNote):
+
+        duration_e = etree.SubElement(note_e, "duration")
+        duration_e.text = "{:d}".format(int(dur))
+
+    notations = []
+
+    if note.tie_prev is not None:
+
+        etree.SubElement(note_e, "tie", type="stop")
+        notations.append(etree.Element("tied", type="stop"))
+
+    if note.tie_next is not None:
+
+        etree.SubElement(note_e, "tie", type="start")
+        notations.append(etree.Element("tied", type="start"))
+
+    if voice not in (None, 0):
+
+        etree.SubElement(note_e, "voice").text = "{}".format(voice)
+
+    if note.fermata is not None:
+
+        notations.append(etree.Element("fermata"))
+
+    if note.articulations:
+        articulations = []
+        for articulation in note.articulations:
+            if articulation in ARTICULATIONS:
+                articulations.append(etree.Element(articulation))
+        if articulations:
+            articulations_e = etree.Element("articulations")
+            articulations_e.extend(articulations)
+            notations.append(articulations_e)
+
+    sym_dur = note.symbolic_duration or {}
+
+    if sym_dur.get("type") is not None:
+
+        etree.SubElement(note_e, "type").text = sym_dur["type"]
+
+    for i in range(sym_dur.get("dots", 0)):
+
+        etree.SubElement(note_e, "dot")
+
+    if (
+        sym_dur.get("actual_notes") is not None
+        and sym_dur.get("normal_notes") is not None
+    ):
+        time_mod_e = etree.SubElement(note_e, "time-modification")
+        actual_e = etree.SubElement(time_mod_e, "actual-notes")
+        actual_e.text = str(sym_dur["actual_notes"])
+        normal_e = etree.SubElement(time_mod_e, "normal-notes")
+        normal_e.text = str(sym_dur["normal_notes"])
+
+    if note.staff is not None:
+        if note.staff != 1 or n_of_staves > 1:
+            etree.SubElement(note_e, "staff").text = "{}".format(note.staff)
+
+    for slur in note.slur_stops:
+
+        number = range_number_from_counter(slur, "slur", counter)
+
+        notations.append(etree.Element("slur", number="{}".format(number), type="stop"))
+
+    for slur in note.slur_starts:
+
+        number = range_number_from_counter(slur, "slur", counter)
+
+        notations.append(
+            etree.Element("slur", number="{}".format(number), type="start")
+        )
+
+    for tuplet in note.tuplet_stops:
+        tuplet_key = ("tuplet", tuplet)
+        number = counter.get(tuplet_key, None)
+
+        if number is None:
+
+            number = 1
+            counter[tuplet_key] = number
+
+        else:
+
+            del counter[tuplet_key]
+
+        notations.append(
+            etree.Element("tuplet", number="{}".format(number), type="stop")
+        )
+
+    for tuplet in note.tuplet_starts:
+        tuplet_key = ("tuplet", tuplet)
+        number = counter.get(tuplet_key, None)
+
+        if number is None:
+
+            number = 1 + sum(1 for o in counter.keys() if o[0] == "tuplet")
+            counter[tuplet_key] = number
+
+        else:
+
+            del counter[tuplet_key]
+
+        notations.append(
+            etree.Element("tuplet", number="{}".format(number), type="start")
+        )
+
+    if notations:
+
+        notations_e = etree.SubElement(note_e, "notations")
+        notations_e.extend(notations)
+
+    return note_e
+
+
+def do_note(note, measure_end, part, voice, counter, n_of_staves):
+    if isinstance(note, score.GraceNote):
+
+        dur_divs = 0
+
+    else:
+
+        dur_divs = note.end.t - note.start.t
+
+    note_e = make_note_el(note, dur_divs, voice, counter, n_of_staves)
+
+    return (note.start.t, dur_divs, note_e)
+
+
+def linearize_measure_contents(part, start, end, state):
+    """
+    Determine the document order of events starting between `start` (inclusive)
+    and `end` (exlusive).  (notes, directions, divisions, time signatures). This
+    function finds any mid-measure attribute/divisions and splits up the measure
+    into segments by divisions, to be linearized separately and
+    concatenated. The actual linearization is done by
+    the `linearize_segment_contents` function.
+
+    Parameters
+    ----------
+    start: score.TimePoint
+        start
+    end: score.TimePoint
+        end
+    part: score.Part
+
+    Returns
+    -------
+    list
+        The contents of measure in document order
+    """
+    splits = [start]
+    q_times = part.quarter_durations(start.t, end.t)
+    if len(q_times) > 0:
+        quarter = start.quarter
+        tp = start.next
+        while tp and tp != end:
+            if tp.quarter != quarter:
+                splits.append(tp)
+                quarter = tp.quarter
+            tp = tp.next
+
+    splits.append(end)
+    contents = []
+
+    for i in range(1, len(splits)):
+        contents.extend(
+            linearize_segment_contents(part, splits[i - 1], splits[i], state)
+        )
+
+    return contents
+
+
+def remove_voice_polyphony_single(notes, voice_spans):
+    """
+    Test wether a list of notes satisfies the MusicXML constraints on voices that:
+    - all notes starting at the same time have the same duration
+    - no <backup> is required to specify the voice in document order
+    whenever a note violates the constraints change its voice
+    (choosing a new voice that is not currently in use)
+
+    Parameters
+    ----------
+    notes: list
+        List of notes in a voice
+
+    Returns
+    -------
+    type
+        Description of return value
+    """
+
+    extraneous = defaultdict(list)
+
+    by_onset = defaultdict(list)
+    for note in notes:
+        if not isinstance(note, score.GraceNote):
+            by_onset[note.start.t].append(note)
+    onsets = sorted(by_onset.keys())
+
+    for o in onsets:
+
+        chord_dur = min(n.duration for n in by_onset[o])
+
+        for n in by_onset[o]:
+
+            if n.duration > chord_dur:
+
+                voice = find_free_voice(voice_spans, n.start.t, n.end.t)
+                voice_spans.append((n.start.t, n.end.t, voice))
+                extraneous[voice].append(n)
+                notes.remove(n)
+
+    # now remove any notes that exceed next onset
+    by_onset = defaultdict(list)
+    for note in notes:
+        by_onset[note.start.t].append(note)
+    onsets = sorted(by_onset.keys())
+
+    for o1, o2 in iter_current_next(onsets):
+
+        for n in by_onset[o1]:
+
+            if o1 + n.duration > o2:
+
+                voice = find_free_voice(voice_spans, n.start.t, n.end.t)
+                voice_spans.append((n.start.t, n.end.t, voice))
+                extraneous[voice].append(n)
+                notes.remove(n)
+
+    return extraneous
+
+
+def find_free_voice(voice_spans, start, end):
+    free_voice = min(voice for _, _, voice in voice_spans) + 1
+
+    for vstart, vend, voice in voice_spans:
+
+        if (end > vstart) and (start < vend):
+
+            free_voice = max(free_voice, voice + 1)
+
+    return free_voice
+
+
+def remove_voice_polyphony(notes_by_voice):
+    voice_spans = [(-math.inf, math.inf, max(notes_by_voice.keys()))]
+    extraneous = defaultdict(list)
+    # n_orig = sum(len(nn) for nn in notes_by_voice.values())
+
+    for voice, vnotes in notes_by_voice.items():
+
+        v_extr = remove_voice_polyphony_single(vnotes, voice_spans)
+
+        for new_voice, new_vnotes in v_extr.items():
+            extraneous[new_voice].extend(new_vnotes)
+
+    # n_1 = sum(len(nn) for nn in notes_by_voice.values())
+    # n_2 = sum(len(nn) for nn in extraneous.values())
+    # n_new = n_1 + n_2
+    # assert n_orig == n_new
+    # assert len(set(notes_by_voice.keys()).intersection(set(extraneous.keys()))) == 0
+    for v, vnotes in extraneous.items():
+        notes_by_voice[v] = vnotes
+
+
+# def fill_gaps_with_rests(notes_by_voice, start, end, part):
+#     for voice, notes in notes_by_voice.items():
+#         if len(notes) == 0:
+#             rest = score.Rest(voice=voice or None)
+#             part.add(rest, start.t, end.t)
+#         else:
+#             t = start.t
+#             for note in notes:
+#                 if note.start.t > t:
+#                     rest = score.Rest(voice=voice or None)
+#                     part.add(rest, t, note.start.t)
+#                 t = note.end.t
+#             if note.end.t < end.t:
+#                 rest = score.Rest(voice=voice or None)
+#                 part.add(rest, note.end.t, end.t)
+
+
+def linearize_segment_contents(part, start, end, state):
+    """
+    Determine the document order of events starting between `start` (inclusive)
+    and `end` (exlusive).
+    (notes, directions, divisions, time signatures).
+    """
+
+    notes = part.iter_all(
+        score.GenericNote, start=start, end=end, include_subclasses=True
+    )
+
+    notes_by_voice = partition(lambda n: n.voice or 0, notes)
+    if len(notes_by_voice) == 0:
+        # if there are no notes in this segment, we add a rest
+        # NOTE: altering the part instance while exporting is bad!
+        # rest = score.Rest()
+        # part.add(start.t, rest, end.t)
+        # notes_by_voice = {0: [rest]}
+        notes_by_voice[None] = []
+
+    # make sure there is no polyphony within voices by assigning any violating
+    # notes to a new (free) voice.
+    remove_voice_polyphony(notes_by_voice)
+
+    # fill_gaps_with_rests(notes_by_voice, start, end, part)
+    # # redo
+    # notes = part.iter_all(score.GenericNote,
+    #                               start=start, end=end,
+    #                               include_subclasses=True)
+    # notes_by_voice = partition(lambda n: n.voice or 0, notes)
+
+    voices_e = defaultdict(list)
+
+    for voice in sorted(notes_by_voice.keys()):
+
+        voice_notes = notes_by_voice[voice]
+        # sort by pitch
+        voice_notes.sort(
+            key=lambda n: n.midi_pitch if hasattr(n, "midi_pitch") else -1, reverse=True
+        )
+        # grace notes should precede other notes at the same onset
+        voice_notes.sort(key=lambda n: not isinstance(n, score.GraceNote))
+        # voice_notes.sort(key=lambda n: -n.duration)
+        voice_notes.sort(key=lambda n: n.start.t)
+
+        n_of_staves = part.number_of_staves
+
+        for n in voice_notes:
+            if isinstance(n, score.GraceNote):
+                # check if it is the first in its sequence
+                if not n.grace_prev:
+                    # if so we add the whole grace sequence at once to ensure
+                    # the correct order
+                    for m in n.iter_grace_seq():
+                        note_e = do_note(
+                            m, end.t, part, voice, state["note_id_counter"], n_of_staves
+                        )
+                        voices_e[voice].append(note_e)
+            else:
+                note_e = do_note(
+                    n, end.t, part, voice, state["note_id_counter"], n_of_staves
+                )
+                voices_e[voice].append(note_e)
+
+        add_chord_tags(voices_e[voice])
+
+    harmony_e = do_harmony(part, start, end)
+    attributes_e = do_attributes(part, start, end)
+    directions_e = do_directions(part, start, end, state["range_counter"])
+    prints_e = do_prints(part, start, end)
+    barline_e = do_barlines(part, start, end)
+
+    other_e = harmony_e + attributes_e + directions_e + barline_e + prints_e
+
+    contents = merge_measure_contents(voices_e, other_e, start.t)
+
+    return contents
+
+
+def do_prints(part, start, end):
+    pages = part.iter_all(score.Page, start, end)
+    systems = part.iter_all(score.System, start, end)
+    by_onset = defaultdict(dict)
+    for page in pages:
+        by_onset[page.start.t]["new-page"] = "yes"
+    for system in systems:
+        by_onset[system.start.t]["new-system"] = "yes"
+    result = []
+    for onset, attrs in by_onset.items():
+        result.append((onset, None, etree.Element("print", **attrs)))
+    return result
+
+
+def do_barlines(part, start, end):
+    # all fermata that are not linked to a note (fermata at time end may be part
+    # of the current or the next measure, depending on the location attribute
+    # (which is stored in fermata.ref)).
+    fermata = [
+        ferm
+        for ferm in part.iter_all(score.Fermata, start, end)
+        if ferm.ref in (None, "left", "middle", "right")
+    ] + [
+        ferm
+        for ferm in part.iter_all(score.Fermata, end, end.next)
+        if ferm.ref in (None, "right")
+    ]
+    repeat_start = part.iter_all(score.Repeat, start, end)
+    repeat_end = part.iter_all(score.Repeat, start.next, end.next, mode="ending")
+    ending_start = part.iter_all(score.Ending, start, end)
+    ending_end = part.iter_all(score.Ending, start.next, end.next, mode="ending")
+    by_onset = defaultdict(list)
+
+    for obj in fermata:
+
+        by_onset[obj.start.t].append(etree.Element("fermata"))
+
+    for obj in repeat_start:
+
+        if obj.start is not None:
+
+            by_onset[obj.start.t].append(etree.Element("repeat", direction="forward"))
+
+    for obj in ending_start:
+
+        if obj.start is not None:
+
+            by_onset[obj.start.t].append(
+                etree.Element("ending", type="start", number=str(obj.number))
+            )
+
+    for obj in repeat_end:
+
+        if obj.end is not None:
+
+            by_onset[obj.end.t].append(etree.Element("repeat", direction="backward"))
+
+    for obj in ending_end:
+
+        if obj.end is not None:
+
+            by_onset[obj.end.t].append(
+                etree.Element("ending", type="stop", number=str(obj.number))
+            )
+
+    result = []
+
+    for onset in sorted(by_onset.keys()):
+
+        attrib = {}
+
+        if onset == start.t:
+
+            attrib["location"] = "left"
+
+        elif onset == end.t:
+
+            attrib["location"] = "right"
+
+        else:
+
+            attrib["location"] = "middle"
+
+        barline_e = etree.Element("barline", **attrib)
+
+        barline_e.extend(by_onset[onset])
+        result.append((onset, None, barline_e))
+
+    return result
+
+
+def add_chord_tags(notes):
+    prev_dur = None
+    prev = None
+    for onset, dur, note in notes:
+        if onset == prev:
+            if dur == prev_dur:
+                note.insert(0, etree.Element("chord"))
+
+        if any(e.tag == "grace" for e in note):
+            # if note is a grace note we don't want to trigger a chord for the
+            # next note
+            prev = None
+        else:
+            prev = onset
+            prev_dur = dur
+
+
+def forward_backup_if_needed(t, t_prev):
+    result = []
+    gap = 0
+
+    if t > t_prev:
+
+        gap = t - t_prev
+        e = etree.Element("forward")
+        ee = etree.SubElement(e, "duration")
+        ee.text = "{:d}".format(int(gap))
+        result.append((t_prev, gap, e))
+
+    elif t < t_prev:
+
+        gap = t_prev - t
+        e = etree.Element("backup")
+        ee = etree.SubElement(e, "duration")
+        ee.text = "{:d}".format(int(gap))
+        result.append((t_prev, -gap, e))
+
+    return result, gap
+
+
+def merge_with_voice(notes, other, measure_start):
+    by_onset = defaultdict(list)
+
+    for onset, dur, el in notes:
+
+        by_onset[onset].append((dur, el))
+
+    for onset, dur, el in other:
+
+        by_onset[onset].append((dur, el))
+
+    result = []
+    last_t = measure_start
+    fb_cost = 0
+    # order to insert simultaneously starting elements; it is important to put
+    # notes last, since they update the position, and thus would lead to
+    # needless backup/forward insertions
+    order = {
+        "barline": 0,
+        "attributes": 1,
+        "direction": 2,
+        "print": 3,
+        "sound": 4,
+        "harmony": 5,
+        "note": 6,
+    }
+    last_note_onset = measure_start
+
+    for onset in sorted(by_onset.keys()):
+
+        elems = by_onset[onset]
+        elems.sort(key=lambda x: order.get(x[1].tag, len(order)))
+
+        for dur, el in elems:
+
+            if el.tag == "note":
+
+                if el.find("chord") is not None:
+
+                    last_t = last_note_onset
+
+                last_note_onset = onset
+
+            els, cost = forward_backup_if_needed(onset, last_t)
+            fb_cost += cost
+            result.extend(els)
+            result.append((onset, dur, el))
+            last_t = onset + (dur or 0)
+
+    return result, fb_cost
+
+
+def merge_measure_contents(notes, other, measure_start):
+    merged = {}
+    # cost (measured as the total forward/backup jumps needed to merge) all
+    # elements in `other` into each voice
+    cost = {}
+
+    for voice in sorted(notes.keys()):
+        # merge `other` with each voice, and keep track of the cost
+        merged[voice], cost[voice] = merge_with_voice(
+            notes[voice], other, measure_start
+        )
+
+    if not merged:
+        merged[0] = []
+        cost[0] = 0
+
+    # get the voice for which merging notes and other has lowest cost
+    merge_voice = sorted(cost.items(), key=itemgetter(1))[0][0]
+    result = []
+    pos = measure_start
+    for i, voice in enumerate(sorted(notes.keys())):
+
+        if voice == merge_voice:
+
+            elements = merged[voice]
+
+        else:
+
+            elements = notes[voice]
+
+        # backup/forward when switching voices if necessary
+        if elements:
+
+            gap = elements[0][0] - pos
+
+            if gap < 0:
+
+                e = etree.Element("backup")
+                ee = etree.SubElement(e, "duration")
+                ee.text = "{:d}".format(-int(gap))
+                result.append(e)
+
+            elif gap > 0:
+
+                e = etree.Element("forward")
+                ee = etree.SubElement(e, "duration")
+                ee.text = "{:d}".format(gap)
+                result.append(e)
+
+        result.extend([e for _, _, e in elements])
+
+        # update current position
+        if elements:
+            pos = elements[-1][0] + (elements[-1][1] or 0)
+
+    return result
+
+
+def do_directions(part, start, end, counter):
+    result = []
+
+    # ending directions
+    directions = part.iter_all(
+        score.DynamicDirection,
+        start.next,
+        end.next,
+        include_subclasses=True,
+        mode="ending",
+    )
+
+    for direction in directions:
+        text = direction.raw_text or direction.text
+        e0 = etree.Element("direction")
+        e1 = etree.SubElement(e0, "direction-type")
+
+        if getattr(direction, "wedge", False):
+
+            number = range_number_from_counter(direction, "wedge", counter)
+            e2 = etree.SubElement(e1, "wedge", number="{}".format(number), type="stop")
+
+        else:
+
+            number = range_number_from_counter(direction, "wedge", counter)
+            etree.SubElement(e1, "dashes", number="{}".format(number), type="stop")
+
+        elem = (direction.end.t, None, e0)
+        result.append(elem)
+
+    tempos = part.iter_all(score.Tempo, start, end)
+    directions = part.iter_all(score.Direction, start, end, include_subclasses=True)
+
+    for tempo in tempos:
+        # e0 = etree.Element('direction')
+        # e1 = etree.SubElement(e0, 'direction-type')
+        # e2 = etree.SubElement(e1, 'words')
+        unit = "q" if tempo.unit is None else tempo.unit
+        # e2.text = '{}={}'.format(unit, tempo.bpm)
+        # result.append((tempo.start.t, None, e0))
+        e3 = etree.Element(
+            "sound", tempo="{}".format(int(to_quarter_tempo(unit, tempo.bpm)))
+        )
+        result.append((tempo.start.t, None, e3))
+
+    for direction in directions:
+
+        text = direction.raw_text or direction.text
+
+        if text in PEDAL_DIRECTIONS:
+            # Pedal directions create an element for start
+            # and an element for ending
+
+            # Use end of the segment as ending of the pedal sign
+            ped_end = end if direction.end is None else direction.end
+
+            # Create a pedal start element
+            if direction.start.t >= start.t:
+                e0s = etree.Element("direction", placement="below")
+                e1s = etree.SubElement(e0s, "direction-type")
+                # For sustain pedals
+                if isinstance(direction, score.SustainPedalDirection):
+                    pedal_kwargs = {}
+                    if direction.line:
+                        pedal_kwargs["line"] = "yes"
+                    # For Flake8 (ignore unused variable), since
+                    # etree.SubElement adds e2s to e1s
+                    e2s = etree.SubElement(  # noqa: F841
+                        e1s, "pedal", type="start", **pedal_kwargs
+                    )
+                if direction.staff is not None and direction.staff != 1:
+                    e3s = etree.SubElement(e0s, "staff")
+                    e3s.text = str(direction.staff)
+                elem = (direction.start.t, None, e0s)
+                result.append(elem)
+            if ped_end.t <= end.t:
+                e0e = etree.Element("direction", placement="below")
+                e1e = etree.SubElement(e0e, "direction-type")
+                if isinstance(direction, score.SustainPedalDirection):
+                    pedal_kwargs = {}
+                    if direction.line:
+                        pedal_kwargs["line"] = "yes"
+                    else:
+                        pedal_kwargs["sign"] = "yes"
+                    # For Flake8 (ignore unused variable), since
+                    # etree.SubElement adds e2e to e1e
+                    e2e = etree.SubElement(  # noqa: F841
+                        e1e, "pedal", type="end", **pedal_kwargs
+                    )
+                if direction.staff is not None and direction.staff != 1:
+                    e3e = etree.SubElement(e0e, "staff")
+                    e3e.text = str(direction.staff)
+                elem = (ped_end.t, None, e0e)
+                result.append(elem)
+        else:
+            e0 = etree.Element("direction")
+            e1 = etree.SubElement(e0, "direction-type")
+
+            if text in DYN_DIRECTIONS:
+
+                e2 = etree.SubElement(e1, "dynamics")
+                etree.SubElement(e2, text)
+
+            elif getattr(direction, "wedge", False):
+
+                if isinstance(direction, score.IncreasingLoudnessDirection):
+                    wtype = "crescendo"
+                else:
+                    wtype = "diminuendo"
+
+                number = range_number_from_counter(direction, "wedge", counter)
+                e2 = etree.SubElement(
+                    e1, "wedge", number="{}".format(number), type=wtype
+                )
+
+            else:
+
+                e2 = etree.SubElement(e1, "words")
+                e2.text = filter_string(text)
+
+                if (
+                    isinstance(direction, score.DynamicDirection)
+                    and direction.end is not None
+                ):
+                    e3 = etree.SubElement(e0, "direction-type")
+                    number = range_number_from_counter(direction, "dashes", counter)
+                    etree.SubElement(
+                        e3, "dashes", number="{}".format(number), type="start"
+                    )
+
+            if direction.staff is not None and direction.staff != 1:
+
+                e5 = etree.SubElement(e0, "staff")
+                e5.text = str(direction.staff)
+
+            elem = (direction.start.t, None, e0)
+            result.append(elem)
+
+    return result
+
+
+def do_harmony(part, start, end):
+    """
+    Produce xml objects for harmony (Roman Numeral Text)
+    """
+    harmony = part.iter_all(score.RomanNumeral, start, end)
+    result = []
+    for h in harmony:
+        harmony_e = etree.Element("harmony", print_frame="no")
+        function = etree.SubElement(harmony_e, "function")
+        function.text = h.text
+        kind_e = etree.SubElement(harmony_e, "kind", text="")
+        kind_e.text = "none"
+        result.append((h.start.t, None, harmony_e))
+    harmony = part.iter_all(score.ChordSymbol, start, end)
+    for h in harmony:
+        harmony_e = etree.Element("harmony", print_frame="no")
+        kind_e = etree.SubElement(harmony_e, "kind", text=h.kind) if h.kind is not None else etree.SubElement(harmony_e, "kind", text="")
+        kind_e.text = "none"
+        root_e = etree.SubElement(harmony_e, "root")
+        root_step_e = etree.SubElement(root_e, "root-step")
+        root_step_e.text = h.root
+        if h.bass is not None:
+            bass_e = etree.SubElement(harmony_e, "bass")
+            bass_step_e = etree.SubElement(bass_e, "bass-step")
+            bass_step_e.text = h.bass
+        result.append((h.start.t, None, harmony_e))
+    return result
+
+
+def do_attributes(part, start, end):
+    """
+    Produce xml objects for non-note measure content
+
+    Parameters
+    ----------
+    others: type
+        Description of `others`
+
+    Returns
+    -------
+    type
+        Description of return value
+    """
+
+    by_start = defaultdict(list)
+
+    # for o in part.iter_all(score.Divisions, start, end):
+    #     by_start[o.start.t].append(o)
+    for t, quarter in part.quarter_durations(start.t, end.t):
+        by_start[t].append(int(quarter))
+    for o in part.iter_all(score.KeySignature, start, end):
+        by_start[o.start.t].append(o)
+    for o in part.iter_all(score.TimeSignature, start, end):
+        by_start[o.start.t].append(o)
+    for o in part.iter_all(score.Staff, start, end):
+        by_start[o.start.t].append(o)
+
+    # sort clefs by number before adding them to by_start
+    clefs_by_start = defaultdict(list)
+
+    for o in part.iter_all(score.Clef, start, end):
+
+        clefs_by_start[o.start.t].append(o)
+
+    for t, clefs in clefs_by_start.items():
+
+        clefs.sort(key=lambda clef: getattr(clef, "number", 0))
+        by_start[t].extend(clefs)
+
+    result = []
+
+    # hacky: flag to include staves element before the first clef
+    staves_included = False
+
+    for t in sorted(by_start.keys()):
+
+        attr_e = etree.Element("attributes")
+
+        for o in by_start[t]:
+
+            if isinstance(o, int):
+
+                etree.SubElement(attr_e, "divisions").text = "{}".format(o)
+
+            elif isinstance(o, score.KeySignature):
+
+                ks_e = etree.SubElement(attr_e, "key")
+                etree.SubElement(ks_e, "fifths").text = "{}".format(o.fifths)
+
+                if o.mode:
+
+                    etree.SubElement(ks_e, "mode").text = "{}".format(o.mode)
+
+            elif isinstance(o, score.TimeSignature):
+
+                ts_e = etree.SubElement(attr_e, "time")
+                etree.SubElement(ts_e, "beats").text = "{}".format(o.beats)
+                etree.SubElement(ts_e, "beat-type").text = "{}".format(o.beat_type)
+
+            elif isinstance(o, score.Clef):
+
+                if not staves_included:
+                    staves_e = etree.SubElement(attr_e, "staves")
+                    staves_e.text = "{}".format(len(clefs))
+                    staves_included = True
+
+                clef_e = etree.SubElement(attr_e, "clef")
+
+                if o.staff and o.staff != 1:
+
+                    clef_e.set("number", "{}".format(o.staff))
+
+                etree.SubElement(clef_e, "sign").text = "{}".format(o.sign)
+                etree.SubElement(clef_e, "line").text = "{}".format(o.line)
+
+                if o.octave_change:
+
+                    etree.SubElement(clef_e, "clef-octave-change").text = "{}".format(
+                        o.octave_change
+                    )
+            elif isinstance(o, score.Staff):
+                staff_e = etree.SubElement(attr_e, "staff-details")
+                if o.lines:
+                    etree.SubElement(staff_e, "staff-lines").text = "{}".format(
+                        o.lines
+                    )
+
+        result.append((t, None, attr_e))
+
+    return result
+
+
+@deprecated_alias(parts="score_data")
+def save_musicxml(
+    score_data: score.ScoreLike,
+    out: Optional[PathLike] = None,
+) -> Optional[str]:
+    """
+    Save a one or more Part or PartGroup instances in MusicXML format.
+
+    Parameters
+    ----------
+    score_data : Score, list, Part, or PartGroup
+        The musical score to be saved. A :class:`partitura.score.Score` object,
+        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
+        a list of these.
+    out: str, file-like object, or None, optional
+        Output file
+
+    Returns
+    -------
+    None or str
+        If no output file is specified using `out` the function returns the
+        MusicXML data as a string. Otherwise the function returns None.
+    """
+
+    if not isinstance(score_data, score.Score):
+        score_data = score.Score(
+            id=None,
+            partlist=score_data,
+        )
+
+    root = etree.Element("score-partwise")
+
+    partlist_e = etree.SubElement(root, "part-list")
+    state = {
+        "note_id_counter": {},
+        "range_counter": {},
+    }
+
+    group_stack = []
+
+    def close_group_stack():
+        while group_stack:
+            # close group
+            etree.SubElement(
+                partlist_e,
+                "part-group",
+                number="{}".format(group_stack[-1].number),
+                type="stop",
+            )
+            # remove from stack
+            group_stack.pop()
+
+    def handle_parents(part):
+        # 1. get deepest parent that is in group_stack (keep track of parents to
+        # add)
+        pg = part.parent
+        to_add = []
+        while pg:
+            if pg in group_stack:
+                break
+            to_add.append(pg)
+            pg = pg.parent
+
+        # close groups while not equal to pg
+        while group_stack:
+            if pg == group_stack[-1]:
+                break
+            else:
+                # close group
+                etree.SubElement(
+                    partlist_e,
+                    "part-group",
+                    number="{}".format(group_stack[-1].number),
+                    type="stop",
+                )
+                # remove from stack
+                group_stack.pop()
+
+        # start all parents in to_add
+        for pg in reversed(to_add):
+            # start group
+            pg_e = etree.SubElement(
+                partlist_e, "part-group", number="{}".format(pg.number), type="start"
+            )
+            if pg.group_symbol is not None:
+                symb_e = etree.SubElement(pg_e, "group-symbol")
+                symb_e.text = pg.group_symbol
+            if pg.group_name is not None:
+                name_e = etree.SubElement(pg_e, "group-name")
+                name_e.text = pg.group_name
+
+            group_stack.append(pg)
+
+    for part in score_data:
+
+        handle_parents(part)
+
+        # handle part list entry
+        scorepart_e = etree.SubElement(partlist_e, "score-part", id=part.id)
+
+        partname_e = etree.SubElement(scorepart_e, "part-name")
+        if part.part_name:
+            partname_e.text = filter_string(part.part_name)
+
+        if part.part_abbreviation:
+            partabbrev_e = etree.SubElement(scorepart_e, "part-abbreviation")
+            partabbrev_e.text = filter_string(part.part_abbreviation)
+
+        # write the part itself
+
+        part_e = etree.SubElement(root, "part", id=part.id)
+
+        for measure in part.iter_all(score.Measure):
+
+            part_e.append(etree.Comment(MEASURE_SEP_COMMENT))
+            attrib = {}
+
+            if measure.number is not None:
+
+                attrib["number"] = str(measure.number)
+
+            measure_e = etree.SubElement(part_e, "measure", **attrib)
+            contents = linearize_measure_contents(
+                part, measure.start, measure.end, state
+            )
+            measure_e.extend(contents)
+
+    close_group_stack()
+
+    if out:
+
+        if hasattr(out, "write"):
+
+            out.write(
+                etree.tostring(
+                    root.getroottree(),
+                    encoding="UTF-8",
+                    xml_declaration=True,
+                    pretty_print=True,
+                    doctype=DOCTYPE,
+                )
+            )
+
+        else:
+
+            with open(out, "wb") as f:
+
+                f.write(
+                    etree.tostring(
+                        root.getroottree(),
+                        encoding="UTF-8",
+                        xml_declaration=True,
+                        pretty_print=True,
+                        doctype=DOCTYPE,
+                    )
+                )
+
+    else:
+
+        return etree.tostring(
+            root.getroottree(),
+            encoding="UTF-8",
+            xml_declaration=True,
+            pretty_print=True,
+            doctype=DOCTYPE,
+        )
```

### Comparing `partitura-1.2.1/partitura/io/exportparangonada.py` & `partitura-1.2.2/partitura/io/exportparangonada.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,315 +1,317 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for saving Parangonada csv files
-"""
-
-import os
-
-import numpy as np
-
-from typing import Union, List, Iterable, Tuple, Optional
-
-from partitura.score import ScoreLike
-from partitura.performance import PerformanceLike, Performance, PerformedPart
-
-from partitura.utils import ensure_notearray
-
-from partitura.utils.misc import PathLike, deprecated_alias
-
-__all__ = [
-    "save_parangonada_csv",
-    "save_parangonada_alignment",
-]
-
-
-def alignment_dicts_to_array(alignment: List[dict]) -> np.ndarray:
-    """
-    create structured array from list of dicts type alignment.
-
-    Parameters
-    ----------
-    alignment : list
-        A list of note alignment dictionaries.
-
-    Returns
-    -------
-    alignarray : structured ndarray
-        Structured array containing note alignment.
-    """
-    fields = [
-        ("idx", "i4"),
-        ("matchtype", "U256"),
-        ("partid", "U256"),
-        ("ppartid", "U256"),
-    ]
-
-    array = []
-    # for all dicts create an appropriate entry in an array:
-    # match = 0, deletion  = 1, insertion = 2
-    for no, i in enumerate(alignment):
-
-        if i["label"] == "match":
-            array.append((no, "0", i["score_id"], str(i["performance_id"])))
-        elif i["label"] == "insertion":
-            array.append((no, "2", "undefined", str(i["performance_id"])))
-        elif i["label"] == "deletion":
-            array.append((no, "1", i["score_id"], "undefined"))
-
-    alignarray = np.array(array, dtype=fields)
-
-    return alignarray
-
-
-@deprecated_alias(
-    spart="score_data",
-    ppart="performance_data",
-    align="alignment",
-)
-def save_parangonada_csv(
-    alignment: List[dict],
-    performance_data: Union[PerformanceLike, np.ndarray],
-    score_data: Union[ScoreLike, np.ndarray],
-    outdir: Optional[PathLike] = None,
-    zalign: Optional[List[dict]] = None,
-    feature: Optional[List[dict]] = None,
-) -> Optional[Tuple[np.ndarray]]:
-    """
-    Save an alignment for visualization with parangonda.
-
-    Parameters
-    ----------
-    alignment : list
-        A list of note alignment dictionaries.
-    performance_data : Performance, PerformedPart, structured ndarray
-        The performance information
-    score_data : ScoreLike
-        The musical score. A :class:`partitura.score.Score` object,
-        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
-        a list of these.
-    outdir : PathLike
-        A directory to save the files into.
-    ppart : PerformedPart, structured ndarray
-        A PerformedPart or its note_array.
-    zalign : list, optional
-        A second list of note alignment dictionaries.
-    feature : list, optional
-        A list of expressive feature dictionaries.
-
-    Returns
-    -------
-    perf_note_array : np.ndarray
-        The performance note array. Only returned if `outdir` is None.
-    score_note_array: np.ndarray
-        The note array from the score. Only returned if `outdir` is None.
-    alignarray: np.ndarray
-    zalignarray: np.ndarray
-    featurearray: np.ndarray
-    """
-
-    score_note_array = ensure_notearray(score_data)
-
-    perf_note_array = ensure_notearray(performance_data)
-
-    ffields = [
-        ("velocity", "<f4"),
-        ("timing", "<f4"),
-        ("articulation", "<f4"),
-        ("id", "U256"),
-    ]
-
-    farray = []
-    notes = list(score_note_array["id"])
-    if feature is not None:
-        # veloctiy, timing, articulation, note
-        for no, i in enumerate(list(feature["id"])):
-            farray.append(
-                (
-                    feature["velocity"][no],
-                    feature["timing"][no],
-                    feature["articulation"][no],
-                    i,
-                )
-            )
-    else:
-        for no, i in enumerate(notes):
-            farray.append((0, 0, 0, i))
-
-    featurearray = np.array(farray, dtype=ffields)
-    alignarray = alignment_dicts_to_array(alignment)
-
-    if zalign is not None:
-        zalignarray = alignment_dicts_to_array(zalign)
-    else:  # if no zalign is available, save the same alignment twice
-        zalignarray = alignment_dicts_to_array(alignment)
-
-    if outdir is not None:
-        np.savetxt(
-            os.path.join(outdir, "ppart.csv"),
-            # outdir + os.path.sep + "perf_note_array.csv",
-            perf_note_array[
-                [
-                    "onset_sec",
-                    "duration_sec",
-                    "pitch",
-                    "velocity",
-                    "track",
-                    "channel",
-                    "id",
-                ]
-            ],
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(
-                [
-                    "onset_sec",
-                    "duration_sec",
-                    "pitch",
-                    "velocity",
-                    "track",
-                    "channel",
-                    "id",
-                ]
-            ),
-            comments="",
-        )
-        np.savetxt(
-            os.path.join(outdir, "part.csv"),
-            # outdir + os.path.sep + "score_note_array.csv",
-            score_note_array,
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(score_note_array.dtype.names),
-            comments="",
-        )
-        np.savetxt(
-            os.path.join(outdir, "align.csv"),
-            # outdir + os.path.sep + "align.csv",
-            alignarray,
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(alignarray.dtype.names),
-            comments="",
-        )
-        np.savetxt(
-            os.path.join(outdir, "zalign.csv"),
-            # outdir + os.path.sep + "zalign.csv",
-            zalignarray,
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(zalignarray.dtype.names),
-            comments="",
-        )
-        np.savetxt(
-            os.path.join(outdir, "feature.csv"),
-            # outdir + os.path.sep + "feature.csv",
-            featurearray,
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(featurearray.dtype.names),
-            comments="",
-        )
-    else:
-        return (
-            perf_note_array,
-            score_note_array,
-            alignarray,
-            zalignarray,
-            featurearray,
-        )
-
-
-# alias
-save_csv_for_parangonada = save_parangonada_csv
-
-
-@deprecated_alias(align="alignment", outfile="out")
-def save_parangonada_alignment(
-    alignment: List[dict],
-    out: Optional[PathLike] = None,
-):
-    """
-    Save only an alignment csv for visualization with parangonda.
-    For score, performance, and expressive features use
-    save_csv_for_parangonada()
-
-    Parameters
-    ----------
-    align : list
-        A list of note alignment dictionaries.
-
-    outdir : str
-        A directory to save the files into.
-
-
-    Returns
-    -------
-    alignarray : np.ndarray
-        Array containing the alignment. This array will only be returned if `out`
-        is not None
-    """
-    alignarray = alignment_dicts_to_array(alignment)
-
-    if out is not None:
-        np.savetxt(
-            out,
-            alignarray,
-            fmt="%.20s",
-            delimiter=",",
-            header=",".join(alignarray.dtype.names),
-            comments="",
-        )
-    else:
-        return alignarray
-
-
-# alias
-save_alignment_for_parangonada = save_parangonada_alignment
-
-
-@deprecated_alias(outfile="out", ppart="performance_data")
-def save_alignment_for_ASAP(
-    alignment: List[dict],
-    performance_data: PerformanceLike,
-    out: PathLike,
-) -> None:
-    """
-    load an alignment exported from parangonda.
-
-    Parameters
-    ----------
-    alignment : list
-        A list of note alignment dictionaries.
-    performance_data : PerformanceLike
-        A performance.
-    out : str
-        A path for the alignment tsv file.
-    """
-    if isinstance(performance_data, (Performance, Iterable)):
-        ppart = performance_data[0]
-    elif isinstance(performance_data, PerformedPart):
-        ppart = performance_data
-    notes_indexed_by_id = {
-        str(n["id"]): [
-            str(n["id"]),
-            str(n["track"]),
-            str(n["channel"]),
-            str(n["midi_pitch"]),
-            str(n["note_on"]),
-        ]
-        for n in ppart.notes
-    }
-    with open(out, "w") as f:
-        f.write("xml_id\tmidi_id\ttrack\tchannel\tpitch\tonset\n")
-        for line in alignment:
-            if line["label"] == "match":
-                outline_score = [str(line["score_id"])]
-                outline_perf = notes_indexed_by_id[str(line["performance_id"])]
-                f.write("\t".join(outline_score + outline_perf) + "\n")
-            elif line["label"] == "deletion":
-                outline_score = str(line["score_id"])
-                f.write(outline_score + "\tdeletion\n")
-            elif line["label"] == "insertion":
-                outline_score = ["insertion"]
-                outline_perf = notes_indexed_by_id[str(line["performance_id"])]
-                f.write("\t".join(outline_score + outline_perf) + "\n")
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for saving Parangonada csv files
+"""
+
+import os
+
+import numpy as np
+
+from typing import Union, List, Iterable, Tuple, Optional
+
+from partitura.score import ScoreLike
+from partitura.performance import PerformanceLike, Performance, PerformedPart
+
+from partitura.utils import ensure_notearray
+
+from partitura.utils.misc import PathLike, deprecated_alias
+
+__all__ = [
+    "save_parangonada_csv",
+    "save_parangonada_alignment",
+]
+
+
+def alignment_dicts_to_array(alignment: List[dict]) -> np.ndarray:
+    """
+    create structured array from list of dicts type alignment.
+
+    Parameters
+    ----------
+    alignment : list
+        A list of note alignment dictionaries.
+
+    Returns
+    -------
+    alignarray : structured ndarray
+        Structured array containing note alignment.
+    """
+    fields = [
+        ("idx", "i4"),
+        ("matchtype", "U256"),
+        ("partid", "U256"),
+        ("ppartid", "U256"),
+    ]
+
+    array = []
+    # for all dicts create an appropriate entry in an array:
+    # match = 0, deletion  = 1, insertion = 2
+    for no, i in enumerate(alignment):
+
+        if i["label"] == "match":
+            array.append((no, "0", i["score_id"], str(i["performance_id"])))
+        elif i["label"] == "insertion":
+            array.append((no, "2", "undefined", str(i["performance_id"])))
+        elif i["label"] == "deletion":
+            array.append((no, "1", i["score_id"], "undefined"))
+
+    alignarray = np.array(array, dtype=fields)
+
+    return alignarray
+
+
+@deprecated_alias(
+    spart="score_data",
+    ppart="performance_data",
+    align="alignment",
+)
+def save_parangonada_csv(
+    alignment: List[dict],
+    performance_data: Union[PerformanceLike, np.ndarray],
+    score_data: Union[ScoreLike, np.ndarray],
+    outdir: Optional[PathLike] = None,
+    zalign: Optional[List[dict]] = None,
+    feature: Optional[List[dict]] = None,
+) -> Optional[Tuple[np.ndarray]]:
+    """
+    Save an alignment for visualization with parangonda.
+
+    Parameters
+    ----------
+    alignment : list
+        A list of note alignment dictionaries.
+    performance_data : Performance, PerformedPart, structured ndarray
+        The performance information
+    score_data : ScoreLike
+        The musical score. A :class:`partitura.score.Score` object,
+        a :class:`partitura.score.Part`, a :class:`partitura.score.PartGroup` or
+        a list of these.
+    outdir : PathLike
+        A directory to save the files into.
+    ppart : PerformedPart, structured ndarray
+        A PerformedPart or its note_array.
+    zalign : list, optional
+        A second list of note alignment dictionaries.
+    feature : list, optional
+        A list of expressive feature dictionaries.
+
+    Returns
+    -------
+    perf_note_array : np.ndarray
+        The performance note array. Only returned if `outdir` is None.
+    score_note_array: np.ndarray
+        The note array from the score. Only returned if `outdir` is None.
+    alignarray: np.ndarray
+    zalignarray: np.ndarray
+    featurearray: np.ndarray
+    """
+
+    score_note_array = ensure_notearray(score_data)
+
+    perf_note_array = ensure_notearray(performance_data)
+
+    valid_score_note_array_fields = [
+                    "onset_beat",
+                    "duration_beat",
+                    "onset_quarter",
+                    "duration_quarter",
+                    "onset_div",
+                    "duration_div",
+                    "pitch",
+                    "voice",
+                    "id"
+                ]
+
+    valid_perf_note_array_fields = [
+                    "onset_sec",
+                    "duration_sec",
+                    "pitch",
+                    "velocity",
+                    "track",
+                    "channel",
+                    "id",
+                ]
+
+    ffields = [
+        ("velocity", "<f4"),
+        ("timing", "<f4"),
+        ("articulation", "<f4"),
+        ("id", "U256"),
+    ]
+
+    farray = []
+    notes = list(score_note_array["id"])
+    if feature is not None:
+        # veloctiy, timing, articulation, note
+        for no, i in enumerate(list(feature["id"])):
+            farray.append(
+                (
+                    feature["velocity"][no],
+                    feature["timing"][no],
+                    feature["articulation"][no],
+                    i,
+                )
+            )
+    else:
+        for no, i in enumerate(notes):
+            farray.append((0, 0, 0, i))
+
+    featurearray = np.array(farray, dtype=ffields)
+    alignarray = alignment_dicts_to_array(alignment)
+
+    if zalign is not None:
+        zalignarray = alignment_dicts_to_array(zalign)
+    else:  # if no zalign is available, save the same alignment twice
+        zalignarray = alignment_dicts_to_array(alignment)
+
+    if outdir is not None:
+        np.savetxt(
+            os.path.join(outdir, "ppart.csv"),
+            # outdir + os.path.sep + "perf_note_array.csv",
+            perf_note_array[valid_perf_note_array_fields],
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(valid_perf_note_array_fields),
+            comments="",
+        )
+        np.savetxt(
+            os.path.join(outdir, "part.csv"),
+            # outdir + os.path.sep + "score_note_array.csv",
+            score_note_array[valid_score_note_array_fields],
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(valid_score_note_array_fields),
+            comments="",
+        )
+        np.savetxt(
+            os.path.join(outdir, "align.csv"),
+            # outdir + os.path.sep + "align.csv",
+            alignarray,
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(alignarray.dtype.names),
+            comments="",
+        )
+        np.savetxt(
+            os.path.join(outdir, "zalign.csv"),
+            # outdir + os.path.sep + "zalign.csv",
+            zalignarray,
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(zalignarray.dtype.names),
+            comments="",
+        )
+        np.savetxt(
+            os.path.join(outdir, "feature.csv"),
+            # outdir + os.path.sep + "feature.csv",
+            featurearray,
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(featurearray.dtype.names),
+            comments="",
+        )
+    else:
+        return (
+            perf_note_array,
+            score_note_array,
+            alignarray,
+            zalignarray,
+            featurearray,
+        )
+
+
+# alias
+save_csv_for_parangonada = save_parangonada_csv
+
+
+@deprecated_alias(align="alignment", outfile="out")
+def save_parangonada_alignment(
+    alignment: List[dict],
+    out: Optional[PathLike] = None,
+):
+    """
+    Save only an alignment csv for visualization with parangonda.
+    For score, performance, and expressive features use
+    save_csv_for_parangonada()
+
+    Parameters
+    ----------
+    align : list
+        A list of note alignment dictionaries.
+
+    outdir : str
+        A directory to save the files into.
+
+
+    Returns
+    -------
+    alignarray : np.ndarray
+        Array containing the alignment. This array will only be returned if `out`
+        is not None
+    """
+    alignarray = alignment_dicts_to_array(alignment)
+
+    if out is not None:
+        np.savetxt(
+            out,
+            alignarray,
+            fmt="%.20s",
+            delimiter=",",
+            header=",".join(alignarray.dtype.names),
+            comments="",
+        )
+    else:
+        return alignarray
+
+
+# alias
+save_alignment_for_parangonada = save_parangonada_alignment
+
+
+@deprecated_alias(outfile="out", ppart="performance_data")
+def save_alignment_for_ASAP(
+    alignment: List[dict],
+    performance_data: PerformanceLike,
+    out: PathLike,
+) -> None:
+    """
+    load an alignment exported from parangonda.
+
+    Parameters
+    ----------
+    alignment : list
+        A list of note alignment dictionaries.
+    performance_data : PerformanceLike
+        A performance.
+    out : str
+        A path for the alignment tsv file.
+    """
+    if isinstance(performance_data, (Performance, Iterable)):
+        ppart = performance_data[0]
+    elif isinstance(performance_data, PerformedPart):
+        ppart = performance_data
+    notes_indexed_by_id = {
+        str(n["id"]): [
+            str(n["id"]),
+            str(n["track"]),
+            str(n["channel"]),
+            str(n["midi_pitch"]),
+            str(n["note_on"]),
+        ]
+        for n in ppart.notes
+    }
+    with open(out, "w") as f:
+        f.write("xml_id\tmidi_id\ttrack\tchannel\tpitch\tonset\n")
+        for line in alignment:
+            if line["label"] == "match":
+                outline_score = [str(line["score_id"])]
+                outline_perf = notes_indexed_by_id[str(line["performance_id"])]
+                f.write("\t".join(outline_score + outline_perf) + "\n")
+            elif line["label"] == "deletion":
+                outline_score = str(line["score_id"])
+                f.write(outline_score + "\tdeletion\n")
+            elif line["label"] == "insertion":
+                outline_score = ["insertion"]
+                outline_perf = notes_indexed_by_id[str(line["performance_id"])]
+                f.write("\t".join(outline_score + outline_perf) + "\n")
```

### Comparing `partitura-1.2.1/partitura/io/importmatch.py` & `partitura-1.2.2/partitura/io/importmatch.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,835 +1,835 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for parsing matchfiles
-"""
-import os
-from typing import Union, Tuple, Optional, Callable, List
-import warnings
-
-import numpy as np
-
-from partitura import score
-from partitura.score import Part, Score
-from partitura.performance import PerformedPart, Performance
-from partitura.musicanalysis import estimate_voices, estimate_key
-
-from partitura.io.matchlines_v0 import (
-    FROM_MATCHLINE_METHODS as FROM_MATCHLINE_METHODSV0,
-    parse_matchline as parse_matchlinev0,
-    MatchInfo as MatchInfoV0,
-    MatchMeta as MatchMetaV0,
-    MatchSnote as MatchSnoteV0,
-    MatchNote as MatchNoteV0,
-    MatchSnoteNote as MatchSnoteNoteV0,
-    MatchSnoteDeletion as MatchSnoteDeletionV0,
-    MatchSnoteTrailingScore as MatchSnoteTrailingScoreV0,
-    MatchInsertionNote as MatchInsertionNoteV0,
-    MatchHammerBounceNote as MatchHammerBounceNoteV0,
-    MatchTrailingPlayedNote as MatchTrailingPlayedNoteV0,
-    MatchSustainPedal as MatchSustainPedalV0,
-    MatchSoftPedal as MatchSoftPedalV0,
-    MatchTrillNote as MatchTrillNoteV0,
-)
-
-from partitura.io.matchlines_v1 import (
-    FROM_MATCHLINE_METHODS as FROM_MATCHLINE_METHODSV1,
-    MatchInfo as MatchInfoV1,
-    MatchScoreProp as MatchScorePropV1,
-    MatchSection as MatchSectionV1,
-    MatchStime as MatchStimeV1,
-    MatchPtime as MatchPtimeV1,
-    MatchStimePtime as MatchStimePtimeV1,
-    MatchSnote as MatchSnoteV1,
-    MatchNote as MatchNoteV1,
-    MatchSnoteNote as MatchSnoteNoteV1,
-    MatchSnoteDeletion as MatchSnoteDeletionV1,
-    MatchInsertionNote as MatchInsertionNoteV1,
-    MatchSustainPedal as MatchSustainPedalV1,
-    MatchSoftPedal as MatchSoftPedalV1,
-    MatchOrnamentNote as MatchOrnamentNoteV1,
-)
-
-from partitura.io.matchfile_base import (
-    MatchError,
-    MatchFile,
-    MatchLine,
-    BaseSnoteLine,
-    BaseSnoteNoteLine,
-    BaseStimePtimeLine,
-    BaseDeletionLine,
-    BaseInsertionLine,
-    BaseOrnamentLine,
-    BaseSustainPedalLine,
-    BaseSoftPedalLine,
-)
-
-from partitura.io.matchfile_utils import (
-    Version,
-    number_pattern,
-    MatchTimeSignature,
-    MatchKeySignature,
-    format_pnote_id,
-)
-
-from partitura.utils.music import (
-    midi_ticks_to_seconds,
-    pitch_spelling_to_midi_pitch,
-    ensure_pitch_spelling_format,
-    key_name_to_fifths_mode,
-    estimate_clef_properties,
-    note_array_from_note_list,
-)
-
-
-from partitura.utils.misc import (
-    deprecated_alias,
-    deprecated_parameter,
-    PathLike,
-    get_document_name,
-)
-
-from partitura.utils.generic import interp1d, partition, iter_current_next
-
-__all__ = ["load_match"]
-
-
-def get_version(line: str) -> Version:
-    """
-    Get version from the first line. Since the
-    first version of the format did not include this line,
-    we assume that the version is 0.1.0 if no version is
-    found.
-
-    Parameters
-    ----------
-    line: str
-        The first line of the match file.
-
-    Returns
-    -------
-    version : Version
-        The version of the match file
-    """
-    version = Version(0, 1, 0)
-
-    for parser in (MatchInfoV1, MatchInfoV0):
-        try:
-            ml = parser.from_matchline(line)
-            if isinstance(getattr(ml, "Value", None), Version):
-                version = ml.Value
-                return version
-
-        except MatchError:
-
-            pass
-
-    return version
-
-
-def parse_matchline(
-    line: str,
-    from_matchline_methods: List[Callable[[str], MatchLine]],
-    version: Version,
-    debug: bool = False,
-) -> Optional[MatchLine]:
-    """
-    Return objects representing the line as one of:
-
-    * hammer_bounce-PlayedNote.
-    * info(Attribute, Value).
-    * insertion-PlayedNote.
-    * ornament(Anchor)-PlayedNote.
-    * ScoreNote-deletion.
-    * ScoreNote-PlayedNote.
-    * ScoreNote-trailing_score_note.
-    * trailing_played_note-PlayedNote.
-    * trill(Anchor)-PlayedNote.
-    * meta(Attribute, Value, Bar, Beat).
-    * sustain(Time, Value)
-    * soft(Time, Value)
-
-    or None if none can be matched
-
-    Parameters
-    ----------
-    line : str
-        Line of the match file
-    from_matchline_methods : List[Callable[[str], MatchLine]]
-
-    Returns
-    -------
-    matchline : subclass of `MatchLine`
-       Object representing the line.
-    """
-
-    matchline = None
-    for from_matchline in from_matchline_methods:
-        try:
-            matchline = from_matchline(line, version=version)
-            break
-        except Exception as e:
-            if not isinstance(e, MatchError):
-                print(line, e, version)  # pragma: no cover
-            continue
-
-    return matchline
-
-
-@deprecated_alias(fn="filename", create_part="create_score")
-def load_matchfile(
-    filename: PathLike,
-) -> MatchFile:
-    """
-    Load a Matchfile as a `MatchFile` instance
-    """
-
-    if not os.path.exists(filename):
-        raise ValueError("Filename does not exist")  # pragma: no cover
-
-    with open(filename) as f:
-        raw_lines = f.read().splitlines()
-
-    version = get_version(raw_lines[0])
-
-    from_matchline_methods = FROM_MATCHLINE_METHODSV1
-    if version < Version(1, 0, 0):
-        from_matchline_methods = FROM_MATCHLINE_METHODSV0
-
-    parsed_lines = [
-        parse_matchline(line, from_matchline_methods, version) for line in raw_lines
-    ]
-
-    parsed_lines = [pl for pl in parsed_lines if pl is not None]
-
-    mf = MatchFile(lines=parsed_lines)
-
-    return mf
-
-
-@deprecated_alias(fn="filename", create_part="create_score")
-def load_match(
-    filename: PathLike,
-    create_score: bool = False,
-    pedal_threshold: int = 64,
-    first_note_at_zero: bool = False,
-    offset_duration_whole: bool = True,
-) -> Tuple[Union[Performance, list, Score]]:
-    """
-    Load a matchfile.
-
-    Parameters
-    ----------
-    filename : str
-        The matchfile
-    create_score : bool, optional
-        When True create a Part object from the snote information in
-        the match file. Defaults to False.
-    pedal_threshold : int, optional
-        Threshold for adjusting sound off of the performed notes using
-        pedal information. Defaults to 64.
-    first_note_at_zero : bool, optional
-        When True the note_on and note_off times in the performance
-        are shifted to make the first note_on time equal zero.
-
-    Returns
-    -------
-    performance : :class:partitura.performance.Performance
-    alignment : list
-        The score--performance alignment, a list of dictionaries
-    scr : :class:partitura.score.Score
-        The score. This item is only returned when `create_score` = True.
-    """
-    # Parse Matchfile
-    mf = load_matchfile(filename)
-
-    # Generate PerformedPart
-    ppart = performed_part_from_match(mf, pedal_threshold, first_note_at_zero)
-
-    performance = Performance(
-        id=get_document_name(filename),
-        performedparts=ppart,
-    )
-    # Generate Part
-    if create_score:
-        spart = part_from_matchfile(
-            mf,
-            match_offset_duration_in_whole=offset_duration_whole,
-        )
-
-        scr = score.Score(id=get_document_name(filename), partlist=[spart])
-    # Alignment
-    alignment = alignment_from_matchfile(mf)
-
-    if create_score:
-        return performance, alignment, scr
-    else:
-        return performance, alignment
-
-
-def note_alignment_from_matchfile(mf: MatchFile) -> List[dict]:
-    """
-    Get a note-level alignment from a MatchFile instance
-
-    Parameters
-    ----------
-    mf : MatchFile
-        A score-to-performance alignment
-
-    Returns
-    -------
-    results : List[dict]
-        An alignmnet as a list of dictionaries for each note.
-    """
-    result = []
-
-    for line in mf.lines:
-        if isinstance(line, BaseSnoteNoteLine):
-            result.append(
-                dict(
-                    label="match",
-                    score_id=str(line.snote.Anchor),
-                    performance_id=format_pnote_id(line.note.Id),
-                )
-            )
-
-        elif isinstance(
-            line,
-            BaseDeletionLine,
-        ):
-            if "leftOutTied" in line.snote.ScoreAttributesList:
-                continue
-            else:
-                result.append(dict(label="deletion", score_id=str(line.snote.Anchor)))
-        elif isinstance(
-            line,
-            BaseInsertionLine,
-        ):
-            result.append(
-                dict(label="insertion", performance_id=format_pnote_id(line.note.Id))
-            )
-        elif isinstance(line, BaseOrnamentLine):
-            if isinstance(line, MatchTrillNoteV0):
-                ornament_type = "trill"
-            elif isinstance(line, MatchOrnamentNoteV1):
-                ornament_type = line.OrnamentType
-            else:
-                ornament_type = "generic_ornament"
-            result.append(
-                dict(
-                    label="ornament",
-                    score_id=str(line.Anchor),
-                    performance_id=format_pnote_id(line.note.Id),
-                    type=ornament_type,
-                )
-            )
-
-    return result
-
-
-# alias
-alignment_from_matchfile = note_alignment_from_matchfile
-
-
-def performed_part_from_match(
-    mf: MatchFile,
-    pedal_threshold: int = 64,
-    first_note_at_zero: bool = False,
-) -> PerformedPart:
-    """
-    Make PerformedPart from performance info in a MatchFile
-
-    Parameters
-    ----------
-    mf : MatchFile
-        A MatchFile instance
-    pedal_threshold : int, optional
-        Threshold for adjusting sound off of the performed notes using
-        pedal information. Defaults to 64.
-    first_note_at_zero : bool, optional
-        When True the note_on and note_off times in the performance
-        are shifted to make the first note_on time equal zero.
-
-    Returns
-    -------
-    ppart : PerformedPart
-        A performed part
-
-    """
-    # Get midi time units
-    mpq = mf.info("midiClockRate")  # 500000 -> microseconds per quarter
-    ppq = mf.info("midiClockUnits")  # 500 -> parts per quarter
-
-    # PerformedNote instances for all MatchNotes
-    notes = []
-
-    first_note = next(mf.iter_notes(), None)
-    if first_note and first_note_at_zero:
-        offset = midi_ticks_to_seconds(first_note.Onset, mpq=mpq, ppq=ppq)
-        offset_tick = first_note.Onset
-    else:
-        offset = 0
-        offset_tick = 0
-
-    notes = [
-        dict(
-            id=format_pnote_id(note.Id),
-            midi_pitch=note.MidiPitch,
-            note_on=midi_ticks_to_seconds(note.Onset, mpq, ppq) - offset,
-            note_off=midi_ticks_to_seconds(note.Offset, mpq, ppq) - offset,
-            note_on_tick=note.Onset - offset_tick,
-            note_off_tick=note.Offset - offset_tick,
-            sound_off=midi_ticks_to_seconds(note.Offset, mpq, ppq) - offset,
-            velocity=note.Velocity,
-            track=getattr(note, "Track", 0),
-            channel=getattr(note, "Channel", 1),
-        )
-        for note in mf.notes
-    ]
-
-    # SustainPedal instances for sustain pedal lines
-    sustain_pedal = [
-        dict(
-            number=64,
-            time=midi_ticks_to_seconds(ped.Time, mpq, ppq),
-            value=ped.Value,
-        )
-        for ped in mf.sustain_pedal
-    ]
-
-    # SoftPedal instances for soft pedal lines
-    soft_pedal = [
-        dict(
-            number=67,
-            time=midi_ticks_to_seconds(ped.Time, mpq, ppq),
-            value=ped.Value,
-        )
-        for ped in mf.soft_pedal
-    ]
-
-    # Make performed part
-    ppart = PerformedPart(
-        id="P1",
-        part_name=mf.info("piece"),
-        notes=notes,
-        controls=sustain_pedal + soft_pedal,
-        sustain_pedal_threshold=pedal_threshold,
-    )
-    return ppart
-
-
-def sort_snotes(snotes: List[BaseSnoteLine]) -> List[BaseSnoteLine]:
-    """
-    Sort s(core)notes.
-
-    Parameters
-    ----------
-    snotes : list
-        The score notes
-
-    Returns
-    -------
-    snotes_sorted : list
-        The sorted score notes
-    """
-    sidx = np.lexsort(
-        list(zip(*[(float(n.Offset), float(n.Beat), float(n.Measure)) for n in snotes]))
-    )
-    return [snotes[i] for i in sidx if snotes[i].NoteName.lower() != "r"]
-
-
-def part_from_matchfile(
-    mf: MatchFile,
-    match_offset_duration_in_whole: bool = True,
-) -> Part:
-    """
-    Create a score part from a matchfile.
-
-    Parameters
-    ----------
-    mf : MatchFile
-        An instance of `MatchFile`
-
-    match_offset_duration_in_whole: Boolean
-        A flag for the type of offset and duration given in the matchfile.
-        When true, the function expects the values to be given in whole
-        notes (e.g. 1/4 for a quarter note) independet of time signature.
-
-
-    Returns
-    -------
-    part : partitura.score.Part
-        An instance of `Part` containing score information.
-
-    """
-    part = score.Part("P1", mf.info("piece"))
-    snotes = sort_snotes(mf.snotes)
-
-    ts = mf.time_signatures
-    min_time = snotes[0].OnsetInBeats  # sorted by OnsetInBeats
-    max_time = max(n.OffsetInBeats for n in snotes)
-    _, beats_map, _, beat_type_map, min_time_q, max_time_q = make_timesig_maps(
-        ts, max_time
-    )
-
-    # compute necessary divs based on the types of notes in the
-    # match snotes (only integers)
-    divs_arg = [
-        max(int((beat_type_map(note.OnsetInBeats) / 4)), 1)
-        * note.Offset.denominator
-        * (note.Offset.tuple_div or 1)
-        for note in snotes
-    ]
-    divs_arg += [
-        max(int((beat_type_map(note.OnsetInBeats) / 4)), 1)
-        * note.Duration.denominator
-        * (note.Duration.tuple_div or 1)
-        for note in snotes
-    ]
-
-    onset_in_beats = np.array([note.OnsetInBeats for note in snotes])
-    unique_onsets, inv_idxs = np.unique(onset_in_beats, return_inverse=True)
-    # unique_onset_idxs = [np.where(onset_in_beats == u) for u in unique_onsets]
-
-    iois_in_beats = np.diff(unique_onsets)
-    beat_to_quarter = 4 / beat_type_map(onset_in_beats)
-
-    iois_in_quarters_offset = np.r_[
-        beat_to_quarter[0] * onset_in_beats[0],
-        (4 / beat_type_map(unique_onsets[:-1])) * iois_in_beats,
-    ]
-    onset_in_quarters = np.cumsum(iois_in_quarters_offset)
-    iois_in_quarters = np.diff(onset_in_quarters)
-
-    # ___ these divs are relative to quarters;
-    divs = np.lcm.reduce(np.unique(divs_arg))
-    onset_in_divs = np.r_[0, np.cumsum(divs * iois_in_quarters)][inv_idxs]
-    onset_in_quarters = onset_in_quarters[inv_idxs]
-
-    # duration_in_beats = np.array([note.DurationInBeats for note in snotes])
-    # duration_in_quarters = duration_in_beats * beat_to_quarter
-    # duration_in_divs = duration_in_quarters * divs
-
-    part.set_quarter_duration(0, divs)
-    bars = np.unique([n.Measure for n in snotes])
-    t = min_time
-    t = t * 4 / beat_type_map(min_time)
-    offset = t
-    bar_times = {}
-
-    if t > 0:
-        # if we have an incomplete first measure that isn't an anacrusis
-        # measure, add a rest (dummy)
-        # t = t-t%beats_map(min_time)
-
-        # if starting beat is above zero, add padding
-        rest = score.Rest()
-        part.add(rest, start=0, end=t * divs)
-        onset_in_divs += t * divs
-        offset = 0
-        t = t - t % beats_map(min_time)
-
-    for b0, b1 in iter_current_next(bars, end=bars[-1] + 1):
-
-        bar_times.setdefault(b0, t)
-        if t < 0:
-            t = 0
-
-        else:
-            # multiply by diff between consecutive bar numbers
-            n_bars = b1 - b0
-            if t <= max_time_q:
-                t += (n_bars * 4 * beats_map(t)) / beat_type_map(t)
-
-    for ni, note in enumerate(snotes):
-        # start of bar in quarter units
-        bar_start = bar_times[note.Measure]
-
-        on_off_scale = 1
-        # on_off_scale = 1 means duration and beat offset are given in
-        # whole notes, else they're given in beats (as in the KAIST data)
-        if not match_offset_duration_in_whole:
-            on_off_scale = beat_type_map(bar_start)
-
-        # offset within bar in quarter units adjusted for different
-        # time signatures -> 4 / beat_type_map(bar_start)
-        bar_offset = (note.Beat - 1) * 4 / beat_type_map(bar_start)
-
-        # offset within beat in quarter units adjusted for different
-        # time signatures -> 4 / beat_type_map(bar_start)
-        beat_offset = (
-            4
-            / on_off_scale
-            * note.Offset.numerator
-            / (note.Offset.denominator * (note.Offset.tuple_div or 1))
-        )
-
-        # check anacrusis measure beat counting type for the first note
-        if bar_start < 0 and (bar_offset != 0 or beat_offset != 0) and ni == 0:
-            # in case of fully counted anacrusis we set the bar_start
-            # to -bar_duration (in quarters) so that the below calculation is correct
-            # not active for shortened anacrusis measures
-            bar_start = -beats_map(bar_start) * 4 / beat_type_map(bar_start)
-            # reset the bar_start for other notes in the anacrusis measure
-            bar_times[note.Bar] = bar_start
-
-        # convert the onset time in quarters (0 at first barline) to onset
-        # time in divs (0 at first note)
-        onset_divs = int(round(divs * (bar_start + bar_offset + beat_offset - offset)))
-
-        if not np.isclose(onset_divs, onset_in_divs[ni], atol=divs * 0.01):
-            warnings.warn(
-                "Calculated `onset_divs` does not match `OnsetInBeats` " "information!."
-            )
-            onset_divs = onset_in_divs[ni]
-        assert onset_divs >= 0
-        assert np.isclose(onset_divs, onset_in_divs[ni], atol=divs * 0.01)
-
-        articulations = set()
-        if "staccato" in note.ScoreAttributesList or "stac" in note.ScoreAttributesList:
-            articulations.add("staccato")
-        if "accent" in note.ScoreAttributesList:
-            articulations.add("accent")
-        if "leftOutTied" in note.ScoreAttributesList:
-            continue
-
-        # dictionary with keyword args with which the Note
-        # (or GraceNote) will be instantiated
-        note_attributes = dict(
-            step=note.NoteName,
-            octave=note.Octave,
-            alter=note.Modifier,
-            id=note.Anchor,
-            articulations=articulations,
-        )
-
-        staff_nr = next(
-            (a[-1] for a in note.ScoreAttributesList if a.startswith("staff")), None
-        )
-        try:
-            note_attributes["staff"] = int(staff_nr)
-        except (TypeError, ValueError):
-            # no staff attribute, or staff attribute does not end with a number
-            note_attributes["staff"] = None
-
-        if "s" in note.ScoreAttributesList:
-            note_attributes["voice"] = 1
-        else:
-            note_attributes["voice"] = next(
-                (int(a) for a in note.ScoreAttributesList if number_pattern.match(a)),
-                None,
-            )
-
-        # get rid of this if as soon as we have a way to iterate over the
-        # duration components. For now we have to treat the cases simple
-        # and compound durations separately.
-        if note.Duration.add_components:
-            prev_part_note = None
-
-            for i, (num, den, tuple_div) in enumerate(note.Duration.add_components):
-                # when we add multiple notes that are tied, the first note will
-                # get the original note id, and subsequent notes will get a
-                # derived note id (by appending, 'a', 'b', 'c',...)
-                if i > 0:
-                    # tnote_id = 'n{}_{}'.format(note.Anchor, i)
-                    note_attributes["id"] = score._make_tied_note_id(
-                        note_attributes["id"]
-                    )
-
-                part_note = score.Note(**note_attributes)
-
-                # duration_divs from local beats --> 4/beat_type_map(bar_start)
-
-                duration_divs = int(
-                    (4 / on_off_scale) * divs * num / (den * (tuple_div or 1))
-                )
-
-                assert duration_divs > 0
-                offset_divs = onset_divs + duration_divs
-                part.add(part_note, onset_divs, offset_divs)
-
-                if prev_part_note:
-                    prev_part_note.tie_next = part_note
-                    part_note.tie_prev = prev_part_note
-                prev_part_note = part_note
-                onset_divs = offset_divs
-
-        else:
-            num = note.Duration.numerator
-            den = note.Duration.denominator
-            tuple_div = note.Duration.tuple_div
-
-            # duration_divs from local beats --> 4/beat_type_map(bar_start)
-            duration_divs = int(
-                divs * 4 / on_off_scale * num / (den * (tuple_div or 1))
-            )
-            offset_divs = onset_divs + duration_divs
-
-            # notes with duration 0, are also treated as grace notes, even if
-            # they do not have a 'grace' score attribute
-            if "grace" in note.ScoreAttributesList or note.Duration.numerator == 0:
-                part_note = score.GraceNote(
-                    grace_type="appoggiatura", **note_attributes
-                )
-
-            else:
-                part_note = score.Note(**note_attributes)
-
-            part.add(part_note, onset_divs, offset_divs)
-
-    # add time signatures
-    for (ts_beat_time, ts_bar, tsg) in ts:
-        ts_beats = tsg.numerator
-        ts_beat_type = tsg.denominator
-        # check if time signature is in a known measure (from notes)
-        if ts_bar in bar_times.keys():
-            bar_start_divs = int(divs * (bar_times[ts_bar] - offset))  # in quarters
-            bar_start_divs = max(0, bar_start_divs)
-        else:
-            bar_start_divs = 0
-        part.add(score.TimeSignature(ts_beats, ts_beat_type), bar_start_divs)
-
-    # add key signatures
-    for (ks_beat_time, ks_bar, keys) in mf.key_signatures:
-
-        if ks_bar in bar_times.keys():
-            bar_start_divs = int(divs * (bar_times[ks_bar] - offset))  # in quarters
-            bar_start_divs = max(0, bar_start_divs)
-        else:
-            bar_start_divs = 0
-
-        # TODO
-        # * use key estimation if there are multiple defined keys
-        # fifths, mode = key_name_to_fifths_mode(key_name)
-        part.add(score.KeySignature(keys.fifths, keys.mode), ks_bar)
-
-    add_staffs(part)
-    # add_clefs(part)
-
-    # add incomplete measure if necessary
-    if offset < 0:
-        part.add(score.Measure(number=0), 0, int(-offset * divs))
-
-    # add the rest of the measures automatically
-    score.add_measures(part)
-    score.tie_notes(part)
-    score.find_tuplets(part)
-
-    if not all([n.voice for n in part.notes_tied]):
-        for note in part.notes_tied:
-            if note.voice is None:
-                note.voice = 1
-
-    return part
-
-
-def make_timesig_maps(
-    ts_orig: List[Tuple[float, int, MatchTimeSignature]],
-    max_time: float,
-) -> (Callable, Callable, Callable, Callable, float, float):
-    """
-    Create time signature (interpolation) maps
-
-    Parameters
-    ----------
-    ts_orig : List[Tuple[float, int, MatchTimeSignature]]
-        A list of tuples containing position in beats, measure and
-        MatchTimeSignature instances
-    max_time : float
-        Maximal time of the time signatures
-
-    Returns
-    -------
-    beats_map: callable
-    qbeats_map: callable
-    beat_type_map: callable
-    qbeat_type_map: callable
-    start_q: float
-    end_q: float
-    """
-    # TODO: make sure that ts_orig covers range from min_time
-    # return two functions that map score times (in quarter units) to time sig
-    # beats, and time sig beat_type respectively
-    ts = list(ts_orig)
-    assert len(ts) > 0
-    ts.append((max_time, None, ts[-1][2]))
-
-    x = np.array([t for t, _, _ in ts])
-    y = np.array([(x.numerator, x.denominator) for _, _, x in ts])
-
-    start_q = x[0] * 4 / y[0, 1]
-    x_q = np.cumsum(np.r_[start_q, 4 * np.diff(x) / y[:-1, 1]])
-    end_q = x_q[-1]
-
-    # TODO: fix error with bounds
-    qbeats_map = interp1d(
-        x_q,
-        y[:, 0],
-        kind="previous",
-        bounds_error=False,
-        fill_value=(y[0, 0], y[-1, 0]),
-    )
-    qbeat_type_map = interp1d(
-        x_q,
-        y[:, 1],
-        kind="previous",
-        bounds_error=False,
-        fill_value=(y[0, 1], y[-1, 1]),
-    )
-    beats_map = interp1d(
-        x,
-        y[:, 0],
-        kind="previous",
-        bounds_error=False,
-        fill_value=(y[0, 0], y[-1, 0]),
-    )
-    beat_type_map = interp1d(
-        x,
-        y[:, 1],
-        kind="previous",
-        bounds_error=False,
-        fill_value=(y[0, 1], y[-1, 1]),
-    )
-
-    return beats_map, qbeats_map, beat_type_map, qbeat_type_map, start_q, end_q
-
-
-def add_staffs(part: Part, split: int = 55, only_missing: bool = True) -> None:
-    """
-        Method to add staff information to a part
-
-        Parameters
-        ----------
-        part: Part
-            Part to add staff information to.
-        split: int
-            MIDI pitch to split staff into upper and lower. Default is 55
-        only_missing: bool
-            If True, only add staff to those notes that do not have staff info already.
-    x"""
-    # assign staffs using a hard limit
-    notes = part.notes_tied
-    for n in notes:
-
-        if only_missing and n.staff:
-            continue
-
-        if n.midi_pitch > split:
-            staff = 1
-        else:
-            staff = 2
-
-        n.staff = staff
-
-        n_tied = n.tie_next
-        while n_tied:
-            n_tied.staff = staff
-            n_tied = n_tied.tie_next
-
-    part.add(score.Clef(staff=1, sign="G", line=2, octave_change=0), 0)
-    part.add(score.Clef(staff=2, sign="F", line=4, octave_change=0), 0)
-
-
-if __name__ == "__main__":
-
-    pass
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for parsing matchfiles
+"""
+import os
+from typing import Union, Tuple, Optional, Callable, List
+import warnings
+
+import numpy as np
+
+from partitura import score
+from partitura.score import Part, Score
+from partitura.performance import PerformedPart, Performance
+from partitura.musicanalysis import estimate_voices, estimate_key
+
+from partitura.io.matchlines_v0 import (
+    FROM_MATCHLINE_METHODS as FROM_MATCHLINE_METHODSV0,
+    parse_matchline as parse_matchlinev0,
+    MatchInfo as MatchInfoV0,
+    MatchMeta as MatchMetaV0,
+    MatchSnote as MatchSnoteV0,
+    MatchNote as MatchNoteV0,
+    MatchSnoteNote as MatchSnoteNoteV0,
+    MatchSnoteDeletion as MatchSnoteDeletionV0,
+    MatchSnoteTrailingScore as MatchSnoteTrailingScoreV0,
+    MatchInsertionNote as MatchInsertionNoteV0,
+    MatchHammerBounceNote as MatchHammerBounceNoteV0,
+    MatchTrailingPlayedNote as MatchTrailingPlayedNoteV0,
+    MatchSustainPedal as MatchSustainPedalV0,
+    MatchSoftPedal as MatchSoftPedalV0,
+    MatchTrillNote as MatchTrillNoteV0,
+)
+
+from partitura.io.matchlines_v1 import (
+    FROM_MATCHLINE_METHODS as FROM_MATCHLINE_METHODSV1,
+    MatchInfo as MatchInfoV1,
+    MatchScoreProp as MatchScorePropV1,
+    MatchSection as MatchSectionV1,
+    MatchStime as MatchStimeV1,
+    MatchPtime as MatchPtimeV1,
+    MatchStimePtime as MatchStimePtimeV1,
+    MatchSnote as MatchSnoteV1,
+    MatchNote as MatchNoteV1,
+    MatchSnoteNote as MatchSnoteNoteV1,
+    MatchSnoteDeletion as MatchSnoteDeletionV1,
+    MatchInsertionNote as MatchInsertionNoteV1,
+    MatchSustainPedal as MatchSustainPedalV1,
+    MatchSoftPedal as MatchSoftPedalV1,
+    MatchOrnamentNote as MatchOrnamentNoteV1,
+)
+
+from partitura.io.matchfile_base import (
+    MatchError,
+    MatchFile,
+    MatchLine,
+    BaseSnoteLine,
+    BaseSnoteNoteLine,
+    BaseStimePtimeLine,
+    BaseDeletionLine,
+    BaseInsertionLine,
+    BaseOrnamentLine,
+    BaseSustainPedalLine,
+    BaseSoftPedalLine,
+)
+
+from partitura.io.matchfile_utils import (
+    Version,
+    number_pattern,
+    MatchTimeSignature,
+    MatchKeySignature,
+    format_pnote_id,
+)
+
+from partitura.utils.music import (
+    midi_ticks_to_seconds,
+    pitch_spelling_to_midi_pitch,
+    ensure_pitch_spelling_format,
+    key_name_to_fifths_mode,
+    estimate_clef_properties,
+    note_array_from_note_list,
+)
+
+
+from partitura.utils.misc import (
+    deprecated_alias,
+    deprecated_parameter,
+    PathLike,
+    get_document_name,
+)
+
+from partitura.utils.generic import interp1d, partition, iter_current_next
+
+__all__ = ["load_match"]
+
+
+def get_version(line: str) -> Version:
+    """
+    Get version from the first line. Since the
+    first version of the format did not include this line,
+    we assume that the version is 0.1.0 if no version is
+    found.
+
+    Parameters
+    ----------
+    line: str
+        The first line of the match file.
+
+    Returns
+    -------
+    version : Version
+        The version of the match file
+    """
+    version = Version(0, 1, 0)
+
+    for parser in (MatchInfoV1, MatchInfoV0):
+        try:
+            ml = parser.from_matchline(line)
+            if isinstance(getattr(ml, "Value", None), Version):
+                version = ml.Value
+                return version
+
+        except MatchError:
+
+            pass
+
+    return version
+
+
+def parse_matchline(
+    line: str,
+    from_matchline_methods: List[Callable[[str], MatchLine]],
+    version: Version,
+    debug: bool = False,
+) -> Optional[MatchLine]:
+    """
+    Return objects representing the line as one of:
+
+    * hammer_bounce-PlayedNote.
+    * info(Attribute, Value).
+    * insertion-PlayedNote.
+    * ornament(Anchor)-PlayedNote.
+    * ScoreNote-deletion.
+    * ScoreNote-PlayedNote.
+    * ScoreNote-trailing_score_note.
+    * trailing_played_note-PlayedNote.
+    * trill(Anchor)-PlayedNote.
+    * meta(Attribute, Value, Bar, Beat).
+    * sustain(Time, Value)
+    * soft(Time, Value)
+
+    or None if none can be matched
+
+    Parameters
+    ----------
+    line : str
+        Line of the match file
+    from_matchline_methods : List[Callable[[str], MatchLine]]
+
+    Returns
+    -------
+    matchline : subclass of `MatchLine`
+       Object representing the line.
+    """
+
+    matchline = None
+    for from_matchline in from_matchline_methods:
+        try:
+            matchline = from_matchline(line, version=version)
+            break
+        except Exception as e:
+            if not isinstance(e, MatchError):
+                print(line, e, version)  # pragma: no cover
+            continue
+
+    return matchline
+
+
+@deprecated_alias(fn="filename", create_part="create_score")
+def load_matchfile(
+    filename: PathLike,
+) -> MatchFile:
+    """
+    Load a Matchfile as a `MatchFile` instance
+    """
+
+    if not os.path.exists(filename):
+        raise ValueError("Filename does not exist")  # pragma: no cover
+
+    with open(filename) as f:
+        raw_lines = f.read().splitlines()
+
+    version = get_version(raw_lines[0])
+
+    from_matchline_methods = FROM_MATCHLINE_METHODSV1
+    if version < Version(1, 0, 0):
+        from_matchline_methods = FROM_MATCHLINE_METHODSV0
+
+    parsed_lines = [
+        parse_matchline(line, from_matchline_methods, version) for line in raw_lines
+    ]
+
+    parsed_lines = [pl for pl in parsed_lines if pl is not None]
+
+    mf = MatchFile(lines=parsed_lines)
+
+    return mf
+
+
+@deprecated_alias(fn="filename", create_part="create_score")
+def load_match(
+    filename: PathLike,
+    create_score: bool = False,
+    pedal_threshold: int = 64,
+    first_note_at_zero: bool = False,
+    offset_duration_whole: bool = True,
+) -> Tuple[Union[Performance, list, Score]]:
+    """
+    Load a matchfile.
+
+    Parameters
+    ----------
+    filename : str
+        The matchfile
+    create_score : bool, optional
+        When True create a Part object from the snote information in
+        the match file. Defaults to False.
+    pedal_threshold : int, optional
+        Threshold for adjusting sound off of the performed notes using
+        pedal information. Defaults to 64.
+    first_note_at_zero : bool, optional
+        When True the note_on and note_off times in the performance
+        are shifted to make the first note_on time equal zero.
+
+    Returns
+    -------
+    performance : :class:partitura.performance.Performance
+    alignment : list
+        The score--performance alignment, a list of dictionaries
+    scr : :class:partitura.score.Score
+        The score. This item is only returned when `create_score` = True.
+    """
+    # Parse Matchfile
+    mf = load_matchfile(filename)
+
+    # Generate PerformedPart
+    ppart = performed_part_from_match(mf, pedal_threshold, first_note_at_zero)
+
+    performance = Performance(
+        id=get_document_name(filename),
+        performedparts=ppart,
+    )
+    # Generate Part
+    if create_score:
+        spart = part_from_matchfile(
+            mf,
+            match_offset_duration_in_whole=offset_duration_whole,
+        )
+
+        scr = score.Score(id=get_document_name(filename), partlist=[spart])
+    # Alignment
+    alignment = alignment_from_matchfile(mf)
+
+    if create_score:
+        return performance, alignment, scr
+    else:
+        return performance, alignment
+
+
+def note_alignment_from_matchfile(mf: MatchFile) -> List[dict]:
+    """
+    Get a note-level alignment from a MatchFile instance
+
+    Parameters
+    ----------
+    mf : MatchFile
+        A score-to-performance alignment
+
+    Returns
+    -------
+    results : List[dict]
+        An alignmnet as a list of dictionaries for each note.
+    """
+    result = []
+
+    for line in mf.lines:
+        if isinstance(line, BaseSnoteNoteLine):
+            result.append(
+                dict(
+                    label="match",
+                    score_id=str(line.snote.Anchor),
+                    performance_id=format_pnote_id(line.note.Id),
+                )
+            )
+
+        elif isinstance(
+            line,
+            BaseDeletionLine,
+        ):
+            if "leftOutTied" in line.snote.ScoreAttributesList:
+                continue
+            else:
+                result.append(dict(label="deletion", score_id=str(line.snote.Anchor)))
+        elif isinstance(
+            line,
+            BaseInsertionLine,
+        ):
+            result.append(
+                dict(label="insertion", performance_id=format_pnote_id(line.note.Id))
+            )
+        elif isinstance(line, BaseOrnamentLine):
+            if isinstance(line, MatchTrillNoteV0):
+                ornament_type = "trill"
+            elif isinstance(line, MatchOrnamentNoteV1):
+                ornament_type = line.OrnamentType
+            else:
+                ornament_type = "generic_ornament"
+            result.append(
+                dict(
+                    label="ornament",
+                    score_id=str(line.Anchor),
+                    performance_id=format_pnote_id(line.note.Id),
+                    type=ornament_type,
+                )
+            )
+
+    return result
+
+
+# alias
+alignment_from_matchfile = note_alignment_from_matchfile
+
+
+def performed_part_from_match(
+    mf: MatchFile,
+    pedal_threshold: int = 64,
+    first_note_at_zero: bool = False,
+) -> PerformedPart:
+    """
+    Make PerformedPart from performance info in a MatchFile
+
+    Parameters
+    ----------
+    mf : MatchFile
+        A MatchFile instance
+    pedal_threshold : int, optional
+        Threshold for adjusting sound off of the performed notes using
+        pedal information. Defaults to 64.
+    first_note_at_zero : bool, optional
+        When True the note_on and note_off times in the performance
+        are shifted to make the first note_on time equal zero.
+
+    Returns
+    -------
+    ppart : PerformedPart
+        A performed part
+
+    """
+    # Get midi time units
+    mpq = mf.info("midiClockRate")  # 500000 -> microseconds per quarter
+    ppq = mf.info("midiClockUnits")  # 500 -> parts per quarter
+
+    # PerformedNote instances for all MatchNotes
+    notes = []
+
+    first_note = next(mf.iter_notes(), None)
+    if first_note and first_note_at_zero:
+        offset = midi_ticks_to_seconds(first_note.Onset, mpq=mpq, ppq=ppq)
+        offset_tick = first_note.Onset
+    else:
+        offset = 0
+        offset_tick = 0
+
+    notes = [
+        dict(
+            id=format_pnote_id(note.Id),
+            midi_pitch=note.MidiPitch,
+            note_on=midi_ticks_to_seconds(note.Onset, mpq, ppq) - offset,
+            note_off=midi_ticks_to_seconds(note.Offset, mpq, ppq) - offset,
+            note_on_tick=note.Onset - offset_tick,
+            note_off_tick=note.Offset - offset_tick,
+            sound_off=midi_ticks_to_seconds(note.Offset, mpq, ppq) - offset,
+            velocity=note.Velocity,
+            track=getattr(note, "Track", 0),
+            channel=getattr(note, "Channel", 1),
+        )
+        for note in mf.notes
+    ]
+
+    # SustainPedal instances for sustain pedal lines
+    sustain_pedal = [
+        dict(
+            number=64,
+            time=midi_ticks_to_seconds(ped.Time, mpq, ppq),
+            value=ped.Value,
+        )
+        for ped in mf.sustain_pedal
+    ]
+
+    # SoftPedal instances for soft pedal lines
+    soft_pedal = [
+        dict(
+            number=67,
+            time=midi_ticks_to_seconds(ped.Time, mpq, ppq),
+            value=ped.Value,
+        )
+        for ped in mf.soft_pedal
+    ]
+
+    # Make performed part
+    ppart = PerformedPart(
+        id="P1",
+        part_name=mf.info("piece"),
+        notes=notes,
+        controls=sustain_pedal + soft_pedal,
+        sustain_pedal_threshold=pedal_threshold,
+    )
+    return ppart
+
+
+def sort_snotes(snotes: List[BaseSnoteLine]) -> List[BaseSnoteLine]:
+    """
+    Sort s(core)notes.
+
+    Parameters
+    ----------
+    snotes : list
+        The score notes
+
+    Returns
+    -------
+    snotes_sorted : list
+        The sorted score notes
+    """
+    sidx = np.lexsort(
+        list(zip(*[(float(n.Offset), float(n.Beat), float(n.Measure)) for n in snotes]))
+    )
+    return [snotes[i] for i in sidx if snotes[i].NoteName.lower() != "r"]
+
+
+def part_from_matchfile(
+    mf: MatchFile,
+    match_offset_duration_in_whole: bool = True,
+) -> Part:
+    """
+    Create a score part from a matchfile.
+
+    Parameters
+    ----------
+    mf : MatchFile
+        An instance of `MatchFile`
+
+    match_offset_duration_in_whole: Boolean
+        A flag for the type of offset and duration given in the matchfile.
+        When true, the function expects the values to be given in whole
+        notes (e.g. 1/4 for a quarter note) independet of time signature.
+
+
+    Returns
+    -------
+    part : partitura.score.Part
+        An instance of `Part` containing score information.
+
+    """
+    part = score.Part("P1", mf.info("piece"))
+    snotes = sort_snotes(mf.snotes)
+
+    ts = mf.time_signatures
+    min_time = snotes[0].OnsetInBeats  # sorted by OnsetInBeats
+    max_time = max(n.OffsetInBeats for n in snotes)
+    _, beats_map, _, beat_type_map, min_time_q, max_time_q = make_timesig_maps(
+        ts, max_time
+    )
+
+    # compute necessary divs based on the types of notes in the
+    # match snotes (only integers)
+    divs_arg = [
+        max(int((beat_type_map(note.OnsetInBeats) / 4)), 1)
+        * note.Offset.denominator
+        * (note.Offset.tuple_div or 1)
+        for note in snotes
+    ]
+    divs_arg += [
+        max(int((beat_type_map(note.OnsetInBeats) / 4)), 1)
+        * note.Duration.denominator
+        * (note.Duration.tuple_div or 1)
+        for note in snotes
+    ]
+
+    onset_in_beats = np.array([note.OnsetInBeats for note in snotes])
+    unique_onsets, inv_idxs = np.unique(onset_in_beats, return_inverse=True)
+    # unique_onset_idxs = [np.where(onset_in_beats == u) for u in unique_onsets]
+
+    iois_in_beats = np.diff(unique_onsets)
+    beat_to_quarter = 4 / beat_type_map(onset_in_beats)
+
+    iois_in_quarters_offset = np.r_[
+        beat_to_quarter[0] * onset_in_beats[0],
+        (4 / beat_type_map(unique_onsets[:-1])) * iois_in_beats,
+    ]
+    onset_in_quarters = np.cumsum(iois_in_quarters_offset)
+    iois_in_quarters = np.diff(onset_in_quarters)
+
+    # ___ these divs are relative to quarters;
+    divs = np.lcm.reduce(np.unique(divs_arg))
+    onset_in_divs = np.r_[0, np.cumsum(divs * iois_in_quarters)][inv_idxs]
+    onset_in_quarters = onset_in_quarters[inv_idxs]
+
+    # duration_in_beats = np.array([note.DurationInBeats for note in snotes])
+    # duration_in_quarters = duration_in_beats * beat_to_quarter
+    # duration_in_divs = duration_in_quarters * divs
+
+    part.set_quarter_duration(0, divs)
+    bars = np.unique([n.Measure for n in snotes])
+    t = min_time
+    t = t * 4 / beat_type_map(min_time)
+    offset = t
+    bar_times = {}
+
+    if t > 0:
+        # if we have an incomplete first measure that isn't an anacrusis
+        # measure, add a rest (dummy)
+        # t = t-t%beats_map(min_time)
+
+        # if starting beat is above zero, add padding
+        rest = score.Rest()
+        part.add(rest, start=0, end=t * divs)
+        onset_in_divs += t * divs
+        offset = 0
+        t = t - t % beats_map(min_time)
+
+    for b0, b1 in iter_current_next(bars, end=bars[-1] + 1):
+
+        bar_times.setdefault(b0, t)
+        if t < 0:
+            t = 0
+
+        else:
+            # multiply by diff between consecutive bar numbers
+            n_bars = b1 - b0
+            if t <= max_time_q:
+                t += (n_bars * 4 * beats_map(t)) / beat_type_map(t)
+
+    for ni, note in enumerate(snotes):
+        # start of bar in quarter units
+        bar_start = bar_times[note.Measure]
+
+        on_off_scale = 1
+        # on_off_scale = 1 means duration and beat offset are given in
+        # whole notes, else they're given in beats (as in the KAIST data)
+        if not match_offset_duration_in_whole:
+            on_off_scale = beat_type_map(bar_start)
+
+        # offset within bar in quarter units adjusted for different
+        # time signatures -> 4 / beat_type_map(bar_start)
+        bar_offset = (note.Beat - 1) * 4 / beat_type_map(bar_start)
+
+        # offset within beat in quarter units adjusted for different
+        # time signatures -> 4 / beat_type_map(bar_start)
+        beat_offset = (
+            4
+            / on_off_scale
+            * note.Offset.numerator
+            / (note.Offset.denominator * (note.Offset.tuple_div or 1))
+        )
+
+        # check anacrusis measure beat counting type for the first note
+        if bar_start < 0 and (bar_offset != 0 or beat_offset != 0) and ni == 0:
+            # in case of fully counted anacrusis we set the bar_start
+            # to -bar_duration (in quarters) so that the below calculation is correct
+            # not active for shortened anacrusis measures
+            bar_start = -beats_map(bar_start) * 4 / beat_type_map(bar_start)
+            # reset the bar_start for other notes in the anacrusis measure
+            bar_times[note.Bar] = bar_start
+
+        # convert the onset time in quarters (0 at first barline) to onset
+        # time in divs (0 at first note)
+        onset_divs = int(round(divs * (bar_start + bar_offset + beat_offset - offset)))
+
+        if not np.isclose(onset_divs, onset_in_divs[ni], atol=divs * 0.01):
+            warnings.warn(
+                "Calculated `onset_divs` does not match `OnsetInBeats` " "information!."
+            )
+            onset_divs = onset_in_divs[ni]
+        assert onset_divs >= 0
+        assert np.isclose(onset_divs, onset_in_divs[ni], atol=divs * 0.01)
+
+        articulations = set()
+        if "staccato" in note.ScoreAttributesList or "stac" in note.ScoreAttributesList:
+            articulations.add("staccato")
+        if "accent" in note.ScoreAttributesList:
+            articulations.add("accent")
+        if "leftOutTied" in note.ScoreAttributesList:
+            continue
+
+        # dictionary with keyword args with which the Note
+        # (or GraceNote) will be instantiated
+        note_attributes = dict(
+            step=note.NoteName,
+            octave=note.Octave,
+            alter=note.Modifier,
+            id=note.Anchor,
+            articulations=articulations,
+        )
+
+        staff_nr = next(
+            (a[-1] for a in note.ScoreAttributesList if a.startswith("staff")), None
+        )
+        try:
+            note_attributes["staff"] = int(staff_nr)
+        except (TypeError, ValueError):
+            # no staff attribute, or staff attribute does not end with a number
+            note_attributes["staff"] = None
+
+        if "s" in note.ScoreAttributesList:
+            note_attributes["voice"] = 1
+        else:
+            note_attributes["voice"] = next(
+                (int(a) for a in note.ScoreAttributesList if number_pattern.match(a)),
+                None,
+            )
+
+        # get rid of this if as soon as we have a way to iterate over the
+        # duration components. For now we have to treat the cases simple
+        # and compound durations separately.
+        if note.Duration.add_components:
+            prev_part_note = None
+
+            for i, (num, den, tuple_div) in enumerate(note.Duration.add_components):
+                # when we add multiple notes that are tied, the first note will
+                # get the original note id, and subsequent notes will get a
+                # derived note id (by appending, 'a', 'b', 'c',...)
+                if i > 0:
+                    # tnote_id = 'n{}_{}'.format(note.Anchor, i)
+                    note_attributes["id"] = score._make_tied_note_id(
+                        note_attributes["id"]
+                    )
+
+                part_note = score.Note(**note_attributes)
+
+                # duration_divs from local beats --> 4/beat_type_map(bar_start)
+
+                duration_divs = int(
+                    (4 / on_off_scale) * divs * num / (den * (tuple_div or 1))
+                )
+
+                assert duration_divs > 0
+                offset_divs = onset_divs + duration_divs
+                part.add(part_note, onset_divs, offset_divs)
+
+                if prev_part_note:
+                    prev_part_note.tie_next = part_note
+                    part_note.tie_prev = prev_part_note
+                prev_part_note = part_note
+                onset_divs = offset_divs
+
+        else:
+            num = note.Duration.numerator
+            den = note.Duration.denominator
+            tuple_div = note.Duration.tuple_div
+
+            # duration_divs from local beats --> 4/beat_type_map(bar_start)
+            duration_divs = int(
+                divs * 4 / on_off_scale * num / (den * (tuple_div or 1))
+            )
+            offset_divs = onset_divs + duration_divs
+
+            # notes with duration 0, are also treated as grace notes, even if
+            # they do not have a 'grace' score attribute
+            if "grace" in note.ScoreAttributesList or note.Duration.numerator == 0:
+                part_note = score.GraceNote(
+                    grace_type="appoggiatura", **note_attributes
+                )
+
+            else:
+                part_note = score.Note(**note_attributes)
+
+            part.add(part_note, onset_divs, offset_divs)
+
+    # add time signatures
+    for (ts_beat_time, ts_bar, tsg) in ts:
+        ts_beats = tsg.numerator
+        ts_beat_type = tsg.denominator
+        # check if time signature is in a known measure (from notes)
+        if ts_bar in bar_times.keys():
+            bar_start_divs = int(divs * (bar_times[ts_bar] - offset))  # in quarters
+            bar_start_divs = max(0, bar_start_divs)
+        else:
+            bar_start_divs = 0
+        part.add(score.TimeSignature(ts_beats, ts_beat_type), bar_start_divs)
+
+    # add key signatures
+    for (ks_beat_time, ks_bar, keys) in mf.key_signatures:
+
+        if ks_bar in bar_times.keys():
+            bar_start_divs = int(divs * (bar_times[ks_bar] - offset))  # in quarters
+            bar_start_divs = max(0, bar_start_divs)
+        else:
+            bar_start_divs = 0
+
+        # TODO
+        # * use key estimation if there are multiple defined keys
+        # fifths, mode = key_name_to_fifths_mode(key_name)
+        part.add(score.KeySignature(keys.fifths, keys.mode), ks_bar)
+
+    add_staffs(part)
+    # add_clefs(part)
+
+    # add incomplete measure if necessary
+    if offset < 0:
+        part.add(score.Measure(number=0), 0, int(-offset * divs))
+
+    # add the rest of the measures automatically
+    score.add_measures(part)
+    score.tie_notes(part)
+    score.find_tuplets(part)
+
+    if not all([n.voice for n in part.notes_tied]):
+        for note in part.notes_tied:
+            if note.voice is None:
+                note.voice = 1
+
+    return part
+
+
+def make_timesig_maps(
+    ts_orig: List[Tuple[float, int, MatchTimeSignature]],
+    max_time: float,
+) -> (Callable, Callable, Callable, Callable, float, float):
+    """
+    Create time signature (interpolation) maps
+
+    Parameters
+    ----------
+    ts_orig : List[Tuple[float, int, MatchTimeSignature]]
+        A list of tuples containing position in beats, measure and
+        MatchTimeSignature instances
+    max_time : float
+        Maximal time of the time signatures
+
+    Returns
+    -------
+    beats_map: callable
+    qbeats_map: callable
+    beat_type_map: callable
+    qbeat_type_map: callable
+    start_q: float
+    end_q: float
+    """
+    # TODO: make sure that ts_orig covers range from min_time
+    # return two functions that map score times (in quarter units) to time sig
+    # beats, and time sig beat_type respectively
+    ts = list(ts_orig)
+    assert len(ts) > 0
+    ts.append((max_time, None, ts[-1][2]))
+
+    x = np.array([t for t, _, _ in ts])
+    y = np.array([(x.numerator, x.denominator) for _, _, x in ts])
+
+    start_q = x[0] * 4 / y[0, 1]
+    x_q = np.cumsum(np.r_[start_q, 4 * np.diff(x) / y[:-1, 1]])
+    end_q = x_q[-1]
+
+    # TODO: fix error with bounds
+    qbeats_map = interp1d(
+        x_q,
+        y[:, 0],
+        kind="previous",
+        bounds_error=False,
+        fill_value=(y[0, 0], y[-1, 0]),
+    )
+    qbeat_type_map = interp1d(
+        x_q,
+        y[:, 1],
+        kind="previous",
+        bounds_error=False,
+        fill_value=(y[0, 1], y[-1, 1]),
+    )
+    beats_map = interp1d(
+        x,
+        y[:, 0],
+        kind="previous",
+        bounds_error=False,
+        fill_value=(y[0, 0], y[-1, 0]),
+    )
+    beat_type_map = interp1d(
+        x,
+        y[:, 1],
+        kind="previous",
+        bounds_error=False,
+        fill_value=(y[0, 1], y[-1, 1]),
+    )
+
+    return beats_map, qbeats_map, beat_type_map, qbeat_type_map, start_q, end_q
+
+
+def add_staffs(part: Part, split: int = 55, only_missing: bool = True) -> None:
+    """
+        Method to add staff information to a part
+
+        Parameters
+        ----------
+        part: Part
+            Part to add staff information to.
+        split: int
+            MIDI pitch to split staff into upper and lower. Default is 55
+        only_missing: bool
+            If True, only add staff to those notes that do not have staff info already.
+    x"""
+    # assign staffs using a hard limit
+    notes = part.notes_tied
+    for n in notes:
+
+        if only_missing and n.staff:
+            continue
+
+        if n.midi_pitch > split:
+            staff = 1
+        else:
+            staff = 2
+
+        n.staff = staff
+
+        n_tied = n.tie_next
+        while n_tied:
+            n_tied.staff = staff
+            n_tied = n_tied.tie_next
+
+    part.add(score.Clef(staff=1, sign="G", line=2, octave_change=0), 0)
+    part.add(score.Clef(staff=2, sign="F", line=4, octave_change=0), 0)
+
+
+if __name__ == "__main__":
+
+    pass
```

### Comparing `partitura-1.2.1/partitura/io/importmei.py` & `partitura-1.2.2/partitura/io/importmei.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,1085 +1,1095 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for importing MEI files.
-"""
-from lxml import etree
-from xmlschema.names import XML_NAMESPACE
-import partitura.score as score
-from partitura.utils.music import (
-    MEI_DURS_TO_SYMBOLIC,
-    SYMBOLIC_TO_INT_DURS,
-    SIGN_TO_ALTER,
-    estimate_symbolic_duration,
-)
-from partitura.utils import PathLike, get_document_name
-from partitura.utils.misc import deprecated_alias
-import partitura as pt
-
-try:
-    import verovio
-    VEROVIO_AVAILABLE = True
-except :
-    VEROVIO_AVAILABLE = False
-
-import re
-import warnings
-
-import numpy as np
-
-
-@deprecated_alias(mei_path="filename")
-def load_mei(filename: PathLike) -> score.Score:
-    """
-    Loads a Mei score from path and returns a list of Partitura.Part
-
-    Parameters
-    ----------
-    filename : PathLike
-        The path to an MEI score.
-
-    Returns
-    -------
-    scr: :class:`partitura.score.Score`
-        A `Score` object
-    """
-    parser = MeiParser(filename)
-    doc_name = get_document_name(filename)
-    # create parts from the specifications in the mei
-    parser.create_parts()
-    # fill parts with the content from the mei
-    parser.fill_parts()
-
-    # TODO: Parse score info (composer, lyricist, etc.)
-    scr = score.Score(
-        id=doc_name,
-        partlist=parser.parts,
-    )
-
-    return scr
-
-
-class MeiParser(object):
-    def __init__(self, mei_path: PathLike) -> None:
-        document, ns = self._parse_mei(mei_path, use_verovio = VEROVIO_AVAILABLE)
-        self.document = document
-        self.ns = ns  # the namespace in the MEI file
-        self.parts = (
-            None  # parts get initialized in create_parts() and filled in fill_parts()
-        )
-        self.repetitions = (
-            []
-        )  # to be filled when we encounter repetitions and process in the end
-        self.barlines = (
-            []
-        )  # to be filled when we encounter barlines and process in the end
-        self.endings = []
-
-    def create_parts(self):
-        # handle main scoreDef info: create the part list
-        main_partgroup_el = self.document.find(self._ns_name("staffGrp", all=True))
-        self.parts = self._handle_main_staff_group(main_partgroup_el)
-
-    def fill_parts(self):
-        # fill parts with the content of the score
-        scores_el = self.document.findall(self._ns_name("score", all=True))
-        if len(scores_el) != 1:
-            raise Exception("Only MEI with a single score element are supported")
-        sections_el = scores_el[0].findall(self._ns_name("section"))
-        position = 0
-        for section_el in sections_el:
-            # insert in parts all elements except ties
-            position = self._handle_section(
-                section_el, list(score.iter_parts(self.parts)), position
-            )
-
-        # handles ties
-        self._tie_notes(scores_el[0], self.parts)
-
-        # handle repetitions
-        self._insert_repetitions()
-
-        # handle barlines
-        self._insert_barlines()
-
-    # -------------- Functions to initialize the xml tree -----------------
-
-    def _ns_name(self, name, ns=None, all=False):
-        """
-        Combines document namespace tag with element to fetch object from MEI lxml trees.
-
-        Parameters
-        ----------
-        name : str
-            Name of MEI element.
-        ns : str or None
-            The namespace tag of the document. Default to None.
-        all : bool
-            if True, search the entire subtree, otherwise only the first level.
-        """
-        if ns is None:
-            ns = self.ns
-
-        if not all:
-            return "{" + ns + "}" + name
-        else:
-            return ".//{" + ns + "}" + name
-
-    def _parse_mei(self, mei_path, use_verovio = True):
-        """
-        Parses an MEI file from path to an lxml tree.
-
-        Parameters
-        ----------
-        mei_path : str
-            The path of the MEI document.
-        Returns
-        -------
-        document : lxml tree
-            An lxml tree of the MEI score.
-        """
-        parser = etree.XMLParser(
-            resolve_entities=False,
-            huge_tree=False,
-            remove_comments=True,
-            remove_blank_text=True,
-            recover = True
-        )
-
-        if use_verovio:
-            tk = verovio.toolkit(True)
-            tk.loadFile(mei_path)
-            mei_score = tk.getMEI("basic")
-            # document = etree.parse(mei_score, parser)
-            root = etree.fromstring(mei_score.encode('utf-8'), parser)
-            tree = etree.ElementTree(root)
-        else:
-            tree = etree.parse(mei_path,parser)
-            root = tree.getroot()
-        # find the namespace
-        ns = root.nsmap[None]
-        # --> nsmap fetches a dict of the namespace Map, generally for root the key `None` fetches the namespace of the document.
-        return tree, ns
-
-    # functions to parse staves info
-
-    def _handle_metersig(self, staffdef_el, position, part):
-        """
-        Handles meter signature and adds to part.
-
-        Parameters
-        ----------
-        staffdef_el : lxml etree
-            A lxml substree of a staff's mei score.
-        position : int
-            Is the current position of the note on the timeline.
-        part : particular.Part
-            The created Partitura Part object.
-        """
-        metersig_el = staffdef_el.find(self._ns_name("meterSig"))
-        if metersig_el is not None:  # new element inside
-            numerator = int(metersig_el.attrib["count"])
-            denominator = int(metersig_el.attrib["unit"])
-        elif (
-            staffdef_el.get("meter.count") is not None
-        ):  # all encoded as attributes in staffdef
-            numerator = int(staffdef_el.attrib["meter.count"])
-            denominator = int(staffdef_el.attrib["meter.unit"])
-        else:  # the informatio is encoded in a parent scoredef
-            found_ancestor_with_metrical_info = False
-            for anc in staffdef_el.iterancestors(tag=self._ns_name("scoreDef")):
-                if anc.get("meter.count") is not None:
-                    found_ancestor_with_metrical_info = True
-                    break
-            if found_ancestor_with_metrical_info:
-                numerator = int(anc.attrib["meter.count"])
-                denominator = int(anc.attrib["meter.unit"])
-            else:
-                raise Exception(
-                    f"The time signature is not encoded in {staffdef_el.get(self._ns_name('id'))} or in any ancestor scoreDef"
-                )
-        new_time_signature = score.TimeSignature(numerator, denominator)
-        part.add(new_time_signature, position)
-
-    def _handle_keysig(self, staffdef_el, position, part):
-        """
-        Handles key signature and adds to part.
-
-        Parameters
-        ----------
-        staffdef_el : lxml tree
-            A lxml substree of a staff's mei score.
-        position : int
-            Is the current position of the note on the timeline.
-        part : particular.Part
-            The created Partitura Part object.
-        """
-        keysig_el = staffdef_el.find(self._ns_name("keySig"))
-        if keysig_el is not None:  # new element inside
-            sig = keysig_el.attrib["sig"]
-            # now extract partitura keysig parameters
-            fifths = self._mei_sig_to_fifths(sig)
-            mode = keysig_el.get("mode")
-        elif (
-            staffdef_el.get("key.sig") is not None
-        ):  # all encoded as attributes in staffdef
-            sig = staffdef_el.attrib["key.sig"]
-            # now extract partitura keysig parameters
-            fifths = self._mei_sig_to_fifths(sig)
-            mode = staffdef_el.get("key.mode")
-        else:  # the information is encoded in a parent scoredef
-            found_ancestor_with_key_info = False
-            for anc in staffdef_el.iterancestors(tag=self._ns_name("scoreDef")):
-                if anc.get("key.sig") is not None:
-                    found_ancestor_with_key_info = True
-                    break
-            if found_ancestor_with_key_info:
-                sig = anc.attrib["key.sig"]
-                # now extract partitura keysig parameters
-                fifths = self._mei_sig_to_fifths(sig)
-                mode = anc.get("key.mode")
-            else:
-                warnings.warn(
-                    f"The key signature is not encoded in {staffdef_el.get(self._ns_name('id'))} or in any ancestor scoreDef."
-                )
-                warnings.warn("A default key signature of C maj is set.")
-                fifths = 0
-                mode = "major"
-
-        new_key_signature = score.KeySignature(fifths, mode)
-        part.add(new_key_signature, position)
-
-    def _compute_clef_octave(self, dis, dis_place):
-        if dis is not None:
-            sign = -1 if dis_place == "below" else 1
-            octave = sign * int(int(dis) / 8)
-        else:
-            octave = 0
-        return octave
-
-    def _mei_sig_to_fifths(self, sig):
-        """Produces partitura KeySignature.fifths parameter from the MEI sig attribute."""
-        if sig[0] == "0":
-            fifths = 0
-        else:
-            sign = 1 if sig[-1] == "s" else -1
-            fifths = sign * int(sig[:-1])
-        return fifths
-
-    def _handle_clef(self, element, position, part):
-        """Inserts a clef. Element can be either a cleff element or staffdef element.
-
-        Parameters
-        ----------
-        staffdef_el : lxml tree
-            A lxml substree of a mei score.
-        position : int
-            Is the current position of the note on the timeline.
-        part : particular.Part
-            The created Partitura Part object.
-
-        Returns
-        -------
-        position : int
-            The current position of the note on the timeline.
-        """
-        # handle the case where we have clef informations inside staffdef el
-        if element.tag == self._ns_name("staffDef"):
-            clef_el = element.find(self._ns_name("clef"))
-            if clef_el is not None:  # if there is a clef element inside
-                return self._handle_clef(clef_el, position, part)
-            else:  # if all info are in the staffdef element
-                number = element.get("n")
-                sign = element.get("clef.shape")
-                line = element.get("clef.line")
-                if (
-                    number is not None and sign is not None and line is not None
-                ):  # if there is clef info
-                    octave = self._compute_clef_octave(
-                        element.get("dis"), element.get("dis.place")
-                    )
-                else:  # no clef info available, go for default
-                    warnings.warn("No clef information found, setting G2 as default.")
-                    sign = "G"
-                    line = 2
-                    number = 1
-                    octave = 0
-        elif element.tag == self._ns_name("clef"):
-            if element.get("sameas") is not None:  # this is a copy of another clef
-                # it seems this is used in different layers for the same staff
-                # we don't handle it to avoid clef duplications
-                return position
-            else:
-                # find the staff number
-                parent = element.getparent()
-                if parent.tag == self._ns_name("staffDef"):
-                    # number = parent.attrib["n"]
-                    number = 1
-                else:  # go back another level to staff element
-                    # number = parent.getparent().attrib["n"]
-                    number = 1
-                sign = element.attrib["shape"]
-                line = element.attrib["line"]
-                octave = self._compute_clef_octave(
-                    element.get("dis"), element.get("dis.place")
-                )
-        else:
-            raise Exception("_handle_clef only accepts staffDef or clef elements")
-        new_clef = score.Clef(int(number), sign, int(line), octave)
-        part.add(new_clef, position)
-        return position
-
-    def _handle_staffdef(self, staffdef_el, position, part):
-        """
-        Derives meter, key and clef from lxml substree and pass them to part.
-
-        Parameters
-        ----------
-        staffdef_el : lxml tree
-            A lxml substree of a mei score.
-        position : int
-            Is the current position of the note on the timeline.
-        part : particular.Part
-            The created Partitura Part object.
-        """
-        # fill with time signature info
-        self._handle_metersig(staffdef_el, position, part)
-        # fill with key signature info
-        self._handle_keysig(staffdef_el, position, part)
-        # fill with clef info
-        self._handle_clef(staffdef_el, position, part)
-
-    def _intsymdur_from_symbolic(self, symbolic_dur):
-        """Produce a int symbolic dur (e.g. 12 is a eight note triplet) and a dot number by looking at the symbolic dur dictionary:
-        i.e., symbol, eventual tuplet ancestors."""
-        intsymdur = SYMBOLIC_TO_INT_DURS[symbolic_dur["type"]]
-        # deals with tuplets
-        if symbolic_dur.get("actual_notes") is not None:
-            assert symbolic_dur.get("normal_notes") is not None
-            intsymdur = (
-                intsymdur * symbolic_dur["actual_notes"] / symbolic_dur["normal_notes"]
-            )
-        # deals with dots
-        dots = symbolic_dur.get("dots") if symbolic_dur.get("dots") is not None else 0
-        return intsymdur, dots
-
-    def _find_ppq(self):
-        """Finds the ppq for MEI filed that do not explicitely encode this information"""
-        els_with_dur = self.document.xpath(".//*[@dur]")
-        durs = []
-        durs_ppq = []
-        for el in els_with_dur:
-            symbolic_duration = self._get_symbolic_duration(el)
-            intsymdur, dots = self._intsymdur_from_symbolic(symbolic_duration)
-            # double the value if we have dots, to be sure be able to encode that with integers in partitura
-            durs.append(intsymdur * (2 ** dots))
-            durs_ppq.append(None if el.get("dur.ppq") is None else int(el.get("dur.ppq")))
-
-        if any([dppq is not None for dppq in durs_ppq]):
-            # there is at least one element with both dur and dur.ppq
-            for dur, dppq in zip(durs,durs_ppq):
-                if dppq is not None:
-                    return dppq*dur/4
-        else: 
-            # compute the ppq from the durations
-            # add 4 to be sure to not go under 1 ppq
-            durs.append(4)
-            durs= np.array(durs)
-            # remove elements smaller than 1
-            durs = durs[durs >= 1]
-
-            least_common_multiple = np.lcm.reduce(durs.astype(int))
-
-            return least_common_multiple / 4
-
-    def _handle_initial_staffdef(self, staffdef_el):
-        """
-        Handles the definition of a single staff.
-
-        Parameters
-        ----------
-        staffdef_el : Element tree
-            A subtree of a particular Staff from a score.
-
-        Returns
-        -------
-        part : partitura.Part
-            Returns a partitura part filled with meter, time signature, key signature information.
-        """
-        # Fetch the namespace of the staff.
-        id = staffdef_el.attrib[self._ns_name("id", XML_NAMESPACE)]
-        label_el = staffdef_el.find(self._ns_name("label"))
-        name = label_el.text if label_el is not None else ""
-        ppq_attrib = staffdef_el.get("ppq")
-        if ppq_attrib is not None:
-            ppq = int(ppq_attrib)
-        else:
-            ppq = self._find_ppq()
-        # generate the part
-        part = score.Part(id, name, quarter_duration=ppq)
-        # fill it with other info, e.g. meter, time signature, key signature
-        self._handle_staffdef(staffdef_el, 0, part)
-        return part
-
-    def _handle_staffgroup(self, staffgroup_el):
-        """
-        Handles a staffGrp. WARNING: in MEI piano staves are a staffGrp
-
-        Parameters
-        ----------
-        staffgroup_el : element tree
-            A subtree of Staff Group from a score.
-
-        Returns
-        -------
-        staff_group : Partitura.PartGroup
-            A partitura PartGroup object made by calling and appending as children ever staff separately.
-        """
-        group_symbol_el = staffgroup_el.find(self._ns_name("grpSym"))
-        if group_symbol_el is None:
-            group_symbol = staffgroup_el.attrib["symbol"]
-        else:
-            group_symbol = group_symbol_el.attrib["symbol"]
-        label_el = staffgroup_el.find(self._ns_name("label"))
-        name = label_el.text if label_el is not None else None
-        id = staffgroup_el.attrib[self._ns_name("id", XML_NAMESPACE)]
-        staff_group = score.PartGroup(group_symbol, group_name=name, id=id)
-        staves_el = staffgroup_el.findall(self._ns_name("staffDef"))
-        for s_el in staves_el:
-            new_part = self._handle_initial_staffdef(s_el)
-            staff_group.children.append(new_part)
-        staff_groups_el = staffgroup_el.findall(self._ns_name("staffGrp"))
-        for sg_el in staff_groups_el:
-            new_staffgroup = self._handle_staffgroup(sg_el)
-            staff_group.children.append(new_staffgroup)
-        return staff_group
-
-    def _handle_main_staff_group(self, main_staffgrp_el):
-        """
-        Handles the main staffGrp that contains all other staves or staff groups.
-
-        Parameters
-        ----------
-        main_staffgrp_el : element_tree
-
-        Returns
-        -------
-        part_list : list
-            Created list of parts filled with key and time signature information.
-        """
-        staves_el = main_staffgrp_el.findall(self._ns_name("staffDef"))
-        staff_groups_el = main_staffgrp_el.findall(self._ns_name("staffGrp"))
-        # the list of parts or part groups
-        part_list = []
-        # process the parts
-        # TODO add Parallelization to handle part parsing in parallel
-        for s_el in staves_el:
-            new_part = self._handle_initial_staffdef(s_el)
-            part_list.append(new_part)
-        # process the part groups
-        for sg_el in staff_groups_el:
-            new_staffgroup = self._handle_staffgroup(sg_el)
-            part_list.append(new_staffgroup)
-        return part_list
-
-    # functions to parse the content of parts
-
-    def _note_el_to_accid_int(self, note_el) -> int:
-        """Accidental strings to integer pitch.
-        It consider the two values of accid and accid.ges (when the accidental is implicit in the bar)"""
-        if note_el.get("accid") is not None:
-            return SIGN_TO_ALTER[note_el.get("accid")]
-        elif note_el.get("accid.ges") is not None:
-            return SIGN_TO_ALTER[note_el.get("accid.ges")]
-        elif note_el.find(self._ns_name("accid")) is not None:
-            if note_el.find(self._ns_name("accid")).get("accid") is not None:
-                return SIGN_TO_ALTER[note_el.find(self._ns_name("accid")).get("accid")]
-            else:
-                return SIGN_TO_ALTER[note_el.find(self._ns_name("accid")).get("accid.ges")]
-        else:
-            return None
-
-    def _pitch_info(self, note_el):
-        """
-        Given a note element fetches PitchClassName, octave and accidental.
-
-        Parameters
-        ----------
-        note_el
-
-        Returns
-        -------
-        step : str
-            The note Pitch class name.
-        octave : int
-            The number of octave
-        alter : int
-            Accidental string transformed to number.
-        """
-        step = note_el.attrib["pname"]
-        octave = int(note_el.attrib["oct"])
-        # accidentals can be accid, accid.ges or accid children elements
-        alter = self._note_el_to_accid_int(note_el)
-        return step, octave, alter
-
-    def _get_symbolic_duration(self, el):
-        symbolic_duration = {}
-        symbolic_duration["type"] = MEI_DURS_TO_SYMBOLIC[el.attrib["dur"]]
-        if not el.get("dots") is None:
-            symbolic_duration["dots"] = int(el.get("dots"))
-        # find eventual time modifications
-        tuplet_ancestors = list(el.iterancestors(tag=self._ns_name("tuplet")))
-        if len(tuplet_ancestors) == 0:
-            pass
-        elif len(tuplet_ancestors) == 1:
-            symbolic_duration["actual_notes"] = int(tuplet_ancestors[0].attrib["num"])
-            symbolic_duration["normal_notes"] = int(
-                tuplet_ancestors[0].attrib["numbase"]
-            )
-        else:
-            raise Exception("Nested tuplets are not yet supported.")
-        return symbolic_duration
-
-    def _duration_info(self, el, part):
-        """
-        Extract duration info from a xml element.
-
-        It works for example with note_el, chord_el
-
-        Parameters
-        ----------
-        el : lxml tree
-            the xml element to analyze
-        part : partitura.Part
-            The created partitura part object.
-
-        Returns
-        -------
-        id :
-        duration :
-        symbolic_duration :
-        """
-        # symbolic duration
-        symbolic_duration = self._get_symbolic_duration(el)
-
-        # duration in ppq
-        if el.get("dur.ppq") is not None or el.get("grace") is not None:
-            # find duration in ppq. For grace notes is 0
-            duration = 0 if el.get("grace") is not None else int(el.get("dur.ppq"))
-        else:
-            # compute the duration from the symbolic duration
-            intsymdur, dots = self._intsymdur_from_symbolic(symbolic_duration)
-            divs = part._quarter_durations[0]  # divs is the same as ppq
-            duration = divs * 4 / intsymdur
-            for d in range(dots):
-                duration = duration + 0.5 * duration
-            # sanity check to verify the divs are correctly set
-            assert duration == int(duration)
-
-        # find id
-        id = el.attrib[self._ns_name("id", XML_NAMESPACE)]
-        return id, int(duration), symbolic_duration
-
-    def _handle_note(self, note_el, position, voice, staff, part) -> int:
-        """
-        Handles note elements and imports the to part.
-
-        Parameters
-        ----------
-        note_el : lxml substree
-            The lxml substree of a note element.
-        position : int
-            The current position on the timeline.
-        voice : int
-            The currect voice index.
-        staff : int
-            The current staff index.
-        part : partitura.Part
-            The created partitura part object.
-
-        Returns
-        -------
-        position + duration : into
-            The updated position on the timeline.
-        """
-        # find pitch info
-        step, octave, alter = self._pitch_info(note_el)
-        # find duration info
-        note_id, duration, symbolic_duration = self._duration_info(note_el, part)
-        # find if it's grace
-        grace_attr = note_el.get("grace")
-        if grace_attr is None:
-            # create normal note
-            note = score.Note(
-                step=step,
-                octave=octave,
-                alter=alter,
-                id=note_id,
-                voice=voice,
-                staff=1,
-                symbolic_duration=symbolic_duration,
-                articulations=None,  # TODO : add articulation
-            )
-        else:
-            # create grace note
-            if grace_attr == "unacc":
-                grace_type = "acciaccatura"
-            elif grace_attr == "acc":
-                grace_type = "appoggiatura"
-            else:  # unknow type
-                grace_type = "grace"
-            note = score.GraceNote(
-                grace_type=grace_type,
-                step=step,
-                octave=octave,
-                alter=alter,
-                id=note_id,
-                voice=voice,
-                staff=1,
-                symbolic_duration=symbolic_duration,
-                articulations=None,  # TODO : add articulation
-            )
-        # add note to the part
-        part.add(note, position, position + duration)
-        # return duration to update the position in the layer
-        return position + duration
-
-    def _handle_rest(self, rest_el, position, voice, staff, part):
-        """
-        Handles the rest element updates part and position.
-
-        Parameters
-        ----------
-        rest_el : lxml tree
-            A rest element in the lxml tree.
-        position : int
-            The current position on the timeline.
-        voice : int
-            The voice of the section.
-        staff : int
-            The current staff also refers to a Part.
-        part : Partitura.Part
-            The created part to add elements to.
-
-        Returns
-        -------
-        position + duration : int
-            Next position on the timeline.
-        Also adds the rest to the partitura part object.
-        """
-        # find duration info
-        rest_id, duration, symbolic_duration = self._duration_info(rest_el, part)
-        # create rest
-        rest = score.Rest(
-            id=rest_id,
-            voice=voice,
-            staff=1,
-            symbolic_duration=symbolic_duration,
-            articulations=None,
-        )
-        # add rest to the part
-        part.add(rest, position, position + duration)
-        # return duration to update the position in the layer
-        return position + duration
-
-    def _handle_mrest(self, mrest_el, position, voice, staff, part):
-        """
-        Handles a rest that spawn the entire measure
-
-        Parameters
-        ----------
-        mrest_el : lxml tree
-            A mrest element in the lxml tree.
-        position : int
-            The current position on the timeline.
-        voice : int
-            The voice of the section.
-        staff : int
-            The current staff also refers to a Part.
-        part : Partitura.Part
-            The created part to add elements to.
-
-        Returns
-        -------
-        position + duration : int
-            Next position on the timeline.
-        """
-        # find id
-        mrest_id = mrest_el.attrib[self._ns_name("id", XML_NAMESPACE)]
-        # find closest time signature
-        last_ts = list(part.iter_all(cls=score.TimeSignature))[-1]
-        # find divs per measure
-        ppq = part.quarter_duration_map(position)
-        parts_per_measure = int(ppq * 4 * last_ts.beats / last_ts.beat_type)
-
-        # create dummy rest to insert in the timeline
-        rest = score.Rest(
-            id=mrest_id,
-            voice=voice,
-            staff=1,
-            symbolic_duration=estimate_symbolic_duration(parts_per_measure, ppq),
-            articulations=None,
-        )
-        # add mrest to the part
-        part.add(rest, position, position + parts_per_measure)
-        # now iterate
-        # return duration to update the position in the layer
-        return position + parts_per_measure
-
-    def _handle_chord(self, chord_el, position, voice, staff, part):
-        """
-        Handles a rest that spawn the entire measure
-
-        Parameters
-        ----------
-        chord_el : lxml tree
-            A chord element in the lxml tree.
-        position : int
-            The current position on the timeline.
-        voice : int
-            The voice of the section.
-        staff : int
-            The current staff also refers to a Part.
-        part : Partitura.Part
-            The created part to add elements to.
-
-        Returns
-        -------
-        position + duration : int
-            Next position on the timeline.
-        """
-        # find duration info
-        chord_id, duration, symbolic_duration = self._duration_info(chord_el, part)
-        # find notes info
-        notes_el = chord_el.findall(self._ns_name("note"))
-        for note_el in notes_el:
-            note_id = note_el.attrib[self._ns_name("id", XML_NAMESPACE)]
-            # find pitch info
-            step, octave, alter = self._pitch_info(note_el)
-            # create note
-            note = score.Note(
-                step=step,
-                octave=octave,
-                alter=alter,
-                id=note_id,
-                voice=voice,
-                staff=1,
-                symbolic_duration=symbolic_duration,
-                articulations=None,  # TODO : add articulation
-            )
-            # add note to the part
-            part.add(note, position, position + duration)
-            # return duration to update the position in the layer
-        return position + duration
-
-    def _handle_space(self, e, position, part):
-        """Moves current position."""
-        space_id, duration, symbolic_duration = self._duration_info(e, part)
-        return position + duration
-
-    def _handle_barline_symbols(self, measure_el, position: int, left_or_right: str):
-        barline = measure_el.get(left_or_right)
-        if barline is not None:
-            if barline == "rptstart":
-                self.repetitions.append({"type": "start", "pos": position})
-                self.barlines.append({"type": "heavy-light", "pos": position})
-            elif barline == "rptend":
-                self.repetitions.append({"type": "stop", "pos": position})
-                self.barlines.append({"type": "light-heavy", "pos": position})
-            elif barline == "dbl":
-                self.barlines.append({"type": "light-light", "pos": position})
-            elif barline == "end":
-                self.barlines.append({"type": "light-heavy", "pos": position})
-            elif barline == "dashed":
-                self.barlines.append({"type": "dashed", "pos": position})
-            else:
-                print(
-                    f"{barline} in measure {measure_el.attrib[self._ns_name('id', XML_NAMESPACE)]} is a non supported barline type."
-                )
-
-    def _handle_layer_in_staff_in_measure(
-        self, layer_el, ind_layer: int, ind_staff: int, position: int, part
-    ) -> int:
-        for i, e in enumerate(layer_el):
-            if e.tag == self._ns_name("note"):
-                new_position = self._handle_note(
-                    e, position, ind_layer, ind_staff, part
-                )
-            elif e.tag == self._ns_name("chord"):
-                new_position = self._handle_chord(
-                    e, position, ind_layer, ind_staff, part
-                )
-            elif e.tag == self._ns_name("rest"):
-                new_position = self._handle_rest(
-                    e, position, ind_layer, ind_staff, part
-                )
-            elif e.tag == self._ns_name("mRest"):  # rest that spawn the entire measure
-                new_position = self._handle_mrest(
-                    e, position, ind_layer, ind_staff, part
-                )
-            elif e.tag == self._ns_name("beam"):
-                # TODO : add Beam element
-                # recursive call to the elements inside beam
-                new_position = self._handle_layer_in_staff_in_measure(
-                    e, ind_layer, ind_staff, position, part
-                )
-            elif e.tag == self._ns_name("tuplet"):
-                # TODO : add Tuplet element
-                # recursive call to the elements inside Tuplet
-                new_position = self._handle_layer_in_staff_in_measure(
-                    e, ind_layer, ind_staff, position, part
-                )
-            elif e.tag == self._ns_name("clef"):
-                new_position = self._handle_clef(e, position, part)
-            elif e.tag == self._ns_name("space"):
-                new_position = self._handle_space(e, position, part)
-            else:
-                raise Exception("Tag " + e.tag + " not supported")
-
-            # update the current position
-            position = new_position
-        return position
-
-    def _handle_staff_in_measure(self, staff_el, staff_ind, position: int, part):
-        """
-        Handles staffs inside a measure element.
-
-        Parameters
-        ----------
-        staff_el : lxml etree
-            The lxml subtree for a staff element.
-        staff_ind : int
-            The Staff index.
-        position : int
-            The current position on the timeline.
-        part : Partitura.Part
-            The created partitura part object.
-
-        Returns
-        -------
-        end_positions[0] : int
-            The final position on the timeline.
-        """
-        # add measure
-        measure = score.Measure(number=staff_el.getparent().get("n"))
-        part.add(measure, position)
-
-        layers_el = staff_el.findall(self._ns_name("layer"))
-        end_positions = []
-        for i_layer, layer_el in enumerate(layers_el):
-            end_positions.append(
-                self._handle_layer_in_staff_in_measure(
-                    layer_el, i_layer + 1, staff_ind, position, part
-                )
-            )
-        # check if layers have equal duration (bad encoding, but it often happens)
-        if not all([e == end_positions[0] for e in end_positions]):
-            warnings.warn(
-                f"Warning: voices have different durations in staff {staff_el.attrib[self._ns_name('id',XML_NAMESPACE)]}"
-            )
-
-        
-        if len(end_positions) == 0: #if a measure contains no elements (e.g., a forgotten rest)
-            end_positions.append(position)
-        # add end time of measure
-        part.add(measure, None, max(end_positions))
-        return max(end_positions)
-
-    def _find_dir_positions(self, dir_el, bar_position):
-        """Compute the position for a <dir> element.
-        Returns an array, one position for each part."""
-        delta_position_beat = float(dir_el.get("tstamp"))
-        return [
-            p.inv_beat_map(p.beat_map(bar_position) + delta_position_beat - 1)
-            for p in score.iter_parts(self.parts)
-        ]
-
-    def _add_in_all_parts(self, tobj, starts):
-        for part, start in zip(score.iter_parts(self.parts), starts):
-            part.add(tobj, start)
-
-    def _handle_dir_element(self, dir_el, position):
-        # find the kind of element
-        kind = dir_el.get("type")
-        if kind is None:
-            return
-        dir_pos = self._find_dir_positions(dir_el, position)
-        if kind == "fine":
-            self._add_in_all_parts(score.Fine(), dir_pos)
-        elif kind == "dacapo":
-            self._add_in_all_parts(score.DaCapo(), dir_pos)
-
-    def _handle_directives(self, measure_el, position):
-        dir_els = measure_el.findall(self._ns_name("dir"))
-        for dir_el in dir_els:
-            self._handle_dir_element(dir_el, position)
-
-    def _handle_section(self, section_el, parts, position: int):
-        """
-        Returns position and fills parts with elements.
-
-        Parameters
-        ----------
-        section_el : lxml tree
-            An lxml substree of a MEI score reffering to a section.
-        parts : list()
-            A list of partitura Parts.
-        position : int
-            The current position on the timeline.
-
-        Returns
-        -------
-        position : int
-            The end position of the section.
-        """
-        for i_el, element in enumerate(section_el):
-            # handle measures
-            if element.tag == self._ns_name("measure"):
-                # handle left barline symbols
-                self._handle_barline_symbols(element, position, "left")
-                # handle staves
-                staves_el = element.findall(self._ns_name("staff"))
-                if len(list(staves_el)) != len(list(parts)):
-                    raise Exception(f"Not all parts are specified in measure {i_el}")
-                end_positions = []
-                for i_s, (part, staff_el) in enumerate(zip(parts, staves_el)):
-                    end_positions.append(
-                        self._handle_staff_in_measure(staff_el, i_s + 1, position, part)
-                    )
-                # handle directives (dir elements)
-                self._handle_directives(element, position)
-                # sanity check that all layers have equal duration
-                max_position = max(end_positions)
-                if not all([e == max_position for e in end_positions]):
-                    warnings.warn(
-                        f"Warning : parts have measures of different duration in measure {element.attrib[self._ns_name('id',XML_NAMESPACE)]}"
-                    )
-                    # enlarge measures to the max
-                    for part in parts:
-                        last_measure = list(part.iter_all(pt.score.Measure))[-1]
-                        if last_measure.end.t != max_position:
-                            part.add(pt.score.Measure(number = last_measure.number), position, max_position)
-                            part.remove(last_measure)
-                position = max_position
-                # handle right barline symbol
-                self._handle_barline_symbols(element, position, "right")
-            # handle staffDef elements
-            elif element.tag == self._ns_name("scoreDef"):
-                # meter modifications
-                metersig_el = element.find(self._ns_name("meterSig"))
-                if (metersig_el is not None) or (
-                    element.get("meter.count") is not None
-                ):
-                    for part in parts:
-                        self._handle_metersig(element, position, part)
-                # key signature modifications
-                keysig_el = element.find(self._ns_name("keySig"))
-                if (keysig_el is not None) or (element.get("key.sig") is not None):
-                    for part in parts:
-                        self._handle_keysig(element, position, part)
-            # handle nested section
-            elif element.tag == self._ns_name("section"):
-                position = self._handle_section(element, parts, position)
-            elif element.tag == self._ns_name("ending"):
-                ending_start = position
-                position = self._handle_section(element, parts, position)
-                # insert the ending element
-                ending_number = int(re.sub("[^0-9]", "", element.attrib["n"]))
-                self._add_ending(ending_start, position, ending_number, parts)
-            # explicit repetition expansions
-            elif element.tag == self._ns_name("expansion"):
-                pass
-            # system break
-            elif element.tag == self._ns_name("sb"):
-                pass
-            # page break
-            elif element.tag == self._ns_name("pb"):
-                pass
-            else:
-                raise Exception(f"element {element.tag} is not yet supported")
-
-        return position
-
-    def _add_ending(self, start_ending, end_ending, ending_string, parts):
-        for part in score.iter_parts(parts):
-            part.add(score.Ending(ending_string), start_ending, end_ending)
-
-    def _tie_notes(self, section_el, part_list):
-        """Ties all notes in a part.
-        This function must be run after the parts are completely created."""
-        # TODO : support ties written as attributes with @tie sintax
-        ties_el = section_el.findall(self._ns_name("tie", all=True))
-        # create a dict of id : note, to speed up search
-        all_notes = [
-            note
-            for part in score.iter_parts(part_list)
-            for note in part.iter_all(cls=score.Note)
-        ]
-        all_notes_dict = {note.id: note for note in all_notes}
-        for tie_el in ties_el:
-            start_id = tie_el.get("startid")
-            end_id = tie_el.get("endid")
-            if start_id is None or end_id is None:
-                warnings.warn(
-                    f"Warning: tie {tie_el.attrib[self._ns_name('id',XML_NAMESPACE)]} is missing the a startid or endid"
-                )
-            else:
-                # remove the # in first position
-                start_id = start_id[1:]
-                end_id = end_id[1:]
-                # set tie prev and tie next in partira note objects
-                all_notes_dict[start_id].tie_next = all_notes_dict[end_id]
-                all_notes_dict[end_id].tie_prev = all_notes_dict[start_id]
-
-    def _insert_repetitions(self):
-        if len(self.repetitions) == 0:
-            return
-        ## sanitize the found repetitions in case a starting rep is missing
-        if self.repetitions[0]["type"] == "stop":
-            # add a start symbol at 0
-            print(
-                "WARNING : unmatched repetitions. adding a repetition start at position 0"
-            )
-            self.repetitions.insert(0, {"type": "start", "pos": 0})
-        status = "stop"
-        sanitized_repetition_list = []
-        # check if start-stop are alternate
-        for i_rep, rep in enumerate(self.repetitions):
-            if rep["type"] != status:
-                sanitized_repetition_list.append(rep)
-            else:
-                if (
-                    rep["type"] == "start"
-                ):  # missing stop, inserting one right before start
-                    print(
-                        f"WARNING : unmatched repetitions. adding a repetition stop at position {rep['pos']}"
-                    )
-                    sanitized_repetition_list.append(
-                        {"type": "stop", "pos": rep["pos"]}
-                    )
-                else:  # missing start, inserting one at the last stop
-                    print(
-                        f"WARNING : unmatched repetitions. adding a repetition start at position {sanitized_repetition_list[-1]['pos']}"
-                    )
-                    sanitized_repetition_list.append(
-                        {"type": "start", "pos": sanitized_repetition_list[-1]["pos"]}
-                    )
-                # proceed by inserting rep
-                sanitized_repetition_list.append(rep)
-            # switch the status
-            status = "stop" if status == "start" else "start"
-        # check if ending with a start
-        if sanitized_repetition_list[-1] == "start":
-            print("WARNING : unmatched repetitions. Ignoring last start")
-        self.repetitions = sanitized_repetition_list
-
-        ## insert the repetitions to all parts
-        for rep_start, rep_stop in zip(self.repetitions[:-1:2], self.repetitions[1::2]):
-            assert rep_start["type"] == "start" and rep_stop["type"] == "stop"
-            for part in score.iter_parts(self.parts):
-                part.add(score.Repeat(), rep_start["pos"], rep_stop["pos"])
-
-    def _insert_barlines(self):
-        for bl in self.barlines:
-            for part in score.iter_parts(self.parts):
-                part.add(score.Barline(bl["type"]), bl["pos"])
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for importing MEI files.
+"""
+from lxml import etree
+from xmlschema.names import XML_NAMESPACE
+import partitura.score as score
+from partitura.utils.music import (
+    MEI_DURS_TO_SYMBOLIC,
+    SYMBOLIC_TO_INT_DURS,
+    SIGN_TO_ALTER,
+    estimate_symbolic_duration,
+)
+from partitura.utils import PathLike, get_document_name
+from partitura.utils.misc import deprecated_alias
+import partitura as pt
+
+try:
+    import verovio
+
+    VEROVIO_AVAILABLE = True
+except:
+    VEROVIO_AVAILABLE = False
+
+import re
+import warnings
+
+import numpy as np
+
+
+@deprecated_alias(mei_path="filename")
+def load_mei(filename: PathLike) -> score.Score:
+    """
+    Loads a Mei score from path and returns a list of Partitura.Part
+
+    Parameters
+    ----------
+    filename : PathLike
+        The path to an MEI score.
+
+    Returns
+    -------
+    scr: :class:`partitura.score.Score`
+        A `Score` object
+    """
+    parser = MeiParser(filename)
+    doc_name = get_document_name(filename)
+    # create parts from the specifications in the mei
+    parser.create_parts()
+    # fill parts with the content from the mei
+    parser.fill_parts()
+
+    # TODO: Parse score info (composer, lyricist, etc.)
+    scr = score.Score(
+        id=doc_name,
+        partlist=parser.parts,
+    )
+
+    return scr
+
+
+class MeiParser(object):
+    def __init__(self, mei_path: PathLike) -> None:
+        document, ns = self._parse_mei(mei_path, use_verovio=VEROVIO_AVAILABLE)
+        self.document = document
+        self.ns = ns  # the namespace in the MEI file
+        self.parts = (
+            None  # parts get initialized in create_parts() and filled in fill_parts()
+        )
+        self.repetitions = (
+            []
+        )  # to be filled when we encounter repetitions and process in the end
+        self.barlines = (
+            []
+        )  # to be filled when we encounter barlines and process in the end
+        self.endings = []
+
+    def create_parts(self):
+        # handle main scoreDef info: create the part list
+        main_partgroup_el = self.document.find(self._ns_name("staffGrp", all=True))
+        self.parts = self._handle_main_staff_group(main_partgroup_el)
+
+    def fill_parts(self):
+        # fill parts with the content of the score
+        scores_el = self.document.findall(self._ns_name("score", all=True))
+        if len(scores_el) != 1:
+            raise Exception("Only MEI with a single score element are supported")
+        sections_el = scores_el[0].findall(self._ns_name("section"))
+        position = 0
+        for section_el in sections_el:
+            # insert in parts all elements except ties
+            position = self._handle_section(
+                section_el, list(score.iter_parts(self.parts)), position
+            )
+
+        # handles ties
+        self._tie_notes(scores_el[0], self.parts)
+
+        # handle repetitions
+        self._insert_repetitions()
+
+        # handle barlines
+        self._insert_barlines()
+
+    # -------------- Functions to initialize the xml tree -----------------
+
+    def _ns_name(self, name, ns=None, all=False):
+        """
+        Combines document namespace tag with element to fetch object from MEI lxml trees.
+
+        Parameters
+        ----------
+        name : str
+            Name of MEI element.
+        ns : str or None
+            The namespace tag of the document. Default to None.
+        all : bool
+            if True, search the entire subtree, otherwise only the first level.
+        """
+        if ns is None:
+            ns = self.ns
+
+        if not all:
+            return "{" + ns + "}" + name
+        else:
+            return ".//{" + ns + "}" + name
+
+    def _parse_mei(self, mei_path, use_verovio=True):
+        """
+        Parses an MEI file from path to an lxml tree.
+
+        Parameters
+        ----------
+        mei_path : str
+            The path of the MEI document.
+        Returns
+        -------
+        document : lxml tree
+            An lxml tree of the MEI score.
+        """
+        parser = etree.XMLParser(
+            resolve_entities=False,
+            huge_tree=False,
+            remove_comments=True,
+            remove_blank_text=True,
+            recover=True,
+        )
+
+        if use_verovio:
+            tk = verovio.toolkit(True)
+            tk.loadFile(mei_path)
+            mei_score = tk.getMEI("basic")
+            # document = etree.parse(mei_score, parser)
+            root = etree.fromstring(mei_score.encode("utf-8"), parser)
+            tree = etree.ElementTree(root)
+        else:
+            tree = etree.parse(mei_path, parser)
+            root = tree.getroot()
+        # find the namespace
+        ns = root.nsmap[None]
+        # --> nsmap fetches a dict of the namespace Map, generally for root the key `None` fetches the namespace of the document.
+        return tree, ns
+
+    # functions to parse staves info
+
+    def _handle_metersig(self, staffdef_el, position, part):
+        """
+        Handles meter signature and adds to part.
+
+        Parameters
+        ----------
+        staffdef_el : lxml etree
+            A lxml substree of a staff's mei score.
+        position : int
+            Is the current position of the note on the timeline.
+        part : particular.Part
+            The created Partitura Part object.
+        """
+        metersig_el = staffdef_el.find(self._ns_name("meterSig"))
+        if metersig_el is not None:  # new element inside
+            numerator = int(metersig_el.attrib["count"])
+            denominator = int(metersig_el.attrib["unit"])
+        elif (
+            staffdef_el.get("meter.count") is not None
+        ):  # all encoded as attributes in staffdef
+            numerator = int(staffdef_el.attrib["meter.count"])
+            denominator = int(staffdef_el.attrib["meter.unit"])
+        else:  # the informatio is encoded in a parent scoredef
+            found_ancestor_with_metrical_info = False
+            for anc in staffdef_el.iterancestors(tag=self._ns_name("scoreDef")):
+                if anc.get("meter.count") is not None:
+                    found_ancestor_with_metrical_info = True
+                    break
+            if found_ancestor_with_metrical_info:
+                numerator = int(anc.attrib["meter.count"])
+                denominator = int(anc.attrib["meter.unit"])
+            else:
+                raise Exception(
+                    f"The time signature is not encoded in {staffdef_el.get(self._ns_name('id'))} or in any ancestor scoreDef"
+                )
+        new_time_signature = score.TimeSignature(numerator, denominator)
+        part.add(new_time_signature, position)
+
+    def _handle_keysig(self, staffdef_el, position, part):
+        """
+        Handles key signature and adds to part.
+
+        Parameters
+        ----------
+        staffdef_el : lxml tree
+            A lxml substree of a staff's mei score.
+        position : int
+            Is the current position of the note on the timeline.
+        part : particular.Part
+            The created Partitura Part object.
+        """
+        keysig_el = staffdef_el.find(self._ns_name("keySig"))
+        if keysig_el is not None:  # new element inside
+            sig = keysig_el.attrib["sig"]
+            # now extract partitura keysig parameters
+            fifths = self._mei_sig_to_fifths(sig)
+            mode = keysig_el.get("mode")
+        elif (
+            staffdef_el.get("key.sig") is not None
+        ):  # all encoded as attributes in staffdef
+            sig = staffdef_el.attrib["key.sig"]
+            # now extract partitura keysig parameters
+            fifths = self._mei_sig_to_fifths(sig)
+            mode = staffdef_el.get("key.mode")
+        else:  # the information is encoded in a parent scoredef
+            found_ancestor_with_key_info = False
+            for anc in staffdef_el.iterancestors(tag=self._ns_name("scoreDef")):
+                if anc.get("key.sig") is not None:
+                    found_ancestor_with_key_info = True
+                    break
+            if found_ancestor_with_key_info:
+                sig = anc.attrib["key.sig"]
+                # now extract partitura keysig parameters
+                fifths = self._mei_sig_to_fifths(sig)
+                mode = anc.get("key.mode")
+            else:
+                warnings.warn(
+                    f"The key signature is not encoded in {staffdef_el.get(self._ns_name('id'))} or in any ancestor scoreDef."
+                )
+                warnings.warn("A default key signature of C maj is set.")
+                fifths = 0
+                mode = "major"
+
+        new_key_signature = score.KeySignature(fifths, mode)
+        part.add(new_key_signature, position)
+
+    def _compute_clef_octave(self, dis, dis_place):
+        if dis is not None:
+            sign = -1 if dis_place == "below" else 1
+            octave = sign * int(int(dis) / 8)
+        else:
+            octave = 0
+        return octave
+
+    def _mei_sig_to_fifths(self, sig):
+        """Produces partitura KeySignature.fifths parameter from the MEI sig attribute."""
+        if sig[0] == "0":
+            fifths = 0
+        else:
+            sign = 1 if sig[-1] == "s" else -1
+            fifths = sign * int(sig[:-1])
+        return fifths
+
+    def _handle_clef(self, element, position, part):
+        """Inserts a clef. Element can be either a cleff element or staffdef element.
+
+        Parameters
+        ----------
+        staffdef_el : lxml tree
+            A lxml substree of a mei score.
+        position : int
+            Is the current position of the note on the timeline.
+        part : particular.Part
+            The created Partitura Part object.
+
+        Returns
+        -------
+        position : int
+            The current position of the note on the timeline.
+        """
+        # handle the case where we have clef informations inside staffdef el
+        if element.tag == self._ns_name("staffDef"):
+            clef_el = element.find(self._ns_name("clef"))
+            if clef_el is not None:  # if there is a clef element inside
+                return self._handle_clef(clef_el, position, part)
+            else:  # if all info are in the staffdef element
+                number = element.get("n")
+                sign = element.get("clef.shape")
+                line = element.get("clef.line")
+                if (
+                    number is not None and sign is not None and line is not None
+                ):  # if there is clef info
+                    octave = self._compute_clef_octave(
+                        element.get("dis"), element.get("dis.place")
+                    )
+                else:  # no clef info available, go for default
+                    warnings.warn("No clef information found, setting G2 as default.")
+                    sign = "G"
+                    line = 2
+                    number = 1
+                    octave = 0
+        elif element.tag == self._ns_name("clef"):
+            if element.get("sameas") is not None:  # this is a copy of another clef
+                # it seems this is used in different layers for the same staff
+                # we don't handle it to avoid clef duplications
+                return position
+            else:
+                # find the staff number
+                parent = element.getparent()
+                if parent.tag == self._ns_name("staffDef"):
+                    # number = parent.attrib["n"]
+                    number = 1
+                else:  # go back another level to staff element
+                    # number = parent.getparent().attrib["n"]
+                    number = 1
+                sign = element.attrib["shape"]
+                line = element.attrib["line"]
+                octave = self._compute_clef_octave(
+                    element.get("dis"), element.get("dis.place")
+                )
+        else:
+            raise Exception("_handle_clef only accepts staffDef or clef elements")
+        new_clef = score.Clef(int(number), sign, int(line), octave)
+        part.add(new_clef, position)
+        return position
+
+    def _handle_staffdef(self, staffdef_el, position, part):
+        """
+        Derives meter, key and clef from lxml substree and pass them to part.
+
+        Parameters
+        ----------
+        staffdef_el : lxml tree
+            A lxml substree of a mei score.
+        position : int
+            Is the current position of the note on the timeline.
+        part : particular.Part
+            The created Partitura Part object.
+        """
+        # fill with time signature info
+        self._handle_metersig(staffdef_el, position, part)
+        # fill with key signature info
+        self._handle_keysig(staffdef_el, position, part)
+        # fill with clef info
+        self._handle_clef(staffdef_el, position, part)
+
+    def _intsymdur_from_symbolic(self, symbolic_dur):
+        """Produce a int symbolic dur (e.g. 12 is a eight note triplet) and a dot number by looking at the symbolic dur dictionary:
+        i.e., symbol, eventual tuplet ancestors."""
+        intsymdur = SYMBOLIC_TO_INT_DURS[symbolic_dur["type"]]
+        # deals with tuplets
+        if symbolic_dur.get("actual_notes") is not None:
+            assert symbolic_dur.get("normal_notes") is not None
+            intsymdur = (
+                intsymdur * symbolic_dur["actual_notes"] / symbolic_dur["normal_notes"]
+            )
+        # deals with dots
+        dots = symbolic_dur.get("dots") if symbolic_dur.get("dots") is not None else 0
+        return intsymdur, dots
+
+    def _find_ppq(self):
+        """Finds the ppq for MEI filed that do not explicitely encode this information"""
+        els_with_dur = self.document.xpath(".//*[@dur]")
+        durs = []
+        durs_ppq = []
+        for el in els_with_dur:
+            symbolic_duration = self._get_symbolic_duration(el)
+            intsymdur, dots = self._intsymdur_from_symbolic(symbolic_duration)
+            # double the value if we have dots, to be sure be able to encode that with integers in partitura
+            durs.append(intsymdur * (2**dots))
+            durs_ppq.append(
+                None if el.get("dur.ppq") is None else int(el.get("dur.ppq"))
+            )
+
+        if any([dppq is not None for dppq in durs_ppq]):
+            # there is at least one element with both dur and dur.ppq
+            for dur, dppq in zip(durs, durs_ppq):
+                if dppq is not None:
+                    return dppq * dur / 4
+        else:
+            # compute the ppq from the durations
+            # add 4 to be sure to not go under 1 ppq
+            durs.append(4)
+            durs = np.array(durs)
+            # remove elements smaller than 1
+            durs = durs[durs >= 1]
+
+            least_common_multiple = np.lcm.reduce(durs.astype(int))
+
+            return least_common_multiple / 4
+
+    def _handle_initial_staffdef(self, staffdef_el):
+        """
+        Handles the definition of a single staff.
+
+        Parameters
+        ----------
+        staffdef_el : Element tree
+            A subtree of a particular Staff from a score.
+
+        Returns
+        -------
+        part : partitura.Part
+            Returns a partitura part filled with meter, time signature, key signature information.
+        """
+        # Fetch the namespace of the staff.
+        id = staffdef_el.attrib[self._ns_name("id", XML_NAMESPACE)]
+        label_el = staffdef_el.find(self._ns_name("label"))
+        name = label_el.text if label_el is not None else ""
+        ppq_attrib = staffdef_el.get("ppq")
+        if ppq_attrib is not None:
+            ppq = int(ppq_attrib)
+        else:
+            ppq = self._find_ppq()
+        # generate the part
+        part = score.Part(id, name, quarter_duration=ppq)
+        # fill it with other info, e.g. meter, time signature, key signature
+        self._handle_staffdef(staffdef_el, 0, part)
+        return part
+
+    def _handle_staffgroup(self, staffgroup_el):
+        """
+        Handles a staffGrp. WARNING: in MEI piano staves are a staffGrp
+
+        Parameters
+        ----------
+        staffgroup_el : element tree
+            A subtree of Staff Group from a score.
+
+        Returns
+        -------
+        staff_group : Partitura.PartGroup
+            A partitura PartGroup object made by calling and appending as children ever staff separately.
+        """
+        group_symbol_el = staffgroup_el.find(self._ns_name("grpSym"))
+        if group_symbol_el is None:
+            group_symbol = staffgroup_el.attrib["symbol"]
+        else:
+            group_symbol = group_symbol_el.attrib["symbol"]
+        label_el = staffgroup_el.find(self._ns_name("label"))
+        name = label_el.text if label_el is not None else None
+        id = staffgroup_el.attrib[self._ns_name("id", XML_NAMESPACE)]
+        staff_group = score.PartGroup(group_symbol, group_name=name, id=id)
+        staves_el = staffgroup_el.findall(self._ns_name("staffDef"))
+        for s_el in staves_el:
+            new_part = self._handle_initial_staffdef(s_el)
+            staff_group.children.append(new_part)
+        staff_groups_el = staffgroup_el.findall(self._ns_name("staffGrp"))
+        for sg_el in staff_groups_el:
+            new_staffgroup = self._handle_staffgroup(sg_el)
+            staff_group.children.append(new_staffgroup)
+        return staff_group
+
+    def _handle_main_staff_group(self, main_staffgrp_el):
+        """
+        Handles the main staffGrp that contains all other staves or staff groups.
+
+        Parameters
+        ----------
+        main_staffgrp_el : element_tree
+
+        Returns
+        -------
+        part_list : list
+            Created list of parts filled with key and time signature information.
+        """
+        staves_el = main_staffgrp_el.findall(self._ns_name("staffDef"))
+        staff_groups_el = main_staffgrp_el.findall(self._ns_name("staffGrp"))
+        # the list of parts or part groups
+        part_list = []
+        # process the parts
+        # TODO add Parallelization to handle part parsing in parallel
+        for s_el in staves_el:
+            new_part = self._handle_initial_staffdef(s_el)
+            part_list.append(new_part)
+        # process the part groups
+        for sg_el in staff_groups_el:
+            new_staffgroup = self._handle_staffgroup(sg_el)
+            part_list.append(new_staffgroup)
+        return part_list
+
+    # functions to parse the content of parts
+
+    def _note_el_to_accid_int(self, note_el) -> int:
+        """Accidental strings to integer pitch.
+        It consider the two values of accid and accid.ges (when the accidental is implicit in the bar)"""
+        if note_el.get("accid") is not None:
+            return SIGN_TO_ALTER[note_el.get("accid")]
+        elif note_el.get("accid.ges") is not None:
+            return SIGN_TO_ALTER[note_el.get("accid.ges")]
+        elif note_el.find(self._ns_name("accid")) is not None:
+            if note_el.find(self._ns_name("accid")).get("accid") is not None:
+                return SIGN_TO_ALTER[note_el.find(self._ns_name("accid")).get("accid")]
+            else:
+                return SIGN_TO_ALTER[
+                    note_el.find(self._ns_name("accid")).get("accid.ges")
+                ]
+        else:
+            return None
+
+    def _pitch_info(self, note_el):
+        """
+        Given a note element fetches PitchClassName, octave and accidental.
+
+        Parameters
+        ----------
+        note_el
+
+        Returns
+        -------
+        step : str
+            The note Pitch class name.
+        octave : int
+            The number of octave
+        alter : int
+            Accidental string transformed to number.
+        """
+        step = note_el.attrib["pname"]
+        octave = int(note_el.attrib["oct"])
+        # accidentals can be accid, accid.ges or accid children elements
+        alter = self._note_el_to_accid_int(note_el)
+        return step, octave, alter
+
+    def _get_symbolic_duration(self, el):
+        symbolic_duration = {}
+        symbolic_duration["type"] = MEI_DURS_TO_SYMBOLIC[el.attrib["dur"]]
+        if not el.get("dots") is None:
+            symbolic_duration["dots"] = int(el.get("dots"))
+        # find eventual time modifications
+        tuplet_ancestors = list(el.iterancestors(tag=self._ns_name("tuplet")))
+        if len(tuplet_ancestors) == 0:
+            pass
+        elif len(tuplet_ancestors) == 1:
+            symbolic_duration["actual_notes"] = int(tuplet_ancestors[0].attrib["num"])
+            symbolic_duration["normal_notes"] = int(
+                tuplet_ancestors[0].attrib["numbase"]
+            )
+        else:
+            raise Exception("Nested tuplets are not yet supported.")
+        return symbolic_duration
+
+    def _duration_info(self, el, part):
+        """
+        Extract duration info from a xml element.
+
+        It works for example with note_el, chord_el
+
+        Parameters
+        ----------
+        el : lxml tree
+            the xml element to analyze
+        part : partitura.Part
+            The created partitura part object.
+
+        Returns
+        -------
+        id :
+        duration :
+        symbolic_duration :
+        """
+        # symbolic duration
+        symbolic_duration = self._get_symbolic_duration(el)
+
+        # duration in ppq
+        if el.get("dur.ppq") is not None or el.get("grace") is not None:
+            # find duration in ppq. For grace notes is 0
+            duration = 0 if el.get("grace") is not None else int(el.get("dur.ppq"))
+        else:
+            # compute the duration from the symbolic duration
+            intsymdur, dots = self._intsymdur_from_symbolic(symbolic_duration)
+            divs = part._quarter_durations[0]  # divs is the same as ppq
+            duration = divs * 4 / intsymdur
+            for d in range(dots):
+                duration = duration + 0.5 * duration
+            # sanity check to verify the divs are correctly set
+            assert duration == int(duration)
+
+        # find id
+        id = el.attrib[self._ns_name("id", XML_NAMESPACE)]
+        return id, int(duration), symbolic_duration
+
+    def _handle_note(self, note_el, position, voice, staff, part) -> int:
+        """
+        Handles note elements and imports the to part.
+
+        Parameters
+        ----------
+        note_el : lxml substree
+            The lxml substree of a note element.
+        position : int
+            The current position on the timeline.
+        voice : int
+            The currect voice index.
+        staff : int
+            The current staff index.
+        part : partitura.Part
+            The created partitura part object.
+
+        Returns
+        -------
+        position + duration : into
+            The updated position on the timeline.
+        """
+        # find pitch info
+        step, octave, alter = self._pitch_info(note_el)
+        # find duration info
+        note_id, duration, symbolic_duration = self._duration_info(note_el, part)
+        # find if it's grace
+        grace_attr = note_el.get("grace")
+        if grace_attr is None:
+            # create normal note
+            note = score.Note(
+                step=step,
+                octave=octave,
+                alter=alter,
+                id=note_id,
+                voice=voice,
+                staff=1,
+                symbolic_duration=symbolic_duration,
+                articulations=None,  # TODO : add articulation
+            )
+        else:
+            # create grace note
+            if grace_attr == "unacc":
+                grace_type = "acciaccatura"
+            elif grace_attr == "acc":
+                grace_type = "appoggiatura"
+            else:  # unknow type
+                grace_type = "grace"
+            note = score.GraceNote(
+                grace_type=grace_type,
+                step=step,
+                octave=octave,
+                alter=alter,
+                id=note_id,
+                voice=voice,
+                staff=1,
+                symbolic_duration=symbolic_duration,
+                articulations=None,  # TODO : add articulation
+            )
+        # add note to the part
+        part.add(note, position, position + duration)
+        # return duration to update the position in the layer
+        return position + duration
+
+    def _handle_rest(self, rest_el, position, voice, staff, part):
+        """
+        Handles the rest element updates part and position.
+
+        Parameters
+        ----------
+        rest_el : lxml tree
+            A rest element in the lxml tree.
+        position : int
+            The current position on the timeline.
+        voice : int
+            The voice of the section.
+        staff : int
+            The current staff also refers to a Part.
+        part : Partitura.Part
+            The created part to add elements to.
+
+        Returns
+        -------
+        position + duration : int
+            Next position on the timeline.
+        Also adds the rest to the partitura part object.
+        """
+        # find duration info
+        rest_id, duration, symbolic_duration = self._duration_info(rest_el, part)
+        # create rest
+        rest = score.Rest(
+            id=rest_id,
+            voice=voice,
+            staff=1,
+            symbolic_duration=symbolic_duration,
+            articulations=None,
+        )
+        # add rest to the part
+        part.add(rest, position, position + duration)
+        # return duration to update the position in the layer
+        return position + duration
+
+    def _handle_mrest(self, mrest_el, position, voice, staff, part):
+        """
+        Handles a rest that spawn the entire measure
+
+        Parameters
+        ----------
+        mrest_el : lxml tree
+            A mrest element in the lxml tree.
+        position : int
+            The current position on the timeline.
+        voice : int
+            The voice of the section.
+        staff : int
+            The current staff also refers to a Part.
+        part : Partitura.Part
+            The created part to add elements to.
+
+        Returns
+        -------
+        position + duration : int
+            Next position on the timeline.
+        """
+        # find id
+        mrest_id = mrest_el.attrib[self._ns_name("id", XML_NAMESPACE)]
+        # find closest time signature
+        last_ts = list(part.iter_all(cls=score.TimeSignature))[-1]
+        # find divs per measure
+        ppq = part.quarter_duration_map(position)
+        parts_per_measure = int(ppq * 4 * last_ts.beats / last_ts.beat_type)
+
+        # create dummy rest to insert in the timeline
+        rest = score.Rest(
+            id=mrest_id,
+            voice=voice,
+            staff=1,
+            symbolic_duration=estimate_symbolic_duration(parts_per_measure, ppq),
+            articulations=None,
+        )
+        # add mrest to the part
+        part.add(rest, position, position + parts_per_measure)
+        # now iterate
+        # return duration to update the position in the layer
+        return position + parts_per_measure
+
+    def _handle_chord(self, chord_el, position, voice, staff, part):
+        """
+        Handles a rest that spawn the entire measure
+
+        Parameters
+        ----------
+        chord_el : lxml tree
+            A chord element in the lxml tree.
+        position : int
+            The current position on the timeline.
+        voice : int
+            The voice of the section.
+        staff : int
+            The current staff also refers to a Part.
+        part : Partitura.Part
+            The created part to add elements to.
+
+        Returns
+        -------
+        position + duration : int
+            Next position on the timeline.
+        """
+        # find duration info
+        chord_id, duration, symbolic_duration = self._duration_info(chord_el, part)
+        # find notes info
+        notes_el = chord_el.findall(self._ns_name("note"))
+        for note_el in notes_el:
+            note_id = note_el.attrib[self._ns_name("id", XML_NAMESPACE)]
+            # find pitch info
+            step, octave, alter = self._pitch_info(note_el)
+            # create note
+            note = score.Note(
+                step=step,
+                octave=octave,
+                alter=alter,
+                id=note_id,
+                voice=voice,
+                staff=1,
+                symbolic_duration=symbolic_duration,
+                articulations=None,  # TODO : add articulation
+            )
+            # add note to the part
+            part.add(note, position, position + duration)
+            # return duration to update the position in the layer
+        return position + duration
+
+    def _handle_space(self, e, position, part):
+        """Moves current position."""
+        space_id, duration, symbolic_duration = self._duration_info(e, part)
+        return position + duration
+
+    def _handle_barline_symbols(self, measure_el, position: int, left_or_right: str):
+        barline = measure_el.get(left_or_right)
+        if barline is not None:
+            if barline == "rptstart":
+                self.repetitions.append({"type": "start", "pos": position})
+                self.barlines.append({"type": "heavy-light", "pos": position})
+            elif barline == "rptend":
+                self.repetitions.append({"type": "stop", "pos": position})
+                self.barlines.append({"type": "light-heavy", "pos": position})
+            elif barline == "dbl":
+                self.barlines.append({"type": "light-light", "pos": position})
+            elif barline == "end":
+                self.barlines.append({"type": "light-heavy", "pos": position})
+            elif barline == "dashed":
+                self.barlines.append({"type": "dashed", "pos": position})
+            else:
+                print(
+                    f"{barline} in measure {measure_el.attrib[self._ns_name('id', XML_NAMESPACE)]} is a non supported barline type."
+                )
+
+    def _handle_layer_in_staff_in_measure(
+        self, layer_el, ind_layer: int, ind_staff: int, position: int, part
+    ) -> int:
+        for i, e in enumerate(layer_el):
+            if e.tag == self._ns_name("note"):
+                new_position = self._handle_note(
+                    e, position, ind_layer, ind_staff, part
+                )
+            elif e.tag == self._ns_name("chord"):
+                new_position = self._handle_chord(
+                    e, position, ind_layer, ind_staff, part
+                )
+            elif e.tag == self._ns_name("rest"):
+                new_position = self._handle_rest(
+                    e, position, ind_layer, ind_staff, part
+                )
+            elif e.tag == self._ns_name("mRest"):  # rest that spawn the entire measure
+                new_position = self._handle_mrest(
+                    e, position, ind_layer, ind_staff, part
+                )
+            elif e.tag == self._ns_name("beam"):
+                # TODO : add Beam element
+                # recursive call to the elements inside beam
+                new_position = self._handle_layer_in_staff_in_measure(
+                    e, ind_layer, ind_staff, position, part
+                )
+            elif e.tag == self._ns_name("tuplet"):
+                # TODO : add Tuplet element
+                # recursive call to the elements inside Tuplet
+                new_position = self._handle_layer_in_staff_in_measure(
+                    e, ind_layer, ind_staff, position, part
+                )
+            elif e.tag == self._ns_name("clef"):
+                new_position = self._handle_clef(e, position, part)
+            elif e.tag == self._ns_name("space"):
+                new_position = self._handle_space(e, position, part)
+            else:
+                raise Exception("Tag " + e.tag + " not supported")
+
+            # update the current position
+            position = new_position
+        return position
+
+    def _handle_staff_in_measure(self, staff_el, staff_ind, position: int, part):
+        """
+        Handles staffs inside a measure element.
+
+        Parameters
+        ----------
+        staff_el : lxml etree
+            The lxml subtree for a staff element.
+        staff_ind : int
+            The Staff index.
+        position : int
+            The current position on the timeline.
+        part : Partitura.Part
+            The created partitura part object.
+
+        Returns
+        -------
+        end_positions[0] : int
+            The final position on the timeline.
+        """
+        # add measure
+        measure = score.Measure(number=staff_el.getparent().get("n"))
+        part.add(measure, position)
+
+        layers_el = staff_el.findall(self._ns_name("layer"))
+        end_positions = []
+        for i_layer, layer_el in enumerate(layers_el):
+            end_positions.append(
+                self._handle_layer_in_staff_in_measure(
+                    layer_el, i_layer + 1, staff_ind, position, part
+                )
+            )
+        # check if layers have equal duration (bad encoding, but it often happens)
+        if not all([e == end_positions[0] for e in end_positions]):
+            warnings.warn(
+                f"Warning: voices have different durations in staff {staff_el.attrib[self._ns_name('id',XML_NAMESPACE)]}"
+            )
+
+        if (
+            len(end_positions) == 0
+        ):  # if a measure contains no elements (e.g., a forgotten rest)
+            end_positions.append(position)
+        # add end time of measure
+        part.add(measure, None, max(end_positions))
+        return max(end_positions)
+
+    def _find_dir_positions(self, dir_el, bar_position):
+        """Compute the position for a <dir> element.
+        Returns an array, one position for each part."""
+        delta_position_beat = float(dir_el.get("tstamp"))
+        return [
+            p.inv_beat_map(p.beat_map(bar_position) + delta_position_beat - 1)
+            for p in score.iter_parts(self.parts)
+        ]
+
+    def _add_in_all_parts(self, tobj, starts):
+        for part, start in zip(score.iter_parts(self.parts), starts):
+            part.add(tobj, start)
+
+    def _handle_dir_element(self, dir_el, position):
+        # find the kind of element
+        kind = dir_el.get("type")
+        if kind is None:
+            return
+        dir_pos = self._find_dir_positions(dir_el, position)
+        if kind == "fine":
+            self._add_in_all_parts(score.Fine(), dir_pos)
+        elif kind == "dacapo":
+            self._add_in_all_parts(score.DaCapo(), dir_pos)
+
+    def _handle_directives(self, measure_el, position):
+        dir_els = measure_el.findall(self._ns_name("dir"))
+        for dir_el in dir_els:
+            self._handle_dir_element(dir_el, position)
+
+    def _handle_section(self, section_el, parts, position: int):
+        """
+        Returns position and fills parts with elements.
+
+        Parameters
+        ----------
+        section_el : lxml tree
+            An lxml substree of a MEI score reffering to a section.
+        parts : list()
+            A list of partitura Parts.
+        position : int
+            The current position on the timeline.
+
+        Returns
+        -------
+        position : int
+            The end position of the section.
+        """
+        for i_el, element in enumerate(section_el):
+            # handle measures
+            if element.tag == self._ns_name("measure"):
+                # handle left barline symbols
+                self._handle_barline_symbols(element, position, "left")
+                # handle staves
+                staves_el = element.findall(self._ns_name("staff"))
+                if len(list(staves_el)) != len(list(parts)):
+                    raise Exception(f"Not all parts are specified in measure {i_el}")
+                end_positions = []
+                for i_s, (part, staff_el) in enumerate(zip(parts, staves_el)):
+                    end_positions.append(
+                        self._handle_staff_in_measure(staff_el, i_s + 1, position, part)
+                    )
+                # handle directives (dir elements)
+                self._handle_directives(element, position)
+                # sanity check that all layers have equal duration
+                max_position = max(end_positions)
+                if not all([e == max_position for e in end_positions]):
+                    warnings.warn(
+                        f"Warning : parts have measures of different duration in measure {element.attrib[self._ns_name('id',XML_NAMESPACE)]}"
+                    )
+                    # enlarge measures to the max
+                    for part in parts:
+                        last_measure = list(part.iter_all(pt.score.Measure))[-1]
+                        if last_measure.end.t != max_position:
+                            part.add(
+                                pt.score.Measure(number=last_measure.number),
+                                position,
+                                max_position,
+                            )
+                            part.remove(last_measure)
+                position = max_position
+                # handle right barline symbol
+                self._handle_barline_symbols(element, position, "right")
+            # handle staffDef elements
+            elif element.tag == self._ns_name("scoreDef"):
+                # meter modifications
+                metersig_el = element.find(self._ns_name("meterSig"))
+                if (metersig_el is not None) or (
+                    element.get("meter.count") is not None
+                ):
+                    for part in parts:
+                        self._handle_metersig(element, position, part)
+                # key signature modifications
+                keysig_el = element.find(self._ns_name("keySig"))
+                if (keysig_el is not None) or (element.get("key.sig") is not None):
+                    for part in parts:
+                        self._handle_keysig(element, position, part)
+            # handle nested section
+            elif element.tag == self._ns_name("section"):
+                position = self._handle_section(element, parts, position)
+            elif element.tag == self._ns_name("ending"):
+                ending_start = position
+                position = self._handle_section(element, parts, position)
+                # insert the ending element
+                ending_number = int(re.sub("[^0-9]", "", element.attrib["n"]))
+                self._add_ending(ending_start, position, ending_number, parts)
+            # explicit repetition expansions
+            elif element.tag == self._ns_name("expansion"):
+                pass
+            # system break
+            elif element.tag == self._ns_name("sb"):
+                pass
+            # page break
+            elif element.tag == self._ns_name("pb"):
+                pass
+            else:
+                raise Exception(f"element {element.tag} is not yet supported")
+
+        return position
+
+    def _add_ending(self, start_ending, end_ending, ending_string, parts):
+        for part in score.iter_parts(parts):
+            part.add(score.Ending(ending_string), start_ending, end_ending)
+
+    def _tie_notes(self, section_el, part_list):
+        """Ties all notes in a part.
+        This function must be run after the parts are completely created."""
+        # TODO : support ties written as attributes with @tie sintax
+        ties_el = section_el.findall(self._ns_name("tie", all=True))
+        # create a dict of id : note, to speed up search
+        all_notes = [
+            note
+            for part in score.iter_parts(part_list)
+            for note in part.iter_all(cls=score.Note)
+        ]
+        all_notes_dict = {note.id: note for note in all_notes}
+        for tie_el in ties_el:
+            start_id = tie_el.get("startid")
+            end_id = tie_el.get("endid")
+            if start_id is None or end_id is None:
+                warnings.warn(
+                    f"Warning: tie {tie_el.attrib[self._ns_name('id',XML_NAMESPACE)]} is missing the a startid or endid"
+                )
+            else:
+                # remove the # in first position
+                start_id = start_id[1:]
+                end_id = end_id[1:]
+                # set tie prev and tie next in partira note objects
+                all_notes_dict[start_id].tie_next = all_notes_dict[end_id]
+                all_notes_dict[end_id].tie_prev = all_notes_dict[start_id]
+
+    def _insert_repetitions(self):
+        if len(self.repetitions) == 0:
+            return
+        ## sanitize the found repetitions in case a starting rep is missing
+        if self.repetitions[0]["type"] == "stop":
+            # add a start symbol at 0
+            print(
+                "WARNING : unmatched repetitions. adding a repetition start at position 0"
+            )
+            self.repetitions.insert(0, {"type": "start", "pos": 0})
+        status = "stop"
+        sanitized_repetition_list = []
+        # check if start-stop are alternate
+        for i_rep, rep in enumerate(self.repetitions):
+            if rep["type"] != status:
+                sanitized_repetition_list.append(rep)
+            else:
+                if (
+                    rep["type"] == "start"
+                ):  # missing stop, inserting one right before start
+                    print(
+                        f"WARNING : unmatched repetitions. adding a repetition stop at position {rep['pos']}"
+                    )
+                    sanitized_repetition_list.append(
+                        {"type": "stop", "pos": rep["pos"]}
+                    )
+                else:  # missing start, inserting one at the last stop
+                    print(
+                        f"WARNING : unmatched repetitions. adding a repetition start at position {sanitized_repetition_list[-1]['pos']}"
+                    )
+                    sanitized_repetition_list.append(
+                        {"type": "start", "pos": sanitized_repetition_list[-1]["pos"]}
+                    )
+                # proceed by inserting rep
+                sanitized_repetition_list.append(rep)
+            # switch the status
+            status = "stop" if status == "start" else "start"
+        # check if ending with a start
+        if sanitized_repetition_list[-1] == "start":
+            print("WARNING : unmatched repetitions. Ignoring last start")
+        self.repetitions = sanitized_repetition_list
+
+        ## insert the repetitions to all parts
+        for rep_start, rep_stop in zip(self.repetitions[:-1:2], self.repetitions[1::2]):
+            assert rep_start["type"] == "start" and rep_stop["type"] == "stop"
+            for part in score.iter_parts(self.parts):
+                part.add(score.Repeat(), rep_start["pos"], rep_stop["pos"])
+
+    def _insert_barlines(self):
+        for bl in self.barlines:
+            for part in score.iter_parts(self.parts):
+                part.add(score.Barline(bl["type"]), bl["pos"])
```

### Comparing `partitura-1.2.1/partitura/io/importmidi.py` & `partitura-1.2.2/partitura/io/importmidi.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,779 +1,776 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for importing MIDI files.
-"""
-import warnings
-
-from collections import defaultdict
-from typing import Union, Optional
-import numpy as np
-
-
-import mido
-
-import partitura.score as score
-import partitura.performance as performance
-from partitura.utils import (
-    estimate_symbolic_duration,
-    key_name_to_fifths_mode,
-    fifths_mode_to_key_name,
-    estimate_clef_properties,
-    deprecated_alias,
-    deprecated_parameter,
-    PathLike,
-    get_document_name,
-    ensure_notearray
-)
-import partitura.musicanalysis as analysis
-
-__all__ = ["load_score_midi", "load_performance_midi", "midi_to_notearray"]
-
-
-# as key for the dict use channel * 128 (max number of pitches) + pitch
-def note_hash(channel: int, pitch: int) -> int:
-    """Generate a note hash."""
-    return channel * 128 + pitch
-
-
-@deprecated_alias(fn="filename")
-def midi_to_notearray(filename: PathLike) -> np.ndarray:
-    """Load a MIDI file in a note_array.
-
-    This function should be used to load MIDI files into an
-    array of MIDI notes given by onset and duration (in seconds),
-    pitch, velocity, and ID.
-
-    Sustain pedal, program changes, control changes, track and
-    channel information as well as mpq and ppq are discarded.
-
-    Parameters
-    ----------
-    filename : str
-        Path to MIDI file
-    Returns
-    -------
-    np.ndarray :
-        Structured array with onset, duration, pitch, velocity, and
-        ID fields.
-    """
-    perf = load_performance_midi(filename, merge_tracks=True)
-    # set sustain pedal threshold to 128 to disable sustain adjusted offsets
-
-    for ppart in perf:
-        ppart.sustain_pedal_threshold = 128
-
-    note_array = ensure_notearray(perf)
-    return note_array
-
-
-@deprecated_alias(fn="filename")
-def load_performance_midi(
-    filename: Union[PathLike, mido.MidiFile],
-    default_bpm: Union[int, float] = 120,
-    merge_tracks: bool = False
-) -> performance.Performance:
-    """Load a musical performance from a MIDI file.
-
-    This function should be used for MIDI files that encode
-    performances, such as those obtained from a capture of a MIDI
-    instrument. This function loads note on/off events as well as
-    control events, but ignores other data such as time and key
-    signatures. Furthermore, the PerformedPart instance that the
-    function returns does not retain the ticks_per_beat or tempo
-    events. The timing of all events is represented in seconds. If you
-    wish to retain this information consider using the
-    `load_score_midi` function.
-
-    Parameters
-    ----------
-    filename : str
-        Path to MIDI file
-    default_bpm : number, optional
-        Tempo to use wherever the MIDI does not specify a tempo.
-        Defaults to 120.
-    merge_tracks: bool, optional
-        For MIDI files, merges all tracks into a single track.
-
-    Returns
-    -------
-    :class:`partitura.performance.Performance`
-        A Performance instance.
-    """
-
-    if isinstance(filename, mido.MidiFile):
-        mid = filename
-        doc_name = filename.filename
-    else:
-        mid = mido.MidiFile(filename)
-        doc_name = get_document_name(filename)
-
-    # parts per quarter
-    ppq = mid.ticks_per_beat
-    # microseconds per quarter
-    mpq = 60 * (10 ** 6 / default_bpm)
-
-    # convert MIDI ticks in seconds
-    time_conversion_factor = mpq / (ppq * 10 ** 6)
-
-    pps = list()
-    
-    if merge_tracks:
-        mid_merge = mido.merge_tracks(mid.tracks)
-        tracks = [(0, mid_merge)]
-    else:
-        tracks = [(i, u) for i, u in enumerate(mid.tracks)]
-    for i, track in tracks:
-        
-        notes = []
-        controls = []
-        programs = []
-
-        t = 0
-        ttick = 0
-        
-        sounding_notes = {}
-
-        for msg in track:
-
-            # update time deltas when they arrive
-            t = t + msg.time * time_conversion_factor
-            ttick = ttick + msg.time 
-
-            if msg.type == "set_tempo":
-
-                mpq = msg.tempo
-                time_conversion_factor = mpq / (ppq * 10 ** 6)
-
-            elif msg.type == "control_change":
-
-                controls.append(
-                    dict(
-                        time=t,
-                        time_tick=ttick,
-                        number=msg.control,
-                        value=msg.value,
-                        track=i,
-                        channel=msg.channel,
-                    )
-                )
-
-            elif msg.type == "program_change":
-
-                programs.append(
-                    dict(
-                        time=t,
-                        time_tick=ttick,
-                        program=msg.program,
-                        track=i,
-                        channel=msg.channel,
-                    )
-                )
-
-            else:
-
-                note_on = msg.type == "note_on"
-                note_off = msg.type == "note_off"
-
-                if not (note_on or note_off):
-                    continue
-
-                # hash sounding note
-                note = note_hash(msg.channel, msg.note)
-
-                # start note if it's a 'note on' event with velocity > 0
-                if note_on and msg.velocity > 0:
-
-                    # save the onset time and velocity
-                    sounding_notes[note] = (t, ttick, msg.velocity)
-
-                # end note if it's a 'note off' event or 'note on' with velocity 0
-                elif note_off or (note_on and msg.velocity == 0):
-
-                    if note not in sounding_notes:
-                        warnings.warn("ignoring MIDI message %s" % msg)
-                        continue
-
-                    # append the note to the list associated with the channel
-
-                    notes.append(
-                        dict(
-                            # id=f"n{len(notes)}",
-                            midi_pitch=msg.note,
-                            note_on=(sounding_notes[note][0]),
-                            note_on_tick=(sounding_notes[note][1]),
-                            note_off=(t),
-                            note_off_tick=(ttick),
-                            track=i,
-                            channel=msg.channel,
-                            velocity=sounding_notes[note][2],
-                        )
-                    )
-                    # remove hash from dict
-                    del sounding_notes[note]
-
-        # fix note ids so that it is sorted lexicographically
-        # by onset, pitch, offset, channel and track
-        notes.sort(
-            key=lambda x: (
-                x["note_on"],
-                x["midi_pitch"],
-                x["note_off"],
-                x["channel"],
-                x["track"],
-            )
-        )
-
-        # add note id to every note
-        for k, note in enumerate(notes):
-            note["id"] = f"n{k}"
-            
-        if len(notes) > 0 or len(controls) > 0 or len(programs) > 0:
-            pp = performance.PerformedPart(notes, 
-                                    controls=controls, 
-                                    programs=programs, 
-                                    ppq = ppq,
-                                    mpq = mpq,
-                                    track = i)
-            
-            pps.append(pp)
-
-    perf = performance.Performance(
-        id=doc_name,
-        performedparts=pps,
-    )
-    return perf
-
-
-@deprecated_parameter("ensure_list")
-@deprecated_alias(fn="filename")
-def load_score_midi(
-    filename: Union[PathLike, mido.MidiFile],
-    part_voice_assign_mode: Optional[int] = 0,
-    quantization_unit: Optional[int] = None,
-    estimate_voice_info: bool = True,
-    estimate_key: bool = False,
-    assign_note_ids: bool = True,
-) -> score.Score:
-    """Load a musical score from a MIDI file and return it as a Part
-    instance.
-
-    This function interprets MIDI information as describing a score.
-    Pitch names are estimated using Meredith's PS13 algorithm [1]_.
-    Assignment of notes to voices can either be done using Chew and
-    Wu's voice separation algorithm [2]_, or by choosing one of the
-    part/voice assignment modes that assign voices based on
-    track/channel information. Furthermore, the key signature can be
-    estimated based on Krumhansl's 1990 key profiles [3]_.
-
-    This function expects times to be metrical/quantized. Optionally a
-    quantization unit may be specified. If you wish to access the non-
-    quantized time of MIDI events you may wish to used the
-    `load_performance_midi` function instead.
-
-    Parameters
-    ----------
-    filename : PathLike or mido.MidiFile
-        Path to MIDI file or mido.MidiFile object.
-    part_voice_assign_mode : {0, 1, 2, 3, 4, 5}, optional
-        This keyword controls how part and voice information is
-        associated to track and channel information in the MIDI file.
-        The semantics of the modes is as follows:
-
-        0
-            Return one Part per track, with voices assigned by channel
-        1
-            Return one PartGroup per track, with Parts assigned by channel
-            (no voices)
-        2
-            Return single Part with voices assigned by track (tracks are
-            combined, channel info is ignored)
-        3
-            Return one Part per track, without voices (channel info is
-            ignored)
-        4
-            Return single Part without voices (channel and track info is
-            ignored)
-        5
-            Return one Part per <track, channel> combination, without
-            voices  Defaults to 0.
-    quantization_unit : integer or None, optional
-        Quantize MIDI times to multiples of this unit. If None, the
-        quantization unit is chosen automatically as the smallest
-        division of the parts per quarter (MIDI "ticks") that can be
-        represented as a symbolic duration. Defaults to None.
-    estimate_key : bool, optional
-        When True use Krumhansl's 1990 key profiles [3]_ to determine
-        the most likely global key, discarding any key information in
-        the MIDI file.
-    estimate_voice_info : bool, optional
-        When True use Chew and Wu's voice separation algorithm [2]_ to
-        estimate voice information. This option is ignored for
-        part/voice assignment modes that infer voice information from
-        the track/channel info (i.e. `part_voice_assign_mode` equals
-        1, 3, 4, or 5). Defaults to True.
-
-    Returns
-    -------
-    :class:`partitura.score.Part`, :class:`partitura.score.PartGroup`, \
-or a list of these
-        One or more part or partgroup objects
-
-    References
-    ----------
-    .. [1] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
-           of New Music Research, 35(2):121.
-    .. [2] Chew, E. and Wu, Xiaodan (2004) "Separating Voices in
-           Polyphonic Music: A Contig Mapping Approach". In Uffe Kock,
-           editor, Computer Music Modeling and Retrieval (CMMR), pp. 1–20,
-           Springer Berlin Heidelberg.
-    .. [3] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
-           Oxford University Press, New York.
-
-    """
-
-    if isinstance(filename, mido.MidiFile):
-        mid = filename
-        doc_name = filename.filename
-    else:
-        mid = mido.MidiFile(filename)
-        doc_name = get_document_name(filename)
-
-    divs = mid.ticks_per_beat
-
-    # these lists will contain information from dedicated tracks for meta
-    # information (i.e. without notes)
-    global_time_sigs = []
-    global_key_sigs = []
-    global_tempos = []
-
-    # these dictionaries will contain meta information indexed by track (only
-    # for tracks that contain notes)
-    time_sigs_by_track = {}
-    key_sigs_by_track = {}
-    track_names_by_track = {}
-    # notes are indexed by (track, channel) tuples
-    notes_by_track_ch = {}
-    relevant = {"time_signature", "key_signature", "set_tempo", "note_on", "note_off"}
-    for track_nr, track in enumerate(mid.tracks):
-        time_sigs = []
-        key_sigs = []
-        # tempos = []
-        notes = defaultdict(list)
-        # dictionary for storing the last onset time and velocity for each
-        # individual note (i.e. same pitch and channel)
-        sounding_notes = {}
-        # current time (will be updated by delta times in messages)
-        t_raw = 0
-
-        for msg in track:
-
-            t_raw = t_raw + msg.time
-
-            if msg.type not in relevant:
-                continue
-
-            if quantization_unit:
-                t = quantize(t_raw, quantization_unit)
-            else:
-                t = t_raw
-
-            if msg.type == "time_signature":
-                time_sigs.append((t, msg.numerator, msg.denominator))
-            if msg.type == "key_signature":
-                key_sigs.append((t, msg.key))
-            if msg.type == "set_tempo":
-                global_tempos.append((t, 60 * 10 ** 6 / msg.tempo))
-            else:
-                note_on = msg.type == "note_on"
-                note_off = msg.type == "note_off"
-
-                if not (note_on or note_off):
-                    continue
-
-                # hash sounding note
-                note = note_hash(msg.channel, msg.note)
-
-                # start note if it's a 'note on' event with velocity > 0
-                if note_on and msg.velocity > 0:
-
-                    # save the onset time and velocity
-                    sounding_notes[note] = (t, msg.velocity)
-
-                # end note if it's a 'note off' event or 'note on' with velocity 0
-                elif note_off or (note_on and msg.velocity == 0):
-
-                    if note not in sounding_notes:
-                        warnings.warn("ignoring MIDI message %s" % msg)
-                        continue
-
-                    # append the note to the list associated with the channel
-                    notes[msg.channel].append(
-                        (sounding_notes[note][0], msg.note, t - sounding_notes[note][0])
-                    )
-                    # sounding_notes[note][1]])
-                    # remove hash from dict
-                    del sounding_notes[note]
-
-        # if a track has no notes, we assume it may contain global time/key sigs
-        if not notes:
-            global_time_sigs.extend(time_sigs)
-            global_key_sigs.extend(key_sigs)
-        else:
-            # if there are note, we store the info under the track number
-            time_sigs_by_track[track_nr] = time_sigs
-            key_sigs_by_track[track_nr] = key_sigs
-            track_names_by_track[track_nr] = track.name
-
-        for ch, ch_notes in notes.items():
-            # if there are any notes, store the notes along with key sig / time
-            # sig / tempo information under the key (track_nr, ch_nr)
-            if len(ch_notes) > 0:
-                notes_by_track_ch[(track_nr, ch)] = ch_notes
-
-    tr_ch_keys = sorted(notes_by_track_ch.keys())
-    group_part_voice_keys, part_names, group_names = assign_group_part_voice(
-        part_voice_assign_mode, tr_ch_keys, track_names_by_track
-    )
-
-    # for key and time sigs:
-    track_to_part_mapping = make_track_to_part_mapping(
-        tr_ch_keys, group_part_voice_keys
-    )
-
-    # pairs of (part, voice) for each note
-    part_voice_list = [
-        [part, voice]
-        for tr_ch, (_, part, voice) in zip(tr_ch_keys, group_part_voice_keys)
-        for i in range(len(notes_by_track_ch[tr_ch]))
-    ]
-
-    # pitch spelling, voice estimation and key estimation are done on a
-    # structured array (onset, pitch, duration) of all notes in the piece
-    # jointly, so we concatenate all notes
-    # note_list = sorted(note for notes in
-    # (notes_by_track_ch[key] for key in tr_ch_keys) for note in notes)
-    note_list = [
-        note
-        for notes in (notes_by_track_ch[key] for key in tr_ch_keys)
-        for note in notes
-    ]
-    note_array = np.array(
-        note_list,
-        dtype=[("onset_div", int), ("pitch", int), ("duration_div", int)],
-    )
-
-    warnings.warn("pitch spelling")
-    spelling_global = analysis.estimate_spelling(note_array)
-
-    if estimate_voice_info:
-        warnings.warn("voice estimation", stacklevel=2)
-        # TODO: deal with zero duration notes in note_array.
-        # Zero duration notes are currently deleted
-        estimated_voices = analysis.estimate_voices(note_array)
-        assert len(part_voice_list) == len(estimated_voices)
-        for part_voice, voice_est in zip(part_voice_list, estimated_voices):
-            if part_voice[1] is None:
-                part_voice[1] = voice_est
-
-    if estimate_key:
-        warnings.warn("key estimation", stacklevel=2)
-        _, mode, fifths = analysis.estimate_key(note_array)
-        key_sigs_by_track = {}
-        global_key_sigs = [(0, fifths_mode_to_key_name(fifths, mode))]
-
-    if assign_note_ids:
-        note_ids = ["n{}".format(i) for i in range(len(note_array))]
-    else:
-        note_ids = [None for i in range(len(note_array))]
-
-    time_sigs_by_part = defaultdict(set)
-    for tr, ts_list in time_sigs_by_track.items():
-        for ts in ts_list:
-            for part in track_to_part_mapping[tr]:
-                time_sigs_by_part[part].add(ts)
-    for ts in global_time_sigs:
-        for part in set(part for _, part, _ in group_part_voice_keys):
-            time_sigs_by_part[part].add(ts)
-
-    key_sigs_by_part = defaultdict(set)
-    for tr, ks_list in key_sigs_by_track.items():
-        for ks in ks_list:
-            for part in track_to_part_mapping[tr]:
-                key_sigs_by_part[part].add(ks)
-    for ks in global_key_sigs:
-        for part in set(part for _, part, _ in group_part_voice_keys):
-            key_sigs_by_part[part].add(ks)
-
-    # names_by_part = defaultdict(set)
-    # for tr_ch, pg_p_v in zip(tr_ch_keys, group_part_voice_keys):
-    #     print(tr_ch, pg_p_v)
-    # for tr, name in track_names_by_track.items():
-    #     print(tr, track_to_part_mapping, name)
-    #     for part in track_to_part_mapping[tr]:
-    #         names_by_part[part] = name
-
-    notes_by_part = defaultdict(list)
-    for (part, voice), note, spelling, note_id in zip(
-        part_voice_list, note_list, spelling_global, note_ids
-    ):
-        notes_by_part[part].append((note, voice, spelling, note_id))
-
-    partlist = []
-    part_to_part_group = dict((p, pg) for pg, p, _ in group_part_voice_keys)
-    part_groups = {}
-    for part_nr, note_info in notes_by_part.items():
-        notes, voices, spellings, note_ids = zip(*note_info)
-        part = create_part(
-            divs,
-            notes,
-            spellings,
-            voices,
-            note_ids,
-            sorted(time_sigs_by_part[part_nr]),
-            sorted(key_sigs_by_part[part_nr]),
-            part_id="P{}".format(part_nr + 1),
-            part_name=part_names.get(part_nr, None),
-        )
-
-        # print(part.pretty())
-        # if this part has an associated part_group number we create a PartGroup
-        # if necessary, and add the part to that. The newly created PartGroup is
-        # then added to the partlist.
-        pg_nr = part_to_part_group[part_nr]
-        if pg_nr is None:
-            partlist.append(part)
-        else:
-            if pg_nr not in part_groups:
-                part_groups[pg_nr] = score.PartGroup(
-                    group_name=group_names.get(pg_nr, None)
-                )
-                partlist.append(part_groups[pg_nr])
-            part_groups[pg_nr].children.append(part)
-
-    # add tempos to first part
-    part = next(score.iter_parts(partlist))
-    for t, qpm in global_tempos:
-        part.add(score.Tempo(qpm, unit="q"), t)
-
-    # TODO: Add info (composer, etc.)
-    scr = score.Score(
-        id=doc_name,
-        partlist=partlist,
-    )
-
-    return scr
-
-
-def make_track_to_part_mapping(tr_ch_keys, group_part_voice_keys):
-    """Return a mapping from track numbers to one or more parts. This mapping tells
-    us where to put meta event info like time and key sigs.
-    """
-    track_to_part_keys = defaultdict(set)
-    for (tr, _), (_, part, _) in zip(tr_ch_keys, group_part_voice_keys):
-        track_to_part_keys[tr].add(part)
-    return track_to_part_keys
-
-
-def assign_group_part_voice(mode, track_ch_combis, track_names):
-    """
-    0: return one Part per track, with voices assigned by channel
-    1. return one PartGroup per track, with Parts assigned by channel (no voices)
-    2. return single Part with voices assigned by track (tracks are combined,
-       channel info is ignored)
-    3. return one Part per track, without voices (channel info is ignored)
-    4. return single Part without voices (channel and track info is ignored)
-    5. return one Part per <track, channel> combination, without voices
-    """
-    part_group = {}
-    part = {}
-    voice = {}
-    part_helper = {}
-    voice_helper = {}
-    part_group_helper = {}
-
-    part_names = {}
-    group_names = {}
-    for tr, ch in track_ch_combis:
-        if mode == 0:
-            prt = part_helper.setdefault(tr, len(part_helper))
-            vc1 = voice_helper.setdefault(tr, {})
-            vc2 = vc1.setdefault(ch, len(vc1) + 1)
-            part_names[prt] = "{}".format(
-                track_names.get(tr, "Track {}".format(tr + 1))
-            )
-            part[(tr, ch)] = prt
-            voice[(tr, ch)] = vc2
-        elif mode == 1:
-            pg = part_group_helper.setdefault(tr, len(part_group_helper))
-            prt = part_helper.setdefault(ch, len(part_helper))
-            part_group.setdefault((tr, ch), pg)
-            group_names[pg] = track_names.get(tr, "Track {}".format(tr + 1))
-            part_names[prt] = "ch={}".format(ch)
-            part[(tr, ch)] = prt
-        elif mode == 2:
-            vc = voice_helper.setdefault(tr, len(voice_helper) + 1)
-            part.setdefault((tr, ch), 0)
-            voice[(tr, ch)] = vc
-        elif mode == 3:
-            prt = part_helper.setdefault(tr, len(part_helper))
-            part_names[prt] = "{}".format(
-                track_names.get(tr, "Track {}".format(tr + 1))
-            )
-            part[(tr, ch)] = prt
-        elif mode == 4:
-            part.setdefault((tr, ch), 0)
-        elif mode == 5:
-            part_names[(tr, ch)] = "{} ch={}".format(
-                track_names.get(tr, "Track {}".format(tr + 1)), ch
-            )
-            part.setdefault((tr, ch), len(part))
-
-    return (
-        [
-            (part_group.get(tr_ch), part.get(tr_ch), voice.get(tr_ch))
-            for tr_ch in track_ch_combis
-        ],
-        part_names,
-        group_names,
-    )
-
-
-def create_part(
-    ticks,
-    notes,
-    spellings,
-    voices,
-    note_ids,
-    time_sigs,
-    key_sigs,
-    part_id=None,
-    part_name=None,
-) -> score.Part:
-    warnings.warn("create_part", stacklevel=2)
-
-    part = score.Part(part_id, part_name=part_name)
-    part.set_quarter_duration(0, ticks)
-
-    clef = score.Clef(
-        staff=1, **estimate_clef_properties([pitch for _, pitch, _ in notes])
-    )
-    part.add(clef, 0)
-    for t, name in key_sigs:
-        fifths, mode = key_name_to_fifths_mode(name)
-        part.add(score.KeySignature(fifths, mode), t)
-
-    warnings.warn("add notes", stacklevel=2)
-
-    for (onset, pitch, duration), (step, alter, octave), voice, note_id in zip(
-        notes, spellings, voices, note_ids
-    ):
-        if duration > 0:
-            note = score.Note(
-                step=step,
-                octave=octave,
-                alter=alter,
-                voice=int(voice or 0),
-                id=note_id,
-                symbolic_duration=estimate_symbolic_duration(duration, ticks),
-            )
-        else:
-            note = score.GraceNote(
-                grace_type="appoggiatura",
-                step=step,
-                octave=octave,
-                alter=alter,
-                voice=int(voice or 0),
-                id=note_id,
-                symbolic_duration=dict(type="quarter"),
-            )
-
-        part.add(note, onset, onset + duration)
-
-    if not time_sigs:
-        warnings.warn("No time signatures found, assuming 4/4")
-        time_sigs = [(0, 4, 4)]
-
-    time_sigs = np.array(time_sigs, dtype=int)
-
-    # for convenience we add the end times for each time signature
-    ts_end_times = np.r_[time_sigs[1:, 0], np.iinfo(int).max]
-    time_sigs = np.column_stack((time_sigs, ts_end_times))
-
-    warnings.warn("add time sigs and measures", stacklevel=2)
-
-    for ts_start, num, den, ts_end in time_sigs:
-        time_sig = score.TimeSignature(num.item(), den.item())
-        part.add(time_sig, ts_start.item())
-
-    score.add_measures(part)
-
-    # this is the old way to add measures. Since part comes from MIDI we
-    # only have a single global divs value, which makes add it easier to compute
-    # measure durations:
-
-    # measure_counter = 1
-    # # we call item() on numpy numbers to get the value in the equivalent python type
-    # for ts_start, num, den, ts_end in time_sigs:
-    #     time_sig = score.TimeSignature(num.item(), den.item())
-    #     part.add(time_sig, ts_start.item())
-    #     measure_duration = (num.item() * ticks * 4) // den.item()
-    #     measure_start_limit = min(ts_end.item(), part.last_point.t)
-    #     for m_start in range(ts_start, measure_start_limit, measure_duration):
-    #         measure = score.Measure(number=measure_counter)
-    #         m_end = min(m_start+measure_duration, ts_end)
-    #         part.add(measure, m_start, m_end)
-    #         measure_counter += 1
-    #     if np.isinf(ts_end):
-    #         ts_end = m_end
-
-    warnings.warn("tie notes", stacklevel=2)
-    # tie notes where necessary (across measure boundaries, and within measures
-    # notes with compound duration)
-    score.tie_notes(part)
-
-    warnings.warn("find tuplets", stacklevel=2)
-    # apply simplistic tuplet finding heuristic
-    score.find_tuplets(part)
-
-    warnings.warn("done create_part", stacklevel=2)
-    return part
-
-
-def quantize(v, unit):
-    """Quantize value `v` to a multiple of `unit`. When `unit` is an integer,
-    the return value will be integer as well, otherwise the function will
-    return a float.
-
-    Parameters
-    ----------
-    v : ndarray or number
-        Number to be quantized
-    unit : number
-        The quantization unit
-
-    Returns
-    -------
-    number
-        The quantized number
-
-    Examples
-    --------
-    >>> quantize(13.3, 4)
-    12
-    >>> quantize(3.3, .5)
-    3.5
-
-    """
-
-    r = unit * np.round(v / unit)
-    if isinstance(unit, int):
-        return int(r)
-    else:
-        return r
-
-
-if __name__ == "__main__":
-    import doctest
-
-    doctest.testmod()
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for importing MIDI files.
+"""
+import warnings
+
+from collections import defaultdict
+from typing import Union, Optional
+import numpy as np
+
+
+import mido
+
+import partitura.score as score
+import partitura.performance as performance
+from partitura.utils import (
+    estimate_symbolic_duration,
+    key_name_to_fifths_mode,
+    fifths_mode_to_key_name,
+    estimate_clef_properties,
+    deprecated_alias,
+    deprecated_parameter,
+    PathLike,
+    get_document_name,
+    ensure_notearray,
+)
+import partitura.musicanalysis as analysis
+
+__all__ = ["load_score_midi", "load_performance_midi", "midi_to_notearray"]
+
+
+# as key for the dict use channel * 128 (max number of pitches) + pitch
+def note_hash(channel: int, pitch: int) -> int:
+    """Generate a note hash."""
+    return channel * 128 + pitch
+
+
+@deprecated_alias(fn="filename")
+def midi_to_notearray(filename: PathLike) -> np.ndarray:
+    """Load a MIDI file in a note_array.
+
+    This function should be used to load MIDI files into an
+    array of MIDI notes given by onset and duration (in seconds),
+    pitch, velocity, and ID.
+
+    Sustain pedal, program changes, control changes, track and
+    channel information as well as mpq and ppq are discarded.
+
+    Parameters
+    ----------
+    filename : str
+        Path to MIDI file
+    Returns
+    -------
+    np.ndarray :
+        Structured array with onset, duration, pitch, velocity, and
+        ID fields.
+    """
+    perf = load_performance_midi(filename, merge_tracks=True)
+    # set sustain pedal threshold to 128 to disable sustain adjusted offsets
+
+    for ppart in perf:
+        ppart.sustain_pedal_threshold = 128
+
+    note_array = ensure_notearray(perf)
+    return note_array
+
+
+@deprecated_alias(fn="filename")
+def load_performance_midi(
+    filename: Union[PathLike, mido.MidiFile],
+    default_bpm: Union[int, float] = 120,
+    merge_tracks: bool = False,
+) -> performance.Performance:
+    """Load a musical performance from a MIDI file.
+
+    This function should be used for MIDI files that encode
+    performances, such as those obtained from a capture of a MIDI
+    instrument. This function loads note on/off events as well as
+    control events, but ignores other data such as time and key
+    signatures. Furthermore, the PerformedPart instance that the
+    function returns does not retain the ticks_per_beat or tempo
+    events. The timing of all events is represented in seconds. If you
+    wish to retain this information consider using the
+    `load_score_midi` function.
+
+    Parameters
+    ----------
+    filename : str
+        Path to MIDI file
+    default_bpm : number, optional
+        Tempo to use wherever the MIDI does not specify a tempo.
+        Defaults to 120.
+    merge_tracks: bool, optional
+        For MIDI files, merges all tracks into a single track.
+
+    Returns
+    -------
+    :class:`partitura.performance.Performance`
+        A Performance instance.
+    """
+
+    if isinstance(filename, mido.MidiFile):
+        mid = filename
+        doc_name = filename.filename
+    else:
+        mid = mido.MidiFile(filename)
+        doc_name = get_document_name(filename)
+
+    # parts per quarter
+    ppq = mid.ticks_per_beat
+    # microseconds per quarter
+    mpq = 60 * (10**6 / default_bpm)
+
+    # convert MIDI ticks in seconds
+    time_conversion_factor = mpq / (ppq * 10**6)
+
+    pps = list()
+
+    if merge_tracks:
+        mid_merge = mido.merge_tracks(mid.tracks)
+        tracks = [(0, mid_merge)]
+    else:
+        tracks = [(i, u) for i, u in enumerate(mid.tracks)]
+    for i, track in tracks:
+
+        notes = []
+        controls = []
+        programs = []
+
+        t = 0
+        ttick = 0
+
+        sounding_notes = {}
+
+        for msg in track:
+
+            # update time deltas when they arrive
+            t = t + msg.time * time_conversion_factor
+            ttick = ttick + msg.time
+
+            if msg.type == "set_tempo":
+
+                mpq = msg.tempo
+                time_conversion_factor = mpq / (ppq * 10**6)
+
+            elif msg.type == "control_change":
+
+                controls.append(
+                    dict(
+                        time=t,
+                        time_tick=ttick,
+                        number=msg.control,
+                        value=msg.value,
+                        track=i,
+                        channel=msg.channel,
+                    )
+                )
+
+            elif msg.type == "program_change":
+
+                programs.append(
+                    dict(
+                        time=t,
+                        time_tick=ttick,
+                        program=msg.program,
+                        track=i,
+                        channel=msg.channel,
+                    )
+                )
+
+            else:
+
+                note_on = msg.type == "note_on"
+                note_off = msg.type == "note_off"
+
+                if not (note_on or note_off):
+                    continue
+
+                # hash sounding note
+                note = note_hash(msg.channel, msg.note)
+
+                # start note if it's a 'note on' event with velocity > 0
+                if note_on and msg.velocity > 0:
+
+                    # save the onset time and velocity
+                    sounding_notes[note] = (t, ttick, msg.velocity)
+
+                # end note if it's a 'note off' event or 'note on' with velocity 0
+                elif note_off or (note_on and msg.velocity == 0):
+
+                    if note not in sounding_notes:
+                        warnings.warn("ignoring MIDI message %s" % msg)
+                        continue
+
+                    # append the note to the list associated with the channel
+
+                    notes.append(
+                        dict(
+                            # id=f"n{len(notes)}",
+                            midi_pitch=msg.note,
+                            note_on=(sounding_notes[note][0]),
+                            note_on_tick=(sounding_notes[note][1]),
+                            note_off=(t),
+                            note_off_tick=(ttick),
+                            track=i,
+                            channel=msg.channel,
+                            velocity=sounding_notes[note][2],
+                        )
+                    )
+                    # remove hash from dict
+                    del sounding_notes[note]
+
+        # fix note ids so that it is sorted lexicographically
+        # by onset, pitch, offset, channel and track
+        notes.sort(
+            key=lambda x: (
+                x["note_on"],
+                x["midi_pitch"],
+                x["note_off"],
+                x["channel"],
+                x["track"],
+            )
+        )
+
+        # add note id to every note
+        for k, note in enumerate(notes):
+            note["id"] = f"n{k}"
+
+        if len(notes) > 0 or len(controls) > 0 or len(programs) > 0:
+            pp = performance.PerformedPart(
+                notes, controls=controls, programs=programs, ppq=ppq, mpq=mpq, track=i
+            )
+
+            pps.append(pp)
+
+    perf = performance.Performance(
+        id=doc_name,
+        performedparts=pps,
+    )
+    return perf
+
+
+@deprecated_parameter("ensure_list")
+@deprecated_alias(fn="filename")
+def load_score_midi(
+    filename: Union[PathLike, mido.MidiFile],
+    part_voice_assign_mode: Optional[int] = 0,
+    quantization_unit: Optional[int] = None,
+    estimate_voice_info: bool = True,
+    estimate_key: bool = False,
+    assign_note_ids: bool = True,
+) -> score.Score:
+    """Load a musical score from a MIDI file and return it as a Part
+    instance.
+
+    This function interprets MIDI information as describing a score.
+    Pitch names are estimated using Meredith's PS13 algorithm [1]_.
+    Assignment of notes to voices can either be done using Chew and
+    Wu's voice separation algorithm [2]_, or by choosing one of the
+    part/voice assignment modes that assign voices based on
+    track/channel information. Furthermore, the key signature can be
+    estimated based on Krumhansl's 1990 key profiles [3]_.
+
+    This function expects times to be metrical/quantized. Optionally a
+    quantization unit may be specified. If you wish to access the non-
+    quantized time of MIDI events you may wish to used the
+    `load_performance_midi` function instead.
+
+    Parameters
+    ----------
+    filename : PathLike or mido.MidiFile
+        Path to MIDI file or mido.MidiFile object.
+    part_voice_assign_mode : {0, 1, 2, 3, 4, 5}, optional
+        This keyword controls how part and voice information is
+        associated to track and channel information in the MIDI file.
+        The semantics of the modes is as follows:
+
+        0
+            Return one Part per track, with voices assigned by channel
+        1
+            Return one PartGroup per track, with Parts assigned by channel
+            (no voices)
+        2
+            Return single Part with voices assigned by track (tracks are
+            combined, channel info is ignored)
+        3
+            Return one Part per track, without voices (channel info is
+            ignored)
+        4
+            Return single Part without voices (channel and track info is
+            ignored)
+        5
+            Return one Part per <track, channel> combination, without
+            voices  Defaults to 0.
+    quantization_unit : integer or None, optional
+        Quantize MIDI times to multiples of this unit. If None, the
+        quantization unit is chosen automatically as the smallest
+        division of the parts per quarter (MIDI "ticks") that can be
+        represented as a symbolic duration. Defaults to None.
+    estimate_key : bool, optional
+        When True use Krumhansl's 1990 key profiles [3]_ to determine
+        the most likely global key, discarding any key information in
+        the MIDI file.
+    estimate_voice_info : bool, optional
+        When True use Chew and Wu's voice separation algorithm [2]_ to
+        estimate voice information. This option is ignored for
+        part/voice assignment modes that infer voice information from
+        the track/channel info (i.e. `part_voice_assign_mode` equals
+        1, 3, 4, or 5). Defaults to True.
+
+    Returns
+    -------
+    :class:`partitura.score.Part`, :class:`partitura.score.PartGroup`, \
+or a list of these
+        One or more part or partgroup objects
+
+    References
+    ----------
+    .. [1] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
+           of New Music Research, 35(2):121.
+    .. [2] Chew, E. and Wu, Xiaodan (2004) "Separating Voices in
+           Polyphonic Music: A Contig Mapping Approach". In Uffe Kock,
+           editor, Computer Music Modeling and Retrieval (CMMR), pp. 1–20,
+           Springer Berlin Heidelberg.
+    .. [3] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
+           Oxford University Press, New York.
+
+    """
+
+    if isinstance(filename, mido.MidiFile):
+        mid = filename
+        doc_name = filename.filename
+    else:
+        mid = mido.MidiFile(filename)
+        doc_name = get_document_name(filename)
+
+    divs = mid.ticks_per_beat
+
+    # these lists will contain information from dedicated tracks for meta
+    # information (i.e. without notes)
+    global_time_sigs = []
+    global_key_sigs = []
+    global_tempos = []
+
+    # these dictionaries will contain meta information indexed by track (only
+    # for tracks that contain notes)
+    time_sigs_by_track = {}
+    key_sigs_by_track = {}
+    track_names_by_track = {}
+    # notes are indexed by (track, channel) tuples
+    notes_by_track_ch = {}
+    relevant = {"time_signature", "key_signature", "set_tempo", "note_on", "note_off"}
+    for track_nr, track in enumerate(mid.tracks):
+        time_sigs = []
+        key_sigs = []
+        # tempos = []
+        notes = defaultdict(list)
+        # dictionary for storing the last onset time and velocity for each
+        # individual note (i.e. same pitch and channel)
+        sounding_notes = {}
+        # current time (will be updated by delta times in messages)
+        t_raw = 0
+
+        for msg in track:
+
+            t_raw = t_raw + msg.time
+
+            if msg.type not in relevant:
+                continue
+
+            if quantization_unit:
+                t = quantize(t_raw, quantization_unit)
+            else:
+                t = t_raw
+
+            if msg.type == "time_signature":
+                time_sigs.append((t, msg.numerator, msg.denominator))
+            if msg.type == "key_signature":
+                key_sigs.append((t, msg.key))
+            if msg.type == "set_tempo":
+                global_tempos.append((t, 60 * 10**6 / msg.tempo))
+            else:
+                note_on = msg.type == "note_on"
+                note_off = msg.type == "note_off"
+
+                if not (note_on or note_off):
+                    continue
+
+                # hash sounding note
+                note = note_hash(msg.channel, msg.note)
+
+                # start note if it's a 'note on' event with velocity > 0
+                if note_on and msg.velocity > 0:
+
+                    # save the onset time and velocity
+                    sounding_notes[note] = (t, msg.velocity)
+
+                # end note if it's a 'note off' event or 'note on' with velocity 0
+                elif note_off or (note_on and msg.velocity == 0):
+
+                    if note not in sounding_notes:
+                        warnings.warn("ignoring MIDI message %s" % msg)
+                        continue
+
+                    # append the note to the list associated with the channel
+                    notes[msg.channel].append(
+                        (sounding_notes[note][0], msg.note, t - sounding_notes[note][0])
+                    )
+                    # sounding_notes[note][1]])
+                    # remove hash from dict
+                    del sounding_notes[note]
+
+        # if a track has no notes, we assume it may contain global time/key sigs
+        if not notes:
+            global_time_sigs.extend(time_sigs)
+            global_key_sigs.extend(key_sigs)
+        else:
+            # if there are note, we store the info under the track number
+            time_sigs_by_track[track_nr] = time_sigs
+            key_sigs_by_track[track_nr] = key_sigs
+            track_names_by_track[track_nr] = track.name
+
+        for ch, ch_notes in notes.items():
+            # if there are any notes, store the notes along with key sig / time
+            # sig / tempo information under the key (track_nr, ch_nr)
+            if len(ch_notes) > 0:
+                notes_by_track_ch[(track_nr, ch)] = ch_notes
+
+    tr_ch_keys = sorted(notes_by_track_ch.keys())
+    group_part_voice_keys, part_names, group_names = assign_group_part_voice(
+        part_voice_assign_mode, tr_ch_keys, track_names_by_track
+    )
+
+    # for key and time sigs:
+    track_to_part_mapping = make_track_to_part_mapping(
+        tr_ch_keys, group_part_voice_keys
+    )
+
+    # pairs of (part, voice) for each note
+    part_voice_list = [
+        [part, voice]
+        for tr_ch, (_, part, voice) in zip(tr_ch_keys, group_part_voice_keys)
+        for i in range(len(notes_by_track_ch[tr_ch]))
+    ]
+
+    # pitch spelling, voice estimation and key estimation are done on a
+    # structured array (onset, pitch, duration) of all notes in the piece
+    # jointly, so we concatenate all notes
+    # note_list = sorted(note for notes in
+    # (notes_by_track_ch[key] for key in tr_ch_keys) for note in notes)
+    note_list = [
+        note
+        for notes in (notes_by_track_ch[key] for key in tr_ch_keys)
+        for note in notes
+    ]
+    note_array = np.array(
+        note_list,
+        dtype=[("onset_div", int), ("pitch", int), ("duration_div", int)],
+    )
+
+    warnings.warn("pitch spelling")
+    spelling_global = analysis.estimate_spelling(note_array)
+
+    if estimate_voice_info:
+        warnings.warn("voice estimation", stacklevel=2)
+        # TODO: deal with zero duration notes in note_array.
+        # Zero duration notes are currently deleted
+        estimated_voices = analysis.estimate_voices(note_array)
+        assert len(part_voice_list) == len(estimated_voices)
+        for part_voice, voice_est in zip(part_voice_list, estimated_voices):
+            if part_voice[1] is None:
+                part_voice[1] = voice_est
+
+    if estimate_key:
+        warnings.warn("key estimation", stacklevel=2)
+        _, mode, fifths = analysis.estimate_key(note_array)
+        key_sigs_by_track = {}
+        global_key_sigs = [(0, fifths_mode_to_key_name(fifths, mode))]
+
+    if assign_note_ids:
+        note_ids = ["n{}".format(i) for i in range(len(note_array))]
+    else:
+        note_ids = [None for i in range(len(note_array))]
+
+    time_sigs_by_part = defaultdict(set)
+    for tr, ts_list in time_sigs_by_track.items():
+        for ts in ts_list:
+            for part in track_to_part_mapping[tr]:
+                time_sigs_by_part[part].add(ts)
+    for ts in global_time_sigs:
+        for part in set(part for _, part, _ in group_part_voice_keys):
+            time_sigs_by_part[part].add(ts)
+
+    key_sigs_by_part = defaultdict(set)
+    for tr, ks_list in key_sigs_by_track.items():
+        for ks in ks_list:
+            for part in track_to_part_mapping[tr]:
+                key_sigs_by_part[part].add(ks)
+    for ks in global_key_sigs:
+        for part in set(part for _, part, _ in group_part_voice_keys):
+            key_sigs_by_part[part].add(ks)
+
+    # names_by_part = defaultdict(set)
+    # for tr_ch, pg_p_v in zip(tr_ch_keys, group_part_voice_keys):
+    #     print(tr_ch, pg_p_v)
+    # for tr, name in track_names_by_track.items():
+    #     print(tr, track_to_part_mapping, name)
+    #     for part in track_to_part_mapping[tr]:
+    #         names_by_part[part] = name
+
+    notes_by_part = defaultdict(list)
+    for (part, voice), note, spelling, note_id in zip(
+        part_voice_list, note_list, spelling_global, note_ids
+    ):
+        notes_by_part[part].append((note, voice, spelling, note_id))
+
+    partlist = []
+    part_to_part_group = dict((p, pg) for pg, p, _ in group_part_voice_keys)
+    part_groups = {}
+    for part_nr, note_info in notes_by_part.items():
+        notes, voices, spellings, note_ids = zip(*note_info)
+        part = create_part(
+            divs,
+            notes,
+            spellings,
+            voices,
+            note_ids,
+            sorted(time_sigs_by_part[part_nr]),
+            sorted(key_sigs_by_part[part_nr]),
+            part_id="P{}".format(part_nr + 1),
+            part_name=part_names.get(part_nr, None),
+        )
+
+        # print(part.pretty())
+        # if this part has an associated part_group number we create a PartGroup
+        # if necessary, and add the part to that. The newly created PartGroup is
+        # then added to the partlist.
+        pg_nr = part_to_part_group[part_nr]
+        if pg_nr is None:
+            partlist.append(part)
+        else:
+            if pg_nr not in part_groups:
+                part_groups[pg_nr] = score.PartGroup(
+                    group_name=group_names.get(pg_nr, None)
+                )
+                partlist.append(part_groups[pg_nr])
+            part_groups[pg_nr].children.append(part)
+
+    # add tempos to first part
+    part = next(score.iter_parts(partlist))
+    for t, qpm in global_tempos:
+        part.add(score.Tempo(qpm, unit="q"), t)
+
+    # TODO: Add info (composer, etc.)
+    scr = score.Score(
+        id=doc_name,
+        partlist=partlist,
+    )
+
+    return scr
+
+
+def make_track_to_part_mapping(tr_ch_keys, group_part_voice_keys):
+    """Return a mapping from track numbers to one or more parts. This mapping tells
+    us where to put meta event info like time and key sigs.
+    """
+    track_to_part_keys = defaultdict(set)
+    for (tr, _), (_, part, _) in zip(tr_ch_keys, group_part_voice_keys):
+        track_to_part_keys[tr].add(part)
+    return track_to_part_keys
+
+
+def assign_group_part_voice(mode, track_ch_combis, track_names):
+    """
+    0: return one Part per track, with voices assigned by channel
+    1. return one PartGroup per track, with Parts assigned by channel (no voices)
+    2. return single Part with voices assigned by track (tracks are combined,
+       channel info is ignored)
+    3. return one Part per track, without voices (channel info is ignored)
+    4. return single Part without voices (channel and track info is ignored)
+    5. return one Part per <track, channel> combination, without voices
+    """
+    part_group = {}
+    part = {}
+    voice = {}
+    part_helper = {}
+    voice_helper = {}
+    part_group_helper = {}
+
+    part_names = {}
+    group_names = {}
+    for tr, ch in track_ch_combis:
+        if mode == 0:
+            prt = part_helper.setdefault(tr, len(part_helper))
+            vc1 = voice_helper.setdefault(tr, {})
+            vc2 = vc1.setdefault(ch, len(vc1) + 1)
+            part_names[prt] = "{}".format(
+                track_names.get(tr, "Track {}".format(tr + 1))
+            )
+            part[(tr, ch)] = prt
+            voice[(tr, ch)] = vc2
+        elif mode == 1:
+            pg = part_group_helper.setdefault(tr, len(part_group_helper))
+            prt = part_helper.setdefault(ch, len(part_helper))
+            part_group.setdefault((tr, ch), pg)
+            group_names[pg] = track_names.get(tr, "Track {}".format(tr + 1))
+            part_names[prt] = "ch={}".format(ch)
+            part[(tr, ch)] = prt
+        elif mode == 2:
+            vc = voice_helper.setdefault(tr, len(voice_helper) + 1)
+            part.setdefault((tr, ch), 0)
+            voice[(tr, ch)] = vc
+        elif mode == 3:
+            prt = part_helper.setdefault(tr, len(part_helper))
+            part_names[prt] = "{}".format(
+                track_names.get(tr, "Track {}".format(tr + 1))
+            )
+            part[(tr, ch)] = prt
+        elif mode == 4:
+            part.setdefault((tr, ch), 0)
+        elif mode == 5:
+            part_names[(tr, ch)] = "{} ch={}".format(
+                track_names.get(tr, "Track {}".format(tr + 1)), ch
+            )
+            part.setdefault((tr, ch), len(part))
+
+    return (
+        [
+            (part_group.get(tr_ch), part.get(tr_ch), voice.get(tr_ch))
+            for tr_ch in track_ch_combis
+        ],
+        part_names,
+        group_names,
+    )
+
+
+def create_part(
+    ticks,
+    notes,
+    spellings,
+    voices,
+    note_ids,
+    time_sigs,
+    key_sigs,
+    part_id=None,
+    part_name=None,
+) -> score.Part:
+    warnings.warn("create_part", stacklevel=2)
+
+    part = score.Part(part_id, part_name=part_name)
+    part.set_quarter_duration(0, ticks)
+
+    clef = score.Clef(
+        staff=1, **estimate_clef_properties([pitch for _, pitch, _ in notes])
+    )
+    part.add(clef, 0)
+    for t, name in key_sigs:
+        fifths, mode = key_name_to_fifths_mode(name)
+        part.add(score.KeySignature(fifths, mode), t)
+
+    warnings.warn("add notes", stacklevel=2)
+
+    for (onset, pitch, duration), (step, alter, octave), voice, note_id in zip(
+        notes, spellings, voices, note_ids
+    ):
+        if duration > 0:
+            note = score.Note(
+                step=step,
+                octave=octave,
+                alter=alter,
+                voice=int(voice or 0),
+                id=note_id,
+                symbolic_duration=estimate_symbolic_duration(duration, ticks),
+            )
+        else:
+            note = score.GraceNote(
+                grace_type="appoggiatura",
+                step=step,
+                octave=octave,
+                alter=alter,
+                voice=int(voice or 0),
+                id=note_id,
+                symbolic_duration=dict(type="quarter"),
+            )
+
+        part.add(note, onset, onset + duration)
+
+    if not time_sigs:
+        warnings.warn("No time signatures found, assuming 4/4")
+        time_sigs = [(0, 4, 4)]
+
+    time_sigs = np.array(time_sigs, dtype=int)
+
+    # for convenience we add the end times for each time signature
+    ts_end_times = np.r_[time_sigs[1:, 0], np.iinfo(int).max]
+    time_sigs = np.column_stack((time_sigs, ts_end_times))
+
+    warnings.warn("add time sigs and measures", stacklevel=2)
+
+    for ts_start, num, den, ts_end in time_sigs:
+        time_sig = score.TimeSignature(num.item(), den.item())
+        part.add(time_sig, ts_start.item())
+
+    score.add_measures(part)
+
+    # this is the old way to add measures. Since part comes from MIDI we
+    # only have a single global divs value, which makes add it easier to compute
+    # measure durations:
+
+    # measure_counter = 1
+    # # we call item() on numpy numbers to get the value in the equivalent python type
+    # for ts_start, num, den, ts_end in time_sigs:
+    #     time_sig = score.TimeSignature(num.item(), den.item())
+    #     part.add(time_sig, ts_start.item())
+    #     measure_duration = (num.item() * ticks * 4) // den.item()
+    #     measure_start_limit = min(ts_end.item(), part.last_point.t)
+    #     for m_start in range(ts_start, measure_start_limit, measure_duration):
+    #         measure = score.Measure(number=measure_counter)
+    #         m_end = min(m_start+measure_duration, ts_end)
+    #         part.add(measure, m_start, m_end)
+    #         measure_counter += 1
+    #     if np.isinf(ts_end):
+    #         ts_end = m_end
+
+    warnings.warn("tie notes", stacklevel=2)
+    # tie notes where necessary (across measure boundaries, and within measures
+    # notes with compound duration)
+    score.tie_notes(part)
+
+    warnings.warn("find tuplets", stacklevel=2)
+    # apply simplistic tuplet finding heuristic
+    score.find_tuplets(part)
+
+    warnings.warn("done create_part", stacklevel=2)
+    return part
+
+
+def quantize(v, unit):
+    """Quantize value `v` to a multiple of `unit`. When `unit` is an integer,
+    the return value will be integer as well, otherwise the function will
+    return a float.
+
+    Parameters
+    ----------
+    v : ndarray or number
+        Number to be quantized
+    unit : number
+        The quantization unit
+
+    Returns
+    -------
+    number
+        The quantized number
+
+    Examples
+    --------
+    >>> quantize(13.3, 4)
+    12
+    >>> quantize(3.3, .5)
+    3.5
+
+    """
+
+    r = unit * np.round(v / unit)
+    if isinstance(unit, int):
+        return int(r)
+    else:
+        return r
+
+
+if __name__ == "__main__":
+    import doctest
+
+    doctest.testmod()
```

### Comparing `partitura-1.2.1/partitura/io/importmusicxml.py` & `partitura-1.2.2/partitura/io/importmusicxml.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,1566 +1,1641 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for importing MusicXML files.
-"""
-
-import os
-import warnings
-import zipfile
-
-from typing import Union, Optional
-import numpy as np
-from lxml import etree
-
-
-# lxml does XSD validation too but has problems with the MusicXML 3.1 XSD, so we use
-# the xmlschema package for validating MusicXML against the definition
-import xmlschema
-import pkg_resources
-from partitura.directions import parse_direction
-import partitura.score as score
-from partitura.score import assign_note_ids
-from partitura.utils import ensure_notearray
-from partitura.utils.misc import deprecated_alias, deprecated_parameter, PathLike
-
-__all__ = ["load_musicxml", "musicxml_to_notearray"]
-
-_MUSICXML_SCHEMA = pkg_resources.resource_filename("partitura", "assets/musicxml.xsd")
-_XML_VALIDATOR = None
-DYN_DIRECTIONS = {
-    "f": score.ConstantLoudnessDirection,
-    "ff": score.ConstantLoudnessDirection,
-    "fff": score.ConstantLoudnessDirection,
-    "ffff": score.ConstantLoudnessDirection,
-    "fffff": score.ConstantLoudnessDirection,
-    "ffffff": score.ConstantLoudnessDirection,
-    "n": score.ConstantLoudnessDirection,
-    "mf": score.ConstantLoudnessDirection,
-    "mp": score.ConstantLoudnessDirection,
-    "p": score.ConstantLoudnessDirection,
-    "pp": score.ConstantLoudnessDirection,
-    "ppp": score.ConstantLoudnessDirection,
-    "pppp": score.ConstantLoudnessDirection,
-    "ppppp": score.ConstantLoudnessDirection,
-    "pppppp": score.ConstantLoudnessDirection,
-    "fp": score.ImpulsiveLoudnessDirection,
-    "pf": score.ImpulsiveLoudnessDirection,
-    "rf": score.ImpulsiveLoudnessDirection,
-    "rfz": score.ImpulsiveLoudnessDirection,
-    "fz": score.ImpulsiveLoudnessDirection,
-    "sf": score.ImpulsiveLoudnessDirection,
-    "sffz": score.ImpulsiveLoudnessDirection,
-    "sfp": score.ImpulsiveLoudnessDirection,
-    "sfzp": score.ImpulsiveLoudnessDirection,
-    "sfpp": score.ImpulsiveLoudnessDirection,
-    "sfz": score.ImpulsiveLoudnessDirection,
-}
-
-PEDAL_DIRECTIONS = {
-    "sustain_pedal": score.SustainPedalDirection,
-}
-
-
-def validate_musicxml(xml, debug=False):
-    """
-    Validate an XML file against an XSD.
-
-    Parameters
-    ----------
-    xml: str
-        Path to XML file
-    debug: bool, optional
-        If True, raise an exception when the xml is invalid, and print out the
-        cause. Otherwise just return True when the XML is valid and False otherwise
-
-    Returns
-    -------
-    bool or None
-        None if debug=True, True or False otherwise, signalling validity
-
-    """
-    global _XML_VALIDATOR
-    if not _XML_VALIDATOR:
-        _XML_VALIDATOR = xmlschema.XMLSchema(_MUSICXML_SCHEMA)
-    if debug:
-        return _XML_VALIDATOR.validate(xml)
-    else:
-        return _XML_VALIDATOR.is_valid(xml)
-
-
-def _parse_partlist(partlist):
-    """
-    This parses the <part-list> ... </part-list> element in the beginning
-    of the MusicXML file where each instrument is declared, instruments and
-    their staves are grouped (braces, brackets), etc.
-
-    Parameters
-    ----------
-    partlist : etree element
-        The part-list etree element
-
-    Returns
-    -------
-    list:
-        list of PartGroup objects
-    dict:
-        Dictionary of pairs (partid, Part) where the Part objects are
-        instantiated with part-name and part-abbreviation if these are specified in
-        the part list definition.
-    """
-
-    structure = []
-    current_group = None
-    part_dict = {}
-
-    for e in partlist:
-        if e.tag == "part-group":
-            if e.get("type") == "start":
-
-                gr_name = get_value_from_tag(e, "group-name", str)
-                gr_symbol = get_value_from_tag(e, "group-symbol", str)
-                gr_number = get_value_from_attribute(e, "number", int)
-                new_group = score.PartGroup(gr_symbol, gr_name, gr_number)
-
-                if current_group is None:
-                    current_group = new_group
-                else:
-                    current_group.children.append(new_group)
-                    new_group.parent = current_group
-                    current_group = new_group
-
-            elif e.get("type") == "stop":
-                if current_group.parent is None:
-                    structure.append(current_group)
-                    current_group = None
-                else:
-                    current_group = current_group.parent
-
-        elif e.tag == "score-part":
-            part_id = e.get("id")
-            part = score.Part(part_id)
-
-            # set part name and abbreviation if available
-            part.part_name = next(iter(e.xpath("part-name/text()")), None)
-            part.part_abbreviation = next(
-                iter(e.xpath("part-abbreviation/text()")), None
-            )
-
-            part_dict[part_id] = part
-
-            if current_group is None:
-                structure.append(part)
-            else:
-                current_group.children.append(part)
-                part.parent = current_group
-
-    if current_group is not None:
-        warnings.warn("part-group {0} was not ended".format(current_group.number))
-        structure.append(current_group)
-
-    return structure, part_dict
-
-
-@deprecated_alias(xml="filename")
-@deprecated_parameter("ensure_list")
-def load_musicxml(
-        filename: PathLike,
-        validate: bool = False,
-        force_note_ids: Optional[Union[bool, str]] = None
-) -> score.Score:
-    """Parse a MusicXML file and build a composite score ontology
-    structure from it (see also scoreontology.py).
-
-    Parameters
-    ----------
-    xml : str or file-like  object
-        Path to the MusicXML file to be parsed, or a file-like object
-    validate : bool, optional
-        When True the validity of the MusicXML is checked against the
-        MusicXML 3.1 specification before loading the file. An
-        exception will be raised when the MusicXML is invalid.
-        Defaults to False.
-    force_note_ids : (bool, 'keep') optional.
-        When True each Note in the returned Part(s) will have a newly
-        assigned unique id attribute. Existing note id attributes in
-        the MusicXML will be discarded. If 'keep', only notes without
-        a note id will be assigned one.
-
-    Returns
-    -------
-    scr: Score
-        A `Score` instance.
-
-    """
-
-    xml = None
-    if isinstance(filename, str):
-        if zipfile.is_zipfile(filename):
-            with zipfile.ZipFile(filename) as zipped_xml:
-                xml = zipped_xml.open(
-                    os.path.splitext(os.path.basename(filename))[0] + ".xml"
-                )
-
-    if xml is None:
-        xml = filename
-
-    if validate:
-        validate_musicxml(xml, debug=True)
-        # if xml is a file-like object we need to set the read pointer to the
-        # start of the file for parsing
-        if hasattr(xml, "seek"):
-            xml.seek(0)
-
-    parser = etree.XMLParser(
-        resolve_entities=False,
-        huge_tree=False,
-        remove_comments=True,
-        remove_blank_text=True,
-    )
-    document = etree.parse(xml, parser)
-
-    if document.getroot().tag != "score-partwise":
-        raise Exception("Currently only score-partwise structure is supported")
-
-    partlist_el = document.find("part-list")
-
-    if partlist_el is not None:
-        # parse the (hierarchical) structure of score parts
-        # (instruments) that are listed in the part-list element
-        partlist, part_dict = _parse_partlist(partlist_el)
-        # Go through each <part> to obtain the content of the parts.
-        # The Part instances will be modified in place
-        _parse_parts(document, part_dict)
-    else:
-        partlist = []
-
-    if force_note_ids is True or force_note_ids == "keep":
-        assign_note_ids(partlist, force_note_ids == "keep")
-
-    composer = None
-    scid = None
-    title = None
-    subtitle = None
-    lyricist = None
-    copyright = None
-
-    # The work tag is preferred for the title of the score, otherwise
-    # this method will search in the credit tags
-    work_info_el = document.find("work")
-
-    if work_info_el is not None:
-        scid = get_value_from_tag(
-            e=work_info_el,
-            tag="work-title",
-            as_type=str,
-        )
-
-        title = scid
-
-    score_identification_el = document.find("identification")
-
-    # The identification tag has preference over credit
-    if score_identification_el is not None:
-
-        copyright = get_value_from_tag(score_identification_el, "rights", str)
-
-        for cel in score_identification_el.findall("creator"):
-            if get_value_from_attribute(cel, "type", str) == "composer":
-                composer = str(cel.text)
-            if get_value_from_attribute(cel, "type", str) == "lyricist":
-                lyricist = str(cel.text)
-
-    for cel in document.findall("credit"):
-
-        credit_type = get_value_from_tag(cel, "credit-type", str)
-        if credit_type == "title" and title is None:
-            title = get_value_from_tag(cel, "credit-words", str)
-
-        elif credit_type == "subtitle" and subtitle is None:
-            subtitle = get_value_from_tag(cel, "credit-words", str)
-
-        elif credit_type == "composer" and composer is None:
-            composer = get_value_from_tag(cel, "credit-words", str)
-
-        elif credit_type == "lyricist" and lyricist is None:
-            lyricist = get_value_from_tag(cel, "credit-words", str)
-
-        elif credit_type == "rights" and copyright is None:
-            copyright = get_value_from_tag(cel, "credit-words", str)
-
-    scr = score.Score(
-        id=scid,
-        partlist=partlist,
-        title=title,
-        subtitle=subtitle,
-        composer=composer,
-        lyricist=lyricist,
-        copyright=copyright,
-    )
-
-    return scr
-
-
-def _parse_parts(document, part_dict):
-    """
-    Populate the Part instances that are the values of `part_dict` with the
-    musical content in document.
-
-    Parameters
-    ----------
-    document : lxml.etree.ElementTree
-        The ElementTree representation of the MusicXML document
-    part_dict : dict
-        A dictionary with key--value pairs (part_id, Part instance), as returned
-        by the _parse_partlist() function.
-    """
-
-    for part_el in document.findall("part"):
-
-        part_id = part_el.get("id", "P1")
-        part = part_dict.get(part_id, score.Part(part_id))
-
-        position = 0
-        ongoing = {}
-        doc_order = 0
-        # add new page and system at start of part
-        _handle_new_page(position, part, ongoing)
-        _handle_new_system(position, part, ongoing)
-
-        for measure_el in part_el.xpath("measure"):
-            position, doc_order = _handle_measure(
-                measure_el, position, part, ongoing, doc_order
-            )
-
-        # complete unfinished endings
-        for o in part.iter_all(score.Ending, mode="ending"):
-            if o.start is None:
-                part.add(o, part.measure_map(o.end.t - 1)[0], None)
-                warnings.warn(
-                    "Found ending[stop] without a preceding ending[start]\n"
-                    "Single measure bracket is assumed"
-                )
-
-        for o in part.iter_all(score.Ending, mode="starting"):
-            if o.end is None:
-                part.add(o, None, part.measure_map(o.start.t)[1])
-                warnings.warn(
-                    "Found ending[start] without a following ending[stop]\n"
-                    "Single measure bracket is assumed"
-                )
-
-        # Complete repeats without end.
-        volta_repeats = list()
-        for o in part.iter_all(score.Repeat, mode="starting"):
-            if o.end is None:
-                # if len(o.start.starting_objects[score.Repeat]) > 0:
-                #     starting = list(o.start.starting_objects[score.Repeat].keys())[0]
-                #     # if unstarted repeat from volta, continue for now
-                #     if len(starting.end.ending_objects[score.Repeat]) > 0:
-                #         # if repeat from volta, continue for now
-                #         volta_repeats.append(o)
-                #         continue
-                
-                starting_repeats = [r for r in part.iter_all(score.Repeat) if r.start is not None] 
-                end_times = [r.start.t for r in starting_repeats] + [part._points[-1].t]
-                end_time_id = np.searchsorted(end_times, o.start.t+1)
-                part.add(o, None, end_times[end_time_id])
-                warnings.warn(
-                    "Found repeat without end\n"
-                    "Ending point {} is assumed".format(end_times[end_time_id])
-                )
-
-        # complete unstarted repeats
-        volta_repeats = list()
-        for o in part.iter_all(score.Repeat, mode="ending"):
-            if o.start is None:
-                if len(o.end.ending_objects[score.Ending]) > 0:
-                    ending = list(o.end.ending_objects[score.Ending].keys())[0]
-                    # if unstarted repeat from volta, continue for now
-                    if len(ending.start.ending_objects[score.Repeat]) > 0:
-                        volta_repeats.append(o)
-                        continue
-
-                # go back to the end of the last repeat
-                start_times = [0] + [r.end.t for r in part.iter_all(score.Repeat)]
-                start_time_id = np.searchsorted(start_times, o.end.t) - 1
-                part.add(o, start_times[start_time_id], None)
-                warnings.warn(
-                    "Found repeat without start\n"
-                    "Starting point {} is assumed".format(start_times[start_time_id])
-                )
-
-        # complete unstarted repeats in volta with start time of first repeat
-        for o in volta_repeats:
-            start_times = [0] + [r.start.t for r in part.iter_all(score.Repeat)]
-            start_time_id = np.searchsorted(start_times, o.end.t) - 1
-            part.add(o, start_times[start_time_id], None)
-            warnings.warn(
-                "Found repeat without start\n"
-                "Starting point {} is assumed".format(start_times[start_time_id])
-            )
-
-        # remove unfinished elements from the timeline
-        for k, o in ongoing.items():
-            if k not in ("page", "system", "repeat") and k[0] not in ("tie", "ending"):
-                if isinstance(o, list):
-                    for o_i in o:
-                        part.remove(o_i)
-                else:
-                    part.remove(o)
-
-        # check whether all grace notes have a main note
-        for gn in part.iter_all(score.GraceNote):
-            if gn.main_note is None:
-
-                for no in part.iter_all(
-                    score.Note,
-                    include_subclasses=False,
-                    start=gn.start.t,
-                    end=gn.start.t + 1,
-                ):
-                    if no.voice == gn.voice:
-                        gn.last_grace_note_in_seq.grace_next = no
-
-            if gn.main_note is None:
-                warnings.warn(
-                    "grace note without recoverable same voice main note: {}".format(gn)
-                )
-                warnings.warn("might be cadenza notation")
-
-        # set end times for various musical elements that only have a start time
-        # when constructed from MusicXML
-        score.set_end_times(part)
-
-
-def _handle_measure(measure_el, position, part, ongoing, doc_order):
-    """
-    Parse a <measure>...</measure> element, adding it and its contents to the
-    part.
-    """
-    # make a measure object
-    measure = make_measure(measure_el)
-
-    # add the start of the measure to the time line
-    part.add(measure, position)
-
-    # keep track of the position within the measure
-    # measure_pos = 0
-    measure_start = position
-    # keep track of the previous note (in case of <chord>)
-    prev_note = None
-    # used to keep track of the duration of the measure
-    measure_maxtime = measure_start
-    trailing_children = []
-    for i, e in enumerate(measure_el):
-
-        if e.tag == "backup":
-            # <xs:documentation>The backup and forward elements are required
-            # to coordinate multiple voices in one part, including music on
-            # multiple staves. The backup type is generally used to move
-            # between voices and staves. Thus the backup element does not
-            # include voice or staff elements. Duration values should always
-            # be positive, and should not cross measure boundaries or
-            # mid-measure changes in the divisions value.</xs:documentation>
-
-            duration = get_value_from_tag(e, "duration", int) or 0
-            position -= duration
-
-            if position < measure.start.t:
-                warnings.warn(
-                    (
-                        "<backup> crosses measure boundary, adjusting "
-                        "position from {} to {} in Measure {}"
-                    ).format(position, measure.start.t, measure.number)
-                )
-                position = measure.start.t
-
-            # <backup> tags trigger an update of the measure
-            # duration up to the measure position (after the
-            # <backup> has been processed); This has been found to
-            # account for implicit measure durations in
-            # Baerenreiter MusicXML files.
-            measure_maxtime = max(measure_maxtime, position)
-
-        elif e.tag == "forward":
-            duration = get_value_from_tag(e, "duration", int) or 0
-            position += duration
-            measure_maxtime = max(measure_maxtime, position)
-
-        elif e.tag == "attributes":
-            _handle_attributes(e, position, part)
-
-        elif e.tag == "direction":
-            _handle_direction(e, position, part, ongoing)
-
-        elif e.tag == "print":
-            # new-page/new-system occurring anywhere in the measure take effect
-            # at the start of the measure, so we pass measure_start rather than
-            # position
-            _handle_print(e, measure_start, part, ongoing)
-
-        elif e.tag == "sound":
-            _handle_sound(e, position, part)
-
-        elif e.tag == "note":
-            (position, prev_note) = _handle_note(
-                e, position, part, ongoing, prev_note, doc_order
-            )
-            doc_order += 1
-            measure_maxtime = max(measure_maxtime, position)
-
-        elif e.tag == "barline":
-            location = get_value_from_attribute(e, "location", str)
-            if (location is None) or (location == "right"):
-                position_barline = measure_maxtime
-            elif location == "left":
-                position_barline = measure_start
-            else:
-                position_barline = position
-
-            repeat = e.find("repeat")
-            if repeat is not None:
-                _handle_repeat(repeat, position_barline, part, ongoing)
-
-            ending = e.find("ending")
-            if ending is not None:
-                _handle_ending(ending, position_barline, part, ongoing)
-
-            bar_style_e = e.find("bar-style")
-            if bar_style_e is not None:
-                bar_style = score.Barline(bar_style_e.text)
-                part.add(bar_style, position)
-
-            # <!ELEMENT barline (bar-style?, %editorial;, wavy-line?,
-            #     segno?, coda?, (fermata, fermata?)?, ending?, repeat?)>
-            # <!ATTLIST barline
-            #     location (right | left | middle) "right"
-            #     segno CDATA #IMPLIED
-            #     coda CDATA #IMPLIED
-            #     divisions CDATA #IMPLIED
-
-            fermata_e = e.find("fermata")
-            if fermata_e is not None:
-                location = e.get("location")
-                fermata = score.Fermata(location)
-                if location is None:
-                    # missing location attribute on barline defaults to
-                    # "right". In this case the barline should occur as the last
-                    # element in the measure
-                    trailing_children.append(fermata)
-                else:
-                    part.add(fermata, position)
-
-            # TODO: handle segno/fine/dacapo
-
-        else:
-            warnings.warn("ignoring tag {0}".format(e.tag), stacklevel=2)
-
-    for obj in trailing_children:
-        part.add(obj, measure_maxtime)
-
-    # add end time of measure
-    part.add(measure, None, measure_maxtime)
-
-    return measure_maxtime, doc_order
-
-
-def _handle_repeat(e, position, part, ongoing):
-    key = "repeat"
-
-    if e.get("direction") == "forward":
-
-        o = score.Repeat()
-        ongoing[key] = o
-        part.add(o, position)
-
-    elif e.get("direction") == "backward":
-
-        o = ongoing.pop(key, None)
-
-        if o is None:
-            # implicit repeat start: create Repeat
-            # object and add it at the beginning of
-            # the self retroactively
-            o = score.Repeat()
-            # no, clean up later with shortest possible repeat start
-            # part.add(o, 0)
-
-        part.add(o, None, position)
-
-
-def _handle_ending(e, position, part, ongoing):
-    # key = "ending"
-    key = ("ending", getattr(e, "number", "0"))
-
-    if e.get("type") == "start":
-
-        o = score.Ending(e.get("number"))
-        ongoing[key] = o
-        part.add(o, position)
-
-    elif e.get("type") in ("stop", "discontinue"):
-
-        o = ongoing.pop(key, None)
-
-        if o is None:
-
-            warnings.warn(
-                "Found ending[stop] without a preceding ending[start]\n"
-                + "Single measure bracket is assumed"
-            )
-            o = score.Ending(e.get("number"))
-            part.add(o, None, position)
-
-        else:
-
-            part.add(o, None, position)
-
-
-def _handle_new_page(position, part, ongoing):
-    if "page" in ongoing:
-        if position == 0:
-            # ignore non-informative new-page at start of score
-            return
-
-        part.add(ongoing["page"], None, position)
-        page_nr = ongoing["page"].number + 1
-    else:
-        page_nr = 1
-
-    page = score.Page(page_nr)
-    part.add(page, position)
-    ongoing["page"] = page
-
-
-def _handle_new_system(position, part, ongoing):
-    if "system" in ongoing:
-
-        if position == 0:
-            # ignore non-informative new-system at start of score
-            return
-
-        # end current page
-        part.add(ongoing["system"], None, position)
-        system_nr = ongoing["system"].number + 1
-    else:
-        system_nr = 1
-
-    system = score.System(system_nr)
-    part.add(system, position)
-    ongoing["system"] = system
-
-
-def make_measure(xml_measure):
-    measure = score.Measure()
-    # try:
-    #     measure.number = int(xml_measure.attrib['number'])
-    # except:
-    #     LOGGER.warn('No number attribute found for measure')
-    measure.number = get_value_from_attribute(xml_measure, "number", int)
-    return measure
-
-
-def _handle_attributes(e, position, part):
-    """"""
-
-    ts_num = get_value_from_tag(e, "time/beats", int)
-    ts_den = get_value_from_tag(e, "time/beat-type", int)
-    if ts_num and ts_den:
-        part.add(score.TimeSignature(ts_num, ts_den), position)
-
-    fifths = get_value_from_tag(e, "key/fifths", int)
-    mode = get_value_from_tag(e, "key/mode", str)
-    if fifths is not None or mode is not None:
-        part.add(score.KeySignature(fifths, mode), position)
-
-    diat = get_value_from_tag(e, "transpose/diatonic", int)
-    chrom = get_value_from_tag(e, "transpose/chromatic", int)
-    if diat is not None or chrom is not None:
-        part.add(score.Transposition(diat, chrom), position)
-
-    divs = get_value_from_tag(e, "divisions", int)
-    if divs:
-        # part.add(score.Divisions(divs), position)
-        part.set_quarter_duration(position, divs)
-
-    clefs = get_clefs(e)
-    for clef in clefs:
-        part.add(score.Clef(**clef), position)
-
-
-def get_offset(e):
-    offset = e.find("offset")
-
-    if offset is None:
-
-        return None
-
-    else:
-
-        sounding = offset.attrib.get("sound", "no")
-        return int(offset.text) if sounding == "yes" else 0
-
-
-def _handle_direction(e, position, part, ongoing):
-
-    # <!--
-    #     A direction is a musical indication that is not attached
-    #     to a specific note. Two or more may be combined to
-    #     indicate starts and stops of wedges, dashes, etc.
-
-    #     By default, a series of direction-type elements and a
-    #     series of child elements of a direction-type within a
-    #     single direction element follow one another in sequence
-    #     visually. For a series of direction-type children, non-
-    #     positional formatting attributes are carried over from
-    #     the previous element by default.
-    # -->
-    # <!ELEMENT direction (direction-type+, offset?,
-    #     %editorial-voice;, staff?, sound?)>
-    # <!ATTLIST direction
-    #     %placement;
-    #     %direction;
-    # >
-
-    staff = get_value_from_tag(e, "staff", int) or None
-
-    sound_directions = e.findall("sound")
-    for sd in sound_directions:
-
-        if get_value_from_attribute(sd, "fine", str) == "yes":
-            part.add(score.Fine(), position)
-        if get_value_from_attribute(sd, "dacapo", str) == "yes":
-            part.add(score.DaCapo(), position)
-        if get_value_from_attribute(sd, "tocoda", str) == "coda":
-            part.add(score.ToCoda(), position)
-        if get_value_from_attribute(sd, "coda", str) == "coda":
-            part.add(score.Coda(), position)
-        if get_value_from_attribute(sd, "dalsegno", str) == "segno":
-            part.add(score.DalSegno(), position)
-        if get_value_from_attribute(sd, "segno", str) == "segno":
-            part.add(score.Segno(), position)
-
-    # <direction-type> ... </...>
-    direction_types = e.findall("direction-type")
-    # <!ELEMENT direction-type (rehearsal+ | segno+ | words+ |
-    #     coda+ | wedge | dynamics+ | dashes | bracket | pedal |
-    #     metronome | octave-shift | harp-pedals | damp | damp-all |
-    #     eyeglasses | string-mute | scordatura | image |
-    #     principal-voice | accordion-registration | percussion+ |
-    #     other-direction)>
-
-    # direction-types supported here:
-    # * words
-    # * wedge
-    # * dynamics
-    # * dashes
-    # * coda
-    # * TODO: pedal
-    # * TODO: damp
-
-    # here we gather all starting and ending directions,
-    # to be added to the part afterwards
-    starting_directions = []
-    ending_directions = []
-
-    # keep track of starting and stopping dashes
-    dashes_keys = {}
-
-    # keep track of starting and stopping pedals
-    # pedal_keys = {}
-
-    for direction_type in direction_types:
-        # direction_type
-        dt = next(iter(direction_type))
-
-        if dt.tag == "dynamics":
-            # first child of direction-type is dynamics, there may be subsequent
-            # dynamics items, so we loop:
-            for child in direction_type:
-                # interpret as score.Direction, fall back to score.Words
-                dyn_el = next(iter(child))
-                if dyn_el is not None:
-                    direction = DYN_DIRECTIONS.get(dyn_el.tag, score.Words)(
-                        dyn_el.tag, staff=staff
-                    )
-                    starting_directions.append(direction)
-
-        elif dt.tag == "words":
-            # first child of direction-type is words, there may be subsequent
-            # words items, so we loop:
-            for child in direction_type:
-
-                # try to make a direction out of words
-                parse_result = parse_direction(child.text)
-                starting_directions.extend(parse_result)
-
-        elif dt.tag == "wedge":
-
-            number = get_value_from_attribute(dt, "number", int) or 1
-            key = ("wedge", number)
-            wedge_type = get_value_from_attribute(dt, "type", str)
-
-            if wedge_type in ("crescendo", "diminuendo"):
-                if wedge_type == "crescendo":
-                    o = score.IncreasingLoudnessDirection(wedge_type, wedge=True)
-                else:
-                    o = score.DecreasingLoudnessDirection(wedge_type, wedge=True)
-                starting_directions.append(o)
-                ongoing[key] = o
-
-            elif wedge_type == "stop":
-
-                o = ongoing.get(key)
-                if o is not None:
-                    ending_directions.append(o)
-                    del ongoing[key]
-                else:
-                    warnings.warn("Did not find a wedge start element for wedge stop!")
-
-        elif dt.tag == "dashes":
-
-            # start/stop/continue
-            dashes_type = get_value_from_attribute(dt, "type", str)
-            number = get_value_from_attribute(dt, "number", int) or 1
-            dashes_keys[("dashes", number)] = dashes_type
-            # TODO: for now we ignore dashes_type == continue, because it exists
-            # only as a function of the visual appearance. However, if dashes
-            # that are continued over a system are stopped at the end of the
-            # system before they are continued at the start of the next, this
-            # will not be treated correctly. I'm not sure how dashes spanning
-            # systems are encoded in practice (need examples).
-
-        elif dt.tag == "pedal":
-
-            # start/stop
-            pedal_type = get_value_from_attribute(dt, "type", str)
-            pedal_line = get_value_from_attribute(dt, "line", str) == "yes"
-
-            number = get_value_from_attribute(dt, "number", int) or 1
-            key = ("pedal", number)
-            if pedal_type == "start":
-                if key in ongoing:
-                    eo = ongoing.pop(key)
-                    ending_directions.append(eo)
-
-                o = score.SustainPedalDirection(staff=staff, line=pedal_line)
-
-                starting_directions.append(o)
-
-                ongoing[key] = o
-
-            elif pedal_type == "stop":
-
-                o = ongoing.get(key)
-                if o is not None:
-                    ending_directions.append(o)
-                    del ongoing[key]
-
-                else:
-                    warnings.warn("Did not find a pedal start element for pedal stop!")
-
-            else:
-                if pedal_type in ("change", "continue"):
-                    warnings.warn(
-                        'pedal types "change" and "continue" are '
-                        "not supported. Ignoring direction."
-                    )
-
-        else:
-            warnings.warn("ignoring direction type: {} {}".format(dt.tag, dt.attrib))
-
-    for dashes_key, dashes_type in dashes_keys.items():
-
-        if dashes_type == "start":
-
-            ongoing[dashes_key] = starting_directions
-
-        elif dashes_type == "stop":
-
-            oo = ongoing.get(dashes_key)
-            if oo is None:
-                warnings.warn("Dashes end without dashes start")
-            else:
-                ending_directions.extend(oo)
-                del ongoing[dashes_key]
-
-    for o in starting_directions:
-        if isinstance(o, score.Tempo):
-            _add_tempo_if_unique(position, part, o)
-        else:
-            part.add(o, position)
-
-    for o in ending_directions:
-        part.add(o, None, position)
-
-
-def get_clefs(e):
-    """
-    Get the clefs
-
-    Returns
-    -------
-
-    (fifths, mode) OR None : tuple of or None.
-
-    """
-    clefs = e.xpath("clef")
-    result = []
-    for clef in clefs:
-        result.append(
-            dict(
-                staff=get_value_from_attribute(clef, "number", int) or 1,
-                sign=get_value_from_tag(clef, "sign", str),
-                line=get_value_from_tag(clef, "line", int),
-                octave_change=get_value_from_tag(clef, "clef-octave-change", int),
-            )
-        )
-    return result
-
-
-def get_value_from_tag(e, tag, as_type, none_on_error=True):
-    """
-    Return the text contents of a particular tag in element e, cast as a
-    particular type. By default the function will return None if either the tag
-    is not found or the value cannot be cast to the desired type.
-
-    Examples
-    --------
-
-    >>> e = lxml.etree.fromstring('<note><duration>2</duration></note>')
-    >>> get_value_from_tag(e, 'duration', int)
-    2
-    >>> get_value_from_tag(e, 'duration', float)
-    2.0
-
-    >>> e = lxml.etree.fromstring('<note><duration>quarter</duration></note>')
-    >>> get_value_from_tag(e, 'duration', float)
-    None
-
-
-    Parameters
-    ----------
-    e: etree.Element
-        An etree Element instance
-    tag: string
-        Child tag to retrieve
-    as_type: function
-        Function that casts the string to the desired type (e.g. int, float)
-    none_on_error: bool, optional (default: True)
-        When False, an exception is raised when `tag` is not found in `e` or the
-        text inside `tag` cannot be cast to an integer. When True, None is returned
-        in such cases.
-
-    Returns
-    -------
-    object
-        The value read from `tag`, cast as `as_type`
-    """
-    try:
-        return as_type(e.find(tag).text)
-    except (ValueError, AttributeError):
-        if none_on_error:
-            return None
-        else:
-            raise
-
-
-def get_value_from_attribute(e, attr, as_type, none_on_error=True):
-    """
-    Return the attribute of a particular attribute of element e, cast as a
-    particular type. By default the function will return None if either `e` does
-    not have the attribute or the value cannot be cast to the desired type.
-
-    Parameters
-    ----------
-    e: etree.Element
-        An etree Element instance
-    attr: string
-        Attribute to retrieve
-    as_type: function
-        Function that casts the string to the desired type (e.g. int, float)
-    none_on_error: bool, optional (default: True)
-        When False, an exception is raised when `tag` is not found in `e` or the
-        text inside `tag` cannot be cast to an integer. When True, None is returned
-        in such cases.
-
-    Returns
-    -------
-    object or None
-        The attribute value, or None
-    """
-
-    value = e.get(attr)
-    if value is None:
-        return None
-    else:
-        try:
-            return as_type(value)
-        except ValueError:
-            if none_on_error:
-                return None
-            else:
-                raise
-
-
-def get_pitch(e):
-    """
-    Check whether the element has a pitch. If so return a tuple (pitch, alter,
-    octave), otherwise return None.
-
-    Returns
-    -------
-    tuple : (str, int or None, int) or None
-        The tuple contains (pitch, alter, octave)
-    """
-
-    pitch = e.find("pitch")
-    if pitch is not None:
-        step = get_value_from_tag(pitch, "step", str)
-        alter = get_value_from_tag(pitch, "alter", int)
-        octave = get_value_from_tag(pitch, "octave", int)
-        return (step, alter, octave)
-    else:
-        return None
-
-
-def _handle_print(e, position, part, ongoing):
-    if "new-page" in e.attrib:
-        _handle_new_page(position, part, ongoing)
-        _handle_new_system(position, part, ongoing)
-    if "new-system" in e.attrib:
-        _handle_new_system(position, part, ongoing)
-
-
-def _add_tempo_if_unique(position, part, tempo):
-    """
-    Add score.Tempo object `tempo` at `position` on `part` if and only if
-    there are no starting score.Tempo objects at that position. score.Tempo
-    objects are generated by <sound tempo=...> as well as textual directions
-    (e.g. "q=100"). This function avoids multiple synchronous tempo indications
-    (whether redundant or conflicting)
-    """
-    point = part.get_point(position)
-    if point is not None:
-        tempos = point.starting_objects.get(score.Tempo, [])
-        if tempos == []:
-            part.add(tempo, position)
-        else:
-            warnings.warn("not adding duplicate or conflicting tempo indication")
-
-
-def _handle_sound(e, position, part):
-    if "tempo" in e.attrib:
-        tempo = score.Tempo(int(e.attrib["tempo"]), "q")
-        # part.add_starting_object(position, tempo)
-        _add_tempo_if_unique(position, part, tempo)
-
-
-def _handle_note(e, position, part, ongoing, prev_note, doc_order):
-
-    # get some common features of element if available
-    duration = get_value_from_tag(e, "duration", int) or 0
-    # elements may have an explicit temporal offset
-    # offset = get_value_from_tag(e, 'offset', int) or 0
-    staff = get_value_from_tag(e, "staff", int) or 1
-    voice = get_value_from_tag(e, "voice", int) or 1
-
-    # add support of uppercase "ID" tags
-    note_id = (
-        get_value_from_attribute(e, "id", str)
-        if get_value_from_attribute(e, "id", str)
-        else get_value_from_attribute(e, "ID", str)
-    )
-
-    symbolic_duration = {}
-    dur_type = get_value_from_tag(e, "type", str)
-    if dur_type:
-        symbolic_duration["type"] = dur_type
-
-    dots = len(e.findall("dot"))
-    if dots:
-        symbolic_duration["dots"] = dots
-
-    actual_notes = get_value_from_tag(e, "time-modification/actual-notes", int)
-    if actual_notes:
-        symbolic_duration["actual_notes"] = actual_notes
-
-    normal_notes = get_value_from_tag(e, "time-modification/normal-notes", int)
-    if normal_notes:
-        symbolic_duration["normal_notes"] = normal_notes
-
-    chord = e.find("chord")
-    if chord is not None:
-        # this note starts at the same position as the previous note, and has
-        # same duration
-        assert prev_note is not None
-        position = prev_note.start.t
-
-    articulations_e = e.find("notations/articulations")
-    if articulations_e is not None:
-        articulations = get_articulations(articulations_e)
-    else:
-        articulations = {}
-
-    ornaments_e = e.find("notations/ornaments")
-    if ornaments_e is not None:
-        ornaments = get_ornaments(ornaments_e)
-    else:
-        ornaments = {}
-
-    pitch = e.find("pitch")
-    unpitch = e.find("unpitched")
-    if pitch is not None:
-
-        step = get_value_from_tag(pitch, "step", str)
-        alter = get_value_from_tag(pitch, "alter", int)
-        octave = get_value_from_tag(pitch, "octave", int)
-
-        grace = e.find("grace")
-
-        if grace is not None:
-            grace_type, steal_proportion = get_grace_info(grace)
-            note = score.GraceNote(
-                grace_type=grace_type,
-                step=step,
-                octave=octave,
-                alter=alter,
-                id=note_id,
-                voice=voice,
-                staff=staff,
-                symbolic_duration=symbolic_duration,
-                articulations=articulations,
-                ornaments=ornaments,
-                steal_proportion=steal_proportion,
-                doc_order=doc_order,
-            )
-            if isinstance(prev_note, score.GraceNote) and prev_note.voice == voice:
-                note.grace_prev = prev_note
-        else:
-            note = score.Note(
-                step=step,
-                octave=octave,
-                alter=alter,
-                id=note_id,
-                voice=voice,
-                staff=staff,
-                symbolic_duration=symbolic_duration,
-                articulations=articulations,
-                ornaments=ornaments,
-                doc_order=doc_order,
-            )
-
-        if isinstance(prev_note, score.GraceNote) and prev_note.voice == voice:
-            prev_note.grace_next = note
-
-    elif unpitch is not None:
-        # note element is unpitched
-        step = get_value_from_tag(unpitch, "display-step", str)
-        octave = get_value_from_tag(unpitch, "display-octave", int)
-        noteheadtag = e.find("notehead")
-        noteheadstylebool = True
-        notehead = None
-        if noteheadtag is not None:
-            notehead = get_value_from_tag(e, "notehead", str)
-            noteheadstyle = get_value_from_attribute(noteheadtag, "filled", str)
-            if noteheadstyle is not None:
-                noteheadstylebool = {"no": False, "yes": True}[noteheadstyle]
-
-        note = score.UnpitchedNote(
-            step=step,
-            octave=octave,
-            id=note_id,
-            voice=voice,
-            staff=staff,
-            notehead=notehead,
-            noteheadstyle=noteheadstylebool,
-            articulations=articulations,
-            symbolic_duration=symbolic_duration,
-            doc_order=doc_order,
-        )
-
-    else:
-        # note element is a rest
-        note = score.Rest(
-            id=note_id,
-            voice=voice,
-            staff=staff,
-            symbolic_duration=symbolic_duration,
-            articulations=articulations,
-            doc_order=doc_order,
-        )
-
-    part.add(note, position, position + duration)
-
-    ties = e.findall("tie")
-    if len(ties) > 0:
-
-        tie_key = ("tie", getattr(note, "midi_pitch", "rest"))
-        tie_types = set(tie.attrib["type"] for tie in ties)
-
-        if "stop" in tie_types:
-
-            tie_prev = ongoing.get(tie_key, None)
-
-            if tie_prev:
-
-                note.tie_prev = tie_prev
-                tie_prev.tie_next = note
-                del ongoing[tie_key]
-
-        if "start" in tie_types:
-
-            ongoing[tie_key] = note
-
-    notations = e.find("notations")
-
-    if notations is not None:
-
-        if notations.find("fermata") is not None:
-
-            fermata = score.Fermata(note)
-            part.add(fermata, position)
-            note.fermata = fermata
-
-        starting_slurs, stopping_slurs = handle_slurs(
-            notations, ongoing, note, position
-        )
-
-        for slur in starting_slurs:
-
-            part.add(slur, position)
-
-        for slur in stopping_slurs:
-
-            part.add(slur, end=position + duration)
-
-        starting_tups, stopping_tups = handle_tuplets(notations, ongoing, note)
-
-        for tup in starting_tups:
-
-            part.add(tup, position)
-
-        for tup in stopping_tups:
-
-            part.add(tup, end=position + duration)
-
-    new_position = position + duration
-
-    return new_position, note
-
-
-def handle_tuplets(notations, ongoing, note):
-    starting_tuplets = []
-    stopping_tuplets = []
-    tuplets = notations.findall("tuplet")
-
-    # this sorts all found tuplets by type (either 'start' or 'stop')
-    # in reverse order, so all with type 'stop' will be before
-    # the ones with 'start'?!.
-    tuplets.sort(key=lambda x: x.attrib["type"], reverse=True)
-
-    # Now that the tuplets are sorted by their type, sort them
-    # by their numbers; First note that tuplets do not always
-    # have a number attribute, then 1 is implied.
-    tuplets.sort(
-        key=lambda x: get_value_from_attribute(x, "number", int) or note.voice or 1
-    )
-
-    for tuplet_e in tuplets:
-
-        tuplet_number = get_value_from_attribute(tuplet_e, "number", int) or note.voice
-        tuplet_type = get_value_from_attribute(tuplet_e, "type", str)
-        start_tuplet_key = ("start_tuplet", tuplet_number)
-        stop_tuplet_key = ("stop_tuplet", tuplet_number)
-
-        if tuplet_type == "start":
-
-            # check if we have a stopped_tuplet in ongoing that corresponds to
-            # this start
-            tuplet = ongoing.pop(stop_tuplet_key, None)
-
-            if tuplet is None:
-
-                tuplet = score.Tuplet(note)
-                ongoing[start_tuplet_key] = tuplet
-
-            else:
-
-                tuplet.start_note = note
-
-            starting_tuplets.append(tuplet)
-
-        elif tuplet_type == "stop":
-
-            tuplet = ongoing.pop(start_tuplet_key, None)
-            if tuplet is None:
-                # tuplet stop occurs before tuplet start in document order, that
-                # is a valid scenario
-                tuplet = score.Tuplet(None, note)
-                ongoing[stop_tuplet_key] = tuplet
-            else:
-                tuplet.end_note = note
-
-            stopping_tuplets.append(tuplet)
-
-    return starting_tuplets, stopping_tuplets
-
-
-def handle_slurs(notations, ongoing, note, position):
-    # we need position here to check for erroneous slurs: sometimes a slur stop
-    # is encountered before the corresponding slur start. This is a valid use
-    # case (e.g. slur starts in staff 2 and ends in staff 1). However, if the
-    # stop is before the start in time, then it is just a MusicXML encoding
-    # error.
-
-    starting_slurs = []
-    stopping_slurs = []
-    slurs = notations.findall("slur")
-
-    # this sorts all found slurs by type (either 'start' or 'stop')
-    # in reverse order, so all with type 'stop' will be before
-    # the ones with 'start'?!.
-    slurs.sort(key=lambda x: x.attrib["type"], reverse=True)
-
-    # Now that the slurs are sorted by their type, sort them
-    # by their numbers; First note that slurs do not always
-    # have a number attribute, then 1 is implied.
-    slurs.sort(
-        key=lambda x: get_value_from_attribute(x, "number", int) or note.voice or 1
-    )
-
-    for slur_e in slurs:
-
-        slur_number = get_value_from_attribute(slur_e, "number", int) or note.voice
-        slur_type = get_value_from_attribute(slur_e, "type", str)
-        start_slur_key = ("start_slur", slur_number)
-        stop_slur_key = ("stop_slur", slur_number)
-
-        if slur_type == "start":
-
-            # check if we have a stopped_slur in ongoing that corresponds to
-            # this stop
-            slur = ongoing.pop(stop_slur_key, None)
-
-            # if slur.end_note.start.t < position then the slur stop is
-            # rogue. We drop it and treat the slur start like a fresh start
-            if slur is None or slur.end_note.start.t < position:
-
-                if slur and slur.end_note.start.t < position:
-                    msg = (
-                        "Dropping slur {} starting at {} ({}) and ending "
-                        "at {} ({})".format(
-                            slur_number,
-                            position,
-                            note.id,
-                            slur.end_note.start.t,
-                            slur.end_note.id,
-                        )
-                    )
-                    warnings.warn(msg)
-                    # remove the slur from the timeline
-                    slur.end_note.start.remove_ending_object(slur)
-                    # remove the reference to the slur in the end note
-                    slur.end_note.slur_stops.remove(slur)
-
-                slur = score.Slur(note)
-                ongoing[start_slur_key] = slur
-
-            else:
-
-                slur.start_note = note
-
-            starting_slurs.append(slur)
-
-        elif slur_type == "stop":
-
-            slur = ongoing.pop(start_slur_key, None)
-
-            if slur is None or slur.start_note.start.t > position:
-
-                if slur and slur.start_note.start.t > position:
-                    msg = (
-                        "Dropping slur {} starting at {} ({}) and ending "
-                        "at {} ({})".format(
-                            slur_number,
-                            slur.start_note.start.t,
-                            slur.start_note.id,
-                            position,
-                            note.id,
-                        )
-                    )
-                    warnings.warn(msg)
-                    # remove the slur from the timeline
-                    slur.start_note.start.remove_starting_object(slur)
-                    # remove the reference to the slur in the end note
-                    slur.start_note.slur_starts.remove(slur)
-
-                # slur stop occurs before slur start in document order, that
-                # is a valid scenario
-                slur = score.Slur(None, note)
-                ongoing[stop_slur_key] = slur
-
-            else:
-
-                slur.end_note = note
-
-            stopping_slurs.append(slur)
-
-    return starting_slurs, stopping_slurs
-
-
-def get_grace_info(grace):
-    # grace note handling
-    grace_type = "grace"
-    steal_proportion = None
-
-    slash_text = get_value_from_attribute(grace, "slash", str)
-    if slash_text == "yes":
-        grace_type = "acciaccatura"
-
-    steal_prc = get_value_from_attribute(grace, "steal-time-following", float)
-    if steal_prc is not None:
-        steal_proportion = steal_prc / 100
-        grace_type = "appoggiatura"
-
-    steal_prc = get_value_from_attribute(grace, "steal-time-previous", float)
-    if steal_prc is not None:
-        steal_proportion = steal_prc / 100
-        grace_type = "acciaccatura"
-
-    return grace_type, steal_proportion
-
-
-def get_articulations(e):
-    # <!ELEMENT articulations
-    # 	((accent | strong-accent | staccato | tenuto |
-    # 	  detached-legato | staccatissimo | spiccato |
-    # 	  scoop | plop | doit | falloff | breath-mark |
-    # 	  caesura | stress | unstress | soft-accent |
-    # 	  other-articulation)*)>
-    articulations = (
-        "accent",
-        "strong-accent",
-        "staccato",
-        "tenuto",
-        "detached-legato",
-        "staccatissimo",
-        "spiccato",
-        "scoop",
-        "plop",
-        "doit",
-        "falloff",
-        "breath-mark",
-        "caesura",
-        "stress",
-        "unstress",
-        "soft-accent",
-    )
-    return [a for a in articulations if e.find(a) is not None]
-
-
-def get_ornaments(e):
-    #  ornaments elements:
-    #  trill-mark
-    #  turn
-    #  delayed-turn
-    #  inverted-turn
-    #  delayed-inverted-turn
-    #  vertical-turn
-    #  inverted-vertical-turn
-    #  shake
-    #  wavy-line
-    #  mordent
-    #  inverted-mordent
-    #  schleifer
-    #  tremolo
-    #  haydn
-    #  other-ornament
-
-    ornaments = (
-        "trill-mark",
-        "turn",
-        "delayed-turn",
-        "inverted-turn",
-        "delayed-inverted-turn",
-        "vertical-turn",
-        "inverted-vertical-turn",
-        "shake",
-        "wavy-line",
-        "mordent",
-        "inverted-mordent",
-        "schleifer",
-        "tremolo",
-        "haydn",
-        "other-ornament",
-    )
-    return [a for a in ornaments if e.find(a) is not None]
-
-
-@deprecated_alias(fn="filename")
-def musicxml_to_notearray(
-    filename,
-    flatten_parts=True,
-    include_pitch_spelling=False,
-    include_key_signature=False,
-    include_time_signature=False,
-):
-    """Return pitch, onset, and duration information for notes from a
-    MusicXML file as a structured array.
-
-    By default a single array is returned by combining the note
-    information of all parts in the MusicXML file.
-
-    Parameters
-    ----------
-    fn : str
-        Path to a MusicXML file
-    flatten_parts : bool
-        If `True`, returns a single array containing all notes.
-        Otherwise, returns a list of arrays for each part.
-    include_pitch_spelling : bool (optional)
-        If `True`, includes pitch spelling information for each
-        note. Default is False
-    include_key_signature : bool (optional)
-        If `True`, includes key signature information, i.e.,
-        the key signature at the onset time of each note (all
-        notes starting at the same time have the same key signature).
-        Default is False
-    include_time_signature : bool (optional)
-        If `True`,  includes time signature information, i.e.,
-        the time signature at the onset time of each note (all
-        notes starting at the same time have the same time signature).
-        Default is False
-
-    Returns
-    -------
-    note_arrays : structured array or list of structured arrays
-        Structured array or list of structured arrays containing
-        score information.
-    """
-
-    scr = load_musicxml(
-        filename=filename,
-        force_note_ids="keep",
-    )
-
-    note_arrays = []
-    for part in scr.parts:
-        # Unfold any repetitions in part
-        unfolded_part = score.unfold_part_maximal(part)
-        # Compute note array
-        note_array = ensure_notearray(
-            notearray_or_part=unfolded_part,
-            include_pitch_spelling=include_pitch_spelling,
-            include_key_signature=include_key_signature,
-            include_time_signature=include_time_signature,
-        )
-        note_arrays.append(note_array)
-
-    if len(note_arrays) == 1:
-        return note_arrays[0]
-    elif len(note_arrays) > 1 and flatten_parts:
-        return np.hstack(note_arrays)
-    else:
-        return note_arrays
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for importing MusicXML files.
+"""
+
+import os
+import warnings
+import zipfile
+
+from typing import Union, Optional
+import numpy as np
+from lxml import etree
+
+
+# lxml does XSD validation too but has problems with the MusicXML 3.1 XSD, so we use
+# the xmlschema package for validating MusicXML against the definition
+import xmlschema
+import pkg_resources
+from partitura.directions import parse_direction
+import partitura.score as score
+from partitura.score import assign_note_ids
+from partitura.utils import ensure_notearray
+from partitura.utils.misc import deprecated_alias, deprecated_parameter, PathLike
+
+__all__ = ["load_musicxml", "musicxml_to_notearray"]
+
+_MUSICXML_SCHEMA = pkg_resources.resource_filename("partitura", "assets/musicxml.xsd")
+_XML_VALIDATOR = None
+DYN_DIRECTIONS = {
+    "f": score.ConstantLoudnessDirection,
+    "ff": score.ConstantLoudnessDirection,
+    "fff": score.ConstantLoudnessDirection,
+    "ffff": score.ConstantLoudnessDirection,
+    "fffff": score.ConstantLoudnessDirection,
+    "ffffff": score.ConstantLoudnessDirection,
+    "n": score.ConstantLoudnessDirection,
+    "mf": score.ConstantLoudnessDirection,
+    "mp": score.ConstantLoudnessDirection,
+    "p": score.ConstantLoudnessDirection,
+    "pp": score.ConstantLoudnessDirection,
+    "ppp": score.ConstantLoudnessDirection,
+    "pppp": score.ConstantLoudnessDirection,
+    "ppppp": score.ConstantLoudnessDirection,
+    "pppppp": score.ConstantLoudnessDirection,
+    "fp": score.ImpulsiveLoudnessDirection,
+    "pf": score.ImpulsiveLoudnessDirection,
+    "rf": score.ImpulsiveLoudnessDirection,
+    "rfz": score.ImpulsiveLoudnessDirection,
+    "fz": score.ImpulsiveLoudnessDirection,
+    "sf": score.ImpulsiveLoudnessDirection,
+    "sffz": score.ImpulsiveLoudnessDirection,
+    "sfp": score.ImpulsiveLoudnessDirection,
+    "sfzp": score.ImpulsiveLoudnessDirection,
+    "sfpp": score.ImpulsiveLoudnessDirection,
+    "sfz": score.ImpulsiveLoudnessDirection,
+}
+
+PEDAL_DIRECTIONS = {
+    "sustain_pedal": score.SustainPedalDirection,
+}
+
+OCTAVE_SHIFTS = {8: 1, 15: 2, 22: 3}
+
+def validate_musicxml(xml, debug=False):
+    """
+    Validate an XML file against an XSD.
+
+    Parameters
+    ----------
+    xml: str
+        Path to XML file
+    debug: bool, optional
+        If True, raise an exception when the xml is invalid, and print out the
+        cause. Otherwise just return True when the XML is valid and False otherwise
+
+    Returns
+    -------
+    bool or None
+        None if debug=True, True or False otherwise, signalling validity
+
+    """
+    global _XML_VALIDATOR
+    if not _XML_VALIDATOR:
+        _XML_VALIDATOR = xmlschema.XMLSchema(_MUSICXML_SCHEMA)
+    if debug:
+        return _XML_VALIDATOR.validate(xml)
+    else:
+        return _XML_VALIDATOR.is_valid(xml)
+
+
+def _parse_partlist(partlist):
+    """
+    This parses the <part-list> ... </part-list> element in the beginning
+    of the MusicXML file where each instrument is declared, instruments and
+    their staves are grouped (braces, brackets), etc.
+
+    Parameters
+    ----------
+    partlist : etree element
+        The part-list etree element
+
+    Returns
+    -------
+    list:
+        list of PartGroup objects
+    dict:
+        Dictionary of pairs (partid, Part) where the Part objects are
+        instantiated with part-name and part-abbreviation if these are specified in
+        the part list definition.
+    """
+
+    structure = []
+    current_group = None
+    part_dict = {}
+
+    for e in partlist:
+        if e.tag == "part-group":
+            if e.get("type") == "start":
+
+                gr_name = get_value_from_tag(e, "group-name", str)
+                gr_symbol = get_value_from_tag(e, "group-symbol", str)
+                gr_number = get_value_from_attribute(e, "number", int)
+                new_group = score.PartGroup(gr_symbol, gr_name, gr_number)
+
+                if current_group is None:
+                    current_group = new_group
+                else:
+                    current_group.children.append(new_group)
+                    new_group.parent = current_group
+                    current_group = new_group
+
+            elif e.get("type") == "stop":
+                if current_group.parent is None:
+                    structure.append(current_group)
+                    current_group = None
+                else:
+                    current_group = current_group.parent
+
+        elif e.tag == "score-part":
+            part_id = e.get("id")
+            part = score.Part(part_id)
+
+            # set part name and abbreviation if available
+            part.part_name = next(iter(e.xpath("part-name/text()")), None)
+            part.part_abbreviation = next(
+                iter(e.xpath("part-abbreviation/text()")), None
+            )
+
+            part_dict[part_id] = part
+
+            if current_group is None:
+                structure.append(part)
+            else:
+                current_group.children.append(part)
+                part.parent = current_group
+
+    if current_group is not None:
+        warnings.warn("part-group {0} was not ended".format(current_group.number))
+        structure.append(current_group)
+
+    return structure, part_dict
+
+
+@deprecated_alias(xml="filename")
+@deprecated_parameter("ensure_list")
+def load_musicxml(
+    filename: PathLike,
+    validate: bool = False,
+    force_note_ids: Optional[Union[bool, str]] = None,
+) -> score.Score:
+    """Parse a MusicXML file and build a composite score ontology
+    structure from it (see also scoreontology.py).
+
+    Parameters
+    ----------
+    xml : str or file-like  object
+        Path to the MusicXML file to be parsed, or a file-like object
+    validate : bool, optional
+        When True the validity of the MusicXML is checked against the
+        MusicXML 3.1 specification before loading the file. An
+        exception will be raised when the MusicXML is invalid.
+        Defaults to False.
+    force_note_ids : (bool, 'keep') optional.
+        When True each Note in the returned Part(s) will have a newly
+        assigned unique id attribute. Existing note id attributes in
+        the MusicXML will be discarded. If 'keep', only notes without
+        a note id will be assigned one.
+
+    Returns
+    -------
+    scr: Score
+        A `Score` instance.
+
+    """
+
+    xml = None
+    if isinstance(filename, str):
+        if zipfile.is_zipfile(filename):
+            with zipfile.ZipFile(filename) as zipped_xml:
+                contained_xml_name = zipped_xml.namelist()[-1]
+                xml = zipped_xml.open(
+                    contained_xml_name
+                )
+
+    if xml is None:
+        xml = filename
+
+    if validate:
+        validate_musicxml(xml, debug=True)
+        # if xml is a file-like object we need to set the read pointer to the
+        # start of the file for parsing
+        if hasattr(xml, "seek"):
+            xml.seek(0)
+
+    parser = etree.XMLParser(
+        resolve_entities=False,
+        huge_tree=False,
+        remove_comments=True,
+        remove_blank_text=True,
+    )
+    document = etree.parse(xml, parser)
+
+    if document.getroot().tag != "score-partwise":
+        raise Exception("Currently only score-partwise structure is supported")
+
+    partlist_el = document.find("part-list")
+
+    if partlist_el is not None:
+        # parse the (hierarchical) structure of score parts
+        # (instruments) that are listed in the part-list element
+        partlist, part_dict = _parse_partlist(partlist_el)
+        # Go through each <part> to obtain the content of the parts.
+        # The Part instances will be modified in place
+        _parse_parts(document, part_dict)
+    else:
+        partlist = []
+
+    if force_note_ids is True or force_note_ids == "keep":
+        assign_note_ids(partlist, force_note_ids == "keep")
+
+    composer = None
+    scid = None
+    title = None
+    subtitle = None
+    lyricist = None
+    copyright = None
+
+    # The work tag is preferred for the title of the score, otherwise
+    # this method will search in the credit tags
+    work_info_el = document.find("work")
+
+    if work_info_el is not None:
+        scid = get_value_from_tag(
+            e=work_info_el,
+            tag="work-title",
+            as_type=str,
+        )
+
+        title = scid
+
+    score_identification_el = document.find("identification")
+
+    # The identification tag has preference over credit
+    if score_identification_el is not None:
+
+        copyright = get_value_from_tag(score_identification_el, "rights", str)
+
+        for cel in score_identification_el.findall("creator"):
+            if get_value_from_attribute(cel, "type", str) == "composer":
+                composer = str(cel.text)
+            if get_value_from_attribute(cel, "type", str) == "lyricist":
+                lyricist = str(cel.text)
+
+    for cel in document.findall("credit"):
+
+        credit_type = get_value_from_tag(cel, "credit-type", str)
+        if credit_type == "title" and title is None:
+            title = get_value_from_tag(cel, "credit-words", str)
+
+        elif credit_type == "subtitle" and subtitle is None:
+            subtitle = get_value_from_tag(cel, "credit-words", str)
+
+        elif credit_type == "composer" and composer is None:
+            composer = get_value_from_tag(cel, "credit-words", str)
+
+        elif credit_type == "lyricist" and lyricist is None:
+            lyricist = get_value_from_tag(cel, "credit-words", str)
+
+        elif credit_type == "rights" and copyright is None:
+            copyright = get_value_from_tag(cel, "credit-words", str)
+
+    scr = score.Score(
+        id=scid,
+        partlist=partlist,
+        title=title,
+        subtitle=subtitle,
+        composer=composer,
+        lyricist=lyricist,
+        copyright=copyright,
+    )
+
+    return scr
+
+
+def _parse_parts(document, part_dict):
+    """
+    Populate the Part instances that are the values of `part_dict` with the
+    musical content in document.
+
+    Parameters
+    ----------
+    document : lxml.etree.ElementTree
+        The ElementTree representation of the MusicXML document
+    part_dict : dict
+        A dictionary with key--value pairs (part_id, Part instance), as returned
+        by the _parse_partlist() function.
+    """
+
+    for part_el in document.findall("part"):
+
+        part_id = part_el.get("id", "P1")
+        part = part_dict.get(part_id, score.Part(part_id))
+
+        position = 0
+        ongoing = {}
+        doc_order = 0
+        # add new page and system at start of part
+        _handle_new_page(position, part, ongoing)
+        _handle_new_system(position, part, ongoing)
+
+        for measure_el in part_el.xpath("measure"):
+            position, doc_order = _handle_measure(
+                measure_el, position, part, ongoing, doc_order
+            )
+
+        # complete unfinished endings
+        for o in part.iter_all(score.Ending, mode="ending"):
+            if o.start is None:
+                part.add(o, part.measure_map(o.end.t - 1)[0], None)
+                warnings.warn(
+                    "Found ending[stop] without a preceding ending[start]\n"
+                    "Single measure bracket is assumed"
+                )
+
+        for o in part.iter_all(score.Ending, mode="starting"):
+            if o.end is None:
+                part.add(o, None, part.measure_map(o.start.t)[1])
+                warnings.warn(
+                    "Found ending[start] without a following ending[stop]\n"
+                    "Single measure bracket is assumed"
+                )
+
+        # Complete repeats without end.
+        volta_repeats = list()
+        for o in part.iter_all(score.Repeat, mode="starting"):
+            if o.end is None:
+                # if len(o.start.starting_objects[score.Repeat]) > 0:
+                #     starting = list(o.start.starting_objects[score.Repeat].keys())[0]
+                #     # if unstarted repeat from volta, continue for now
+                #     if len(starting.end.ending_objects[score.Repeat]) > 0:
+                #         # if repeat from volta, continue for now
+                #         volta_repeats.append(o)
+                #         continue
+
+                starting_repeats = [
+                    r for r in part.iter_all(score.Repeat) if r.start is not None
+                ]
+                end_times = [r.start.t for r in starting_repeats] + [part._points[-1].t]
+                end_time_id = np.searchsorted(end_times, o.start.t + 1)
+                part.add(o, None, end_times[end_time_id])
+                warnings.warn(
+                    "Found repeat without end\n"
+                    "Ending point {} is assumed".format(end_times[end_time_id])
+                )
+
+        # complete unstarted repeats
+        volta_repeats = list()
+        for o in part.iter_all(score.Repeat, mode="ending"):
+            if o.start is None:
+                if len(o.end.ending_objects[score.Ending]) > 0:
+                    ending = list(o.end.ending_objects[score.Ending].keys())[0]
+                    # if unstarted repeat from volta, continue for now
+                    if len(ending.start.ending_objects[score.Repeat]) > 0:
+                        volta_repeats.append(o)
+                        continue
+
+                # go back to the end of the last repeat
+                start_times = [0] + [r.end.t for r in part.iter_all(score.Repeat)]
+                start_time_id = np.searchsorted(start_times, o.end.t) - 1
+                part.add(o, start_times[start_time_id], None)
+                warnings.warn(
+                    "Found repeat without start\n"
+                    "Starting point {} is assumed".format(start_times[start_time_id])
+                )
+
+        # complete unstarted repeats in volta with start time of first repeat
+        for o in volta_repeats:
+            start_times = [0] + [r.start.t for r in part.iter_all(score.Repeat)]
+            start_time_id = np.searchsorted(start_times, o.end.t) - 1
+            part.add(o, start_times[start_time_id], None)
+            warnings.warn(
+                "Found repeat without start\n"
+                "Starting point {} is assumed".format(start_times[start_time_id])
+            )
+
+        # remove unfinished elements from the timeline
+        for k, o in ongoing.items():
+            if k not in ("page", "system", "repeat") and k[0] not in ("tie", "ending"):
+                if isinstance(o, list):
+                    for o_i in o:
+                        part.remove(o_i)
+                else:
+                    part.remove(o)
+
+        # check whether all grace notes have a main note
+        for gn in part.iter_all(score.GraceNote):
+            if gn.main_note is None:
+
+                for no in part.iter_all(
+                    score.Note,
+                    include_subclasses=False,
+                    start=gn.start.t,
+                    end=gn.start.t + 1,
+                ):
+                    if no.voice == gn.voice:
+                        gn.last_grace_note_in_seq.grace_next = no
+
+            if gn.main_note is None:
+                warnings.warn(
+                    "grace note without recoverable same voice main note: {}".format(gn)
+                )
+                warnings.warn("might be cadenza notation")
+
+        # set end times for various musical elements that only have a start time
+        # when constructed from MusicXML
+        score.set_end_times(part)
+
+        # Octave Shifts are only visual doesn't to change the octave of notes.
+        # Apply octave shifts directly to notes
+        # for shift in part.iter_all(score.OctaveShiftDirection):
+        #     # Shifts normal notes
+        #     for note in part.iter_all(score.Note, start=shift.start.t, end=shift.end.t):
+        #         if note.staff == shift.staff:
+        #             if shift.shift_type == "up":
+        #                 note.octave -= OCTAVE_SHIFTS[shift.shift_size] if shift.shift_size in OCTAVE_SHIFTS.keys() else 0
+        #             elif shift.shift_type == "down":
+        #                 note.octave += OCTAVE_SHIFTS[shift.shift_size] if shift.shift_size in OCTAVE_SHIFTS.keys() else 0
+        #     # Shifts grace notes
+        #     for note in part.iter_all(score.GraceNote, start=shift.start.t, end=shift.end.t):
+        #         if note.staff == shift.staff:
+        #             if shift.shift_type == "up":
+        #                 note.octave -= OCTAVE_SHIFTS[shift.shift_size] if shift.shift_size in OCTAVE_SHIFTS.keys() else 0
+        #             elif shift.shift_type == "down":
+        #                 note.octave += OCTAVE_SHIFTS[shift.shift_size] if shift.shift_size in OCTAVE_SHIFTS.keys() else 0
+        #     shift.applied = True
+
+
+def _handle_measure(measure_el, position, part, ongoing, doc_order):
+    """
+    Parse a <measure>...</measure> element, adding it and its contents to the
+    part.
+    """
+    # make a measure object
+    measure = make_measure(measure_el)
+
+    # add the start of the measure to the time line
+    part.add(measure, position)
+
+    # keep track of the position within the measure
+    # measure_pos = 0
+    measure_start = position
+    # keep track of the previous note (in case of <chord>)
+    prev_note = None
+    # used to keep track of the duration of the measure
+    measure_maxtime = measure_start
+    trailing_children = []
+    for i, e in enumerate(measure_el):
+
+        if e.tag == "backup":
+            # <xs:documentation>The backup and forward elements are required
+            # to coordinate multiple voices in one part, including music on
+            # multiple staves. The backup type is generally used to move
+            # between voices and staves. Thus the backup element does not
+            # include voice or staff elements. Duration values should always
+            # be positive, and should not cross measure boundaries or
+            # mid-measure changes in the divisions value.</xs:documentation>
+
+            duration = get_value_from_tag(e, "duration", int) or 0
+            position -= duration
+
+            if position < measure.start.t:
+                warnings.warn(
+                    (
+                        "<backup> crosses measure boundary, adjusting "
+                        "position from {} to {} in Measure {}"
+                    ).format(position, measure.start.t, measure.number)
+                )
+                position = measure.start.t
+
+            # <backup> tags trigger an update of the measure
+            # duration up to the measure position (after the
+            # <backup> has been processed); This has been found to
+            # account for implicit measure durations in
+            # Baerenreiter MusicXML files.
+            measure_maxtime = max(measure_maxtime, position)
+
+        elif e.tag == "forward":
+            duration = get_value_from_tag(e, "duration", int) or 0
+            position += duration
+            measure_maxtime = max(measure_maxtime, position)
+
+        elif e.tag == "attributes":
+            _handle_attributes(e, position, part)
+
+        elif e.tag == "direction":
+            _handle_direction(e, position, part, ongoing)
+
+        elif e.tag == "print":
+            # new-page/new-system occurring anywhere in the measure take effect
+            # at the start of the measure, so we pass measure_start rather than
+            # position
+            _handle_print(e, measure_start, part, ongoing)
+
+        elif e.tag == "sound":
+            _handle_sound(e, position, part)
+
+        elif e.tag == "note":
+            (position, prev_note) = _handle_note(
+                e, position, part, ongoing, prev_note, doc_order
+            )
+            doc_order += 1
+            measure_maxtime = max(measure_maxtime, position)
+
+        elif e.tag == "harmony":
+            _handle_harmony(e, position, part)
+
+        elif e.tag == "barline":
+            location = get_value_from_attribute(e, "location", str)
+            if (location is None) or (location == "right"):
+                position_barline = measure_maxtime
+            elif location == "left":
+                position_barline = measure_start
+            else:
+                position_barline = position
+
+            repeat = e.find("repeat")
+            if repeat is not None:
+                _handle_repeat(repeat, position_barline, part, ongoing)
+
+            ending = e.find("ending")
+            if ending is not None:
+                _handle_ending(ending, position_barline, part, ongoing)
+
+            bar_style_e = e.find("bar-style")
+            if bar_style_e is not None:
+                bar_style = score.Barline(bar_style_e.text)
+                part.add(bar_style, position)
+
+            # <!ELEMENT barline (bar-style?, %editorial;, wavy-line?,
+            #     segno?, coda?, (fermata, fermata?)?, ending?, repeat?)>
+            # <!ATTLIST barline
+            #     location (right | left | middle) "right"
+            #     segno CDATA #IMPLIED
+            #     coda CDATA #IMPLIED
+            #     divisions CDATA #IMPLIED
+
+            fermata_e = e.find("fermata")
+            if fermata_e is not None:
+                location = e.get("location")
+                fermata = score.Fermata(location)
+                if location is None:
+                    # missing location attribute on barline defaults to
+                    # "right". In this case the barline should occur as the last
+                    # element in the measure
+                    trailing_children.append(fermata)
+                else:
+                    part.add(fermata, position)
+
+            # TODO: handle segno/fine/dacapo
+
+        else:
+            warnings.warn("ignoring tag {0}".format(e.tag), stacklevel=2)
+
+    for obj in trailing_children:
+        part.add(obj, measure_maxtime)
+
+    # add end time of measure
+    part.add(measure, None, measure_maxtime)
+
+    return measure_maxtime, doc_order
+
+
+def _handle_harmony(e, position, part):
+    """Handle a <harmony> element."""
+    if e.find("function") is not None:
+        text = e.find("function").text
+        if text is not None:
+            part.add(score.RomanNumeral(text), position)
+    elif e.find("kind") is not None and e.find("root") is not None:
+        # TODO: handle kind text which is other kind of annotation also root
+        kind = e.find("kind").get("text")
+        root = e.find("root").find("root-step").text
+        part.add(score.ChordSymbol(root=root, kind=kind), position)
+        text = None
+    else:
+        text = None
+
+    if text is None:
+        warnings.warn("ignoring empty <harmony> tag", stacklevel=2)
+
+
+def _handle_repeat(e, position, part, ongoing):
+    key = "repeat"
+
+    if e.get("direction") == "forward":
+
+        o = score.Repeat()
+        ongoing[key] = o
+        part.add(o, position)
+
+    elif e.get("direction") == "backward":
+
+        o = ongoing.pop(key, None)
+
+        if o is None:
+            # implicit repeat start: create Repeat
+            # object and add it at the beginning of
+            # the self retroactively
+            o = score.Repeat()
+            # no, clean up later with shortest possible repeat start
+            # part.add(o, 0)
+
+        part.add(o, None, position)
+
+
+def _handle_ending(e, position, part, ongoing):
+    # key = "ending"
+    key = ("ending", getattr(e, "number", "0"))
+
+    if e.get("type") == "start":
+
+        o = score.Ending(e.get("number"))
+        ongoing[key] = o
+        part.add(o, position)
+
+    elif e.get("type") in ("stop", "discontinue"):
+
+        o = ongoing.pop(key, None)
+
+        if o is None:
+
+            warnings.warn(
+                "Found ending[stop] without a preceding ending[start]\n"
+                + "Single measure bracket is assumed"
+            )
+            o = score.Ending(e.get("number"))
+            part.add(o, None, position)
+
+        else:
+
+            part.add(o, None, position)
+
+
+def _handle_new_page(position, part, ongoing):
+    if "page" in ongoing:
+        if position == 0:
+            # ignore non-informative new-page at start of score
+            return
+
+        part.add(ongoing["page"], None, position)
+        page_nr = ongoing["page"].number + 1
+    else:
+        page_nr = 1
+
+    page = score.Page(page_nr)
+    part.add(page, position)
+    ongoing["page"] = page
+
+
+def _handle_new_system(position, part, ongoing):
+    if "system" in ongoing:
+
+        if position == 0:
+            # ignore non-informative new-system at start of score
+            return
+
+        # end current page
+        part.add(ongoing["system"], None, position)
+        system_nr = ongoing["system"].number + 1
+    else:
+        system_nr = 1
+
+    system = score.System(system_nr)
+    part.add(system, position)
+    ongoing["system"] = system
+
+
+def make_measure(xml_measure):
+    measure = score.Measure()
+    # try:
+    #     measure.number = int(xml_measure.attrib['number'])
+    # except:
+    #     LOGGER.warn('No number attribute found for measure')
+    measure.number = get_value_from_attribute(xml_measure, "number", int)
+    return measure
+
+
+def _handle_attributes(e, position, part):
+    """"""
+
+    ts_num = get_value_from_tag(e, "time/beats", int)
+    ts_den = get_value_from_tag(e, "time/beat-type", int)
+    if ts_num and ts_den:
+        part.add(score.TimeSignature(ts_num, ts_den), position)
+
+    fifths = get_value_from_tag(e, "key/fifths", int)
+    mode = get_value_from_tag(e, "key/mode", str)
+    if fifths is not None or mode is not None:
+        part.add(score.KeySignature(fifths, mode), position)
+
+    diat = get_value_from_tag(e, "transpose/diatonic", int)
+    chrom = get_value_from_tag(e, "transpose/chromatic", int)
+    if diat is not None or chrom is not None:
+        part.add(score.Transposition(diat, chrom), position)
+
+    divs = get_value_from_tag(e, "divisions", int)
+    if divs:
+        # part.add(score.Divisions(divs), position)
+        part.set_quarter_duration(position, divs)
+
+    clefs = get_clefs(e)
+    for clef in clefs:
+        part.add(score.Clef(**clef), position)
+
+
+def get_offset(e):
+    offset = e.find("offset")
+
+    if offset is None:
+
+        return None
+
+    else:
+
+        sounding = offset.attrib.get("sound", "no")
+        return int(offset.text) if sounding == "yes" else 0
+
+
+def _handle_direction(e, position, part, ongoing):
+
+    # <!--
+    #     A direction is a musical indication that is not attached
+    #     to a specific note. Two or more may be combined to
+    #     indicate starts and stops of wedges, dashes, etc.
+
+    #     By default, a series of direction-type elements and a
+    #     series of child elements of a direction-type within a
+    #     single direction element follow one another in sequence
+    #     visually. For a series of direction-type children, non-
+    #     positional formatting attributes are carried over from
+    #     the previous element by default.
+    # -->
+    # <!ELEMENT direction (direction-type+, offset?,
+    #     %editorial-voice;, staff?, sound?)>
+    # <!ATTLIST direction
+    #     %placement;
+    #     %direction;
+    # >
+
+    staff = get_value_from_tag(e, "staff", int) or None
+
+    sound_directions = e.findall("sound")
+    for sd in sound_directions:
+        # TODO: figure out which values occur in the wild for each attribute
+        if get_value_from_attribute(sd, "fine", str) in ("yes", "1"):
+            part.add(score.Fine(), position)
+        if get_value_from_attribute(sd, "dacapo", str) == "yes":
+            part.add(score.DaCapo(), position)
+        if get_value_from_attribute(sd, "tocoda", str) == "coda":
+            part.add(score.ToCoda(), position)
+        if get_value_from_attribute(sd, "coda", str) == "coda":
+            part.add(score.Coda(), position)
+        if get_value_from_attribute(sd, "dalsegno", str) == "segno":
+            part.add(score.DalSegno(), position)
+        if get_value_from_attribute(sd, "segno", str) == "segno":
+            part.add(score.Segno(), position)
+
+    # <direction-type> ... </...>
+    direction_types = e.findall("direction-type")
+    # <!ELEMENT direction-type (rehearsal+ | segno+ | words+ |
+    #     coda+ | wedge | dynamics+ | dashes | bracket | pedal |
+    #     metronome | octave-shift | harp-pedals | damp | damp-all |
+    #     eyeglasses | string-mute | scordatura | image |
+    #     principal-voice | accordion-registration | percussion+ |
+    #     other-direction)>
+
+    # direction-types supported here:
+    # * words
+    # * wedge
+    # * dynamics
+    # * dashes
+    # * coda
+    # * TODO: pedal
+    # * TODO: damp
+
+    # here we gather all starting and ending directions,
+    # to be added to the part afterwards
+    starting_directions = []
+    ending_directions = []
+
+    # keep track of starting and stopping dashes
+    dashes_keys = {}
+
+    # keep track of starting and stopping pedals
+    # pedal_keys = {}
+
+    for direction_type in direction_types:
+        # direction_type
+        dt = next(iter(direction_type))
+
+        if dt.tag == "dynamics":
+            # first child of direction-type is dynamics, there may be subsequent
+            # dynamics items, so we loop:
+            for child in direction_type:
+                # interpret as score.Direction, fall back to score.Words
+                dyn_el = next(iter(child))
+                if dyn_el is not None:
+                    direction = DYN_DIRECTIONS.get(dyn_el.tag, score.Words)(
+                        dyn_el.tag, staff=staff
+                    )
+                    starting_directions.append(direction)
+
+        elif dt.tag == "words":
+            # first child of direction-type is words, there may be subsequent
+            # words items, so we loop:
+            for child in direction_type:
+
+                # try to make a direction out of words
+                parse_result = parse_direction(child.text)
+                starting_directions.extend(parse_result)
+
+        elif dt.tag == "wedge":
+
+            number = get_value_from_attribute(dt, "number", int) or 1
+            key = ("wedge", number)
+            wedge_type = get_value_from_attribute(dt, "type", str)
+
+            if wedge_type in ("crescendo", "diminuendo"):
+                if wedge_type == "crescendo":
+                    o = score.IncreasingLoudnessDirection(wedge_type, wedge=True)
+                else:
+                    o = score.DecreasingLoudnessDirection(wedge_type, wedge=True)
+                starting_directions.append(o)
+                ongoing[key] = o
+
+            elif wedge_type == "stop":
+
+                o = ongoing.get(key)
+                if o is not None:
+                    ending_directions.append(o)
+                    del ongoing[key]
+                else:
+                    warnings.warn("Did not find a wedge start element for wedge stop!")
+
+        elif dt.tag == "dashes":
+
+            # start/stop/continue
+            dashes_type = get_value_from_attribute(dt, "type", str)
+            number = get_value_from_attribute(dt, "number", int) or 1
+            dashes_keys[("dashes", number)] = dashes_type
+            # TODO: for now we ignore dashes_type == continue, because it exists
+            # only as a function of the visual appearance. However, if dashes
+            # that are continued over a system are stopped at the end of the
+            # system before they are continued at the start of the next, this
+            # will not be treated correctly. I'm not sure how dashes spanning
+            # systems are encoded in practice (need examples).
+        elif dt.tag == "octave-shift":
+            # start/stop
+            octave_shift_type = get_value_from_attribute(dt, "type", str)
+            octave_shift_size = get_value_from_attribute(dt, "size", int) or 8
+            octave_shift_number = get_value_from_attribute(dt, "number", int) or 1
+            key = ("octave-shift", octave_shift_number)
+            if octave_shift_type in ["up", "down"]:
+                if key in ongoing:
+                    eo = ongoing.pop(key)
+                    ending_directions.append(eo)
+
+                o = score.OctaveShiftDirection(
+                    octave_shift_type, octave_shift_size, staff=staff
+                )
+
+                starting_directions.append(o)
+
+                ongoing[key] = o
+
+            elif octave_shift_type == "stop":
+
+                o = ongoing.get(key)
+                if o is not None:
+                    ending_directions.append(o)
+                    del ongoing[key]
+
+                else:
+                    warnings.warn(
+                        "Did not find a octave_shift start element for octave_shift stop!"
+                    )
+
+        elif dt.tag == "pedal":
+
+            # start/stop
+            pedal_type = get_value_from_attribute(dt, "type", str)
+            pedal_line = get_value_from_attribute(dt, "line", str) == "yes"
+
+            number = get_value_from_attribute(dt, "number", int) or 1
+            key = ("pedal", number)
+            if pedal_type == "start":
+                if key in ongoing:
+                    eo = ongoing.pop(key)
+                    ending_directions.append(eo)
+
+                o = score.SustainPedalDirection(staff=staff, line=pedal_line)
+
+                starting_directions.append(o)
+
+                ongoing[key] = o
+
+            elif pedal_type == "stop":
+
+                o = ongoing.get(key)
+                if o is not None:
+                    ending_directions.append(o)
+                    del ongoing[key]
+
+                else:
+                    warnings.warn("Did not find a pedal start element for pedal stop!")
+
+            else:
+                if pedal_type in ("change", "continue"):
+                    warnings.warn(
+                        'pedal types "change" and "continue" are '
+                        "not supported. Ignoring direction."
+                    )
+
+        else:
+            warnings.warn("ignoring direction type: {} {}".format(dt.tag, dt.attrib))
+
+    for dashes_key, dashes_type in dashes_keys.items():
+
+        if dashes_type == "start":
+
+            ongoing[dashes_key] = starting_directions
+
+        elif dashes_type == "stop":
+
+            oo = ongoing.get(dashes_key)
+            if oo is None:
+                warnings.warn("Dashes end without dashes start")
+            else:
+                ending_directions.extend(oo)
+                del ongoing[dashes_key]
+
+    for o in starting_directions:
+        if isinstance(o, score.Tempo):
+            _add_tempo_if_unique(position, part, o)
+        else:
+            part.add(o, position)
+
+    for o in ending_directions:
+        part.add(o, None, position)
+
+
+def get_clefs(e):
+    """
+    Get the clefs
+
+    Returns
+    -------
+
+    (fifths, mode) OR None : tuple of or None.
+
+    """
+    clefs = e.xpath("clef")
+    result = []
+    for clef in clefs:
+        result.append(
+            dict(
+                staff=get_value_from_attribute(clef, "number", int) or 1,
+                sign=get_value_from_tag(clef, "sign", str),
+                line=get_value_from_tag(clef, "line", int),
+                octave_change=get_value_from_tag(clef, "clef-octave-change", int),
+            )
+        )
+    return result
+
+
+def get_value_from_tag(e, tag, as_type, none_on_error=True):
+    """
+    Return the text contents of a particular tag in element e, cast as a
+    particular type. By default the function will return None if either the tag
+    is not found or the value cannot be cast to the desired type.
+
+    Examples
+    --------
+
+    >>> e = lxml.etree.fromstring('<note><duration>2</duration></note>')
+    >>> get_value_from_tag(e, 'duration', int)
+    2
+    >>> get_value_from_tag(e, 'duration', float)
+    2.0
+
+    >>> e = lxml.etree.fromstring('<note><duration>quarter</duration></note>')
+    >>> get_value_from_tag(e, 'duration', float)
+    None
+
+
+    Parameters
+    ----------
+    e: etree.Element
+        An etree Element instance
+    tag: string
+        Child tag to retrieve
+    as_type: function
+        Function that casts the string to the desired type (e.g. int, float)
+    none_on_error: bool, optional (default: True)
+        When False, an exception is raised when `tag` is not found in `e` or the
+        text inside `tag` cannot be cast to an integer. When True, None is returned
+        in such cases.
+
+    Returns
+    -------
+    object
+        The value read from `tag`, cast as `as_type`
+    """
+    try:
+        return as_type(e.find(tag).text)
+    except (ValueError, AttributeError):
+        if none_on_error:
+            return None
+        else:
+            raise
+
+
+def get_value_from_attribute(e, attr, as_type, none_on_error=True):
+    """
+    Return the attribute of a particular attribute of element e, cast as a
+    particular type. By default the function will return None if either `e` does
+    not have the attribute or the value cannot be cast to the desired type.
+
+    Parameters
+    ----------
+    e: etree.Element
+        An etree Element instance
+    attr: string
+        Attribute to retrieve
+    as_type: function
+        Function that casts the string to the desired type (e.g. int, float)
+    none_on_error: bool, optional (default: True)
+        When False, an exception is raised when `tag` is not found in `e` or the
+        text inside `tag` cannot be cast to an integer. When True, None is returned
+        in such cases.
+
+    Returns
+    -------
+    object or None
+        The attribute value, or None
+    """
+
+    value = e.get(attr)
+    if value is None:
+        return None
+    else:
+        try:
+            return as_type(value)
+        except ValueError:
+            if none_on_error:
+                return None
+            else:
+                raise
+
+
+def get_pitch(e):
+    """
+    Check whether the element has a pitch. If so return a tuple (pitch, alter,
+    octave), otherwise return None.
+
+    Returns
+    -------
+    tuple : (str, int or None, int) or None
+        The tuple contains (pitch, alter, octave)
+    """
+
+    pitch = e.find("pitch")
+    if pitch is not None:
+        step = get_value_from_tag(pitch, "step", str)
+        alter = get_value_from_tag(pitch, "alter", int)
+        octave = get_value_from_tag(pitch, "octave", int)
+        return (step, alter, octave)
+    else:
+        return None
+
+
+def _handle_print(e, position, part, ongoing):
+    if "new-page" in e.attrib:
+        _handle_new_page(position, part, ongoing)
+        _handle_new_system(position, part, ongoing)
+    if "new-system" in e.attrib:
+        _handle_new_system(position, part, ongoing)
+
+
+def _add_tempo_if_unique(position, part, tempo):
+    """
+    Add score.Tempo object `tempo` at `position` on `part` if and only if
+    there are no starting score.Tempo objects at that position. score.Tempo
+    objects are generated by <sound tempo=...> as well as textual directions
+    (e.g. "q=100"). This function avoids multiple synchronous tempo indications
+    (whether redundant or conflicting)
+    """
+    point = part.get_point(position)
+    if point is not None:
+        tempos = point.starting_objects.get(score.Tempo, [])
+        if tempos == []:
+            part.add(tempo, position)
+        else:
+            warnings.warn("not adding duplicate or conflicting tempo indication")
+
+
+def _handle_sound(e, position, part):
+    if "tempo" in e.attrib:
+        tempo = score.Tempo(int(e.attrib["tempo"]), "q")
+        # part.add_starting_object(position, tempo)
+        _add_tempo_if_unique(position, part, tempo)
+
+
+def _handle_note(e, position, part, ongoing, prev_note, doc_order):
+
+    # get some common features of element if available
+    duration = get_value_from_tag(e, "duration", int) or 0
+    # elements may have an explicit temporal offset
+    # offset = get_value_from_tag(e, 'offset', int) or 0
+    staff = get_value_from_tag(e, "staff", int) or 1
+    voice = get_value_from_tag(e, "voice", int) or 1
+
+    # add support of uppercase "ID" tags
+    note_id = (
+        get_value_from_attribute(e, "id", str)
+        if get_value_from_attribute(e, "id", str)
+        else get_value_from_attribute(e, "ID", str)
+    )
+
+    symbolic_duration = {}
+    dur_type = get_value_from_tag(e, "type", str)
+    if dur_type:
+        symbolic_duration["type"] = dur_type
+
+    dots = len(e.findall("dot"))
+    if dots:
+        symbolic_duration["dots"] = dots
+
+    actual_notes = get_value_from_tag(e, "time-modification/actual-notes", int)
+    if actual_notes:
+        symbolic_duration["actual_notes"] = actual_notes
+
+    normal_notes = get_value_from_tag(e, "time-modification/normal-notes", int)
+    if normal_notes:
+        symbolic_duration["normal_notes"] = normal_notes
+
+    chord = e.find("chord")
+    if chord is not None:
+        # this note starts at the same position as the previous note, and has
+        # same duration
+        assert prev_note is not None
+        position = prev_note.start.t
+
+    articulations_e = e.find("notations/articulations")
+    if articulations_e is not None:
+        articulations = get_articulations(articulations_e)
+    else:
+        articulations = {}
+
+    ornaments_e = e.find("notations/ornaments")
+    if ornaments_e is not None:
+        ornaments = get_ornaments(ornaments_e)
+    else:
+        ornaments = {}
+
+    pitch = e.find("pitch")
+    unpitch = e.find("unpitched")
+    if pitch is not None:
+
+        step = get_value_from_tag(pitch, "step", str)
+        alter = get_value_from_tag(pitch, "alter", int)
+        octave = get_value_from_tag(pitch, "octave", int)
+
+        grace = e.find("grace")
+
+        if grace is not None:
+            grace_type, steal_proportion = get_grace_info(grace)
+            note = score.GraceNote(
+                grace_type=grace_type,
+                step=step,
+                octave=octave,
+                alter=alter,
+                id=note_id,
+                voice=voice,
+                staff=staff,
+                symbolic_duration=symbolic_duration,
+                articulations=articulations,
+                ornaments=ornaments,
+                steal_proportion=steal_proportion,
+                doc_order=doc_order,
+            )
+            if isinstance(prev_note, score.GraceNote) and prev_note.voice == voice:
+                note.grace_prev = prev_note
+        else:
+            note = score.Note(
+                step=step,
+                octave=octave,
+                alter=alter,
+                id=note_id,
+                voice=voice,
+                staff=staff,
+                symbolic_duration=symbolic_duration,
+                articulations=articulations,
+                ornaments=ornaments,
+                doc_order=doc_order,
+            )
+
+        if isinstance(prev_note, score.GraceNote) and prev_note.voice == voice:
+            prev_note.grace_next = note
+
+    elif unpitch is not None:
+        # note element is unpitched
+        step = get_value_from_tag(unpitch, "display-step", str)
+        octave = get_value_from_tag(unpitch, "display-octave", int)
+        noteheadtag = e.find("notehead")
+        noteheadstylebool = True
+        notehead = None
+        if noteheadtag is not None:
+            notehead = get_value_from_tag(e, "notehead", str)
+            noteheadstyle = get_value_from_attribute(noteheadtag, "filled", str)
+            if noteheadstyle is not None:
+                noteheadstylebool = {"no": False, "yes": True}[noteheadstyle]
+
+        note = score.UnpitchedNote(
+            step=step,
+            octave=octave,
+            id=note_id,
+            voice=voice,
+            staff=staff,
+            notehead=notehead,
+            noteheadstyle=noteheadstylebool,
+            articulations=articulations,
+            symbolic_duration=symbolic_duration,
+            doc_order=doc_order,
+        )
+
+    else:
+        # note element is a rest
+        note = score.Rest(
+            id=note_id,
+            voice=voice,
+            staff=staff,
+            symbolic_duration=symbolic_duration,
+            articulations=articulations,
+            doc_order=doc_order,
+        )
+
+    part.add(note, position, position + duration)
+
+    ties = e.findall("tie")
+    if len(ties) > 0:
+
+        tie_key = ("tie", getattr(note, "midi_pitch", "rest"))
+        tie_types = set(tie.attrib["type"] for tie in ties)
+
+        if "stop" in tie_types:
+
+            tie_prev = ongoing.get(tie_key, None)
+
+            if tie_prev:
+
+                note.tie_prev = tie_prev
+                tie_prev.tie_next = note
+                del ongoing[tie_key]
+
+        if "start" in tie_types:
+
+            ongoing[tie_key] = note
+
+    notations = e.find("notations")
+
+    if notations is not None:
+
+        if notations.find("fermata") is not None:
+
+            fermata = score.Fermata(note)
+            part.add(fermata, position)
+            note.fermata = fermata
+
+        starting_slurs, stopping_slurs = handle_slurs(
+            notations, ongoing, note, position
+        )
+
+        for slur in starting_slurs:
+
+            part.add(slur, position)
+
+        for slur in stopping_slurs:
+
+            part.add(slur, end=position + duration)
+
+        starting_tups, stopping_tups = handle_tuplets(notations, ongoing, note)
+
+        for tup in starting_tups:
+
+            part.add(tup, position)
+
+        for tup in stopping_tups:
+
+            part.add(tup, end=position + duration)
+
+    new_position = position + duration
+
+    return new_position, note
+
+
+def handle_tuplets(notations, ongoing, note):
+    starting_tuplets = []
+    stopping_tuplets = []
+    tuplets = notations.findall("tuplet")
+
+    # this sorts all found tuplets by type (either 'start' or 'stop')
+    # in reverse order, so all with type 'stop' will be before
+    # the ones with 'start'?!.
+    tuplets.sort(key=lambda x: x.attrib["type"], reverse=True)
+
+    # Now that the tuplets are sorted by their type, sort them
+    # by their numbers; First note that tuplets do not always
+    # have a number attribute, then 1 is implied.
+    tuplets.sort(
+        key=lambda x: get_value_from_attribute(x, "number", int) or note.voice or 1
+    )
+
+    for tuplet_e in tuplets:
+
+        tuplet_number = get_value_from_attribute(tuplet_e, "number", int) or note.voice
+        tuplet_type = get_value_from_attribute(tuplet_e, "type", str)
+        start_tuplet_key = ("start_tuplet", tuplet_number)
+        stop_tuplet_key = ("stop_tuplet", tuplet_number)
+
+        if tuplet_type == "start":
+
+            # check if we have a stopped_tuplet in ongoing that corresponds to
+            # this start
+            tuplet = ongoing.pop(stop_tuplet_key, None)
+
+            if tuplet is None:
+
+                tuplet = score.Tuplet(note)
+                ongoing[start_tuplet_key] = tuplet
+
+            else:
+
+                tuplet.start_note = note
+
+            starting_tuplets.append(tuplet)
+
+        elif tuplet_type == "stop":
+
+            tuplet = ongoing.pop(start_tuplet_key, None)
+            if tuplet is None:
+                # tuplet stop occurs before tuplet start in document order, that
+                # is a valid scenario
+                tuplet = score.Tuplet(None, note)
+                ongoing[stop_tuplet_key] = tuplet
+            else:
+                tuplet.end_note = note
+
+            stopping_tuplets.append(tuplet)
+
+    return starting_tuplets, stopping_tuplets
+
+
+def handle_slurs(notations, ongoing, note, position):
+    # we need position here to check for erroneous slurs: sometimes a slur stop
+    # is encountered before the corresponding slur start. This is a valid use
+    # case (e.g. slur starts in staff 2 and ends in staff 1). However, if the
+    # stop is before the start in time, then it is just a MusicXML encoding
+    # error.
+
+    starting_slurs = []
+    stopping_slurs = []
+    slurs = notations.findall("slur")
+
+    # this sorts all found slurs by type (either 'start' or 'stop')
+    # in reverse order, so all with type 'stop' will be before
+    # the ones with 'start'?!.
+    slurs.sort(key=lambda x: x.attrib["type"], reverse=True)
+
+    # Now that the slurs are sorted by their type, sort them
+    # by their numbers; First note that slurs do not always
+    # have a number attribute, then 1 is implied.
+    slurs.sort(
+        key=lambda x: get_value_from_attribute(x, "number", int) or note.voice or 1
+    )
+
+    for slur_e in slurs:
+
+        slur_number = get_value_from_attribute(slur_e, "number", int) or note.voice
+        slur_type = get_value_from_attribute(slur_e, "type", str)
+        start_slur_key = ("start_slur", slur_number)
+        stop_slur_key = ("stop_slur", slur_number)
+
+        if slur_type == "start":
+
+            # check if we have a stopped_slur in ongoing that corresponds to
+            # this stop
+            slur = ongoing.pop(stop_slur_key, None)
+
+            # if slur.end_note.start.t < position then the slur stop is
+            # rogue. We drop it and treat the slur start like a fresh start
+            if slur is None or slur.end_note.start.t < position:
+
+                if slur and slur.end_note.start.t < position:
+                    msg = (
+                        "Dropping slur {} starting at {} ({}) and ending "
+                        "at {} ({})".format(
+                            slur_number,
+                            position,
+                            note.id,
+                            slur.end_note.start.t,
+                            slur.end_note.id,
+                        )
+                    )
+                    warnings.warn(msg)
+                    # remove the slur from the timeline
+                    slur.end_note.start.remove_ending_object(slur)
+                    # remove the reference to the slur in the end note
+                    slur.end_note.slur_stops.remove(slur)
+
+                slur = score.Slur(note)
+                ongoing[start_slur_key] = slur
+
+            else:
+
+                slur.start_note = note
+
+            starting_slurs.append(slur)
+
+        elif slur_type == "stop":
+
+            slur = ongoing.pop(start_slur_key, None)
+
+            if slur is None or slur.start_note.start.t > position:
+
+                if slur and slur.start_note.start.t > position:
+                    msg = (
+                        "Dropping slur {} starting at {} ({}) and ending "
+                        "at {} ({})".format(
+                            slur_number,
+                            slur.start_note.start.t,
+                            slur.start_note.id,
+                            position,
+                            note.id,
+                        )
+                    )
+                    warnings.warn(msg)
+                    # remove the slur from the timeline
+                    slur.start_note.start.remove_starting_object(slur)
+                    # remove the reference to the slur in the end note
+                    slur.start_note.slur_starts.remove(slur)
+
+                # slur stop occurs before slur start in document order, that
+                # is a valid scenario
+                slur = score.Slur(None, note)
+                ongoing[stop_slur_key] = slur
+
+            else:
+
+                slur.end_note = note
+
+            stopping_slurs.append(slur)
+
+    return starting_slurs, stopping_slurs
+
+
+def get_grace_info(grace):
+    # grace note handling
+    grace_type = "grace"
+    steal_proportion = None
+
+    slash_text = get_value_from_attribute(grace, "slash", str)
+    if slash_text == "yes":
+        grace_type = "acciaccatura"
+
+    steal_prc = get_value_from_attribute(grace, "steal-time-following", float)
+    if steal_prc is not None:
+        steal_proportion = steal_prc / 100
+        grace_type = "appoggiatura"
+
+    steal_prc = get_value_from_attribute(grace, "steal-time-previous", float)
+    if steal_prc is not None:
+        steal_proportion = steal_prc / 100
+        grace_type = "acciaccatura"
+
+    return grace_type, steal_proportion
+
+
+def get_articulations(e):
+    # <!ELEMENT articulations
+    # 	((accent | strong-accent | staccato | tenuto |
+    # 	  detached-legato | staccatissimo | spiccato |
+    # 	  scoop | plop | doit | falloff | breath-mark |
+    # 	  caesura | stress | unstress | soft-accent |
+    # 	  other-articulation)*)>
+    articulations = (
+        "accent",
+        "strong-accent",
+        "staccato",
+        "tenuto",
+        "detached-legato",
+        "staccatissimo",
+        "spiccato",
+        "scoop",
+        "plop",
+        "doit",
+        "falloff",
+        "breath-mark",
+        "caesura",
+        "stress",
+        "unstress",
+        "soft-accent",
+    )
+    return [a for a in articulations if e.find(a) is not None]
+
+
+def get_ornaments(e):
+    #  ornaments elements:
+    #  trill-mark
+    #  turn
+    #  delayed-turn
+    #  inverted-turn
+    #  delayed-inverted-turn
+    #  vertical-turn
+    #  inverted-vertical-turn
+    #  shake
+    #  wavy-line
+    #  mordent
+    #  inverted-mordent
+    #  schleifer
+    #  tremolo
+    #  haydn
+    #  other-ornament
+
+    ornaments = (
+        "trill-mark",
+        "turn",
+        "delayed-turn",
+        "inverted-turn",
+        "delayed-inverted-turn",
+        "vertical-turn",
+        "inverted-vertical-turn",
+        "shake",
+        "wavy-line",
+        "mordent",
+        "inverted-mordent",
+        "schleifer",
+        "tremolo",
+        "haydn",
+        "other-ornament",
+    )
+    return [a for a in ornaments if e.find(a) is not None]
+
+
+@deprecated_alias(fn="filename")
+def musicxml_to_notearray(
+    filename,
+    flatten_parts=True,
+    include_pitch_spelling=False,
+    include_key_signature=False,
+    include_time_signature=False,
+):
+    """Return pitch, onset, and duration information for notes from a
+    MusicXML file as a structured array.
+
+    By default a single array is returned by combining the note
+    information of all parts in the MusicXML file.
+
+    Parameters
+    ----------
+    fn : str
+        Path to a MusicXML file
+    flatten_parts : bool
+        If `True`, returns a single array containing all notes.
+        Otherwise, returns a list of arrays for each part.
+    include_pitch_spelling : bool (optional)
+        If `True`, includes pitch spelling information for each
+        note. Default is False
+    include_key_signature : bool (optional)
+        If `True`, includes key signature information, i.e.,
+        the key signature at the onset time of each note (all
+        notes starting at the same time have the same key signature).
+        Default is False
+    include_time_signature : bool (optional)
+        If `True`,  includes time signature information, i.e.,
+        the time signature at the onset time of each note (all
+        notes starting at the same time have the same time signature).
+        Default is False
+
+    Returns
+    -------
+    note_arrays : structured array or list of structured arrays
+        Structured array or list of structured arrays containing
+        score information.
+    """
+
+    scr = load_musicxml(
+        filename=filename,
+        force_note_ids="keep",
+    )
+
+    note_arrays = []
+    for part in scr.parts:
+        # Unfold any repetitions in part
+        unfolded_part = score.unfold_part_maximal(part)
+        # Compute note array
+        note_array = ensure_notearray(
+            notearray_or_part=unfolded_part,
+            include_pitch_spelling=include_pitch_spelling,
+            include_key_signature=include_key_signature,
+            include_time_signature=include_time_signature,
+        )
+        note_arrays.append(note_array)
+
+    if len(note_arrays) == 1:
+        return note_arrays[0]
+    elif len(note_arrays) > 1 and flatten_parts:
+        return np.hstack(note_arrays)
+    else:
+        return note_arrays
```

### Comparing `partitura-1.2.1/partitura/io/importparangonada.py` & `partitura-1.2.2/partitura/io/importparangonada.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,209 +1,209 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for parsing Parangonada csv files
-"""
-import os
-import numpy as np
-
-from typing import List
-
-from partitura.performance import PerformedPart, Performance
-from partitura.utils.misc import PathLike, deprecated_alias
-
-NOTE_ARRAY_DTYPES = dict(
-    onset_sec=("onset_sec", "f4"),
-    duration_sec=("duration_sec", "f4"),
-    onset_beat=("onset_beat", "f4"),
-    duration_beat=("duration_beat", "f4"),
-    onset_quarter=("onset_quarter", "f4"),
-    duration_quarter=("duration_quarter", "f4"),
-    onset_div=("onset_div", "i4"),
-    duration_div=("duration_div", "i4"),
-    pitch=("pitch", "i4"),
-    voice=("voice", "i4"),
-    velocity=("velocity", "i4"),
-    track=("track", "i4"),
-    channel=("channel", "i4"),
-    id=("id", "U256"),
-)
-
-__all__ = [
-    "load_parangonada_alignment",
-    "load_parangonada_csv",
-]
-
-
-def _load_csv(filename: PathLike) -> np.ndarray:
-    """
-    Load a CSV file where the headers are one of the note array columns
-    and return a structured array
-
-    Parameters
-    ----------
-    filename: PathLike
-        Path of the CSV file
-
-
-    Returns
-    -------
-    struct_array: np.ndarray
-        Structured array
-    """
-    raw_array = np.loadtxt(
-        fname=filename,
-        delimiter=",",
-        comments=None,
-        dtype=str,
-    )
-
-    columns = raw_array[0]
-    dtypes = [NOTE_ARRAY_DTYPES.get(c, (c, "U256")) for c in columns]
-
-    struct_array = np.empty(len(raw_array) - 1, dtype=dtypes)
-    for i, (c, dt) in enumerate(zip(columns, dtypes)):
-
-        if dt[-1] == "i4":
-            # Weird behavior trying to cast 0.0 as an integer
-            struct_array[c] = raw_array[1:, i].astype(float).astype(int)
-        else:
-            struct_array[c] = raw_array[1:, i].astype(dt[-1])
-
-    return struct_array
-
-
-@deprecated_alias(outfile="filename")
-def load_parangonada_alignment(filename) -> List[dict]:
-    """
-    load an alignment exported from parangonda.
-
-    Parameters
-    ----------
-    filename : str
-        A path to the alignment csv file
-
-    Returns
-    -------
-    alignment : list
-        A list of note alignment dictionaries.
-    """
-    array = np.loadtxt(filename, dtype=str, delimiter=",")
-    alignment = list()
-    # match = 0, deletion  = 1, insertion = 2
-    for k in range(1, array.shape[0]):
-        if int(array[k, 1]) == 0:
-            alignment.append(
-                {
-                    "label": "match",
-                    "score_id": array[k, 2],
-                    "performance_id": array[k, 3],
-                }
-            )
-
-        elif int(array[k, 1]) == 2:
-            alignment.append({"label": "insertion", "performance_id": array[k, 3]})
-
-        elif int(array[k, 1]) == 1:
-            alignment.append({"label": "deletion", "score_id": array[k, 2]})
-    return alignment
-
-
-def load_parangonada_csv(dirname: PathLike, create_score: bool = False) -> np.ndarray:
-    """
-    Load Parangonada Project alignment files
-
-    Parameters
-    ----------
-    dirname : PathLike
-        Directory with the CSV files in Parangonada
-    create_score: bool
-        Create a score. For now it just creats a note array, but the argument
-        name was chosen to be consistent with `load_match`.
-
-    Returns
-    -------
-    performance : partitura.performance.Performance
-        The performance in the alignment
-    alignment : List of dict
-        The main alignment
-    zalignment : List of dict
-        The secondary alignment (for comparing the first one)
-    feature : np.ndarray
-        A structured array with note-level feature information
-    score_note_array
-        A note array containing note information in the score. Will change to a
-        score object in a future release!
-    """
-    # Will the names change in the future?
-    perf_note_array_fn = os.path.join(dirname, "ppart.csv")
-    score_note_array_fn = os.path.join(dirname, "part.csv")
-    alignment_fn = os.path.join(dirname, "align.csv")
-    feature_fn = os.path.join(dirname, "feature.csv")
-    zalign_fn = os.path.join(dirname, "zalign.csv")
-
-    perf_note_array = _load_csv(perf_note_array_fn)
-
-    performed_part = PerformedPart.from_note_array(perf_note_array)
-    performance = Performance(
-        performedparts=performed_part,
-        id=dirname,
-    )
-
-    feature = _load_csv(feature_fn)
-    alignment = load_parangonada_alignment(alignment_fn)
-    zalignment = load_parangonada_alignment(zalign_fn)
-
-    if create_score:
-        # TODO: Generate a Score
-        score_note_array = _load_csv(score_note_array_fn)
-
-        return (
-            performance,
-            alignment,
-            zalignment,
-            feature,
-            score_note_array,
-        )
-
-    else:
-        return (
-            performance,
-            alignment,
-            zalignment,
-            feature,
-        )
-
-
-@deprecated_alias(outfile="filename")
-def load_alignment_from_ASAP(filename: PathLike) -> List[dict]:
-    """
-    load a note alignment of the ASAP dataset.
-
-    Parameters
-    ----------
-    filename : str
-        A path to the alignment tsv file
-
-    Returns
-    -------
-    alignment : list
-        A list of note alignment dictionaries.
-    """
-    alignment = list()
-    with open(filename, "r") as f:
-        for line in f.readlines():
-            fields = line.split("\t")
-            if fields[0][0] == "n" and "deletion" not in fields[1]:
-                alignment.append(
-                    {
-                        "label": "match",
-                        "score_id": fields[0],
-                        "performance_id": fields[1],
-                    }
-                )
-            elif fields[0] == "insertion":
-                alignment.append({"label": "insertion", "performance_id": fields[1]})
-            elif fields[0][0] == "n" and "deletion" in fields[1]:
-                alignment.append({"label": "deletion", "score_id": fields[0]})
-
-    return alignment
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for parsing Parangonada csv files
+"""
+import os
+import numpy as np
+
+from typing import List
+
+from partitura.performance import PerformedPart, Performance
+from partitura.utils.misc import PathLike, deprecated_alias
+
+NOTE_ARRAY_DTYPES = dict(
+    onset_sec=("onset_sec", "f4"),
+    duration_sec=("duration_sec", "f4"),
+    onset_beat=("onset_beat", "f4"),
+    duration_beat=("duration_beat", "f4"),
+    onset_quarter=("onset_quarter", "f4"),
+    duration_quarter=("duration_quarter", "f4"),
+    onset_div=("onset_div", "i4"),
+    duration_div=("duration_div", "i4"),
+    pitch=("pitch", "i4"),
+    voice=("voice", "i4"),
+    velocity=("velocity", "i4"),
+    track=("track", "i4"),
+    channel=("channel", "i4"),
+    id=("id", "U256"),
+)
+
+__all__ = [
+    "load_parangonada_alignment",
+    "load_parangonada_csv",
+]
+
+
+def _load_csv(filename: PathLike) -> np.ndarray:
+    """
+    Load a CSV file where the headers are one of the note array columns
+    and return a structured array
+
+    Parameters
+    ----------
+    filename: PathLike
+        Path of the CSV file
+
+
+    Returns
+    -------
+    struct_array: np.ndarray
+        Structured array
+    """
+    raw_array = np.loadtxt(
+        fname=filename,
+        delimiter=",",
+        comments=None,
+        dtype=str,
+    )
+
+    columns = raw_array[0]
+    dtypes = [NOTE_ARRAY_DTYPES.get(c, (c, "U256")) for c in columns]
+
+    struct_array = np.empty(len(raw_array) - 1, dtype=dtypes)
+    for i, (c, dt) in enumerate(zip(columns, dtypes)):
+
+        if dt[-1] == "i4":
+            # Weird behavior trying to cast 0.0 as an integer
+            struct_array[c] = raw_array[1:, i].astype(float).astype(int)
+        else:
+            struct_array[c] = raw_array[1:, i].astype(dt[-1])
+
+    return struct_array
+
+
+@deprecated_alias(outfile="filename")
+def load_parangonada_alignment(filename) -> List[dict]:
+    """
+    load an alignment exported from parangonda.
+
+    Parameters
+    ----------
+    filename : str
+        A path to the alignment csv file
+
+    Returns
+    -------
+    alignment : list
+        A list of note alignment dictionaries.
+    """
+    array = np.loadtxt(filename, dtype=str, delimiter=",")
+    alignment = list()
+    # match = 0, deletion  = 1, insertion = 2
+    for k in range(1, array.shape[0]):
+        if int(array[k, 1]) == 0:
+            alignment.append(
+                {
+                    "label": "match",
+                    "score_id": array[k, 2],
+                    "performance_id": array[k, 3],
+                }
+            )
+
+        elif int(array[k, 1]) == 2:
+            alignment.append({"label": "insertion", "performance_id": array[k, 3]})
+
+        elif int(array[k, 1]) == 1:
+            alignment.append({"label": "deletion", "score_id": array[k, 2]})
+    return alignment
+
+
+def load_parangonada_csv(dirname: PathLike, create_score: bool = False) -> np.ndarray:
+    """
+    Load Parangonada Project alignment files
+
+    Parameters
+    ----------
+    dirname : PathLike
+        Directory with the CSV files in Parangonada
+    create_score: bool
+        Create a score. For now it just creats a note array, but the argument
+        name was chosen to be consistent with `load_match`.
+
+    Returns
+    -------
+    performance : partitura.performance.Performance
+        The performance in the alignment
+    alignment : List of dict
+        The main alignment
+    zalignment : List of dict
+        The secondary alignment (for comparing the first one)
+    feature : np.ndarray
+        A structured array with note-level feature information
+    score_note_array
+        A note array containing note information in the score. Will change to a
+        score object in a future release!
+    """
+    # Will the names change in the future?
+    perf_note_array_fn = os.path.join(dirname, "ppart.csv")
+    score_note_array_fn = os.path.join(dirname, "part.csv")
+    alignment_fn = os.path.join(dirname, "align.csv")
+    feature_fn = os.path.join(dirname, "feature.csv")
+    zalign_fn = os.path.join(dirname, "zalign.csv")
+
+    perf_note_array = _load_csv(perf_note_array_fn)
+
+    performed_part = PerformedPart.from_note_array(perf_note_array)
+    performance = Performance(
+        performedparts=performed_part,
+        id=dirname,
+    )
+
+    feature = _load_csv(feature_fn)
+    alignment = load_parangonada_alignment(alignment_fn)
+    zalignment = load_parangonada_alignment(zalign_fn)
+
+    if create_score:
+        # TODO: Generate a Score
+        score_note_array = _load_csv(score_note_array_fn)
+
+        return (
+            performance,
+            alignment,
+            zalignment,
+            feature,
+            score_note_array,
+        )
+
+    else:
+        return (
+            performance,
+            alignment,
+            zalignment,
+            feature,
+        )
+
+
+@deprecated_alias(outfile="filename")
+def load_alignment_from_ASAP(filename: PathLike) -> List[dict]:
+    """
+    load a note alignment of the ASAP dataset.
+
+    Parameters
+    ----------
+    filename : str
+        A path to the alignment tsv file
+
+    Returns
+    -------
+    alignment : list
+        A list of note alignment dictionaries.
+    """
+    alignment = list()
+    with open(filename, "r") as f:
+        for line in f.readlines():
+            fields = line.split("\t")
+            if fields[0][0] == "n" and "deletion" not in fields[1]:
+                alignment.append(
+                    {
+                        "label": "match",
+                        "score_id": fields[0],
+                        "performance_id": fields[1],
+                    }
+                )
+            elif fields[0] == "insertion":
+                alignment.append({"label": "insertion", "performance_id": fields[1]})
+            elif fields[0][0] == "n" and "deletion" in fields[1]:
+                alignment.append({"label": "deletion", "score_id": fields[0]})
+
+    return alignment
```

### Comparing `partitura-1.2.1/partitura/io/matchfile_base.py` & `partitura-1.2.2/partitura/io/matchfile_base.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,1201 +1,1202 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains base classes for Match lines and utilities for
-parsing and formatting match lines.
-"""
-from __future__ import annotations
-
-from typing import Callable, Tuple, Any, Optional, Union, Dict, List, Iterable
-import re
-
-import numpy as np
-
-from partitura.utils.music import (
-    pitch_spelling_to_midi_pitch,
-    ensure_pitch_spelling_format,
-    ALTER_SIGNS,
-)
-
-from partitura.io.matchfile_utils import (
-    Version,
-    interpret_as_string,
-    format_string,
-    interpret_as_float,
-    format_float,
-    format_float_unconstrained,
-    interpret_as_int,
-    format_int,
-    FractionalSymbolicDuration,
-    format_fractional,
-    interpret_as_fractional,
-    interpret_as_list,
-    interpret_as_list_int,
-    format_list,
-    MatchKeySignature,
-    MatchTimeSignature,
-)
-
-from partitura.utils.misc import (
-    PathLike,
-    deprecated_alias,
-)
-
-
-class MatchError(Exception):
-    """
-    Base exception for parsing match files.
-    """
-
-    pass
-
-
-class MatchLine(object):
-    """
-    Base class for representing match lines.
-
-    This class should be subclassed for the different match lines.
-
-    Parameters
-    ----------
-    version : Version
-        Indicate the version of the match line.
-
-    Attributes
-    ----------
-    version: Version
-        The version of the match line.
-    field_names: Tuple[str]
-        The names of the different fields with information in the match line.
-    field_types : Tuple[type]
-        The data type of the different fields.
-    out_pattern : str
-        The output pattern for the match line (i.e., how the match line looks like
-        in a match file).
-    pattern : re.Pattern
-        Regular expression to parse information from a string.
-    format_fun: Dict[str, Callable]
-        A dictionary of methods for formatting the values of each field name.
-    """
-
-    # Version of the match line
-    version: Version
-
-    # Field names that appear in the match line
-    # A match line will generally have these
-    # field names as attributes.
-    # Following the original Prolog-based specification
-    # the names of the attributes start with upper-case letters
-    field_names: Tuple[str]
-
-    # type of the information in the fields
-    field_types: Tuple[Union[type, Tuple[type]]]
-
-    # Output pattern
-    out_pattern: str
-
-    # A dictionary of callables for each field name
-    # the callables should get the value of the input
-    # and return a string formatted for the matchfile.
-    format_fun: Union[
-        Dict[str, Callable[Any, str]],
-        Tuple[Dict[str, Callable[Any, str]]],
-    ]
-
-    # Regular expression to parse
-    # information from a string.
-    pattern: Union[re.Pattern, Tuple[re.Pattern]]
-
-    def __init__(self, version: Version) -> None:
-        # Subclasses need to initialize the other
-        # default field names
-        self.version = version
-
-    def __str__(self) -> str:
-        """
-        Prints the printing the match line
-        """
-        r = [self.__class__.__name__]
-        for fn in self.field_names:
-            r.append(" {0}: {1}".format(fn, self.__dict__[fn]))
-        return "\n".join(r) + "\n"
-
-    @property
-    def matchline(self) -> str:
-        """
-        Generate matchline as a string.
-
-        This method can be adapted as needed by subclasses.
-        """
-        matchline = self.out_pattern.format(
-            **dict(
-                [
-                    (field, self.format_fun[field](getattr(self, field)))
-                    for field in self.field_names
-                ]
-            )
-        )
-
-        return matchline
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version,
-    ) -> MatchLine:
-        """
-        Create a new MatchLine object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        version : Version
-            Version of the matchline
-
-        Returns
-        -------
-        a MatchLine instance
-        """
-        raise NotImplementedError  # pragma: no cover
-
-    def check_types(self, verbose: bool = False) -> bool:
-        """
-        Check whether the values of the fields are of the correct type.
-
-        Parameters
-        ----------
-        verbose : bool
-            Prints whether each of the attributes in field_names has the correct dtype.
-            values are
-
-        Returns
-        -------
-        types_are_correct : bool
-            True if the values of all fields in the match line have the
-            correct type.
-        """
-        types_are_correct_list = [
-            isinstance(getattr(self, field), field_type)
-            for field, field_type in zip(self.field_names, self.field_types)
-        ]
-        if verbose:
-            print(list(zip(self.field_names, types_are_correct_list)))
-
-        types_are_correct = all(types_are_correct_list)
-        return types_are_correct
-
-
-## The following classes define base information for match lines
-## These classes need to be subclassed in the corresponding module for each version.
-
-
-class BaseInfoLine(MatchLine):
-    """
-    Base class specifying global information lines.
-
-    These lines have the general structure "info(<Attribute>,<Value>)."
-    Which attributes are valid depending on the version of the match line.
-
-    Parameters
-    ----------
-    version : Version
-        The version of the info line.
-    attribute: str
-        Name of the attribute
-    value: Any
-        Value of the attribute
-    value_type: type
-        Type of the value
-    format_fun: callable
-        A function for maping values to the attribute to strings (for formatting
-        the output matchline)
-    """
-
-    # Base field names (can be updated in subclasses).
-    # "attribute" will have type str, but the type of value needs to be specified
-    # during initialization.
-    field_names = ("Attribute", "Value")
-
-    out_pattern = "info({Attribute},{Value})."
-
-    pattern = re.compile(r"info\((?P<Attribute>[^,]+),(?P<Value>.+)\)\.")
-
-    def __init__(
-        self,
-        version: Version,
-        attribute: str,
-        value: Any,
-        value_type: type,
-        format_fun: Callable[Any, str],
-    ) -> None:
-        super().__init__(version)
-
-        self.field_types = (str, value_type)
-        self.format_fun = dict(Attribute=format_string, Value=format_fun)
-        self.Attribute = attribute
-        self.Value = value
-
-
-class BaseStimeLine(MatchLine):
-    """
-    Base class for specifying stime lines. These lines should looke like
-
-    stime(<Measure>:<Beat>,<Offset>,<OnsetInBeats>,<AnnotationType>)
-
-    Parameters
-    ----------
-    version: Version
-        The version of the matchline
-    measure: int
-        The measure number
-    beat: int
-        The beat within the measure (first beat starts at 1)
-    offset: FractionalSymbolicDuration
-        The offset of the event with respect to the current beat.
-    onset_in_beats: float
-        Onset in beats
-    annotation_type: List[str]
-        List of annotation types for the score time.
-    """
-
-    field_names = ("Measure", "Beat", "Offset", "OnsetInBeats", "AnnotationType")
-
-    field_types = (int, int, FractionalSymbolicDuration, float, list)
-
-    format_fun = dict(
-        Measure=format_int,
-        Beat=format_int,
-        Offset=format_fractional,
-        OnsetInBeats=format_float,
-        AnnotationType=format_list,
-    )
-
-    out_pattern = "stime({Measure}:{Beat},{Offset},{OnsetInBeats},{AnnotationType})"
-
-    pattern = re.compile(
-        r"stime\("
-        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<OnsetInBeats>[^,]+),"
-        r"\[(?P<AnnotationType>[a-z,]*)\]\)"
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        onset_in_beats: float,
-        annotation_type: List[str],
-    ) -> None:
-        super().__init__(version)
-
-        self.Measure = measure
-        self.Beat = beat
-        self.Offset = offset
-        self.OnsetInBeats = onset_in_beats
-        self.AnnotationType = annotation_type
-
-
-class BasePtimeLine(MatchLine):
-    """
-    Base class for specifying performance time. Tese lines have the form
-
-    ptime([<Onsets>])
-
-    Parameters
-    ----------
-    version: Version
-        The version of the matchline
-    onsets: List[int]
-        The list of onsets.
-    """
-
-    field_names = ("Onsets",)
-    field_types = (list,)
-
-    out_pattern = "ptime({Onsets})."
-
-    pattern = re.compile(r"ptime\(\[(?P<Onsets>[0-9,]+)\]\)\.")
-
-    format_fun = dict(Onsets=format_list)
-
-    def __init__(self, version: Version, onsets: List[int]) -> None:
-        super().__init__(version)
-        self.Onsets = onsets
-
-    @property
-    def Onset(self) -> float:
-        """
-        Average onset time
-        """
-        return np.mean(self.Onsets)
-
-
-class BaseStimePtimeLine(MatchLine):
-    """
-    Base class for represeting score-to-performance time alignments
-
-    Parameters
-    ----------
-    version: Version
-        The version of the matchline
-    stime: BaseStimeLine
-        Score time as a BaseStimeLine instance.
-    ptime: BasePtimeLine
-        Performance time as a BasePtimeLine instance.
-    """
-    out_pattern = "{StimeLine}-{PtimeLine}"
-
-    def __init__(
-        self,
-        version: Version,
-        stime: BaseStimeLine,
-        ptime: BasePtimeLine,
-    ) -> None:
-        super().__init__(version)
-
-        self.stime = stime
-        self.ptime = ptime
-
-        self.field_names = self.stime.field_names + self.ptime.field_names
-        self.field_types = self.stime.field_types + self.ptime.field_types
-
-        self.pattern = (self.stime.pattern, self.ptime.pattern)
-
-        self.format_fun = (self.stime.format_fun, self.ptime.format_fun)
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            StimeLine=self.stime.matchline,
-            PtimeLine=self.ptime.matchline,
-        )
-
-    def __str__(self) -> str:
-        """
-        String magic method
-        """
-        r = [self.__class__.__name__]
-        r += [" Stime"] + [
-            "   {0}: {1}".format(fn, getattr(self.stime, fn, None))
-            for fn in self.stime.field_names
-        ]
-
-        r += [" Ptime"] + [
-            "   {0}: {1}".format(fn, getattr(self.ptime, fn, None))
-            for fn in self.ptime.field_names
-        ]
-
-        return "\n".join(r) + "\n"
-
-    def check_types(self, verbose: bool) -> bool:
-        """
-        Check whether the values of the fields are of the correct type.
-
-        Parameters
-        ----------
-        verbose : bool
-            Prints whether each of the attributes in field_names has the correct dtype.
-            values are
-
-        Returns
-        -------
-        types_are_correct : bool
-            True if the values of all fields in the match line have the
-            correct type.
-        """
-
-        stime_types_are_correct = self.stime.check_types(verbose)
-        ptime_types_are_correct = self.ptime.check_types(verbose)
-
-        types_are_correct = stime_types_are_correct and ptime_types_are_correct
-
-        return types_are_correct
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        stime_class: BaseStimeLine,
-        ptime_class: BaseNoteLine,
-        version: Version,
-    ) -> Dict:
-        stime = stime_class.from_matchline(matchline, version=version)
-        ptime = ptime_class.from_matchline(matchline, version=version)
-
-        kwargs = dict(
-            version=version,
-            stime=stime,
-            ptime=ptime,
-        )
-
-        return kwargs
-
-
-# deprecate bar for measure
-class BaseSnoteLine(MatchLine):
-    """
-    Base class to represent score notes.
-
-    Parameters
-    ----------
-    version: Version
-    anchor: str
-    note_name: str
-    modifier: str
-    octave: Optional[int]
-    measure: int
-    beat: int
-    offset: FractionalSymbolicDuration
-    duration: FractionalSymbolicDuration
-    onset_in_beats: float
-    offset_in_beats: float
-    score_attributes_list: List[str]
-
-    Attributes
-    ----------
-    DurationInBeats : float
-    DurationSymbolic : float
-    MidiPitch : float
-
-    Notes
-    -----
-    * The snote line has not changed much since the first version of
-      the Match file format. New versions are just more explicit in the
-      the formatting of the attributes (field names), e.g., NoteName
-      should always be uppercase starting from version 1.0.0, etc.
-    """
-
-    # All derived classes should include
-    # at least these field names
-    field_names = (
-        "Anchor",
-        "NoteName",
-        "Modifier",
-        "Octave",
-        "Measure",
-        "Beat",
-        "Offset",
-        "Duration",
-        "OnsetInBeats",
-        "OffsetInBeats",
-        "ScoreAttributesList",
-    )
-
-    field_types = (
-        str,
-        str,
-        (int, type(None)),
-        (int, type(None)),
-        int,
-        int,
-        FractionalSymbolicDuration,
-        FractionalSymbolicDuration,
-        float,
-        float,
-        list,
-    )
-
-    out_pattern = (
-        "snote({Anchor},[{NoteName},{Modifier}],{Octave},"
-        "{Measure}:{Beat},{Offset},{Duration},{OnsetInBeats},"
-        "{OffsetInBeats},{ScoreAttributesList})"
-    )
-
-    pattern = re.compile(
-        r"snote\("
-        r"(?P<Anchor>[^,]+),"
-        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
-        r"(?P<Octave>[^,]+),"
-        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<Duration>[^,]+),"
-        r"(?P<OnsetInBeats>[^,]+),"
-        r"(?P<OffsetInBeats>[^,]+),"
-        r"\[(?P<ScoreAttributesList>.*)\]\)"
-    )
-
-    format_fun = dict(
-        Anchor=format_string,
-        NoteName=lambda x: str(x).upper(),
-        Modifier=lambda x: "n" if x == 0 else ALTER_SIGNS[x],
-        Octave=format_int,
-        Measure=format_int,
-        Beat=format_int,
-        Offset=format_fractional,
-        Duration=format_fractional,
-        OnsetInBeats=format_float_unconstrained,
-        OffsetInBeats=format_float_unconstrained,
-        ScoreAttributesList=format_list,
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        anchor: str,
-        note_name: str,
-        modifier: str,
-        octave: Optional[int],
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        duration: FractionalSymbolicDuration,
-        onset_in_beats: float,
-        offset_in_beats: float,
-        score_attributes_list: List[str],
-    ) -> None:
-        super().__init__(version)
-
-        # All of these attributes should have the
-        # correct dtype (otherwise we need to be constantly
-        # checking the types).
-        self.Anchor = anchor
-        self.NoteName = note_name
-        self.Modifier = modifier
-        self.Octave = octave
-        self.Measure = measure
-        self.Beat = beat
-        self.Offset = offset
-        self.Duration = duration
-        self.OnsetInBeats = onset_in_beats
-        self.OffsetInBeats = offset_in_beats
-        self.ScoreAttributesList = score_attributes_list
-
-    @property
-    def DurationInBeats(self) -> float:
-        return self.OffsetInBeats - self.OnsetInBeats
-
-    @property
-    def DurationSymbolic(self) -> str:
-        # Duration should always be a FractionalSymbolicDuration
-        return str(self.Duration)
-
-    @property
-    def Bar(self) -> int:
-        # deprecatd property measure
-        return self.Measure
-
-    @property
-    def MidiPitch(self) -> Optional[int]:
-        if isinstance(self.Octave, int):
-            return pitch_spelling_to_midi_pitch(
-                step=self.NoteName, octave=self.Octave, alter=self.Modifier
-            )
-        else:
-            return None
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-    ) -> Dict:
-
-        match_pattern = cls.pattern.search(matchline, pos)
-
-        if match_pattern is not None:
-
-            (
-                anchor_str,
-                note_name_str,
-                modifier_str,
-                octave_str,
-                measure_str,
-                beat_str,
-                offset_str,
-                duration_str,
-                onset_in_beats_str,
-                offset_in_beats_str,
-                score_attributes_list_str,
-            ) = match_pattern.groups()
-
-            anchor = interpret_as_string(anchor_str)
-            note_name, modifier, octave = ensure_pitch_spelling_format(
-                step=note_name_str,
-                alter=modifier_str,
-                octave=octave_str,
-            )
-
-            return dict(
-                anchor=interpret_as_string(anchor),
-                note_name=note_name,
-                modifier=modifier,
-                octave=octave,
-                measure=interpret_as_int(measure_str),
-                beat=interpret_as_int(beat_str),
-                offset=interpret_as_fractional(offset_str),
-                duration=interpret_as_fractional(duration_str),
-                onset_in_beats=interpret_as_float(onset_in_beats_str),
-                offset_in_beats=interpret_as_float(offset_in_beats_str),
-                score_attributes_list=interpret_as_list(score_attributes_list_str),
-            )
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-
-class BaseNoteLine(MatchLine):
-
-    # All derived classes should include at least
-    # these field names
-    field_names = (
-        "Id",
-        "Onset",
-        "Offset",
-        "Velocity",
-    )
-
-    field_types = (
-        str,
-        int,
-        float,
-        float,
-        int,
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        id: str,
-        midi_pitch: int,
-        onset: float,
-        offset: float,
-        velocity: int,
-    ) -> None:
-        super().__init__(version)
-        self.Id = id
-        # The MIDI pitch is not a part of all
-        # note versions. For versions < 1.0.0
-        # it needs to be inferred from pitch spelling.
-        self.MidiPitch = midi_pitch
-        self.Onset = onset
-        self.Offset = offset
-        self.Velocity = velocity
-
-    @property
-    def Duration(self):
-        return self.Offset - self.Onset
-
-
-class BaseSnoteNoteLine(MatchLine):
-
-    out_pattern = "{SnoteLine}-{NoteLine}"
-
-    def __init__(
-        self,
-        version: Version,
-        snote: BaseSnoteLine,
-        note: BaseNoteLine,
-    ) -> None:
-
-        super().__init__(version)
-
-        self.snote = snote
-        self.note = note
-
-        self.field_names = self.snote.field_names + self.note.field_names
-
-        self.field_types = self.snote.field_types + self.note.field_types
-
-        self.pattern = (self.snote.pattern, self.note.pattern)
-
-        self.format_fun = (self.snote.format_fun, self.note.format_fun)
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            SnoteLine=self.snote.matchline,
-            NoteLine=self.note.matchline,
-        )
-
-    def __str__(self) -> str:
-
-        """
-        Prints the printing the match line
-        """
-        r = [self.__class__.__name__]
-        r += [" Snote"] + [
-            "   {0}: {1}".format(fn, getattr(self.snote, fn, None))
-            for fn in self.snote.field_names
-        ]
-
-        r += [" Note"] + [
-            "   {0}: {1}".format(fn, getattr(self.note, fn, None))
-            for fn in self.note.field_names
-        ]
-
-        return "\n".join(r) + "\n"
-
-    def check_types(self, verbose: bool = False) -> bool:
-        """
-        Check whether the values of the fields are of the correct type.
-
-        Parameters
-        ----------
-        verbose : bool
-            Prints whether each of the attributes in field_names has the correct dtype.
-            values are
-
-        Returns
-        -------
-        types_are_correct : bool
-            True if the values of all fields in the match line have the
-            correct type.
-        """
-        snote_types_are_correct = self.snote.check_types(verbose)
-        note_types_are_correct = self.note.check_types(verbose)
-
-        types_are_correct = snote_types_are_correct and note_types_are_correct
-
-        return types_are_correct
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        snote_class: BaseSnoteLine,
-        note_class: BaseNoteLine,
-        version: Version,
-    ) -> Dict:
-        snote = snote_class.from_matchline(matchline, version=version)
-        note = note_class.from_matchline(matchline, version=version)
-
-        kwargs = dict(
-            version=version,
-            snote=snote,
-            note=note,
-        )
-
-        return kwargs
-
-
-class BaseDeletionLine(MatchLine):
-
-    out_pattern = "{SnoteLine}-deletion."
-
-    def __init__(self, version: Version, snote: BaseSnoteLine) -> None:
-
-        super().__init__(version)
-
-        self.snote = snote
-
-        self.field_names = self.snote.field_names
-
-        self.field_types = self.snote.field_types
-
-        self.pattern = re.compile(rf"{self.snote.pattern.pattern}-deletion\.")
-
-        self.format_fun = self.snote.format_fun
-
-        for fn in self.field_names:
-            setattr(self, fn, getattr(self.snote, fn))
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            SnoteLine=self.snote.matchline,
-        )
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        snote_class: BaseSnoteLine,
-        version: Version,
-    ) -> Dict:
-
-        snote = snote_class.from_matchline(matchline, version=version)
-
-        kwargs = dict(
-            version=version,
-            snote=snote,
-        )
-
-        return kwargs
-
-
-class BaseInsertionLine(MatchLine):
-
-    out_pattern = "insertion-{NoteLine}"
-
-    def __init__(self, version: Version, note: BaseNoteLine) -> None:
-
-        super().__init__(version)
-
-        self.note = note
-
-        self.field_names = self.note.field_names
-
-        self.field_types = self.note.field_types
-
-        self.pattern = re.compile(f"insertion-{self.note.pattern.pattern}")
-
-        self.format_fun = self.note.format_fun
-
-        for fn in self.field_names:
-            setattr(self, fn, getattr(self.note, fn))
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            NoteLine=self.note.matchline,
-        )
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        note_class: BaseNoteLine,
-        version: Version,
-    ) -> Dict:
-
-        note = note_class.from_matchline(matchline, version=version)
-
-        kwargs = dict(
-            version=version,
-            note=note,
-        )
-
-        return kwargs
-
-
-class BaseOrnamentLine(MatchLine):
-
-    # These field names and types need to be expanded
-    # with the attributes of the note
-    field_names = ("Anchor",)
-    field_types = (str,)
-    format_fun = dict(Anchor=format_string)
-    out_pattern = "ornament({Anchor})-{NoteLine}"
-    ornament_pattern: re.Pattern = re.compile(r"ornament\((?P<Anchor>[^\)]*)\)-")
-
-    def __init__(self, version: Version, anchor: str, note: BaseNoteLine) -> None:
-
-        super().__init__(version)
-
-        self.note = note
-
-        self.field_names = self.field_names + self.note.field_names
-
-        self.field_types = self.field_types + self.note.field_types
-
-        self.pattern = (self.ornament_pattern, self.note.pattern)
-
-        self.format_fun = (self.format_fun, self.note.format_fun)
-
-        for fn in self.note.field_names:
-            setattr(self, fn, getattr(self.note, fn))
-
-        self.Anchor = anchor
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            Anchor=self.Anchor,
-            NoteLine=self.note.matchline,
-        )
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        note_class: BaseNoteLine,
-        version: Version,
-    ) -> Dict:
-
-        anchor_pattern = cls.ornament_pattern.search(matchline)
-
-        if anchor_pattern is None:
-            raise MatchError("")
-
-        anchor = interpret_as_string(anchor_pattern.group("Anchor"))
-        note = note_class.from_matchline(matchline, version=version)
-
-        kwargs = dict(
-            version=version,
-            anchor=anchor,
-            note=note,
-        )
-
-        return kwargs
-
-
-class BasePedalLine(MatchLine):
-    """
-    Class for representing a sustain pedal line
-    """
-
-    field_names = ("Time", "Value")
-    field_types = (int, int)
-    base_pattern: str = r"pedal\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\."
-    out_pattern: str = "pedal({Time},{Value})."
-
-    format_fun = dict(
-        Time=format_int,
-        Value=format_int,
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ):
-        super().__init__(version)
-        self.Time = time
-        self.Value = value
-
-    @classmethod
-    def prepare_kwargs_from_matchline(
-        cls,
-        matchline: str,
-        version: Version,
-        pos: int = 0,
-    ) -> Dict:
-
-        kwargs = None
-        # pattern = re.compile(cls.base_pattern.format(pedal_type=pedal_type))
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-
-        if match_pattern is not None:
-
-            time_str, value_str = match_pattern.groups()
-
-            kwargs = dict(
-                version=version,
-                time=interpret_as_int(time_str),
-                value=interpret_as_int(value_str),
-            )
-
-        return kwargs
-
-
-class BaseSustainPedalLine(BasePedalLine):
-
-    pattern = re.compile(r"sustain\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\.")
-    out_pattern: str = "sustain({Time},{Value})."
-
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ):
-        super().__init__(version=version, time=time, value=value)
-
-
-class BaseSoftPedalLine(BasePedalLine):
-
-    pattern = re.compile(r"soft\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\.")
-    out_pattern: str = "soft({Time},{Value})."
-
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ):
-        super().__init__(version=version, time=time, value=value)
-
-
-## MatchFile
-
-# classes that contain score notes
-snote_classes = (BaseSnoteLine, BaseSnoteNoteLine, BaseDeletionLine)
-
-# classes that contain performed notes.
-note_classes = (BaseNoteLine, BaseSnoteNoteLine, BaseInsertionLine)
-
-
-class MatchFile(object):
-    """
-    Class for representing MatchFiles
-    """
-
-    version: Version
-    lines: np.ndarray
-
-    def __init__(self, lines: Iterable[MatchLine]) -> None:
-
-        # check that all lines have the same version
-        same_version = all([line.version == lines[0].version for line in lines])
-
-        if not same_version:
-            raise ValueError("All lines should have the same version")
-
-        self.lines = np.array(lines)
-
-    @property
-    def note_pairs(self) -> List[Tuple[BaseSnoteLine, BaseNoteLine]]:
-        """
-        Return all(snote, note) tuples
-
-        """
-        return [
-            (x.snote, x.note) for x in self.lines if isinstance(x, BaseSnoteNoteLine)
-        ]
-
-    @property
-    def notes(self) -> List[BaseNoteLine]:
-        """
-        Return all performed notes (as MatchNote objects)
-        """
-        return [x.note for x in self.lines if isinstance(x, note_classes)]
-
-    def iter_notes(self) -> BaseNoteLine:
-        """
-        Iterate over all performed notes (as MatchNote objects)
-        """
-        for x in self.lines:
-            if isinstance(x, note_classes):
-                yield x.note
-
-    @property
-    def snotes(self) -> List[BaseSnoteLine]:
-        """
-        Return all score notes (as MatchSnote objects)
-        """
-        return [x.snote for x in self.lines if isinstance(x, snote_classes)]
-
-    def iter_snotes(self) -> BaseSnoteLine:
-        """
-        Iterate over all performed notes (as MatchNote objects)
-        """
-        for x in self.lines:
-            if hasattr(x, "snote"):
-                yield x.snote
-
-    @property
-    def sustain_pedal(self) -> List[BaseSustainPedalLine]:
-        return [line for line in self.lines if isinstance(line, BaseSustainPedalLine)]
-
-    @property
-    def soft_pedal(self) -> List[BasePedalLine]:
-        return [line for line in self.lines if isinstance(line, BaseSoftPedalLine)]
-
-    @property
-    def insertions(self) -> List[BaseNoteLine]:
-        return [x.note for x in self.lines if isinstance(x, BaseInsertionLine)]
-
-    @property
-    def deletions(self) -> List[BaseSnoteLine]:
-        return [x.snote for x in self.lines if isinstance(x, BaseDeletionLine)]
-
-    @property
-    def _info(self) -> List[BaseInfoLine]:
-        """
-        Return all InfoLine objects
-
-        """
-        return [i for i in self.lines if isinstance(i, BaseInfoLine)]
-
-    def info(
-        self, attribute: Optional[str] = None
-    ) -> Union[BaseInfoLine, List[BaseInfoLine]]:
-        """
-        Return the value of the MatchInfo object corresponding to
-        attribute, or None if there is no such object
-
-        : param attribute: the name of the attribute to return the value for
-
-        """
-        if attribute:
-            try:
-                idx = [i.Attribute for i in self._info].index(attribute)
-                return self._info[idx].Value
-            except ValueError:
-                return None
-        else:
-            return self._info
-
-    @property
-    def first_onset(self) -> float:
-        return min([n.OnsetInBeats for n in self.snotes])
-
-    @property
-    def first_measure(self) -> float:
-        return min([n.Measure for n in self.snotes])
-
-    @property
-    def time_signatures(self):
-        """
-        A list of tuples(t, b, (n, d)), indicating a time signature of
-        n over v, starting at t in bar b
-
-        """
-        _tsigs = [
-            (
-                getattr(tsl, "TimeInBeats", self.first_onset),
-                getattr(tsl, "Measure", self.first_measure),
-                tsl.Value,
-            )
-            for tsl in self.time_sig_lines
-        ]
-
-        _tsigs.sort(key=lambda x: x[0])
-
-        tsigs = []
-        if len(_tsigs) > 0:
-            tsigs.append(_tsigs[0])
-
-            for k in _tsigs:
-                if k[2] != tsigs[-1][2]:
-                    tsigs.append(k)
-
-        return tsigs
-
-    @property
-    def time_sig_lines(self):
-        ml = [
-            line
-            for line in self.lines
-            if getattr(line, "Attribute", None) == "timeSignature"
-        ]
-        return ml
-
-    @property
-    def key_signatures(self):
-        """
-        A list of tuples (t, b, (ks,)) or (t, b, (ks1, ks2))
-        """
-        _keysigs = [
-            (
-                getattr(ksl, "TimeInBeats", self.first_onset),
-                getattr(ksl, "Measure", self.first_measure),
-                ksl.Value,
-            )
-            for ksl in self.key_sig_lines
-        ]
-
-        _keysigs.sort(key=lambda x: x[0])
-
-        keysigs = []
-        if len(_keysigs) > 0:
-            keysigs.append(_keysigs[0])
-
-            for k in _keysigs:
-                if k[2] != keysigs[-1][2]:
-                    keysigs.append(k)
-
-        return keysigs
-
-    @property
-    def key_sig_lines(self):
-
-        ml = [
-            line
-            for line in self.lines
-            if getattr(line, "Attribute", None) == "keySignature"
-        ]
-
-        return ml
-
-    def write(self, filename: PathLike) -> None:
-        with open(filename, "w") as f:
-            for line in self.lines:
-                f.write(line.matchline + "\n")
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains base classes for Match lines and utilities for
+parsing and formatting match lines.
+"""
+from __future__ import annotations
+
+from typing import Callable, Tuple, Any, Optional, Union, Dict, List, Iterable
+import re
+
+import numpy as np
+
+from partitura.utils.music import (
+    pitch_spelling_to_midi_pitch,
+    ensure_pitch_spelling_format,
+    ALTER_SIGNS,
+)
+
+from partitura.io.matchfile_utils import (
+    Version,
+    interpret_as_string,
+    format_string,
+    interpret_as_float,
+    format_float,
+    format_float_unconstrained,
+    interpret_as_int,
+    format_int,
+    FractionalSymbolicDuration,
+    format_fractional,
+    interpret_as_fractional,
+    interpret_as_list,
+    interpret_as_list_int,
+    format_list,
+    MatchKeySignature,
+    MatchTimeSignature,
+)
+
+from partitura.utils.misc import (
+    PathLike,
+    deprecated_alias,
+)
+
+
+class MatchError(Exception):
+    """
+    Base exception for parsing match files.
+    """
+
+    pass
+
+
+class MatchLine(object):
+    """
+    Base class for representing match lines.
+
+    This class should be subclassed for the different match lines.
+
+    Parameters
+    ----------
+    version : Version
+        Indicate the version of the match line.
+
+    Attributes
+    ----------
+    version: Version
+        The version of the match line.
+    field_names: Tuple[str]
+        The names of the different fields with information in the match line.
+    field_types : Tuple[type]
+        The data type of the different fields.
+    out_pattern : str
+        The output pattern for the match line (i.e., how the match line looks like
+        in a match file).
+    pattern : re.Pattern
+        Regular expression to parse information from a string.
+    format_fun: Dict[str, Callable]
+        A dictionary of methods for formatting the values of each field name.
+    """
+
+    # Version of the match line
+    version: Version
+
+    # Field names that appear in the match line
+    # A match line will generally have these
+    # field names as attributes.
+    # Following the original Prolog-based specification
+    # the names of the attributes start with upper-case letters
+    field_names: Tuple[str]
+
+    # type of the information in the fields
+    field_types: Tuple[Union[type, Tuple[type]]]
+
+    # Output pattern
+    out_pattern: str
+
+    # A dictionary of callables for each field name
+    # the callables should get the value of the input
+    # and return a string formatted for the matchfile.
+    format_fun: Union[
+        Dict[str, Callable[Any, str]],
+        Tuple[Dict[str, Callable[Any, str]]],
+    ]
+
+    # Regular expression to parse
+    # information from a string.
+    pattern: Union[re.Pattern, Tuple[re.Pattern]]
+
+    def __init__(self, version: Version) -> None:
+        # Subclasses need to initialize the other
+        # default field names
+        self.version = version
+
+    def __str__(self) -> str:
+        """
+        Prints the printing the match line
+        """
+        r = [self.__class__.__name__]
+        for fn in self.field_names:
+            r.append(" {0}: {1}".format(fn, self.__dict__[fn]))
+        return "\n".join(r) + "\n"
+
+    @property
+    def matchline(self) -> str:
+        """
+        Generate matchline as a string.
+
+        This method can be adapted as needed by subclasses.
+        """
+        matchline = self.out_pattern.format(
+            **dict(
+                [
+                    (field, self.format_fun[field](getattr(self, field)))
+                    for field in self.field_names
+                ]
+            )
+        )
+
+        return matchline
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version,
+    ) -> MatchLine:
+        """
+        Create a new MatchLine object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        version : Version
+            Version of the matchline
+
+        Returns
+        -------
+        a MatchLine instance
+        """
+        raise NotImplementedError  # pragma: no cover
+
+    def check_types(self, verbose: bool = False) -> bool:
+        """
+        Check whether the values of the fields are of the correct type.
+
+        Parameters
+        ----------
+        verbose : bool
+            Prints whether each of the attributes in field_names has the correct dtype.
+            values are
+
+        Returns
+        -------
+        types_are_correct : bool
+            True if the values of all fields in the match line have the
+            correct type.
+        """
+        types_are_correct_list = [
+            isinstance(getattr(self, field), field_type)
+            for field, field_type in zip(self.field_names, self.field_types)
+        ]
+        if verbose:
+            print(list(zip(self.field_names, types_are_correct_list)))
+
+        types_are_correct = all(types_are_correct_list)
+        return types_are_correct
+
+
+## The following classes define base information for match lines
+## These classes need to be subclassed in the corresponding module for each version.
+
+
+class BaseInfoLine(MatchLine):
+    """
+    Base class specifying global information lines.
+
+    These lines have the general structure "info(<Attribute>,<Value>)."
+    Which attributes are valid depending on the version of the match line.
+
+    Parameters
+    ----------
+    version : Version
+        The version of the info line.
+    attribute: str
+        Name of the attribute
+    value: Any
+        Value of the attribute
+    value_type: type
+        Type of the value
+    format_fun: callable
+        A function for maping values to the attribute to strings (for formatting
+        the output matchline)
+    """
+
+    # Base field names (can be updated in subclasses).
+    # "attribute" will have type str, but the type of value needs to be specified
+    # during initialization.
+    field_names = ("Attribute", "Value")
+
+    out_pattern = "info({Attribute},{Value})."
+
+    pattern = re.compile(r"info\((?P<Attribute>[^,]+),(?P<Value>.+)\)\.")
+
+    def __init__(
+        self,
+        version: Version,
+        attribute: str,
+        value: Any,
+        value_type: type,
+        format_fun: Callable[Any, str],
+    ) -> None:
+        super().__init__(version)
+
+        self.field_types = (str, value_type)
+        self.format_fun = dict(Attribute=format_string, Value=format_fun)
+        self.Attribute = attribute
+        self.Value = value
+
+
+class BaseStimeLine(MatchLine):
+    """
+    Base class for specifying stime lines. These lines should looke like
+
+    stime(<Measure>:<Beat>,<Offset>,<OnsetInBeats>,<AnnotationType>)
+
+    Parameters
+    ----------
+    version: Version
+        The version of the matchline
+    measure: int
+        The measure number
+    beat: int
+        The beat within the measure (first beat starts at 1)
+    offset: FractionalSymbolicDuration
+        The offset of the event with respect to the current beat.
+    onset_in_beats: float
+        Onset in beats
+    annotation_type: List[str]
+        List of annotation types for the score time.
+    """
+
+    field_names = ("Measure", "Beat", "Offset", "OnsetInBeats", "AnnotationType")
+
+    field_types = (int, int, FractionalSymbolicDuration, float, list)
+
+    format_fun = dict(
+        Measure=format_int,
+        Beat=format_int,
+        Offset=format_fractional,
+        OnsetInBeats=format_float,
+        AnnotationType=format_list,
+    )
+
+    out_pattern = "stime({Measure}:{Beat},{Offset},{OnsetInBeats},{AnnotationType})"
+
+    pattern = re.compile(
+        r"stime\("
+        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<OnsetInBeats>[^,]+),"
+        r"\[(?P<AnnotationType>[a-z,]*)\]\)"
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        onset_in_beats: float,
+        annotation_type: List[str],
+    ) -> None:
+        super().__init__(version)
+
+        self.Measure = measure
+        self.Beat = beat
+        self.Offset = offset
+        self.OnsetInBeats = onset_in_beats
+        self.AnnotationType = annotation_type
+
+
+class BasePtimeLine(MatchLine):
+    """
+    Base class for specifying performance time. Tese lines have the form
+
+    ptime([<Onsets>])
+
+    Parameters
+    ----------
+    version: Version
+        The version of the matchline
+    onsets: List[int]
+        The list of onsets.
+    """
+
+    field_names = ("Onsets",)
+    field_types = (list,)
+
+    out_pattern = "ptime({Onsets})."
+
+    pattern = re.compile(r"ptime\(\[(?P<Onsets>[0-9,]+)\]\)\.")
+
+    format_fun = dict(Onsets=format_list)
+
+    def __init__(self, version: Version, onsets: List[int]) -> None:
+        super().__init__(version)
+        self.Onsets = onsets
+
+    @property
+    def Onset(self) -> float:
+        """
+        Average onset time
+        """
+        return np.mean(self.Onsets)
+
+
+class BaseStimePtimeLine(MatchLine):
+    """
+    Base class for represeting score-to-performance time alignments
+
+    Parameters
+    ----------
+    version: Version
+        The version of the matchline
+    stime: BaseStimeLine
+        Score time as a BaseStimeLine instance.
+    ptime: BasePtimeLine
+        Performance time as a BasePtimeLine instance.
+    """
+
+    out_pattern = "{StimeLine}-{PtimeLine}"
+
+    def __init__(
+        self,
+        version: Version,
+        stime: BaseStimeLine,
+        ptime: BasePtimeLine,
+    ) -> None:
+        super().__init__(version)
+
+        self.stime = stime
+        self.ptime = ptime
+
+        self.field_names = self.stime.field_names + self.ptime.field_names
+        self.field_types = self.stime.field_types + self.ptime.field_types
+
+        self.pattern = (self.stime.pattern, self.ptime.pattern)
+
+        self.format_fun = (self.stime.format_fun, self.ptime.format_fun)
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            StimeLine=self.stime.matchline,
+            PtimeLine=self.ptime.matchline,
+        )
+
+    def __str__(self) -> str:
+        """
+        String magic method
+        """
+        r = [self.__class__.__name__]
+        r += [" Stime"] + [
+            "   {0}: {1}".format(fn, getattr(self.stime, fn, None))
+            for fn in self.stime.field_names
+        ]
+
+        r += [" Ptime"] + [
+            "   {0}: {1}".format(fn, getattr(self.ptime, fn, None))
+            for fn in self.ptime.field_names
+        ]
+
+        return "\n".join(r) + "\n"
+
+    def check_types(self, verbose: bool) -> bool:
+        """
+        Check whether the values of the fields are of the correct type.
+
+        Parameters
+        ----------
+        verbose : bool
+            Prints whether each of the attributes in field_names has the correct dtype.
+            values are
+
+        Returns
+        -------
+        types_are_correct : bool
+            True if the values of all fields in the match line have the
+            correct type.
+        """
+
+        stime_types_are_correct = self.stime.check_types(verbose)
+        ptime_types_are_correct = self.ptime.check_types(verbose)
+
+        types_are_correct = stime_types_are_correct and ptime_types_are_correct
+
+        return types_are_correct
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        stime_class: BaseStimeLine,
+        ptime_class: BaseNoteLine,
+        version: Version,
+    ) -> Dict:
+        stime = stime_class.from_matchline(matchline, version=version)
+        ptime = ptime_class.from_matchline(matchline, version=version)
+
+        kwargs = dict(
+            version=version,
+            stime=stime,
+            ptime=ptime,
+        )
+
+        return kwargs
+
+
+# deprecate bar for measure
+class BaseSnoteLine(MatchLine):
+    """
+    Base class to represent score notes.
+
+    Parameters
+    ----------
+    version: Version
+    anchor: str
+    note_name: str
+    modifier: str
+    octave: Optional[int]
+    measure: int
+    beat: int
+    offset: FractionalSymbolicDuration
+    duration: FractionalSymbolicDuration
+    onset_in_beats: float
+    offset_in_beats: float
+    score_attributes_list: List[str]
+
+    Attributes
+    ----------
+    DurationInBeats : float
+    DurationSymbolic : float
+    MidiPitch : float
+
+    Notes
+    -----
+    * The snote line has not changed much since the first version of
+      the Match file format. New versions are just more explicit in the
+      the formatting of the attributes (field names), e.g., NoteName
+      should always be uppercase starting from version 1.0.0, etc.
+    """
+
+    # All derived classes should include
+    # at least these field names
+    field_names = (
+        "Anchor",
+        "NoteName",
+        "Modifier",
+        "Octave",
+        "Measure",
+        "Beat",
+        "Offset",
+        "Duration",
+        "OnsetInBeats",
+        "OffsetInBeats",
+        "ScoreAttributesList",
+    )
+
+    field_types = (
+        str,
+        str,
+        (int, type(None)),
+        (int, type(None)),
+        int,
+        int,
+        FractionalSymbolicDuration,
+        FractionalSymbolicDuration,
+        float,
+        float,
+        list,
+    )
+
+    out_pattern = (
+        "snote({Anchor},[{NoteName},{Modifier}],{Octave},"
+        "{Measure}:{Beat},{Offset},{Duration},{OnsetInBeats},"
+        "{OffsetInBeats},{ScoreAttributesList})"
+    )
+
+    pattern = re.compile(
+        r"snote\("
+        r"(?P<Anchor>[^,]+),"
+        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
+        r"(?P<Octave>[^,]+),"
+        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<Duration>[^,]+),"
+        r"(?P<OnsetInBeats>[^,]+),"
+        r"(?P<OffsetInBeats>[^,]+),"
+        r"\[(?P<ScoreAttributesList>.*)\]\)"
+    )
+
+    format_fun = dict(
+        Anchor=format_string,
+        NoteName=lambda x: str(x).upper(),
+        Modifier=lambda x: "n" if x == 0 else ALTER_SIGNS[x],
+        Octave=format_int,
+        Measure=format_int,
+        Beat=format_int,
+        Offset=format_fractional,
+        Duration=format_fractional,
+        OnsetInBeats=format_float_unconstrained,
+        OffsetInBeats=format_float_unconstrained,
+        ScoreAttributesList=format_list,
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        anchor: str,
+        note_name: str,
+        modifier: str,
+        octave: Optional[int],
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        duration: FractionalSymbolicDuration,
+        onset_in_beats: float,
+        offset_in_beats: float,
+        score_attributes_list: List[str],
+    ) -> None:
+        super().__init__(version)
+
+        # All of these attributes should have the
+        # correct dtype (otherwise we need to be constantly
+        # checking the types).
+        self.Anchor = anchor
+        self.NoteName = note_name
+        self.Modifier = modifier
+        self.Octave = octave
+        self.Measure = measure
+        self.Beat = beat
+        self.Offset = offset
+        self.Duration = duration
+        self.OnsetInBeats = onset_in_beats
+        self.OffsetInBeats = offset_in_beats
+        self.ScoreAttributesList = score_attributes_list
+
+    @property
+    def DurationInBeats(self) -> float:
+        return self.OffsetInBeats - self.OnsetInBeats
+
+    @property
+    def DurationSymbolic(self) -> str:
+        # Duration should always be a FractionalSymbolicDuration
+        return str(self.Duration)
+
+    @property
+    def Bar(self) -> int:
+        # deprecatd property measure
+        return self.Measure
+
+    @property
+    def MidiPitch(self) -> Optional[int]:
+        if isinstance(self.Octave, int):
+            return pitch_spelling_to_midi_pitch(
+                step=self.NoteName, octave=self.Octave, alter=self.Modifier
+            )
+        else:
+            return None
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+    ) -> Dict:
+
+        match_pattern = cls.pattern.search(matchline, pos)
+
+        if match_pattern is not None:
+
+            (
+                anchor_str,
+                note_name_str,
+                modifier_str,
+                octave_str,
+                measure_str,
+                beat_str,
+                offset_str,
+                duration_str,
+                onset_in_beats_str,
+                offset_in_beats_str,
+                score_attributes_list_str,
+            ) = match_pattern.groups()
+
+            anchor = interpret_as_string(anchor_str)
+            note_name, modifier, octave = ensure_pitch_spelling_format(
+                step=note_name_str,
+                alter=modifier_str,
+                octave=octave_str,
+            )
+
+            return dict(
+                anchor=interpret_as_string(anchor),
+                note_name=note_name,
+                modifier=modifier,
+                octave=octave,
+                measure=interpret_as_int(measure_str),
+                beat=interpret_as_int(beat_str),
+                offset=interpret_as_fractional(offset_str),
+                duration=interpret_as_fractional(duration_str),
+                onset_in_beats=interpret_as_float(onset_in_beats_str),
+                offset_in_beats=interpret_as_float(offset_in_beats_str),
+                score_attributes_list=interpret_as_list(score_attributes_list_str),
+            )
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+
+class BaseNoteLine(MatchLine):
+
+    # All derived classes should include at least
+    # these field names
+    field_names = (
+        "Id",
+        "Onset",
+        "Offset",
+        "Velocity",
+    )
+
+    field_types = (
+        str,
+        int,
+        float,
+        float,
+        int,
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        id: str,
+        midi_pitch: int,
+        onset: float,
+        offset: float,
+        velocity: int,
+    ) -> None:
+        super().__init__(version)
+        self.Id = id
+        # The MIDI pitch is not a part of all
+        # note versions. For versions < 1.0.0
+        # it needs to be inferred from pitch spelling.
+        self.MidiPitch = midi_pitch
+        self.Onset = onset
+        self.Offset = offset
+        self.Velocity = velocity
+
+    @property
+    def Duration(self):
+        return self.Offset - self.Onset
+
+
+class BaseSnoteNoteLine(MatchLine):
+
+    out_pattern = "{SnoteLine}-{NoteLine}"
+
+    def __init__(
+        self,
+        version: Version,
+        snote: BaseSnoteLine,
+        note: BaseNoteLine,
+    ) -> None:
+
+        super().__init__(version)
+
+        self.snote = snote
+        self.note = note
+
+        self.field_names = self.snote.field_names + self.note.field_names
+
+        self.field_types = self.snote.field_types + self.note.field_types
+
+        self.pattern = (self.snote.pattern, self.note.pattern)
+
+        self.format_fun = (self.snote.format_fun, self.note.format_fun)
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            SnoteLine=self.snote.matchline,
+            NoteLine=self.note.matchline,
+        )
+
+    def __str__(self) -> str:
+
+        """
+        Prints the printing the match line
+        """
+        r = [self.__class__.__name__]
+        r += [" Snote"] + [
+            "   {0}: {1}".format(fn, getattr(self.snote, fn, None))
+            for fn in self.snote.field_names
+        ]
+
+        r += [" Note"] + [
+            "   {0}: {1}".format(fn, getattr(self.note, fn, None))
+            for fn in self.note.field_names
+        ]
+
+        return "\n".join(r) + "\n"
+
+    def check_types(self, verbose: bool = False) -> bool:
+        """
+        Check whether the values of the fields are of the correct type.
+
+        Parameters
+        ----------
+        verbose : bool
+            Prints whether each of the attributes in field_names has the correct dtype.
+            values are
+
+        Returns
+        -------
+        types_are_correct : bool
+            True if the values of all fields in the match line have the
+            correct type.
+        """
+        snote_types_are_correct = self.snote.check_types(verbose)
+        note_types_are_correct = self.note.check_types(verbose)
+
+        types_are_correct = snote_types_are_correct and note_types_are_correct
+
+        return types_are_correct
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        snote_class: BaseSnoteLine,
+        note_class: BaseNoteLine,
+        version: Version,
+    ) -> Dict:
+        snote = snote_class.from_matchline(matchline, version=version)
+        note = note_class.from_matchline(matchline, version=version)
+
+        kwargs = dict(
+            version=version,
+            snote=snote,
+            note=note,
+        )
+
+        return kwargs
+
+
+class BaseDeletionLine(MatchLine):
+
+    out_pattern = "{SnoteLine}-deletion."
+
+    def __init__(self, version: Version, snote: BaseSnoteLine) -> None:
+
+        super().__init__(version)
+
+        self.snote = snote
+
+        self.field_names = self.snote.field_names
+
+        self.field_types = self.snote.field_types
+
+        self.pattern = re.compile(rf"{self.snote.pattern.pattern}-deletion\.")
+
+        self.format_fun = self.snote.format_fun
+
+        for fn in self.field_names:
+            setattr(self, fn, getattr(self.snote, fn))
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            SnoteLine=self.snote.matchline,
+        )
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        snote_class: BaseSnoteLine,
+        version: Version,
+    ) -> Dict:
+
+        snote = snote_class.from_matchline(matchline, version=version)
+
+        kwargs = dict(
+            version=version,
+            snote=snote,
+        )
+
+        return kwargs
+
+
+class BaseInsertionLine(MatchLine):
+
+    out_pattern = "insertion-{NoteLine}"
+
+    def __init__(self, version: Version, note: BaseNoteLine) -> None:
+
+        super().__init__(version)
+
+        self.note = note
+
+        self.field_names = self.note.field_names
+
+        self.field_types = self.note.field_types
+
+        self.pattern = re.compile(f"insertion-{self.note.pattern.pattern}")
+
+        self.format_fun = self.note.format_fun
+
+        for fn in self.field_names:
+            setattr(self, fn, getattr(self.note, fn))
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            NoteLine=self.note.matchline,
+        )
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        note_class: BaseNoteLine,
+        version: Version,
+    ) -> Dict:
+
+        note = note_class.from_matchline(matchline, version=version)
+
+        kwargs = dict(
+            version=version,
+            note=note,
+        )
+
+        return kwargs
+
+
+class BaseOrnamentLine(MatchLine):
+
+    # These field names and types need to be expanded
+    # with the attributes of the note
+    field_names = ("Anchor",)
+    field_types = (str,)
+    format_fun = dict(Anchor=format_string)
+    out_pattern = "ornament({Anchor})-{NoteLine}"
+    ornament_pattern: re.Pattern = re.compile(r"ornament\((?P<Anchor>[^\)]*)\)-")
+
+    def __init__(self, version: Version, anchor: str, note: BaseNoteLine) -> None:
+
+        super().__init__(version)
+
+        self.note = note
+
+        self.field_names = self.field_names + self.note.field_names
+
+        self.field_types = self.field_types + self.note.field_types
+
+        self.pattern = (self.ornament_pattern, self.note.pattern)
+
+        self.format_fun = (self.format_fun, self.note.format_fun)
+
+        for fn in self.note.field_names:
+            setattr(self, fn, getattr(self.note, fn))
+
+        self.Anchor = anchor
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            Anchor=self.Anchor,
+            NoteLine=self.note.matchline,
+        )
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        note_class: BaseNoteLine,
+        version: Version,
+    ) -> Dict:
+
+        anchor_pattern = cls.ornament_pattern.search(matchline)
+
+        if anchor_pattern is None:
+            raise MatchError("")
+
+        anchor = interpret_as_string(anchor_pattern.group("Anchor"))
+        note = note_class.from_matchline(matchline, version=version)
+
+        kwargs = dict(
+            version=version,
+            anchor=anchor,
+            note=note,
+        )
+
+        return kwargs
+
+
+class BasePedalLine(MatchLine):
+    """
+    Class for representing a sustain pedal line
+    """
+
+    field_names = ("Time", "Value")
+    field_types = (int, int)
+    base_pattern: str = r"pedal\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\."
+    out_pattern: str = "pedal({Time},{Value})."
+
+    format_fun = dict(
+        Time=format_int,
+        Value=format_int,
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ):
+        super().__init__(version)
+        self.Time = time
+        self.Value = value
+
+    @classmethod
+    def prepare_kwargs_from_matchline(
+        cls,
+        matchline: str,
+        version: Version,
+        pos: int = 0,
+    ) -> Dict:
+
+        kwargs = None
+        # pattern = re.compile(cls.base_pattern.format(pedal_type=pedal_type))
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+
+        if match_pattern is not None:
+
+            time_str, value_str = match_pattern.groups()
+
+            kwargs = dict(
+                version=version,
+                time=interpret_as_int(time_str),
+                value=interpret_as_int(value_str),
+            )
+
+        return kwargs
+
+
+class BaseSustainPedalLine(BasePedalLine):
+
+    pattern = re.compile(r"sustain\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\.")
+    out_pattern: str = "sustain({Time},{Value})."
+
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ):
+        super().__init__(version=version, time=time, value=value)
+
+
+class BaseSoftPedalLine(BasePedalLine):
+
+    pattern = re.compile(r"soft\((?P<Time>[^,]+),(?P<Value>[^,]+)\)\.")
+    out_pattern: str = "soft({Time},{Value})."
+
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ):
+        super().__init__(version=version, time=time, value=value)
+
+
+## MatchFile
+
+# classes that contain score notes
+snote_classes = (BaseSnoteLine, BaseSnoteNoteLine, BaseDeletionLine)
+
+# classes that contain performed notes.
+note_classes = (BaseNoteLine, BaseSnoteNoteLine, BaseInsertionLine)
+
+
+class MatchFile(object):
+    """
+    Class for representing MatchFiles
+    """
+
+    version: Version
+    lines: np.ndarray
+
+    def __init__(self, lines: Iterable[MatchLine]) -> None:
+
+        # check that all lines have the same version
+        same_version = all([line.version == lines[0].version for line in lines])
+
+        if not same_version:
+            raise ValueError("All lines should have the same version")
+
+        self.lines = np.array(lines)
+
+    @property
+    def note_pairs(self) -> List[Tuple[BaseSnoteLine, BaseNoteLine]]:
+        """
+        Return all(snote, note) tuples
+
+        """
+        return [
+            (x.snote, x.note) for x in self.lines if isinstance(x, BaseSnoteNoteLine)
+        ]
+
+    @property
+    def notes(self) -> List[BaseNoteLine]:
+        """
+        Return all performed notes (as MatchNote objects)
+        """
+        return [x.note for x in self.lines if isinstance(x, note_classes)]
+
+    def iter_notes(self) -> BaseNoteLine:
+        """
+        Iterate over all performed notes (as MatchNote objects)
+        """
+        for x in self.lines:
+            if isinstance(x, note_classes):
+                yield x.note
+
+    @property
+    def snotes(self) -> List[BaseSnoteLine]:
+        """
+        Return all score notes (as MatchSnote objects)
+        """
+        return [x.snote for x in self.lines if isinstance(x, snote_classes)]
+
+    def iter_snotes(self) -> BaseSnoteLine:
+        """
+        Iterate over all performed notes (as MatchNote objects)
+        """
+        for x in self.lines:
+            if hasattr(x, "snote"):
+                yield x.snote
+
+    @property
+    def sustain_pedal(self) -> List[BaseSustainPedalLine]:
+        return [line for line in self.lines if isinstance(line, BaseSustainPedalLine)]
+
+    @property
+    def soft_pedal(self) -> List[BasePedalLine]:
+        return [line for line in self.lines if isinstance(line, BaseSoftPedalLine)]
+
+    @property
+    def insertions(self) -> List[BaseNoteLine]:
+        return [x.note for x in self.lines if isinstance(x, BaseInsertionLine)]
+
+    @property
+    def deletions(self) -> List[BaseSnoteLine]:
+        return [x.snote for x in self.lines if isinstance(x, BaseDeletionLine)]
+
+    @property
+    def _info(self) -> List[BaseInfoLine]:
+        """
+        Return all InfoLine objects
+
+        """
+        return [i for i in self.lines if isinstance(i, BaseInfoLine)]
+
+    def info(
+        self, attribute: Optional[str] = None
+    ) -> Union[BaseInfoLine, List[BaseInfoLine]]:
+        """
+        Return the value of the MatchInfo object corresponding to
+        attribute, or None if there is no such object
+
+        : param attribute: the name of the attribute to return the value for
+
+        """
+        if attribute:
+            try:
+                idx = [i.Attribute for i in self._info].index(attribute)
+                return self._info[idx].Value
+            except ValueError:
+                return None
+        else:
+            return self._info
+
+    @property
+    def first_onset(self) -> float:
+        return min([n.OnsetInBeats for n in self.snotes])
+
+    @property
+    def first_measure(self) -> float:
+        return min([n.Measure for n in self.snotes])
+
+    @property
+    def time_signatures(self):
+        """
+        A list of tuples(t, b, (n, d)), indicating a time signature of
+        n over v, starting at t in bar b
+
+        """
+        _tsigs = [
+            (
+                getattr(tsl, "TimeInBeats", self.first_onset),
+                getattr(tsl, "Measure", self.first_measure),
+                tsl.Value,
+            )
+            for tsl in self.time_sig_lines
+        ]
+
+        _tsigs.sort(key=lambda x: x[0])
+
+        tsigs = []
+        if len(_tsigs) > 0:
+            tsigs.append(_tsigs[0])
+
+            for k in _tsigs:
+                if k[2] != tsigs[-1][2]:
+                    tsigs.append(k)
+
+        return tsigs
+
+    @property
+    def time_sig_lines(self):
+        ml = [
+            line
+            for line in self.lines
+            if getattr(line, "Attribute", None) == "timeSignature"
+        ]
+        return ml
+
+    @property
+    def key_signatures(self):
+        """
+        A list of tuples (t, b, (ks,)) or (t, b, (ks1, ks2))
+        """
+        _keysigs = [
+            (
+                getattr(ksl, "TimeInBeats", self.first_onset),
+                getattr(ksl, "Measure", self.first_measure),
+                ksl.Value,
+            )
+            for ksl in self.key_sig_lines
+        ]
+
+        _keysigs.sort(key=lambda x: x[0])
+
+        keysigs = []
+        if len(_keysigs) > 0:
+            keysigs.append(_keysigs[0])
+
+            for k in _keysigs:
+                if k[2] != keysigs[-1][2]:
+                    keysigs.append(k)
+
+        return keysigs
+
+    @property
+    def key_sig_lines(self):
+
+        ml = [
+            line
+            for line in self.lines
+            if getattr(line, "Attribute", None) == "keySignature"
+        ]
+
+        return ml
+
+    def write(self, filename: PathLike) -> None:
+        with open(filename, "w") as f:
+            for line in self.lines:
+                f.write(line.matchline + "\n")
```

### Comparing `partitura-1.2.1/partitura/io/matchfile_utils.py` & `partitura-1.2.2/partitura/io/matchfile_utils.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,954 +1,954 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains utilities for parsing and formatting match lines.
-"""
-from __future__ import annotations
-
-from typing import Tuple, Any, Optional, Union, List, Dict, Callable
-import re
-
-import numpy as np
-
-from collections import namedtuple
-
-from partitura.utils.music import (
-    ALTER_SIGNS,
-    fifths_mode_to_key_name,
-    note_name_to_pitch_spelling,
-    key_name_to_fifths_mode,
-    MAJOR_KEYS,
-    MINOR_KEYS,
-)
-
-Version = namedtuple("Version", ["major", "minor", "patch"])
-
-# General patterns
-rational_pattern = re.compile(r"^(?P<numerator>[0-9]+)/(?P<denominator>[0-9]+)$")
-double_rational_pattern = re.compile(
-    r"^(?P<numerator>[0-9]+)/(?P<denominator>[0-9]+)/(?P<tuple_div>[0-9]+)$"
-)
-integer_pattern = re.compile(r"^(?P<integer>[0-9]+)$")
-version_pattern = re.compile(
-    r"^(?P<major>[0-9]+)\.(?P<minor>[0-9]+)\.(?P<patch>[0-9]+)"
-)
-attribute_list_pattern = re.compile(r"^\[(?P<attributes>.*)\]")
-
-key_signature_pattern = re.compile(
-    (
-        r"(?P<step1>[A-G])(?P<alter1>[#b]*)\s*"
-        r"(?P<mode1>[a-zA-z]+)/*"
-        "(?P<step2>[A-G]*)(?P<alter2>[#b]*)"
-        r"\s*(?P<mode2>[a-zA-z]*)"
-    )
-)
-
-pitch_class_pattern = re.compile("(?P<step>[A-Ga-g])(?P<alter>[#bn]*)")
-
-number_pattern = re.compile(r"\d+")
-
-# For matchfiles before 1.0.0.
-old_version_pattern = re.compile(r"^(?P<minor>[0-9]+)\.(?P<patch>[0-9]+)")
-
-
-def interpret_version(version_string: str) -> Version:
-    """
-    Parse matchfile format version from a string. This method
-    parses a string like "1.0.0" and returns a Version instance.
-
-    Parameters
-    ----------
-    version_string : str
-        The string containg the version. The version string should be
-        in the form "{major}.{minor}.{patch}" or "{minor}.{patch}" for versions
-        previous to 1.0.0. Incorrectly formatted strings
-        will result in an error.
-
-    Returns
-    -------
-    version : Version
-        A named tuple specifying the version
-    """
-    version_info = version_pattern.search(version_string)
-
-    if version_info is not None:
-        ma, mi, pa = version_info.groups()
-        version = Version(int(ma), int(mi), int(pa))
-        return version
-
-    # If using the first pattern fails, try with old version
-    version_info = old_version_pattern.search(version_string)
-
-    if version_info is not None:
-        mi, pa = version_info.groups()
-        version = Version(0, int(mi), int(pa))
-        return version
-
-    else:
-        raise ValueError(f"The version '{version_string}' is incorrectly formatted!")
-
-
-def format_version(version: Version) -> str:
-    """
-    Format version as a string.
-
-    Parameters
-    ----------
-    version : Version
-        A Version instance.
-
-    Returns
-    -------
-    version_str : str
-        A string representation of the version.
-    """
-    ma, mi, pa = version
-
-    version_str = f"{ma}.{mi}.{pa}"
-    return version_str
-
-
-def interpret_as_int(value: str) -> int:
-    """
-    Interpret value as an integer
-
-    Parameters
-    ----------
-    value : str
-       The value to interpret as integer.
-
-    Returns
-    -------
-    int
-        The value cast as an integer.
-    """
-    return int(value)
-
-
-def format_int(value: Optional[int]) -> str:
-    """
-    Format a string from an integer
-
-    Parameters
-    ----------
-    value : int
-        The value to be converted to format as a string.
-
-    Returns
-    -------
-    str
-        The value formatted as a string.
-    """
-    return f"{int(value)}" if value is not None else "-"
-
-
-def interpret_as_float(value: str) -> float:
-    """
-    Interpret value as a float
-
-    Parameters
-    ----------
-    value : str
-       The string to interpret as float.
-
-    Returns
-    -------
-    int
-        The value cast as an float.
-    """
-    return float(value)
-
-
-def format_float(value: float) -> str:
-    """
-    Format a float as a string (with 4 digits of precision).
-
-    Parameters
-    ----------
-    value : float
-        The value to be converted to format as a string.
-
-    Returns
-    -------
-    str
-        The value formatted as a string.
-    """
-    return f"{value:.4f}"
-
-
-def format_float_unconstrained(value: float) -> str:
-    """
-    Format a float as a string.
-
-    Parameters
-    ----------
-    value : float
-        The value to be converted to format as a string.
-
-    Returns
-    -------
-    str
-        The value formatted as a string.
-    """
-    return str(value)
-
-
-def interpret_as_string(value: Any) -> str:
-    """
-    Interpret value as a string. This method is for completeness.
-
-    Parameters
-    ----------
-    value : Any
-       The value to be interpreted as a string.
-
-    Returns
-    -------
-    int
-        The string representation of the value.
-    """
-    return str(value)
-
-
-old_string_pat = re.compile(r"'(?P<value>.+)'")
-
-
-def interpret_as_string_old(value: str) -> str:
-
-    val = old_string_pat.match(value)
-    if val is not None:
-        return val.group("value").strip()
-    else:
-        return value.strip()
-
-
-def format_string(value: str) -> str:
-    """
-    Format a string as a string (for completeness ;).
-
-    Parameters
-    ----------
-    value : int
-        The value to be converted to format as a string.
-
-    Returns
-    -------
-    str
-        The value formatted as a string.
-    """
-    return str(value).strip()
-
-
-def format_string_old(value: str) -> str:
-    return f"'{value.strip()}'"
-
-
-class FractionalSymbolicDuration(object):
-    """
-    A class to represent symbolic duration information.
-
-    Parameters
-    ----------
-    numerator : int
-        The value of the numerator.
-    denominator: int
-        The denominator of the duration (whole notes = 1, half notes = 2, etc.)
-    tuple_div : int (optional)
-        Tuple divisor (for triplets, etc.). For example a single note in a quintuplet
-        with a total duration of one quarter could be specified as
-        `duration = FractionalSymbolicDuration(1, 4, 5)`.
-    add_components : List[Tuple[int, int, Optional[int]]] (optional)
-        additive components (to express durations like 1/4+1/16+1/32). The components
-        are a list of tuples, each of which contains its own numerator, denominator
-        and tuple_div (or None). To represent the components in the example above
-        this variable would look like
-        `add_components = [(1, 4, None), (1, 16, None), (1, 32, None)]`.
-    """
-
-    def __init__(
-        self,
-        numerator: int,
-        denominator: int = 1,
-        tuple_div: Optional[int] = None,
-        add_components: Optional[List[Tuple[int, int, Optional[int]]]] = None,
-    ) -> None:
-
-        self.numerator = numerator
-        self.denominator = denominator
-        self.tuple_div = tuple_div
-        self.add_components = add_components
-        self.bound_integers(1024)
-
-    def _str(
-        self,
-        numerator: int,
-        denominator: int,
-        tuple_div: Optional[int],
-    ) -> str:
-        """
-        Helper for representing an instance as a string.
-        """
-        if denominator == 1 and tuple_div is None:
-            return str(numerator)
-        else:
-            if tuple_div is None:
-                return "{0}/{1}".format(numerator, denominator)
-            else:
-                return "{0}/{1}/{2}".format(numerator, denominator, tuple_div)
-
-    def bound_integers(self, bound: int) -> None:
-        """
-        Bound numerator and denominator
-        """
-        denominators = [
-            2,
-            3,
-            4,
-            5,
-            6,
-            7,
-            8,
-            9,
-            10,
-            12,
-            14,
-            16,
-            18,
-            20,
-            22,
-            24,
-            28,
-            32,
-            48,
-            64,
-            96,
-            128,
-        ]
-        sign = (
-            np.sign(self.numerator)
-            * np.sign(self.denominator)
-            * (np.sign(self.tuple_div) if self.tuple_div is not None else 1)
-        )
-        self.numerator = np.abs(self.numerator)
-        self.denominator = np.abs(self.denominator)
-        self.tuple_div = np.abs(self.tuple_div) if self.tuple_div is not None else None
-
-        if self.numerator > bound or self.denominator > bound:
-            val = float(self.numerator / self.denominator)
-            dif = []
-            for den in denominators:
-                if np.round(val * den) > 0.9:
-                    dif.append(np.abs(np.round(val * den) - val * den))
-                else:
-                    dif.append(np.abs(1 - val * den))
-
-            difn = np.array(dif)
-            min_idx = int(np.argmin(difn))
-
-            self.denominator = denominators[min_idx]
-            if int(np.round(val * self.denominator)) < 1:
-                self.numerator = sign * 1
-            else:
-                self.numerator = sign * int(np.round(val * self.denominator))
-
-    def __str__(self) -> str:
-        """
-        Represent an instance as a string.
-        """
-        if self.add_components is None:
-            return self._str(self.numerator, self.denominator, self.tuple_div)
-        else:
-            r = [self._str(*i) for i in self.add_components]
-            return "+".join(r)
-
-    def __add__(
-        self, sd: Union[FractionalSymbolicDuration, int]
-    ) -> FractionalSymbolicDuration:
-        """
-        Define addition between FractionalSymbolicDuration instances.
-
-        Parameters
-        ----------
-        sd : Union[FractionalSymbolicDuration, int]
-            A FractionalSymbolicDuration instance or an integer to add
-            to the current instance (self).
-
-        Returns
-        -------
-        FractionalSymbolicDuration
-            A new instance with the value equal to the sum
-            of `sd` + `self`.
-        """
-        if isinstance(sd, int):
-            sd = FractionalSymbolicDuration(sd, 1)
-
-        dens = np.array(
-            [
-                self.denominator
-                * (self.tuple_div if self.tuple_div is not None else 1),
-                sd.denominator * (sd.tuple_div if sd.tuple_div is not None else 1),
-            ],
-            dtype=int,
-        )
-        new_den = np.lcm(dens[0], dens[1])
-        a_mult = new_den // dens
-        new_num = np.dot(a_mult, [self.numerator, sd.numerator])
-
-        if self.add_components is None and sd.add_components is None:
-            add_components = [
-                (self.numerator, self.denominator, self.tuple_div),
-                (sd.numerator, sd.denominator, sd.tuple_div),
-            ]
-
-        elif self.add_components is not None and sd.add_components is None:
-            add_components = self.add_components + [
-                (sd.numerator, sd.denominator, sd.tuple_div)
-            ]
-        elif self.add_components is None and sd.add_components is not None:
-            add_components = [
-                (self.numerator, self.denominator, self.tuple_div)
-            ] + sd.add_components
-        else:
-            add_components = self.add_components + sd.add_components
-
-        # Remove spurious components with 0 in the numerator
-        add_components = [c for c in add_components if c[0] != 0]
-
-        return FractionalSymbolicDuration(
-            numerator=new_num,
-            denominator=new_den,
-            add_components=add_components,
-        )
-
-    def __eq__(self, sd: FractionalSymbolicDuration) -> bool:
-        """
-        Equal magic method
-        """
-        is_equal = all(
-            [
-                getattr(self, attr, None) == getattr(sd, attr, None)
-                for attr in ("numerator", "denominator", "tuple_div", "add_components")
-            ]
-        )
-
-        return is_equal
-
-    def __ne__(self, sd: FractionalSymbolicDuration) -> bool:
-        """
-        Not equal magic method
-        """
-        not_equal = any(
-            [
-                getattr(self, attr, None) != getattr(sd, attr, None)
-                for attr in ("numerator", "denominator", "tuple_div", "add_components")
-            ]
-        )
-
-        return not_equal
-
-    def __radd__(
-        self, sd: Union[FractionalSymbolicDuration, int]
-    ) -> FractionalSymbolicDuration:
-        return self.__add__(sd)
-
-    def __float__(self) -> float:
-        # Cast as float since the ability to return an instance of a strict
-        # subclass of float is deprecated, and may be removed in a future
-        # version of Python. (following a deprecation warning)
-        return float(self.numerator / (self.denominator * (self.tuple_div or 1)))
-
-    @classmethod
-    def from_string(cls, string: str, allow_additions: bool = True):
-
-        m = rational_pattern.match(string)
-        m2 = double_rational_pattern.match(string)
-        m3 = integer_pattern.match(string)
-        if m:
-            groups = m.groups()
-            return cls(*[int(g) for g in groups])
-        elif m2:
-            groups = m2.groups()
-            return cls(*[int(g) for g in groups])
-        elif m3:
-            return cls(numerator=int(m3.group("integer")))
-
-        else:
-            if allow_additions:
-                parts = string.split("+")
-
-                if len(parts) > 1:
-                    iparts = [
-                        cls.from_string(
-                            i,
-                            allow_additions=False,
-                        )
-                        for i in parts
-                    ]
-
-                    # to be replaced with isinstance(i,numbers.Number)
-                    if all(type(i) in (int, float, cls) for i in iparts):
-                        if any([isinstance(i, cls) for i in iparts]):
-                            iparts = [
-                                cls(i) if not isinstance(i, cls) else i for i in iparts
-                            ]
-                        return sum(iparts)
-
-        raise ValueError(
-            f"{string} cannot be interpreted as FractionalSymbolicDuration"
-        )
-
-
-def interpret_as_fractional(value: str) -> FractionalSymbolicDuration:
-    """
-    Interpret string as FractionalSymbolicDuration
-    """
-
-    content = attribute_list_pattern.search(value)
-
-    if content is not None:
-        # string includes square brackets
-        vals_string = content.group("attributes")
-        content_list = [
-            FractionalSymbolicDuration.from_string(v, allow_additions=True)
-            for v in vals_string.split(",")
-        ]
-        return content_list
-
-    return FractionalSymbolicDuration.from_string(value, allow_additions=True)
-
-
-def format_fractional(
-    value: Union[List[FractionalSymbolicDuration], FractionalSymbolicDuration]
-) -> str:
-    """
-    Format fractional symbolic duration as string
-    """
-
-    if isinstance(value, list):
-        return format_list(value)
-
-    return str(value)
-
-
-def format_fractional_rational(value: FractionalSymbolicDuration) -> str:
-    """
-    Format fractional symbolic duration as string and ensure that the output
-    is always rational ("a/b")
-    """
-
-    if value.denominator == 1 and value.tuple_div is None:
-
-        out = f"{value.numerator}/1"
-
-    else:
-        out = str(value)
-
-    return out
-
-
-def interpret_as_list(value: str) -> List[str]:
-    """
-    Interpret string as list of values.
-
-    Parameters
-    ----------
-    value: str
-
-    Returns
-    -------
-    content_list : List[str]
-    """
-    content = attribute_list_pattern.search(value)
-
-    if content is not None:
-        # string includes square brackets
-        vals_string = content.group("attributes")
-        content_list = [v.strip() for v in vals_string.split(",")]
-
-    else:
-        # value is not inside square brackets
-        content_list = [v.strip() for v in value.split(",")]
-
-    return content_list
-
-
-def interpret_as_list_int(value: str) -> List[int]:
-    string_list = interpret_as_list(value)
-    return [int(v) for v in string_list]
-
-
-def interpret_as_list_fractional(value: str) -> List[FractionalSymbolicDuration]:
-    string_list = interpret_as_list(value)
-    return [FractionalSymbolicDuration.from_string(v) for v in string_list]
-
-
-def format_list(value: List[Any]) -> str:
-    formatted_string = f"[{','.join([str(v) for v in value])}]"
-    return formatted_string
-
-
-def format_accidental(value: Optional[int]) -> str:
-
-    alter = "n" if value == 0 else ALTER_SIGNS[value]
-
-    return alter
-
-
-def format_accidental_old(value: Optional[int]) -> str:
-
-    if value is None:
-        return "-"
-    else:
-        return format_accidental(value)
-
-
-def format_pnote_id(value: Any) -> str:
-
-    pnote_id = f"n{str(value)}" if not str(value).startswith("n") else str(value)
-
-    return pnote_id
-
-
-## Methods for parsing special attributes
-
-
-class MatchParameter(object):
-    def __init__(self, *args, **kwargs) -> None:
-        pass
-
-    def __str__(self) -> str:
-        raise NotImplementedError
-
-    @classmethod
-    def from_string(self, *args, **kwargs) -> MatchParameter:
-        raise NotImplementedError
-
-
-class MatchKeySignature(MatchParameter):
-    def __init__(
-        self,
-        fifths: int,
-        mode: str,
-        fifths_alt: Optional[int] = None,
-        mode_alt: Optional[str] = None,
-        is_list: bool = False,
-        other_components: Optional[List[MatchKeySignature]] = None,
-        fmt: str = "v1.0.0",
-    ):
-        super().__init__()
-        self.fifths = fifths
-        self.mode = mode
-        self.fifths_alt = fifths_alt
-        self.mode_alt = mode_alt
-        self.is_list = is_list
-        self.other_components = [] if other_components is None else other_components
-        self.fmt = fmt
-
-    @property
-    def fmt(self) -> str:
-        return self._fmt
-
-    @fmt.setter
-    def fmt(self, fmt: str) -> None:
-        self._fmt = fmt
-        for component in self.other_components:
-            component.fmt = fmt
-
-    def fifths_mode_to_key_name_v0_1_0(self, fifths: int, mode: str) -> str:
-        if mode == "major":
-            keylist = MAJOR_KEYS
-            suffix = "major"
-        elif mode == "minor":
-            keylist = MINOR_KEYS
-            suffix = "minor"
-
-        step, alter, _ = note_name_to_pitch_spelling(f"{keylist[fifths + 7]}4")
-        alter_str = "n" if (alter is None or alter == 0) else ALTER_SIGNS[alter]
-        name = f"{step.lower()}{alter_str}"
-        ks = f"[{name},{suffix}]"
-
-        return ks
-
-    def fifths_mode_to_key_name_v0_3_0(self, fifths: int, mode: str) -> str:
-        if mode == "major":
-            keylist = MAJOR_KEYS
-            suffix = "Maj"
-        elif mode == "minor":
-            keylist = MINOR_KEYS
-            suffix = "min"
-
-        name = keylist[fifths + 7]
-
-        ks = f"{name} {suffix}"
-
-        return ks
-
-    def __str__(self):
-
-        if self.fmt == "v1.0.0":
-            ks = fifths_mode_to_key_name(self.fifths, self.mode)
-
-            if self.fifths_alt is not None:
-                ks = f"{ks}/{fifths_mode_to_key_name(self.fifths_alt, self.mode_alt)}"
-
-        if self.fmt == "v0.3.0":
-            ks = self.fifths_mode_to_key_name_v0_3_0(self.fifths, self.mode)
-
-            if self.fifths_alt is not None:
-                ks = f"{ks}/{self.fifths_mode_to_key_name_v0_3_0(self.fifths_alt, self.mode_alt)}"
-
-        if self.fmt == "v0.1.0":
-            ks = self.fifths_mode_to_key_name_v0_1_0(self.fifths, self.mode)
-
-        if self.is_list:
-            return format_list([ks] + self.other_components)
-        return ks
-
-    def __eq__(self, ks: MatchKeySignature) -> bool:
-
-        crit = (
-            self.fifths == ks.fifths
-            and self.mode == ks.mode
-            and self.fifths_alt == ks.fifths_alt
-            and self.mode_alt == ks.mode_alt
-            and self.other_components == ks.other_components
-        )
-
-        return crit
-
-    @classmethod
-    def _parse_key_signature(cls, kstr: str) -> MatchKeySignature:
-
-        # import pdb
-        # pdb.set_trace()
-        ksinfo = key_signature_pattern.search(kstr)
-
-        if ksinfo is None:
-            fmt = "v1.0.0"
-            ksinfo = kstr.split("/")
-            fifths1, mode1 = key_name_to_fifths_mode(ksinfo[0].upper())
-            fifths2, mode2 = None, None
-            if len(ksinfo) == 2:
-                fifths2, mode2 = key_name_to_fifths_mode(ksinfo[1].upper())
-        else:
-
-            fmt = "v0.3.0"
-            step1, alter1, mode1, step2, alter2, mode2 = ksinfo.groups()
-            mode1_str = "m" if mode1.lower() in ("minor", "min") else ""
-            fifths1, mode1 = key_name_to_fifths_mode(
-                f"{step1.upper()}{alter1}{mode1_str}"
-            )
-
-            if step2 != "":
-                mode2_str = "m" if mode2.lower() in ("minor", "min") else ""
-                fifths2, mode2 = key_name_to_fifths_mode(
-                    f"{step2.upper()}{alter2}{mode2_str}"
-                )
-            else:
-                fifths2, mode2 = None, None
-
-        return cls(
-            fifths=fifths1,
-            mode=mode1,
-            fifths_alt=fifths2,
-            mode_alt=mode2,
-            is_list=False,
-            fmt=fmt,
-        )
-
-    @classmethod
-    def from_string(cls, string: str) -> MatchKeySignature:
-        content = interpret_as_list(string)
-
-        if len(content) == 2:
-            # try parsing it as v0.1.0
-            if content[1].lower() in ("minor", "major", "min", "maj"):
-                note_info = pitch_class_pattern.search(content[0].lower())
-
-                mode_str = "m" if content[1].lower() in ("min", "minor") else ""
-
-                if note_info is not None:
-                    step, alter = note_info.groups()
-
-                alter_str = alter.replace("n", "")
-
-                fifths, mode = key_name_to_fifths_mode(
-                    f"{step.upper()}{alter_str}{mode_str}"
-                )
-
-                return cls(fifths=fifths, mode=mode, fmt="v0.1.0")
-
-        if len(content) > 0:
-
-            ksigs = [cls._parse_key_signature(ksig) for ksig in content]
-
-            ks = ksigs[0]
-            ks.other_components = ksigs[1:] if len(ksigs) > 1 else []
-
-            return ks
-
-
-def interpret_as_key_signature(value: str) -> MatchKeySignature:
-    ks = MatchKeySignature.from_string(value)
-    return ks
-
-
-def format_key_signature_v1_0_0(value: MatchKeySignature) -> str:
-    value.is_list = False
-    value.fmt = "v1.0.0"
-    return str(value)
-
-
-def format_key_signature_v0_3_0(value: MatchKeySignature) -> str:
-    value.is_list = False
-    value.fmt = "v0.3.0"
-    return str(value)
-
-
-def format_key_signature_v0_3_0_list(value: MatchKeySignature) -> str:
-    value.is_list = True
-    value.fmt = "v0.3.0"
-    return str(value)
-
-
-def format_key_signature_v0_1_0(value: MatchKeySignature) -> str:
-    value.is_list = False
-    value.fmt = "v0.1.0"
-    return str(value)
-
-
-def format_time_signature_v0_1_0_list(value: MatchKeySignature) -> str:
-    value.is_list = True
-    value.fmt = "v0.1.0"
-    return str(value)
-
-
-class MatchTimeSignature(MatchParameter):
-    def __init__(
-        self,
-        numerator: int,
-        denominator: int,
-        other_components: Optional[List[Any]],
-        is_list: bool = False,
-    ) -> None:
-        super().__init__()
-        self.numerator = numerator
-        self.denominator = denominator
-        self.other_components = other_components
-        self.is_list = is_list
-
-    def __str__(self):
-
-        ts = f"{self.numerator}/{self.denominator}"
-        if self.is_list:
-            return format_list([ts] + self.other_components)
-        else:
-            return ts
-
-    def __eq__(self, ts: MatchKeySignature) -> bool:
-
-        crit = (
-            (self.numerator == ts.numerator)
-            and (self.denominator == ts.denominator)
-            and (self.other_components == ts.other_components)
-        )
-        return crit
-
-    @classmethod
-    def from_string(cls, string: str, is_list: bool = False) -> MatchTimeSignature:
-        content = interpret_as_list_fractional(string.strip())
-        numerator = content[0].numerator
-        denominator = content[0].denominator
-
-        other_components = [] if len(content) == 1 else content[1:]
-
-        return cls(
-            numerator=numerator,
-            denominator=denominator,
-            other_components=other_components,
-            is_list=is_list,
-        )
-
-
-def interpret_as_time_signature(value: str) -> MatchTimeSignature:
-
-    ts = MatchTimeSignature.from_string(value)
-    return ts
-
-
-def format_time_signature(value: MatchTimeSignature) -> str:
-    value.is_list = False
-    return str(value)
-
-
-def format_time_signature_list(value: MatchTimeSignature) -> str:
-    value.is_list = True
-    return str(value)
-
-
-## Miscellaneous utils
-
-
-def to_snake_case(field_name: str) -> str:
-    """
-    Convert name in camelCase to snake_case
-    """
-    snake_case = "".join(
-        [f"_{fn.lower()}" if fn.isupper() else fn for fn in field_name]
-    )
-
-    if snake_case.startswith("_"):
-        snake_case = snake_case[1:]
-
-    return snake_case
-
-
-def to_camel_case(field_name: str) -> str:
-    """
-    Convert name in snake_case to camelCase
-    """
-    parts = field_name.split("_")
-
-    camel_case = f"{parts[0].lower()}"
-
-    if len(parts) > 1:
-
-        camel_case += "".join([p.title() for p in parts[1:]])
-
-    return camel_case
-
-
-def get_kwargs_from_matchline(
-    matchline: str,
-    pattern: re.Pattern,
-    field_names: Tuple[str],
-    class_dict: Dict[str, Tuple[Callable, Callable, type]],
-    pos: int = 0,
-) -> Optional[Dict[str, Any]]:
-    """
-    Parameters
-    ----------
-    matchline: str
-    pattern: re.Pattern
-    field_names: Tuple[str]
-    class_dict: Dict[str, Tuple[Callable, Callable, type]]
-    pos: int
-
-    Returns
-    -------
-    kwargs : dict
-
-    """
-    kwargs = None
-    match_pattern = pattern.search(matchline, pos=pos)
-
-    if match_pattern is not None:
-
-        kwargs = dict(
-            [
-                (to_snake_case(fn), class_dict[fn][0](match_pattern.group(fn)))
-                for fn in field_names
-            ]
-        )
-
-    return kwargs
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains utilities for parsing and formatting match lines.
+"""
+from __future__ import annotations
+
+from typing import Tuple, Any, Optional, Union, List, Dict, Callable
+import re
+
+import numpy as np
+
+from collections import namedtuple
+
+from partitura.utils.music import (
+    ALTER_SIGNS,
+    fifths_mode_to_key_name,
+    note_name_to_pitch_spelling,
+    key_name_to_fifths_mode,
+    MAJOR_KEYS,
+    MINOR_KEYS,
+)
+
+Version = namedtuple("Version", ["major", "minor", "patch"])
+
+# General patterns
+rational_pattern = re.compile(r"^(?P<numerator>[0-9]+)/(?P<denominator>[0-9]+)$")
+double_rational_pattern = re.compile(
+    r"^(?P<numerator>[0-9]+)/(?P<denominator>[0-9]+)/(?P<tuple_div>[0-9]+)$"
+)
+integer_pattern = re.compile(r"^(?P<integer>[0-9]+)$")
+version_pattern = re.compile(
+    r"^(?P<major>[0-9]+)\.(?P<minor>[0-9]+)\.(?P<patch>[0-9]+)"
+)
+attribute_list_pattern = re.compile(r"^\[(?P<attributes>.*)\]")
+
+key_signature_pattern = re.compile(
+    (
+        r"(?P<step1>[A-G])(?P<alter1>[#b]*)\s*"
+        r"(?P<mode1>[a-zA-z]+)/*"
+        "(?P<step2>[A-G]*)(?P<alter2>[#b]*)"
+        r"\s*(?P<mode2>[a-zA-z]*)"
+    )
+)
+
+pitch_class_pattern = re.compile("(?P<step>[A-Ga-g])(?P<alter>[#bn]*)")
+
+number_pattern = re.compile(r"\d+")
+
+# For matchfiles before 1.0.0.
+old_version_pattern = re.compile(r"^(?P<minor>[0-9]+)\.(?P<patch>[0-9]+)")
+
+
+def interpret_version(version_string: str) -> Version:
+    """
+    Parse matchfile format version from a string. This method
+    parses a string like "1.0.0" and returns a Version instance.
+
+    Parameters
+    ----------
+    version_string : str
+        The string containg the version. The version string should be
+        in the form "{major}.{minor}.{patch}" or "{minor}.{patch}" for versions
+        previous to 1.0.0. Incorrectly formatted strings
+        will result in an error.
+
+    Returns
+    -------
+    version : Version
+        A named tuple specifying the version
+    """
+    version_info = version_pattern.search(version_string)
+
+    if version_info is not None:
+        ma, mi, pa = version_info.groups()
+        version = Version(int(ma), int(mi), int(pa))
+        return version
+
+    # If using the first pattern fails, try with old version
+    version_info = old_version_pattern.search(version_string)
+
+    if version_info is not None:
+        mi, pa = version_info.groups()
+        version = Version(0, int(mi), int(pa))
+        return version
+
+    else:
+        raise ValueError(f"The version '{version_string}' is incorrectly formatted!")
+
+
+def format_version(version: Version) -> str:
+    """
+    Format version as a string.
+
+    Parameters
+    ----------
+    version : Version
+        A Version instance.
+
+    Returns
+    -------
+    version_str : str
+        A string representation of the version.
+    """
+    ma, mi, pa = version
+
+    version_str = f"{ma}.{mi}.{pa}"
+    return version_str
+
+
+def interpret_as_int(value: str) -> int:
+    """
+    Interpret value as an integer
+
+    Parameters
+    ----------
+    value : str
+       The value to interpret as integer.
+
+    Returns
+    -------
+    int
+        The value cast as an integer.
+    """
+    return int(value)
+
+
+def format_int(value: Optional[int]) -> str:
+    """
+    Format a string from an integer
+
+    Parameters
+    ----------
+    value : int
+        The value to be converted to format as a string.
+
+    Returns
+    -------
+    str
+        The value formatted as a string.
+    """
+    return f"{int(value)}" if value is not None else "-"
+
+
+def interpret_as_float(value: str) -> float:
+    """
+    Interpret value as a float
+
+    Parameters
+    ----------
+    value : str
+       The string to interpret as float.
+
+    Returns
+    -------
+    int
+        The value cast as an float.
+    """
+    return float(value)
+
+
+def format_float(value: float) -> str:
+    """
+    Format a float as a string (with 4 digits of precision).
+
+    Parameters
+    ----------
+    value : float
+        The value to be converted to format as a string.
+
+    Returns
+    -------
+    str
+        The value formatted as a string.
+    """
+    return f"{value:.4f}"
+
+
+def format_float_unconstrained(value: float) -> str:
+    """
+    Format a float as a string.
+
+    Parameters
+    ----------
+    value : float
+        The value to be converted to format as a string.
+
+    Returns
+    -------
+    str
+        The value formatted as a string.
+    """
+    return str(value)
+
+
+def interpret_as_string(value: Any) -> str:
+    """
+    Interpret value as a string. This method is for completeness.
+
+    Parameters
+    ----------
+    value : Any
+       The value to be interpreted as a string.
+
+    Returns
+    -------
+    int
+        The string representation of the value.
+    """
+    return str(value)
+
+
+old_string_pat = re.compile(r"'(?P<value>.+)'")
+
+
+def interpret_as_string_old(value: str) -> str:
+
+    val = old_string_pat.match(value)
+    if val is not None:
+        return val.group("value").strip()
+    else:
+        return value.strip()
+
+
+def format_string(value: str) -> str:
+    """
+    Format a string as a string (for completeness ;).
+
+    Parameters
+    ----------
+    value : int
+        The value to be converted to format as a string.
+
+    Returns
+    -------
+    str
+        The value formatted as a string.
+    """
+    return str(value).strip()
+
+
+def format_string_old(value: str) -> str:
+    return f"'{value.strip()}'"
+
+
+class FractionalSymbolicDuration(object):
+    """
+    A class to represent symbolic duration information.
+
+    Parameters
+    ----------
+    numerator : int
+        The value of the numerator.
+    denominator: int
+        The denominator of the duration (whole notes = 1, half notes = 2, etc.)
+    tuple_div : int (optional)
+        Tuple divisor (for triplets, etc.). For example a single note in a quintuplet
+        with a total duration of one quarter could be specified as
+        `duration = FractionalSymbolicDuration(1, 4, 5)`.
+    add_components : List[Tuple[int, int, Optional[int]]] (optional)
+        additive components (to express durations like 1/4+1/16+1/32). The components
+        are a list of tuples, each of which contains its own numerator, denominator
+        and tuple_div (or None). To represent the components in the example above
+        this variable would look like
+        `add_components = [(1, 4, None), (1, 16, None), (1, 32, None)]`.
+    """
+
+    def __init__(
+        self,
+        numerator: int,
+        denominator: int = 1,
+        tuple_div: Optional[int] = None,
+        add_components: Optional[List[Tuple[int, int, Optional[int]]]] = None,
+    ) -> None:
+
+        self.numerator = numerator
+        self.denominator = denominator
+        self.tuple_div = tuple_div
+        self.add_components = add_components
+        self.bound_integers(1024)
+
+    def _str(
+        self,
+        numerator: int,
+        denominator: int,
+        tuple_div: Optional[int],
+    ) -> str:
+        """
+        Helper for representing an instance as a string.
+        """
+        if denominator == 1 and tuple_div is None:
+            return str(numerator)
+        else:
+            if tuple_div is None:
+                return "{0}/{1}".format(numerator, denominator)
+            else:
+                return "{0}/{1}/{2}".format(numerator, denominator, tuple_div)
+
+    def bound_integers(self, bound: int) -> None:
+        """
+        Bound numerator and denominator
+        """
+        denominators = [
+            2,
+            3,
+            4,
+            5,
+            6,
+            7,
+            8,
+            9,
+            10,
+            12,
+            14,
+            16,
+            18,
+            20,
+            22,
+            24,
+            28,
+            32,
+            48,
+            64,
+            96,
+            128,
+        ]
+        sign = (
+            np.sign(self.numerator)
+            * np.sign(self.denominator)
+            * (np.sign(self.tuple_div) if self.tuple_div is not None else 1)
+        )
+        self.numerator = np.abs(self.numerator)
+        self.denominator = np.abs(self.denominator)
+        self.tuple_div = np.abs(self.tuple_div) if self.tuple_div is not None else None
+
+        if self.numerator > bound or self.denominator > bound:
+            val = float(self.numerator / self.denominator)
+            dif = []
+            for den in denominators:
+                if np.round(val * den) > 0.9:
+                    dif.append(np.abs(np.round(val * den) - val * den))
+                else:
+                    dif.append(np.abs(1 - val * den))
+
+            difn = np.array(dif)
+            min_idx = int(np.argmin(difn))
+
+            self.denominator = denominators[min_idx]
+            if int(np.round(val * self.denominator)) < 1:
+                self.numerator = sign * 1
+            else:
+                self.numerator = sign * int(np.round(val * self.denominator))
+
+    def __str__(self) -> str:
+        """
+        Represent an instance as a string.
+        """
+        if self.add_components is None:
+            return self._str(self.numerator, self.denominator, self.tuple_div)
+        else:
+            r = [self._str(*i) for i in self.add_components]
+            return "+".join(r)
+
+    def __add__(
+        self, sd: Union[FractionalSymbolicDuration, int]
+    ) -> FractionalSymbolicDuration:
+        """
+        Define addition between FractionalSymbolicDuration instances.
+
+        Parameters
+        ----------
+        sd : Union[FractionalSymbolicDuration, int]
+            A FractionalSymbolicDuration instance or an integer to add
+            to the current instance (self).
+
+        Returns
+        -------
+        FractionalSymbolicDuration
+            A new instance with the value equal to the sum
+            of `sd` + `self`.
+        """
+        if isinstance(sd, int):
+            sd = FractionalSymbolicDuration(sd, 1)
+
+        dens = np.array(
+            [
+                self.denominator
+                * (self.tuple_div if self.tuple_div is not None else 1),
+                sd.denominator * (sd.tuple_div if sd.tuple_div is not None else 1),
+            ],
+            dtype=int,
+        )
+        new_den = np.lcm(dens[0], dens[1])
+        a_mult = new_den // dens
+        new_num = np.dot(a_mult, [self.numerator, sd.numerator])
+
+        if self.add_components is None and sd.add_components is None:
+            add_components = [
+                (self.numerator, self.denominator, self.tuple_div),
+                (sd.numerator, sd.denominator, sd.tuple_div),
+            ]
+
+        elif self.add_components is not None and sd.add_components is None:
+            add_components = self.add_components + [
+                (sd.numerator, sd.denominator, sd.tuple_div)
+            ]
+        elif self.add_components is None and sd.add_components is not None:
+            add_components = [
+                (self.numerator, self.denominator, self.tuple_div)
+            ] + sd.add_components
+        else:
+            add_components = self.add_components + sd.add_components
+
+        # Remove spurious components with 0 in the numerator
+        add_components = [c for c in add_components if c[0] != 0]
+
+        return FractionalSymbolicDuration(
+            numerator=new_num,
+            denominator=new_den,
+            add_components=add_components,
+        )
+
+    def __eq__(self, sd: FractionalSymbolicDuration) -> bool:
+        """
+        Equal magic method
+        """
+        is_equal = all(
+            [
+                getattr(self, attr, None) == getattr(sd, attr, None)
+                for attr in ("numerator", "denominator", "tuple_div", "add_components")
+            ]
+        )
+
+        return is_equal
+
+    def __ne__(self, sd: FractionalSymbolicDuration) -> bool:
+        """
+        Not equal magic method
+        """
+        not_equal = any(
+            [
+                getattr(self, attr, None) != getattr(sd, attr, None)
+                for attr in ("numerator", "denominator", "tuple_div", "add_components")
+            ]
+        )
+
+        return not_equal
+
+    def __radd__(
+        self, sd: Union[FractionalSymbolicDuration, int]
+    ) -> FractionalSymbolicDuration:
+        return self.__add__(sd)
+
+    def __float__(self) -> float:
+        # Cast as float since the ability to return an instance of a strict
+        # subclass of float is deprecated, and may be removed in a future
+        # version of Python. (following a deprecation warning)
+        return float(self.numerator / (self.denominator * (self.tuple_div or 1)))
+
+    @classmethod
+    def from_string(cls, string: str, allow_additions: bool = True):
+
+        m = rational_pattern.match(string)
+        m2 = double_rational_pattern.match(string)
+        m3 = integer_pattern.match(string)
+        if m:
+            groups = m.groups()
+            return cls(*[int(g) for g in groups])
+        elif m2:
+            groups = m2.groups()
+            return cls(*[int(g) for g in groups])
+        elif m3:
+            return cls(numerator=int(m3.group("integer")))
+
+        else:
+            if allow_additions:
+                parts = string.split("+")
+
+                if len(parts) > 1:
+                    iparts = [
+                        cls.from_string(
+                            i,
+                            allow_additions=False,
+                        )
+                        for i in parts
+                    ]
+
+                    # to be replaced with isinstance(i,numbers.Number)
+                    if all(type(i) in (int, float, cls) for i in iparts):
+                        if any([isinstance(i, cls) for i in iparts]):
+                            iparts = [
+                                cls(i) if not isinstance(i, cls) else i for i in iparts
+                            ]
+                        return sum(iparts)
+
+        raise ValueError(
+            f"{string} cannot be interpreted as FractionalSymbolicDuration"
+        )
+
+
+def interpret_as_fractional(value: str) -> FractionalSymbolicDuration:
+    """
+    Interpret string as FractionalSymbolicDuration
+    """
+
+    content = attribute_list_pattern.search(value)
+
+    if content is not None:
+        # string includes square brackets
+        vals_string = content.group("attributes")
+        content_list = [
+            FractionalSymbolicDuration.from_string(v, allow_additions=True)
+            for v in vals_string.split(",")
+        ]
+        return content_list
+
+    return FractionalSymbolicDuration.from_string(value, allow_additions=True)
+
+
+def format_fractional(
+    value: Union[List[FractionalSymbolicDuration], FractionalSymbolicDuration]
+) -> str:
+    """
+    Format fractional symbolic duration as string
+    """
+
+    if isinstance(value, list):
+        return format_list(value)
+
+    return str(value)
+
+
+def format_fractional_rational(value: FractionalSymbolicDuration) -> str:
+    """
+    Format fractional symbolic duration as string and ensure that the output
+    is always rational ("a/b")
+    """
+
+    if value.denominator == 1 and value.tuple_div is None:
+
+        out = f"{value.numerator}/1"
+
+    else:
+        out = str(value)
+
+    return out
+
+
+def interpret_as_list(value: str) -> List[str]:
+    """
+    Interpret string as list of values.
+
+    Parameters
+    ----------
+    value: str
+
+    Returns
+    -------
+    content_list : List[str]
+    """
+    content = attribute_list_pattern.search(value)
+
+    if content is not None:
+        # string includes square brackets
+        vals_string = content.group("attributes")
+        content_list = [v.strip() for v in vals_string.split(",")]
+
+    else:
+        # value is not inside square brackets
+        content_list = [v.strip() for v in value.split(",")]
+
+    return content_list
+
+
+def interpret_as_list_int(value: str) -> List[int]:
+    string_list = interpret_as_list(value)
+    return [int(v) for v in string_list]
+
+
+def interpret_as_list_fractional(value: str) -> List[FractionalSymbolicDuration]:
+    string_list = interpret_as_list(value)
+    return [FractionalSymbolicDuration.from_string(v) for v in string_list]
+
+
+def format_list(value: List[Any]) -> str:
+    formatted_string = f"[{','.join([str(v) for v in value])}]"
+    return formatted_string
+
+
+def format_accidental(value: Optional[int]) -> str:
+
+    alter = "n" if value == 0 else ALTER_SIGNS[value]
+
+    return alter
+
+
+def format_accidental_old(value: Optional[int]) -> str:
+
+    if value is None:
+        return "-"
+    else:
+        return format_accidental(value)
+
+
+def format_pnote_id(value: Any) -> str:
+
+    pnote_id = f"n{str(value)}" if not str(value).startswith("n") else str(value)
+
+    return pnote_id
+
+
+## Methods for parsing special attributes
+
+
+class MatchParameter(object):
+    def __init__(self, *args, **kwargs) -> None:
+        pass
+
+    def __str__(self) -> str:
+        raise NotImplementedError
+
+    @classmethod
+    def from_string(self, *args, **kwargs) -> MatchParameter:
+        raise NotImplementedError
+
+
+class MatchKeySignature(MatchParameter):
+    def __init__(
+        self,
+        fifths: int,
+        mode: str,
+        fifths_alt: Optional[int] = None,
+        mode_alt: Optional[str] = None,
+        is_list: bool = False,
+        other_components: Optional[List[MatchKeySignature]] = None,
+        fmt: str = "v1.0.0",
+    ):
+        super().__init__()
+        self.fifths = fifths
+        self.mode = mode
+        self.fifths_alt = fifths_alt
+        self.mode_alt = mode_alt
+        self.is_list = is_list
+        self.other_components = [] if other_components is None else other_components
+        self.fmt = fmt
+
+    @property
+    def fmt(self) -> str:
+        return self._fmt
+
+    @fmt.setter
+    def fmt(self, fmt: str) -> None:
+        self._fmt = fmt
+        for component in self.other_components:
+            component.fmt = fmt
+
+    def fifths_mode_to_key_name_v0_1_0(self, fifths: int, mode: str) -> str:
+        if mode == "major":
+            keylist = MAJOR_KEYS
+            suffix = "major"
+        elif mode == "minor":
+            keylist = MINOR_KEYS
+            suffix = "minor"
+
+        step, alter, _ = note_name_to_pitch_spelling(f"{keylist[fifths + 7]}4")
+        alter_str = "n" if (alter is None or alter == 0) else ALTER_SIGNS[alter]
+        name = f"{step.lower()}{alter_str}"
+        ks = f"[{name},{suffix}]"
+
+        return ks
+
+    def fifths_mode_to_key_name_v0_3_0(self, fifths: int, mode: str) -> str:
+        if mode == "major":
+            keylist = MAJOR_KEYS
+            suffix = "Maj"
+        elif mode == "minor":
+            keylist = MINOR_KEYS
+            suffix = "min"
+
+        name = keylist[fifths + 7]
+
+        ks = f"{name} {suffix}"
+
+        return ks
+
+    def __str__(self):
+
+        if self.fmt == "v1.0.0":
+            ks = fifths_mode_to_key_name(self.fifths, self.mode)
+
+            if self.fifths_alt is not None:
+                ks = f"{ks}/{fifths_mode_to_key_name(self.fifths_alt, self.mode_alt)}"
+
+        if self.fmt == "v0.3.0":
+            ks = self.fifths_mode_to_key_name_v0_3_0(self.fifths, self.mode)
+
+            if self.fifths_alt is not None:
+                ks = f"{ks}/{self.fifths_mode_to_key_name_v0_3_0(self.fifths_alt, self.mode_alt)}"
+
+        if self.fmt == "v0.1.0":
+            ks = self.fifths_mode_to_key_name_v0_1_0(self.fifths, self.mode)
+
+        if self.is_list:
+            return format_list([ks] + self.other_components)
+        return ks
+
+    def __eq__(self, ks: MatchKeySignature) -> bool:
+
+        crit = (
+            self.fifths == ks.fifths
+            and self.mode == ks.mode
+            and self.fifths_alt == ks.fifths_alt
+            and self.mode_alt == ks.mode_alt
+            and self.other_components == ks.other_components
+        )
+
+        return crit
+
+    @classmethod
+    def _parse_key_signature(cls, kstr: str) -> MatchKeySignature:
+
+        # import pdb
+        # pdb.set_trace()
+        ksinfo = key_signature_pattern.search(kstr)
+
+        if ksinfo is None:
+            fmt = "v1.0.0"
+            ksinfo = kstr.split("/")
+            fifths1, mode1 = key_name_to_fifths_mode(ksinfo[0].upper())
+            fifths2, mode2 = None, None
+            if len(ksinfo) == 2:
+                fifths2, mode2 = key_name_to_fifths_mode(ksinfo[1].upper())
+        else:
+
+            fmt = "v0.3.0"
+            step1, alter1, mode1, step2, alter2, mode2 = ksinfo.groups()
+            mode1_str = "m" if mode1.lower() in ("minor", "min") else ""
+            fifths1, mode1 = key_name_to_fifths_mode(
+                f"{step1.upper()}{alter1}{mode1_str}"
+            )
+
+            if step2 != "":
+                mode2_str = "m" if mode2.lower() in ("minor", "min") else ""
+                fifths2, mode2 = key_name_to_fifths_mode(
+                    f"{step2.upper()}{alter2}{mode2_str}"
+                )
+            else:
+                fifths2, mode2 = None, None
+
+        return cls(
+            fifths=fifths1,
+            mode=mode1,
+            fifths_alt=fifths2,
+            mode_alt=mode2,
+            is_list=False,
+            fmt=fmt,
+        )
+
+    @classmethod
+    def from_string(cls, string: str) -> MatchKeySignature:
+        content = interpret_as_list(string)
+
+        if len(content) == 2:
+            # try parsing it as v0.1.0
+            if content[1].lower() in ("minor", "major", "min", "maj"):
+                note_info = pitch_class_pattern.search(content[0].lower())
+
+                mode_str = "m" if content[1].lower() in ("min", "minor") else ""
+
+                if note_info is not None:
+                    step, alter = note_info.groups()
+
+                alter_str = alter.replace("n", "")
+
+                fifths, mode = key_name_to_fifths_mode(
+                    f"{step.upper()}{alter_str}{mode_str}"
+                )
+
+                return cls(fifths=fifths, mode=mode, fmt="v0.1.0")
+
+        if len(content) > 0:
+
+            ksigs = [cls._parse_key_signature(ksig) for ksig in content]
+
+            ks = ksigs[0]
+            ks.other_components = ksigs[1:] if len(ksigs) > 1 else []
+
+            return ks
+
+
+def interpret_as_key_signature(value: str) -> MatchKeySignature:
+    ks = MatchKeySignature.from_string(value)
+    return ks
+
+
+def format_key_signature_v1_0_0(value: MatchKeySignature) -> str:
+    value.is_list = False
+    value.fmt = "v1.0.0"
+    return str(value)
+
+
+def format_key_signature_v0_3_0(value: MatchKeySignature) -> str:
+    value.is_list = False
+    value.fmt = "v0.3.0"
+    return str(value)
+
+
+def format_key_signature_v0_3_0_list(value: MatchKeySignature) -> str:
+    value.is_list = True
+    value.fmt = "v0.3.0"
+    return str(value)
+
+
+def format_key_signature_v0_1_0(value: MatchKeySignature) -> str:
+    value.is_list = False
+    value.fmt = "v0.1.0"
+    return str(value)
+
+
+def format_time_signature_v0_1_0_list(value: MatchKeySignature) -> str:
+    value.is_list = True
+    value.fmt = "v0.1.0"
+    return str(value)
+
+
+class MatchTimeSignature(MatchParameter):
+    def __init__(
+        self,
+        numerator: int,
+        denominator: int,
+        other_components: Optional[List[Any]],
+        is_list: bool = False,
+    ) -> None:
+        super().__init__()
+        self.numerator = numerator
+        self.denominator = denominator
+        self.other_components = other_components
+        self.is_list = is_list
+
+    def __str__(self):
+
+        ts = f"{self.numerator}/{self.denominator}"
+        if self.is_list:
+            return format_list([ts] + self.other_components)
+        else:
+            return ts
+
+    def __eq__(self, ts: MatchKeySignature) -> bool:
+
+        crit = (
+            (self.numerator == ts.numerator)
+            and (self.denominator == ts.denominator)
+            and (self.other_components == ts.other_components)
+        )
+        return crit
+
+    @classmethod
+    def from_string(cls, string: str, is_list: bool = False) -> MatchTimeSignature:
+        content = interpret_as_list_fractional(string.strip())
+        numerator = content[0].numerator
+        denominator = content[0].denominator
+
+        other_components = [] if len(content) == 1 else content[1:]
+
+        return cls(
+            numerator=numerator,
+            denominator=denominator,
+            other_components=other_components,
+            is_list=is_list,
+        )
+
+
+def interpret_as_time_signature(value: str) -> MatchTimeSignature:
+
+    ts = MatchTimeSignature.from_string(value)
+    return ts
+
+
+def format_time_signature(value: MatchTimeSignature) -> str:
+    value.is_list = False
+    return str(value)
+
+
+def format_time_signature_list(value: MatchTimeSignature) -> str:
+    value.is_list = True
+    return str(value)
+
+
+## Miscellaneous utils
+
+
+def to_snake_case(field_name: str) -> str:
+    """
+    Convert name in camelCase to snake_case
+    """
+    snake_case = "".join(
+        [f"_{fn.lower()}" if fn.isupper() else fn for fn in field_name]
+    )
+
+    if snake_case.startswith("_"):
+        snake_case = snake_case[1:]
+
+    return snake_case
+
+
+def to_camel_case(field_name: str) -> str:
+    """
+    Convert name in snake_case to camelCase
+    """
+    parts = field_name.split("_")
+
+    camel_case = f"{parts[0].lower()}"
+
+    if len(parts) > 1:
+
+        camel_case += "".join([p.title() for p in parts[1:]])
+
+    return camel_case
+
+
+def get_kwargs_from_matchline(
+    matchline: str,
+    pattern: re.Pattern,
+    field_names: Tuple[str],
+    class_dict: Dict[str, Tuple[Callable, Callable, type]],
+    pos: int = 0,
+) -> Optional[Dict[str, Any]]:
+    """
+    Parameters
+    ----------
+    matchline: str
+    pattern: re.Pattern
+    field_names: Tuple[str]
+    class_dict: Dict[str, Tuple[Callable, Callable, type]]
+    pos: int
+
+    Returns
+    -------
+    kwargs : dict
+
+    """
+    kwargs = None
+    match_pattern = pattern.search(matchline, pos=pos)
+
+    if match_pattern is not None:
+
+        kwargs = dict(
+            [
+                (to_snake_case(fn), class_dict[fn][0](match_pattern.group(fn)))
+                for fn in field_names
+            ]
+        )
+
+    return kwargs
```

### Comparing `partitura-1.2.1/partitura/io/matchlines_v0.py` & `partitura-1.2.2/partitura/io/matchlines_v0.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,1057 +1,1057 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains definitions for Matchfile lines for version <1.0.0
-"""
-from __future__ import annotations
-
-from collections import defaultdict
-
-import re
-
-from typing import Any, Callable, Tuple, Union, List, Dict, Optional
-
-from partitura.io.matchfile_base import (
-    MatchLine,
-    MatchError,
-    BaseInfoLine,
-    BaseSnoteLine,
-    BaseNoteLine,
-    BaseSnoteNoteLine,
-    BaseDeletionLine,
-    BaseInsertionLine,
-    BaseSustainPedalLine,
-    BaseSoftPedalLine,
-    BaseOrnamentLine,
-)
-
-from partitura.io.matchfile_utils import (
-    Version,
-    interpret_version,
-    format_version,
-    interpret_as_string,
-    interpret_as_string_old,
-    format_string,
-    format_string_old,
-    interpret_as_float,
-    format_float,
-    format_float_unconstrained,
-    interpret_as_int,
-    format_int,
-    FractionalSymbolicDuration,
-    format_fractional,
-    format_fractional_rational,
-    interpret_as_fractional,
-    interpret_as_list,
-    format_list,
-    format_accidental_old,
-    MatchTimeSignature,
-    interpret_as_time_signature,
-    format_time_signature,
-    format_time_signature_list,
-    MatchKeySignature,
-    interpret_as_key_signature,
-    format_key_signature_v0_1_0,
-    format_key_signature_v0_3_0,
-    format_key_signature_v0_3_0_list,
-    get_kwargs_from_matchline,
-)
-
-from partitura.utils.music import (
-    ALTER_SIGNS,
-    pitch_spelling_to_midi_pitch,
-    ensure_pitch_spelling_format,
-)
-
-# Define last supported version of the match file format in this module
-# other modules might include different versions.
-LAST_MAJOR_VERSION = 0
-LAST_MINOR_VERSION = 5
-LAST_PATCH_VERSION = 0
-
-LAST_VERSION = Version(
-    LAST_MAJOR_VERSION,
-    LAST_MINOR_VERSION,
-    LAST_PATCH_VERSION,
-)
-
-
-# Dictionary of interpreter, formatters and datatypes for info lines
-# each entry in the dictionary is a tuple with
-# an intepreter (to parse the input), a formatter (for the output matchline)
-# and type
-
-
-default_infoline_attributes = {
-    "matchFileVersion": (interpret_version, format_version, Version),
-    "piece": (interpret_as_string_old, format_string_old, str),
-    "scoreFileName": (interpret_as_string_old, format_string_old, str),
-    "scoreFilePath": (interpret_as_string_old, format_string_old, str),
-    "midiFileName": (interpret_as_string_old, format_string_old, str),
-    "midiFilename": (interpret_as_string_old, format_string_old, str),
-    "midiFilePath": (interpret_as_string_old, format_string_old, str),
-    "audioFileName": (interpret_as_string_old, format_string_old, str),
-    "audioFilePath": (interpret_as_string_old, format_string_old, str),
-    "audioFirstNote": (interpret_as_float, format_float_unconstrained, float),
-    "audioLastNote": (interpret_as_float, format_float_unconstrained, float),
-    "performer": (interpret_as_string_old, format_string_old, str),
-    "composer": (interpret_as_string_old, format_string_old, str),
-    "midiClockUnits": (interpret_as_int, format_int, int),
-    "midiClockRate": (interpret_as_int, format_int, int),
-    "approximateTempo": (interpret_as_float, format_float_unconstrained, float),
-    "subtitle": (interpret_as_list, format_list, list),
-    # "keySignature": (interpret_as_list, format_list, list),
-    # "timeSignature": (
-    #     interpret_as_fractional,
-    #     format_fractional,
-    #     (FractionalSymbolicDuration, list),
-    # ),
-    "tempoIndication": (interpret_as_list, format_list, list),
-    "beatSubDivision": (interpret_as_list, format_list, list),
-    "beatSubdivision": (interpret_as_list, format_list, list),
-    "partSequence": (interpret_as_string, format_string, str),
-    "mergedFrom": (interpret_as_list, format_list, list),
-}
-
-# INFO_LINE = defaultdict(lambda: default_infoline_attributes.copy())
-
-INFO_LINE = {
-    Version(0, 1, 0): {
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v0_1_0,
-            MatchKeySignature,
-        ),
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature,
-            MatchTimeSignature,
-        ),
-        **default_infoline_attributes,
-    },
-    Version(0, 2, 0): {
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v0_1_0,
-            MatchKeySignature,
-        ),
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature,
-            MatchTimeSignature,
-        ),
-        **default_infoline_attributes,
-    },
-    Version(0, 3, 0): {
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v0_3_0_list,
-            MatchKeySignature,
-        ),
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature,
-            MatchTimeSignature,
-        ),
-        **default_infoline_attributes,
-    },
-    Version(0, 4, 0): {
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v0_3_0_list,
-            MatchKeySignature,
-        ),
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature_list,
-            MatchTimeSignature,
-        ),
-        **default_infoline_attributes,
-    },
-    Version(0, 5, 0): {
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v0_3_0_list,
-            MatchKeySignature,
-        ),
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature_list,
-            MatchTimeSignature,
-        ),
-        **default_infoline_attributes,
-    },
-}
-
-
-class MatchInfo(BaseInfoLine):
-    """
-    Main class specifying global information lines.
-
-    For version 0.x.0, these lines have the general structure:
-
-    `info(attribute,value).`
-
-    Parameters
-    ----------
-    version : Version
-        The version of the info line.
-    kwargs : keyword arguments
-        Keyword arguments specifying the type of line and its value.
-    """
-
-    def __init__(
-        self,
-        version: Version,
-        attribute: str,
-        value: Any,
-        value_type: type,
-        format_fun: Callable[Any, str],
-    ) -> None:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError("The version must be < 1.0.0")
-
-        super().__init__(
-            version=version,
-            attribute=attribute,
-            value=value,
-            value_type=value_type,
-            format_fun=format_fun,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LAST_VERSION,
-    ) -> MatchInfo:
-        """
-        Create a new MatchLine object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchInfo instance
-        """
-
-        if version >= Version(1, 0, 0):
-            raise ValueError("The version must be < 1.0.0")
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-
-        class_dict = INFO_LINE[version]
-
-        if match_pattern is not None:
-            attribute, value_str = match_pattern.groups()
-            if attribute not in class_dict:
-                raise ValueError(f"Attribute {attribute} is not specified in {version}")
-
-            interpret_fun, format_fun, value_type = class_dict[attribute]
-
-            value = interpret_fun(value_str)
-
-            return cls(
-                version=version,
-                attribute=attribute,
-                value=value,
-                value_type=value_type,
-                format_fun=format_fun,
-            )
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-
-default_meta_attributes = {
-    "timeSignature": (
-        interpret_as_time_signature,
-        format_time_signature,
-        MatchTimeSignature,
-    ),
-    "keySignature": (
-        interpret_as_key_signature,
-        format_key_signature_v0_3_0,
-        MatchKeySignature,
-    ),
-}
-META_LINE = {
-    Version(0, 3, 0): default_meta_attributes,
-    Version(0, 4, 0): default_meta_attributes,
-    Version(0, 5, 0): default_meta_attributes,
-}
-
-
-class MatchMeta(MatchLine):
-
-    field_names = (
-        "Attribute",
-        "Value",
-        "Measure",
-        "TimeInBeats",
-    )
-
-    out_pattern = "meta({Attribute},{Value},{Measure},{TimeInBeats})."
-
-    pattern = re.compile(
-        r"meta\("
-        r"(?P<Attribute>[^,]+),"
-        r"(?P<Value>[^,]+),"
-        r"(?P<Measure>[^,]+),"
-        r"(?P<TimeInBeats>[^,]+)\)\."
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        attribute: str,
-        value: Any,
-        value_type: type,
-        format_fun: Callable[Any, str],
-        measure: int,
-        time_in_beats: float,
-    ) -> None:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError("The version must be < 1.0.0")
-
-        super().__init__(version)
-
-        self.field_types = (
-            str,
-            value_type,
-            int,
-            float,
-        )
-
-        self.format_fun = dict(
-            Attribute=format_string,
-            Value=format_fun,
-            Measure=format_int,
-            TimeInBeats=format_float_unconstrained,
-        )
-
-        # set class attributes
-        self.Attribute = attribute
-        self.Value = value
-        self.Measure = measure
-        self.TimeInBeats = time_in_beats
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LAST_VERSION,
-    ) -> MatchMeta:
-        """
-        Create a new MatchMeta object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchScoreProp object
-        """
-
-        if version not in META_LINE:
-            raise ValueError(f"{version} is not specified for this class.")
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-
-        class_dict = META_LINE[version]
-
-        if match_pattern is not None:
-
-            (
-                attribute,
-                value_str,
-                measure_str,
-                time_in_beats_str,
-            ) = match_pattern.groups()
-
-            if attribute not in class_dict:
-                raise ValueError(f"Attribute {attribute} is not specified in {version}")
-
-            interpret_fun, format_fun, value_type = class_dict[attribute]
-
-            value = interpret_fun(value_str)
-
-            measure = interpret_as_int(measure_str)
-
-            time_in_beats = interpret_as_float(time_in_beats_str)
-
-            return cls(
-                version=version,
-                attribute=attribute,
-                value=value,
-                value_type=value_type,
-                format_fun=format_fun,
-                measure=measure,
-                time_in_beats=time_in_beats,
-            )
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-
-SNOTE_LINE_Vgeq0_4_0 = dict(
-    Anchor=format_string,
-    NoteName=lambda x: str(x).upper(),
-    Modifier=format_accidental_old,
-    Octave=format_int,
-    Measure=format_int,
-    Beat=format_int,
-    Offset=format_fractional,
-    Duration=format_fractional,
-    OnsetInBeats=format_float_unconstrained,
-    OffsetInBeats=format_float_unconstrained,
-    ScoreAttributesList=format_list,
-)
-
-SNOTE_LINE_Vlt0_3_0 = dict(
-    Anchor=format_string,
-    NoteName=lambda x: str(x).lower(),
-    Modifier=format_accidental_old,
-    Octave=format_int,
-    Measure=format_int,
-    Beat=format_int,
-    Offset=format_fractional_rational,
-    Duration=format_fractional_rational,
-    OnsetInBeats=lambda x: f"{x:.5f}",
-    OffsetInBeats=lambda x: f"{x:.5f}",
-    ScoreAttributesList=format_list,
-)
-
-SNOTE_LINE = {
-    Version(0, 5, 0): SNOTE_LINE_Vgeq0_4_0,
-    Version(0, 4, 0): SNOTE_LINE_Vgeq0_4_0,
-    Version(0, 3, 0): dict(
-        Anchor=format_string,
-        NoteName=lambda x: str(x).lower(),
-        Modifier=format_accidental_old,
-        Octave=format_int,
-        Measure=format_int,
-        Beat=format_int,
-        Offset=format_fractional,
-        Duration=format_fractional,
-        OnsetInBeats=format_float_unconstrained,
-        OffsetInBeats=format_float_unconstrained,
-        ScoreAttributesList=format_list,
-    ),
-    Version(0, 2, 0): SNOTE_LINE_Vlt0_3_0,
-    Version(0, 1, 0): SNOTE_LINE_Vlt0_3_0,
-}
-
-
-class MatchSnote(BaseSnoteLine):
-    def __init__(
-        self,
-        version: Version,
-        anchor: str,
-        note_name: str,
-        modifier: str,
-        octave: Union[int, str],
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        duration: FractionalSymbolicDuration,
-        onset_in_beats: float,
-        offset_in_beats: float,
-        score_attributes_list: List[str],
-    ) -> None:
-        if version not in SNOTE_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(SNOTE_LINE.keys())}"
-            )
-        super().__init__(
-            version=version,
-            anchor=anchor,
-            note_name=note_name,
-            modifier=modifier,
-            octave=octave,
-            measure=measure,
-            beat=beat,
-            offset=offset,
-            duration=duration,
-            onset_in_beats=onset_in_beats,
-            offset_in_beats=offset_in_beats,
-            score_attributes_list=score_attributes_list,
-        )
-
-        self.format_fun = SNOTE_LINE[version]
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LAST_VERSION,
-    ) -> MatchSnote:
-        """
-        Create a new MatchLine object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchSnote object
-        """
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} > Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            pos=pos,
-        )
-
-        return cls(version=version, **kwargs)
-
-
-# Note lines for versions larger than 3.0
-NOTE_LINE_Vge0_3_0 = {
-    "field_names": (
-        "Id",
-        "NoteName",
-        "Modifier",
-        "Octave",
-        "Onset",
-        "Offset",
-        "AdjOffset",
-        "Velocity",
-    ),
-    "out_pattern": (
-        "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},"
-        "{AdjOffset},{Velocity})."
-    ),
-    "pattern": re.compile(
-        r"note\((?P<Id>[^,]+),"
-        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
-        r"(?P<Octave>[^,]+),"
-        r"(?P<Onset>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<AdjOffset>[^,]+),"
-        r"(?P<Velocity>[^,]+)\)"
-    ),
-    "field_interpreters": {
-        "Id": (interpret_as_string, format_string, str),
-        "NoteName": (interpret_as_string, lambda x: str(x).upper(), str),
-        "Modifier": (
-            interpret_as_string,
-            format_accidental_old,
-            (int, type(None)),
-        ),
-        "Octave": (interpret_as_int, format_int, (int, type(None))),
-        "Onset": (interpret_as_int, format_int, int),
-        "Offset": (interpret_as_int, format_int, int),
-        "AdjOffset": (interpret_as_int, format_int, int),
-        "Velocity": (interpret_as_int, format_int, int),
-    },
-}
-
-NOTE_LINE_Vlt0_3_0 = {
-    "field_names": (
-        "Id",
-        "NoteName",
-        "Modifier",
-        "Octave",
-        "Onset",
-        "Offset",
-        "Velocity",
-    ),
-    "out_pattern": (
-        "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},{Velocity})."
-    ),
-    "pattern": re.compile(
-        r"note\((?P<Id>[^,]+),"
-        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
-        r"(?P<Octave>[^,]+),"
-        r"(?P<Onset>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<Velocity>[^,]+)\)"
-    ),
-    "field_interpreters": {
-        "Id": (interpret_as_string, format_string, str),
-        "NoteName": (interpret_as_string, lambda x: str(x).lower(), str),
-        "Modifier": (
-            interpret_as_string,
-            format_accidental_old,
-            (int, type(None)),
-        ),
-        "Octave": (interpret_as_int, format_int, (int, type(None))),
-        "Onset": (interpret_as_float, lambda x: f"{x:.2f}", float),
-        "Offset": (interpret_as_float, lambda x: f"{x:.2f}", float),
-        "Velocity": (interpret_as_int, format_int, int),
-    },
-}
-
-
-NOTE_LINE = {
-    Version(0, 5, 0): NOTE_LINE_Vge0_3_0,
-    Version(0, 4, 0): NOTE_LINE_Vge0_3_0,
-    Version(0, 3, 0): {
-        "field_names": (
-            "Id",
-            "NoteName",
-            "Modifier",
-            "Octave",
-            "Onset",
-            "Offset",
-            "AdjOffset",
-            "Velocity",
-        ),
-        "out_pattern": (
-            "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},"
-            "{AdjOffset},{Velocity})."
-        ),
-        "pattern": re.compile(
-            r"note\((?P<Id>[^,]+),"
-            r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
-            r"(?P<Octave>[^,]+),"
-            r"(?P<Onset>[^,]+),"
-            r"(?P<Offset>[^,]+),"
-            r"(?P<AdjOffset>[^,]+),"
-            r"(?P<Velocity>[^,]+)\)"
-        ),
-        "field_interpreters": {
-            "Id": (interpret_as_string, format_string, str),
-            "NoteName": (interpret_as_string, lambda x: str(x).lower(), str),
-            "Modifier": (
-                interpret_as_string,
-                format_accidental_old,
-                (int, type(None)),
-            ),
-            "Octave": (
-                interpret_as_int,
-                format_int,
-                (int, type(None)),
-            ),
-            "Onset": (interpret_as_int, format_int, int),
-            "Offset": (interpret_as_int, format_int, int),
-            "AdjOffset": (interpret_as_int, format_int, int),
-            "Velocity": (interpret_as_int, format_int, int),
-        },
-    },
-    Version(0, 2, 0): NOTE_LINE_Vlt0_3_0,
-    Version(0, 1, 0): NOTE_LINE_Vlt0_3_0,
-}
-
-
-class MatchNote(BaseNoteLine):
-    def __init__(
-        self,
-        version: Version,
-        id: str,
-        note_name: str,
-        modifier: int,
-        octave: int,
-        onset: int,
-        offset: int,
-        velocity: int,
-        **kwargs,
-    ) -> None:
-
-        if version not in NOTE_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(NOTE_LINE.keys())}"
-            )
-
-        step, alter, octave = ensure_pitch_spelling_format(note_name, modifier, octave)
-        midi_pitch = pitch_spelling_to_midi_pitch(step, alter, octave)
-
-        super().__init__(
-            version=version,
-            id=id,
-            midi_pitch=midi_pitch,
-            onset=onset,
-            offset=offset,
-            velocity=velocity,
-        )
-
-        self.field_names = NOTE_LINE[version]["field_names"]
-        self.field_types = tuple(
-            NOTE_LINE[version]["field_interpreters"][fn][2] for fn in self.field_names
-        )
-        self.format_fun = dict(
-            [
-                (fn, NOTE_LINE[version]["field_interpreters"][fn][1])
-                for fn in self.field_names
-            ]
-        )
-
-        self.pattern = NOTE_LINE[version]["pattern"]
-        self.out_pattern = NOTE_LINE[version]["out_pattern"]
-
-        self.NoteName = step
-        self.Modifier = alter
-        self.Octave = octave
-        self.AdjOffset = offset
-
-        if "adj_offset" in kwargs:
-
-            self.AdjOffset = kwargs["adj_offset"]
-
-    @property
-    def AdjDuration(self) -> float:
-        return self.AdjOffset - self.Onset
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LAST_VERSION,
-    ) -> MatchNote:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} >= Version(1, 0, 0)")
-
-        kwargs = get_kwargs_from_matchline(
-            matchline=matchline,
-            pattern=NOTE_LINE[version]["pattern"],
-            field_names=NOTE_LINE[version]["field_names"],
-            class_dict=NOTE_LINE[version]["field_interpreters"],
-            pos=pos,
-        )
-
-        if kwargs is not None:
-            return cls(version=version, **kwargs)
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-
-class MatchSnoteNote(BaseSnoteNoteLine):
-    def __init__(
-        self,
-        version: Version,
-        snote: MatchSnote,
-        note: MatchNote,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            snote=snote,
-            note=note,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-    ) -> MatchSnoteNote:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} >= Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            snote_class=MatchSnote,
-            note_class=MatchNote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-
-class MatchSnoteDeletion(BaseDeletionLine):
-    def __init__(self, version: Version, snote: MatchSnote) -> None:
-
-        super().__init__(
-            version=version,
-            snote=snote,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-    ) -> MatchSnoteDeletion:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} >= Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            snote_class=MatchSnote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-
-class MatchSnoteTrailingScore(MatchSnoteDeletion):
-    out_pattern = "{SnoteLine}-trailing_score_note."
-
-    def __init__(self, version: Version, snote: MatchSnote) -> None:
-        super().__init__(version=version, snote=snote)
-        self.pattern = re.compile(
-            rf"{self.snote.pattern.pattern}-trailing_score_note\."
-        )
-
-
-class MatchSnoteNoPlayedNote(MatchSnoteDeletion):
-    out_pattern = "{SnoteLine}-no_played_note."
-
-    def __init__(self, version: Version, snote: MatchSnote) -> None:
-        super().__init__(version=version, snote=snote)
-        self.pattern = re.compile(rf"{self.snote.pattern.pattern}-no_played_note\.")
-
-
-class MatchInsertionNote(BaseInsertionLine):
-    def __init__(self, version: Version, note: MatchNote) -> None:
-
-        super().__init__(
-            version=version,
-            note=note,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-    ) -> MatchInsertionNote:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} >= Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            note_class=MatchNote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-
-class MatchHammerBounceNote(MatchInsertionNote):
-
-    out_pattern = "hammer_bounce-{NoteLine}"
-
-    def __init__(self, version: Version, note: MatchNote) -> None:
-        super().__init__(version=version, note=note)
-        self.pattern = re.compile(f"hammer_bounce-{self.note.pattern.pattern}")
-
-
-class MatchTrailingPlayedNote(MatchInsertionNote):
-
-    out_pattern = "trailing_played_note-{NoteLine}"
-
-    def __init__(self, version: Version, note: MatchNote) -> None:
-        super().__init__(version=version, note=note)
-        self.pattern = re.compile(f"trailing_played_note-{self.note.pattern.pattern}")
-
-
-class MatchTrillNote(BaseOrnamentLine):
-
-    out_pattern = "trill({Anchor})-{NoteLine}"
-    ornament_pattern: re.Pattern = re.compile(r"trill\((?P<Anchor>[^\)]*)\)-")
-
-    def __init__(
-        self,
-        version: Version,
-        anchor: str,
-        note: BaseNoteLine,
-    ) -> None:
-        super().__init__(
-            version=version,
-            anchor=anchor,
-            note=note,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-    ) -> MatchTrillNote:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} >= Version(1, 0, 0)")
-
-        anchor_pattern = cls.ornament_pattern.search(matchline)
-
-        if anchor_pattern is None:
-            raise MatchError("")
-        note = MatchNote.from_matchline(matchline, version=version)
-
-        return cls(
-            version=version,
-            note=note,
-            anchor=interpret_as_string(anchor_pattern.group("Anchor")),
-        )
-
-
-class MatchSustainPedal(BaseSustainPedalLine):
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            time=time,
-            value=value,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-        pos: int = 0,
-    ) -> MatchSustainPedal:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} less than 1.0.0")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            version=version,
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(**kwargs)
-
-
-class MatchSoftPedal(BaseSoftPedalLine):
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            time=time,
-            value=value,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LAST_VERSION,
-        pos: int = 0,
-    ) -> MatchSoftPedal:
-
-        if version >= Version(1, 0, 0):
-            raise ValueError(f"{version} should be less than 1.0.0")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            version=version,
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(**kwargs)
-
-
-FROM_MATCHLINE_METHODS = [
-    MatchSnoteNote.from_matchline,
-    MatchSnoteDeletion.from_matchline,
-    MatchSnoteTrailingScore.from_matchline,
-    MatchSnoteNoPlayedNote.from_matchline,
-    MatchInsertionNote.from_matchline,
-    MatchHammerBounceNote.from_matchline,
-    MatchTrailingPlayedNote.from_matchline,
-    MatchTrillNote.from_matchline,
-    MatchSustainPedal.from_matchline,
-    MatchSoftPedal.from_matchline,
-    MatchInfo.from_matchline,
-    MatchMeta.from_matchline,
-]
-
-
-def parse_matchline(line: str, version: Version) -> Optional[MatchLine]:
-    def parse(mlt: MatchLine) -> Optional[MatchLine]:
-        matchline = None
-        try:
-            matchline = mlt.from_matchline(line, version)
-        except MatchError:
-            pass
-
-        return matchline
-
-    matchline = None
-    if matchline.startswith("info"):
-        return parse(MatchInfo)
-
-    if line.startswith("meta"):
-        return parse(MatchMeta)
-
-    if line.startswith("snote"):
-
-        for mlt in [
-            MatchSnoteNote,
-            MatchSnoteDeletion,
-            MatchSnoteTrailingScore,
-            MatchSnoteNoPlayedNote,
-        ]:
-            matchline = parse(mlt)
-            if matchline is not None:
-                return matchline
-
-    if line.startswith("insertion"):
-        return parse(MatchInsertionNote)
-
-    if line.startswith("trailing_played"):
-        return parse(MatchTrailingPlayedNote)
-
-    if line.startswith("hammer_bounce"):
-        return parse(MatchHammerBounceNote)
-
-    if line.startswith("sustain"):
-        return parse(MatchSustainPedal)
-
-    if line.startswith("soft"):
-        return parse(MatchSoftPedal)
-
-    if line.startswith("trill"):
-        return parse(MatchTrillNote)
-
-    return matchline
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains definitions for Matchfile lines for version <1.0.0
+"""
+from __future__ import annotations
+
+from collections import defaultdict
+
+import re
+
+from typing import Any, Callable, Tuple, Union, List, Dict, Optional
+
+from partitura.io.matchfile_base import (
+    MatchLine,
+    MatchError,
+    BaseInfoLine,
+    BaseSnoteLine,
+    BaseNoteLine,
+    BaseSnoteNoteLine,
+    BaseDeletionLine,
+    BaseInsertionLine,
+    BaseSustainPedalLine,
+    BaseSoftPedalLine,
+    BaseOrnamentLine,
+)
+
+from partitura.io.matchfile_utils import (
+    Version,
+    interpret_version,
+    format_version,
+    interpret_as_string,
+    interpret_as_string_old,
+    format_string,
+    format_string_old,
+    interpret_as_float,
+    format_float,
+    format_float_unconstrained,
+    interpret_as_int,
+    format_int,
+    FractionalSymbolicDuration,
+    format_fractional,
+    format_fractional_rational,
+    interpret_as_fractional,
+    interpret_as_list,
+    format_list,
+    format_accidental_old,
+    MatchTimeSignature,
+    interpret_as_time_signature,
+    format_time_signature,
+    format_time_signature_list,
+    MatchKeySignature,
+    interpret_as_key_signature,
+    format_key_signature_v0_1_0,
+    format_key_signature_v0_3_0,
+    format_key_signature_v0_3_0_list,
+    get_kwargs_from_matchline,
+)
+
+from partitura.utils.music import (
+    ALTER_SIGNS,
+    pitch_spelling_to_midi_pitch,
+    ensure_pitch_spelling_format,
+)
+
+# Define last supported version of the match file format in this module
+# other modules might include different versions.
+LAST_MAJOR_VERSION = 0
+LAST_MINOR_VERSION = 5
+LAST_PATCH_VERSION = 0
+
+LAST_VERSION = Version(
+    LAST_MAJOR_VERSION,
+    LAST_MINOR_VERSION,
+    LAST_PATCH_VERSION,
+)
+
+
+# Dictionary of interpreter, formatters and datatypes for info lines
+# each entry in the dictionary is a tuple with
+# an intepreter (to parse the input), a formatter (for the output matchline)
+# and type
+
+
+default_infoline_attributes = {
+    "matchFileVersion": (interpret_version, format_version, Version),
+    "piece": (interpret_as_string_old, format_string_old, str),
+    "scoreFileName": (interpret_as_string_old, format_string_old, str),
+    "scoreFilePath": (interpret_as_string_old, format_string_old, str),
+    "midiFileName": (interpret_as_string_old, format_string_old, str),
+    "midiFilename": (interpret_as_string_old, format_string_old, str),
+    "midiFilePath": (interpret_as_string_old, format_string_old, str),
+    "audioFileName": (interpret_as_string_old, format_string_old, str),
+    "audioFilePath": (interpret_as_string_old, format_string_old, str),
+    "audioFirstNote": (interpret_as_float, format_float_unconstrained, float),
+    "audioLastNote": (interpret_as_float, format_float_unconstrained, float),
+    "performer": (interpret_as_string_old, format_string_old, str),
+    "composer": (interpret_as_string_old, format_string_old, str),
+    "midiClockUnits": (interpret_as_int, format_int, int),
+    "midiClockRate": (interpret_as_int, format_int, int),
+    "approximateTempo": (interpret_as_float, format_float_unconstrained, float),
+    "subtitle": (interpret_as_list, format_list, list),
+    # "keySignature": (interpret_as_list, format_list, list),
+    # "timeSignature": (
+    #     interpret_as_fractional,
+    #     format_fractional,
+    #     (FractionalSymbolicDuration, list),
+    # ),
+    "tempoIndication": (interpret_as_list, format_list, list),
+    "beatSubDivision": (interpret_as_list, format_list, list),
+    "beatSubdivision": (interpret_as_list, format_list, list),
+    "partSequence": (interpret_as_string, format_string, str),
+    "mergedFrom": (interpret_as_list, format_list, list),
+}
+
+# INFO_LINE = defaultdict(lambda: default_infoline_attributes.copy())
+
+INFO_LINE = {
+    Version(0, 1, 0): {
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v0_1_0,
+            MatchKeySignature,
+        ),
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature,
+            MatchTimeSignature,
+        ),
+        **default_infoline_attributes,
+    },
+    Version(0, 2, 0): {
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v0_1_0,
+            MatchKeySignature,
+        ),
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature,
+            MatchTimeSignature,
+        ),
+        **default_infoline_attributes,
+    },
+    Version(0, 3, 0): {
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v0_3_0_list,
+            MatchKeySignature,
+        ),
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature,
+            MatchTimeSignature,
+        ),
+        **default_infoline_attributes,
+    },
+    Version(0, 4, 0): {
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v0_3_0_list,
+            MatchKeySignature,
+        ),
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature_list,
+            MatchTimeSignature,
+        ),
+        **default_infoline_attributes,
+    },
+    Version(0, 5, 0): {
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v0_3_0_list,
+            MatchKeySignature,
+        ),
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature_list,
+            MatchTimeSignature,
+        ),
+        **default_infoline_attributes,
+    },
+}
+
+
+class MatchInfo(BaseInfoLine):
+    """
+    Main class specifying global information lines.
+
+    For version 0.x.0, these lines have the general structure:
+
+    `info(attribute,value).`
+
+    Parameters
+    ----------
+    version : Version
+        The version of the info line.
+    kwargs : keyword arguments
+        Keyword arguments specifying the type of line and its value.
+    """
+
+    def __init__(
+        self,
+        version: Version,
+        attribute: str,
+        value: Any,
+        value_type: type,
+        format_fun: Callable[Any, str],
+    ) -> None:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError("The version must be < 1.0.0")
+
+        super().__init__(
+            version=version,
+            attribute=attribute,
+            value=value,
+            value_type=value_type,
+            format_fun=format_fun,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LAST_VERSION,
+    ) -> MatchInfo:
+        """
+        Create a new MatchLine object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchInfo instance
+        """
+
+        if version >= Version(1, 0, 0):
+            raise ValueError("The version must be < 1.0.0")
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+
+        class_dict = INFO_LINE[version]
+
+        if match_pattern is not None:
+            attribute, value_str = match_pattern.groups()
+            if attribute not in class_dict:
+                raise ValueError(f"Attribute {attribute} is not specified in {version}")
+
+            interpret_fun, format_fun, value_type = class_dict[attribute]
+
+            value = interpret_fun(value_str)
+
+            return cls(
+                version=version,
+                attribute=attribute,
+                value=value,
+                value_type=value_type,
+                format_fun=format_fun,
+            )
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+
+default_meta_attributes = {
+    "timeSignature": (
+        interpret_as_time_signature,
+        format_time_signature,
+        MatchTimeSignature,
+    ),
+    "keySignature": (
+        interpret_as_key_signature,
+        format_key_signature_v0_3_0,
+        MatchKeySignature,
+    ),
+}
+META_LINE = {
+    Version(0, 3, 0): default_meta_attributes,
+    Version(0, 4, 0): default_meta_attributes,
+    Version(0, 5, 0): default_meta_attributes,
+}
+
+
+class MatchMeta(MatchLine):
+
+    field_names = (
+        "Attribute",
+        "Value",
+        "Measure",
+        "TimeInBeats",
+    )
+
+    out_pattern = "meta({Attribute},{Value},{Measure},{TimeInBeats})."
+
+    pattern = re.compile(
+        r"meta\("
+        r"(?P<Attribute>[^,]+),"
+        r"(?P<Value>[^,]+),"
+        r"(?P<Measure>[^,]+),"
+        r"(?P<TimeInBeats>[^,]+)\)\."
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        attribute: str,
+        value: Any,
+        value_type: type,
+        format_fun: Callable[Any, str],
+        measure: int,
+        time_in_beats: float,
+    ) -> None:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError("The version must be < 1.0.0")
+
+        super().__init__(version)
+
+        self.field_types = (
+            str,
+            value_type,
+            int,
+            float,
+        )
+
+        self.format_fun = dict(
+            Attribute=format_string,
+            Value=format_fun,
+            Measure=format_int,
+            TimeInBeats=format_float_unconstrained,
+        )
+
+        # set class attributes
+        self.Attribute = attribute
+        self.Value = value
+        self.Measure = measure
+        self.TimeInBeats = time_in_beats
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LAST_VERSION,
+    ) -> MatchMeta:
+        """
+        Create a new MatchMeta object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchScoreProp object
+        """
+
+        if version not in META_LINE:
+            raise ValueError(f"{version} is not specified for this class.")
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+
+        class_dict = META_LINE[version]
+
+        if match_pattern is not None:
+
+            (
+                attribute,
+                value_str,
+                measure_str,
+                time_in_beats_str,
+            ) = match_pattern.groups()
+
+            if attribute not in class_dict:
+                raise ValueError(f"Attribute {attribute} is not specified in {version}")
+
+            interpret_fun, format_fun, value_type = class_dict[attribute]
+
+            value = interpret_fun(value_str)
+
+            measure = interpret_as_int(measure_str)
+
+            time_in_beats = interpret_as_float(time_in_beats_str)
+
+            return cls(
+                version=version,
+                attribute=attribute,
+                value=value,
+                value_type=value_type,
+                format_fun=format_fun,
+                measure=measure,
+                time_in_beats=time_in_beats,
+            )
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+
+SNOTE_LINE_Vgeq0_4_0 = dict(
+    Anchor=format_string,
+    NoteName=lambda x: str(x).upper(),
+    Modifier=format_accidental_old,
+    Octave=format_int,
+    Measure=format_int,
+    Beat=format_int,
+    Offset=format_fractional,
+    Duration=format_fractional,
+    OnsetInBeats=format_float_unconstrained,
+    OffsetInBeats=format_float_unconstrained,
+    ScoreAttributesList=format_list,
+)
+
+SNOTE_LINE_Vlt0_3_0 = dict(
+    Anchor=format_string,
+    NoteName=lambda x: str(x).lower(),
+    Modifier=format_accidental_old,
+    Octave=format_int,
+    Measure=format_int,
+    Beat=format_int,
+    Offset=format_fractional_rational,
+    Duration=format_fractional_rational,
+    OnsetInBeats=lambda x: f"{x:.5f}",
+    OffsetInBeats=lambda x: f"{x:.5f}",
+    ScoreAttributesList=format_list,
+)
+
+SNOTE_LINE = {
+    Version(0, 5, 0): SNOTE_LINE_Vgeq0_4_0,
+    Version(0, 4, 0): SNOTE_LINE_Vgeq0_4_0,
+    Version(0, 3, 0): dict(
+        Anchor=format_string,
+        NoteName=lambda x: str(x).lower(),
+        Modifier=format_accidental_old,
+        Octave=format_int,
+        Measure=format_int,
+        Beat=format_int,
+        Offset=format_fractional,
+        Duration=format_fractional,
+        OnsetInBeats=format_float_unconstrained,
+        OffsetInBeats=format_float_unconstrained,
+        ScoreAttributesList=format_list,
+    ),
+    Version(0, 2, 0): SNOTE_LINE_Vlt0_3_0,
+    Version(0, 1, 0): SNOTE_LINE_Vlt0_3_0,
+}
+
+
+class MatchSnote(BaseSnoteLine):
+    def __init__(
+        self,
+        version: Version,
+        anchor: str,
+        note_name: str,
+        modifier: str,
+        octave: Union[int, str],
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        duration: FractionalSymbolicDuration,
+        onset_in_beats: float,
+        offset_in_beats: float,
+        score_attributes_list: List[str],
+    ) -> None:
+        if version not in SNOTE_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(SNOTE_LINE.keys())}"
+            )
+        super().__init__(
+            version=version,
+            anchor=anchor,
+            note_name=note_name,
+            modifier=modifier,
+            octave=octave,
+            measure=measure,
+            beat=beat,
+            offset=offset,
+            duration=duration,
+            onset_in_beats=onset_in_beats,
+            offset_in_beats=offset_in_beats,
+            score_attributes_list=score_attributes_list,
+        )
+
+        self.format_fun = SNOTE_LINE[version]
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LAST_VERSION,
+    ) -> MatchSnote:
+        """
+        Create a new MatchLine object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchSnote object
+        """
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} > Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            pos=pos,
+        )
+
+        return cls(version=version, **kwargs)
+
+
+# Note lines for versions larger than 3.0
+NOTE_LINE_Vge0_3_0 = {
+    "field_names": (
+        "Id",
+        "NoteName",
+        "Modifier",
+        "Octave",
+        "Onset",
+        "Offset",
+        "AdjOffset",
+        "Velocity",
+    ),
+    "out_pattern": (
+        "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},"
+        "{AdjOffset},{Velocity})."
+    ),
+    "pattern": re.compile(
+        r"note\((?P<Id>[^,]+),"
+        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
+        r"(?P<Octave>[^,]+),"
+        r"(?P<Onset>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<AdjOffset>[^,]+),"
+        r"(?P<Velocity>[^,]+)\)"
+    ),
+    "field_interpreters": {
+        "Id": (interpret_as_string, format_string, str),
+        "NoteName": (interpret_as_string, lambda x: str(x).upper(), str),
+        "Modifier": (
+            interpret_as_string,
+            format_accidental_old,
+            (int, type(None)),
+        ),
+        "Octave": (interpret_as_int, format_int, (int, type(None))),
+        "Onset": (interpret_as_int, format_int, int),
+        "Offset": (interpret_as_int, format_int, int),
+        "AdjOffset": (interpret_as_int, format_int, int),
+        "Velocity": (interpret_as_int, format_int, int),
+    },
+}
+
+NOTE_LINE_Vlt0_3_0 = {
+    "field_names": (
+        "Id",
+        "NoteName",
+        "Modifier",
+        "Octave",
+        "Onset",
+        "Offset",
+        "Velocity",
+    ),
+    "out_pattern": (
+        "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},{Velocity})."
+    ),
+    "pattern": re.compile(
+        r"note\((?P<Id>[^,]+),"
+        r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
+        r"(?P<Octave>[^,]+),"
+        r"(?P<Onset>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<Velocity>[^,]+)\)"
+    ),
+    "field_interpreters": {
+        "Id": (interpret_as_string, format_string, str),
+        "NoteName": (interpret_as_string, lambda x: str(x).lower(), str),
+        "Modifier": (
+            interpret_as_string,
+            format_accidental_old,
+            (int, type(None)),
+        ),
+        "Octave": (interpret_as_int, format_int, (int, type(None))),
+        "Onset": (interpret_as_float, lambda x: f"{x:.2f}", float),
+        "Offset": (interpret_as_float, lambda x: f"{x:.2f}", float),
+        "Velocity": (interpret_as_int, format_int, int),
+    },
+}
+
+
+NOTE_LINE = {
+    Version(0, 5, 0): NOTE_LINE_Vge0_3_0,
+    Version(0, 4, 0): NOTE_LINE_Vge0_3_0,
+    Version(0, 3, 0): {
+        "field_names": (
+            "Id",
+            "NoteName",
+            "Modifier",
+            "Octave",
+            "Onset",
+            "Offset",
+            "AdjOffset",
+            "Velocity",
+        ),
+        "out_pattern": (
+            "note({Id},[{NoteName},{Modifier}],{Octave},{Onset},{Offset},"
+            "{AdjOffset},{Velocity})."
+        ),
+        "pattern": re.compile(
+            r"note\((?P<Id>[^,]+),"
+            r"\[(?P<NoteName>[^,]+),(?P<Modifier>[^,]+)\],"
+            r"(?P<Octave>[^,]+),"
+            r"(?P<Onset>[^,]+),"
+            r"(?P<Offset>[^,]+),"
+            r"(?P<AdjOffset>[^,]+),"
+            r"(?P<Velocity>[^,]+)\)"
+        ),
+        "field_interpreters": {
+            "Id": (interpret_as_string, format_string, str),
+            "NoteName": (interpret_as_string, lambda x: str(x).lower(), str),
+            "Modifier": (
+                interpret_as_string,
+                format_accidental_old,
+                (int, type(None)),
+            ),
+            "Octave": (
+                interpret_as_int,
+                format_int,
+                (int, type(None)),
+            ),
+            "Onset": (interpret_as_int, format_int, int),
+            "Offset": (interpret_as_int, format_int, int),
+            "AdjOffset": (interpret_as_int, format_int, int),
+            "Velocity": (interpret_as_int, format_int, int),
+        },
+    },
+    Version(0, 2, 0): NOTE_LINE_Vlt0_3_0,
+    Version(0, 1, 0): NOTE_LINE_Vlt0_3_0,
+}
+
+
+class MatchNote(BaseNoteLine):
+    def __init__(
+        self,
+        version: Version,
+        id: str,
+        note_name: str,
+        modifier: int,
+        octave: int,
+        onset: int,
+        offset: int,
+        velocity: int,
+        **kwargs,
+    ) -> None:
+
+        if version not in NOTE_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(NOTE_LINE.keys())}"
+            )
+
+        step, alter, octave = ensure_pitch_spelling_format(note_name, modifier, octave)
+        midi_pitch = pitch_spelling_to_midi_pitch(step, alter, octave)
+
+        super().__init__(
+            version=version,
+            id=id,
+            midi_pitch=midi_pitch,
+            onset=onset,
+            offset=offset,
+            velocity=velocity,
+        )
+
+        self.field_names = NOTE_LINE[version]["field_names"]
+        self.field_types = tuple(
+            NOTE_LINE[version]["field_interpreters"][fn][2] for fn in self.field_names
+        )
+        self.format_fun = dict(
+            [
+                (fn, NOTE_LINE[version]["field_interpreters"][fn][1])
+                for fn in self.field_names
+            ]
+        )
+
+        self.pattern = NOTE_LINE[version]["pattern"]
+        self.out_pattern = NOTE_LINE[version]["out_pattern"]
+
+        self.NoteName = step
+        self.Modifier = alter
+        self.Octave = octave
+        self.AdjOffset = offset
+
+        if "adj_offset" in kwargs:
+
+            self.AdjOffset = kwargs["adj_offset"]
+
+    @property
+    def AdjDuration(self) -> float:
+        return self.AdjOffset - self.Onset
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LAST_VERSION,
+    ) -> MatchNote:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} >= Version(1, 0, 0)")
+
+        kwargs = get_kwargs_from_matchline(
+            matchline=matchline,
+            pattern=NOTE_LINE[version]["pattern"],
+            field_names=NOTE_LINE[version]["field_names"],
+            class_dict=NOTE_LINE[version]["field_interpreters"],
+            pos=pos,
+        )
+
+        if kwargs is not None:
+            return cls(version=version, **kwargs)
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+
+class MatchSnoteNote(BaseSnoteNoteLine):
+    def __init__(
+        self,
+        version: Version,
+        snote: MatchSnote,
+        note: MatchNote,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            snote=snote,
+            note=note,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+    ) -> MatchSnoteNote:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} >= Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            snote_class=MatchSnote,
+            note_class=MatchNote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+
+class MatchSnoteDeletion(BaseDeletionLine):
+    def __init__(self, version: Version, snote: MatchSnote) -> None:
+
+        super().__init__(
+            version=version,
+            snote=snote,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+    ) -> MatchSnoteDeletion:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} >= Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            snote_class=MatchSnote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+
+class MatchSnoteTrailingScore(MatchSnoteDeletion):
+    out_pattern = "{SnoteLine}-trailing_score_note."
+
+    def __init__(self, version: Version, snote: MatchSnote) -> None:
+        super().__init__(version=version, snote=snote)
+        self.pattern = re.compile(
+            rf"{self.snote.pattern.pattern}-trailing_score_note\."
+        )
+
+
+class MatchSnoteNoPlayedNote(MatchSnoteDeletion):
+    out_pattern = "{SnoteLine}-no_played_note."
+
+    def __init__(self, version: Version, snote: MatchSnote) -> None:
+        super().__init__(version=version, snote=snote)
+        self.pattern = re.compile(rf"{self.snote.pattern.pattern}-no_played_note\.")
+
+
+class MatchInsertionNote(BaseInsertionLine):
+    def __init__(self, version: Version, note: MatchNote) -> None:
+
+        super().__init__(
+            version=version,
+            note=note,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+    ) -> MatchInsertionNote:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} >= Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            note_class=MatchNote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+
+class MatchHammerBounceNote(MatchInsertionNote):
+
+    out_pattern = "hammer_bounce-{NoteLine}"
+
+    def __init__(self, version: Version, note: MatchNote) -> None:
+        super().__init__(version=version, note=note)
+        self.pattern = re.compile(f"hammer_bounce-{self.note.pattern.pattern}")
+
+
+class MatchTrailingPlayedNote(MatchInsertionNote):
+
+    out_pattern = "trailing_played_note-{NoteLine}"
+
+    def __init__(self, version: Version, note: MatchNote) -> None:
+        super().__init__(version=version, note=note)
+        self.pattern = re.compile(f"trailing_played_note-{self.note.pattern.pattern}")
+
+
+class MatchTrillNote(BaseOrnamentLine):
+
+    out_pattern = "trill({Anchor})-{NoteLine}"
+    ornament_pattern: re.Pattern = re.compile(r"trill\((?P<Anchor>[^\)]*)\)-")
+
+    def __init__(
+        self,
+        version: Version,
+        anchor: str,
+        note: BaseNoteLine,
+    ) -> None:
+        super().__init__(
+            version=version,
+            anchor=anchor,
+            note=note,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+    ) -> MatchTrillNote:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} >= Version(1, 0, 0)")
+
+        anchor_pattern = cls.ornament_pattern.search(matchline)
+
+        if anchor_pattern is None:
+            raise MatchError("")
+        note = MatchNote.from_matchline(matchline, version=version)
+
+        return cls(
+            version=version,
+            note=note,
+            anchor=interpret_as_string(anchor_pattern.group("Anchor")),
+        )
+
+
+class MatchSustainPedal(BaseSustainPedalLine):
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            time=time,
+            value=value,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+        pos: int = 0,
+    ) -> MatchSustainPedal:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} less than 1.0.0")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            version=version,
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(**kwargs)
+
+
+class MatchSoftPedal(BaseSoftPedalLine):
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            time=time,
+            value=value,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LAST_VERSION,
+        pos: int = 0,
+    ) -> MatchSoftPedal:
+
+        if version >= Version(1, 0, 0):
+            raise ValueError(f"{version} should be less than 1.0.0")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            version=version,
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(**kwargs)
+
+
+FROM_MATCHLINE_METHODS = [
+    MatchSnoteNote.from_matchline,
+    MatchSnoteDeletion.from_matchline,
+    MatchSnoteTrailingScore.from_matchline,
+    MatchSnoteNoPlayedNote.from_matchline,
+    MatchInsertionNote.from_matchline,
+    MatchHammerBounceNote.from_matchline,
+    MatchTrailingPlayedNote.from_matchline,
+    MatchTrillNote.from_matchline,
+    MatchSustainPedal.from_matchline,
+    MatchSoftPedal.from_matchline,
+    MatchInfo.from_matchline,
+    MatchMeta.from_matchline,
+]
+
+
+def parse_matchline(line: str, version: Version) -> Optional[MatchLine]:
+    def parse(mlt: MatchLine) -> Optional[MatchLine]:
+        matchline = None
+        try:
+            matchline = mlt.from_matchline(line, version)
+        except MatchError:
+            pass
+
+        return matchline
+
+    matchline = None
+    if matchline.startswith("info"):
+        return parse(MatchInfo)
+
+    if line.startswith("meta"):
+        return parse(MatchMeta)
+
+    if line.startswith("snote"):
+
+        for mlt in [
+            MatchSnoteNote,
+            MatchSnoteDeletion,
+            MatchSnoteTrailingScore,
+            MatchSnoteNoPlayedNote,
+        ]:
+            matchline = parse(mlt)
+            if matchline is not None:
+                return matchline
+
+    if line.startswith("insertion"):
+        return parse(MatchInsertionNote)
+
+    if line.startswith("trailing_played"):
+        return parse(MatchTrailingPlayedNote)
+
+    if line.startswith("hammer_bounce"):
+        return parse(MatchHammerBounceNote)
+
+    if line.startswith("sustain"):
+        return parse(MatchSustainPedal)
+
+    if line.startswith("soft"):
+        return parse(MatchSoftPedal)
+
+    if line.startswith("trill"):
+        return parse(MatchTrillNote)
+
+    return matchline
```

### Comparing `partitura-1.2.1/partitura/io/matchlines_v1.py` & `partitura-1.2.2/partitura/io/matchlines_v1.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,1446 +1,1446 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains definitions for Matchfile lines for version >1.0.0
-"""
-from __future__ import annotations
-
-import re
-
-import numpy as np
-
-from typing import Any, Callable, Tuple, Union, List, Optional
-
-from partitura.utils.music import (
-    ALTER_SIGNS,
-    ensure_pitch_spelling_format,
-)
-
-from partitura.io.matchfile_base import (
-    MatchLine,
-    MatchError,
-    Version,
-    BaseInfoLine,
-    BaseSnoteLine,
-    BaseStimeLine,
-    BasePtimeLine,
-    BaseStimePtimeLine,
-    BaseNoteLine,
-    BaseSnoteNoteLine,
-    BaseDeletionLine,
-    BaseInsertionLine,
-    BaseOrnamentLine,
-    BaseSustainPedalLine,
-    BaseSoftPedalLine,
-)
-
-from partitura.io.matchfile_utils import (
-    interpret_version,
-    format_version,
-    interpret_as_string,
-    format_string,
-    format_accidental_old,
-    interpret_as_float,
-    format_float,
-    interpret_as_int,
-    format_int,
-    FractionalSymbolicDuration,
-    format_fractional,
-    interpret_as_fractional,
-    interpret_as_list,
-    interpret_as_list_int,
-    format_list,
-    MatchTimeSignature,
-    interpret_as_time_signature,
-    format_time_signature,
-    MatchKeySignature,
-    interpret_as_key_signature,
-    format_key_signature_v1_0_0,
-    to_snake_case,
-    get_kwargs_from_matchline,
-)
-
-# Define current version of the match file format
-LATEST_MAJOR_VERSION = 1
-LATEST_MINOR_VERSION = 0
-LATEST_PATCH_VERSION = 0
-
-LATEST_VERSION = Version(
-    LATEST_MAJOR_VERSION,
-    LATEST_MINOR_VERSION,
-    LATEST_PATCH_VERSION,
-)
-
-
-# Dictionary of interpreter, formatters and datatypes for info lines
-# each entry in the dictionary is a tuple with
-# an intepreter (to parse the input), a formatter (for the output matchline)
-# and type
-
-INFO_LINE = {
-    Version(1, 0, 0): {
-        "matchFileVersion": (interpret_version, format_version, Version),
-        "piece": (interpret_as_string, format_string, str),
-        "scoreFileName": (interpret_as_string, format_string, str),
-        "scoreFilePath": (interpret_as_string, format_string, str),
-        "midiFileName": (interpret_as_string, format_string, str),
-        "midiFilePath": (interpret_as_string, format_string, str),
-        "audioFileName": (interpret_as_string, format_string, str),
-        "audioFilePath": (interpret_as_string, format_string, str),
-        "audioFirstNote": (interpret_as_float, format_float, float),
-        "audioLastNote": (interpret_as_float, format_float, float),
-        "performer": (interpret_as_string, format_string, str),
-        "composer": (interpret_as_string, format_string, str),
-        "midiClockUnits": (interpret_as_int, format_int, int),
-        "midiClockRate": (interpret_as_int, format_int, int),
-        "approximateTempo": (interpret_as_float, format_float, float),
-        "subtitle": (interpret_as_string, format_string, str),
-    }
-}
-
-INFO_ATTRIBUTE_EQUIVALENCES = dict(
-    midiFilename="midiFileName",
-)
-
-
-class MatchInfo(BaseInfoLine):
-    """
-    Main class specifying global information lines.
-
-    For version 1.0.0, these lines have the general structure:
-
-    `info(attribute,value).`
-
-    Parameters
-    ----------
-    version : Version
-        The version of the info line.
-    kwargs : keyword arguments
-        Keyword arguments specifying the type of line and its value.
-    """
-
-    def __init__(
-        self,
-        version: Version,
-        attribute: str,
-        value: Any,
-        value_type: type,
-        format_fun: Callable[Any, str],
-    ) -> None:
-
-        if version < Version(1, 0, 0):
-            raise ValueError("The version must be >= 1.0.0")
-
-        super().__init__(
-            version=version,
-            attribute=attribute,
-            value=value,
-            value_type=value_type,
-            format_fun=format_fun,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchInfo:
-        """
-        Create a new MatchLine object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchInfo instance
-        """
-        if version not in INFO_LINE:
-            raise ValueError(f"{version} is not specified for this class.")
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-
-        class_dict = INFO_LINE[version]
-
-        if match_pattern is not None:
-            attribute, value_str = match_pattern.groups()
-            if attribute not in class_dict:
-                raise ValueError(f"Attribute {attribute} is not specified in {version}")
-
-            interpret_fun, format_fun, value_type = class_dict[attribute]
-
-            value = interpret_fun(value_str)
-
-            return cls(
-                version=version,
-                attribute=attribute,
-                value=value,
-                value_type=value_type,
-                format_fun=format_fun,
-            )
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseInfoLine, version: Version = LATEST_VERSION
-    ) -> MatchInfo:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseInfoLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseInfoLine`")
-
-        class_dict = INFO_LINE[version]
-
-        if instance.Attribute in INFO_ATTRIBUTE_EQUIVALENCES:
-            attr = INFO_ATTRIBUTE_EQUIVALENCES[instance.Attribute]
-        else:
-            attr = instance.Attribute
-
-        if attr not in class_dict:
-            raise ValueError(f"Attribute {attr} is not specified in {version}")
-
-        interpret_fun, format_fun, value_type = class_dict[attr]
-
-        value = instance.Value
-
-        if attr == "subtitle" and isinstance(value, list):
-            value = "" if len(value) == 0 else str(value)
-        return cls(
-            version=version,
-            attribute=attr,
-            value=value,
-            value_type=value_type,
-            format_fun=format_fun,
-        )
-
-
-SCOREPROP_LINE = {
-    Version(1, 0, 0): {
-        "timeSignature": (
-            interpret_as_time_signature,
-            format_time_signature,
-            MatchTimeSignature,
-        ),
-        "keySignature": (
-            interpret_as_key_signature,
-            format_key_signature_v1_0_0,
-            MatchKeySignature,
-        ),
-        "beatSubDivision": (interpret_as_list_int, format_list, list),
-        "directions": (interpret_as_list, format_list, list),
-    }
-}
-
-SCOREPROP_ATTRIBUTE_EQUIVALENCES = dict(
-    beatSubdivision="beatSubDivision",
-)
-
-
-class MatchScoreProp(MatchLine):
-
-    field_names = (
-        "Attribute",
-        "Value",
-        "Measure",
-        "Beat",
-        "Offset",
-        "TimeInBeats",
-    )
-
-    out_pattern = (
-        "scoreprop({Attribute},{Value},{Measure}:{Beat},{Offset},{TimeInBeats})."
-    )
-
-    pattern = re.compile(
-        r"scoreprop\("
-        r"(?P<Attribute>[^,]+),"
-        r"(?P<Value>.+),"
-        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<TimeInBeats>[^,]+)\)\."
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        attribute: str,
-        value: Any,
-        value_type: type,
-        format_fun: Callable[Any, str],
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        time_in_beats: float,
-    ) -> None:
-
-        if version < Version(1, 0, 0):
-            raise ValueError("The version must be >= 1.0.0")
-
-        super().__init__(version)
-
-        self.field_types = (
-            str,
-            value_type,
-            int,
-            int,
-            FractionalSymbolicDuration,
-            float,
-        )
-
-        self.format_fun = dict(
-            Attribute=format_string,
-            Value=format_fun,
-            Measure=format_int,
-            Beat=format_int,
-            Offset=format_fractional,
-            TimeInBeats=format_float,
-        )
-
-        # set class attributes
-        self.Attribute = attribute
-        self.Value = value
-        self.Measure = measure
-        self.Beat = beat
-        self.Offset = offset
-        self.TimeInBeats = time_in_beats
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchScoreProp:
-        """
-        Create a new MatchScoreProp object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchScoreProp object
-        """
-
-        if version not in SCOREPROP_LINE:
-            raise ValueError(f"{version} is not specified for this class.")
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-
-        class_dict = SCOREPROP_LINE[version]
-
-        if match_pattern is not None:
-
-            (
-                attribute,
-                value_str,
-                measure_str,
-                beat_str,
-                offset_str,
-                time_in_beats_str,
-            ) = match_pattern.groups()
-
-            if attribute not in class_dict:
-                raise ValueError(f"Attribute {attribute} is not specified in {version}")
-
-            interpret_fun, format_fun, value_type = class_dict[attribute]
-
-            value = interpret_fun(value_str)
-
-            measure = interpret_as_int(measure_str)
-
-            beat = interpret_as_int(beat_str)
-
-            offset = interpret_as_fractional(offset_str)
-
-            time_in_beats = interpret_as_float(time_in_beats_str)
-
-            return cls(
-                version=version,
-                attribute=attribute,
-                value=value,
-                value_type=value_type,
-                format_fun=format_fun,
-                measure=measure,
-                beat=beat,
-                offset=offset,
-                time_in_beats=time_in_beats,
-            )
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-    @classmethod
-    def from_instance(
-        cls,
-        instance: MatchLine,
-        version: Version = LATEST_VERSION,
-        measure: Optional[int] = None,
-        beat: Optional[int] = None,
-        offset: Optional[FractionalSymbolicDuration] = None,
-        time_in_beats: Optional[float] = None,
-    ) -> MatchScoreProp:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, MatchLine):
-            raise ValueError("`instance` needs to be a subclass of `MatchLine`")
-
-        # ensure that at least the basic attributes are in the field names of the match line
-        if not (
-            "Attribute" in instance.field_names and "Value" in instance.field_names
-        ):
-            raise ValueError(
-                "`instance` must contain at least 'Attribute', 'Value' and 'TimeInBeats'"
-            )
-
-        class_dict = SCOREPROP_LINE[version]
-
-        if not (
-            instance.Attribute in class_dict
-            or instance.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES
-        ):
-            raise ValueError(
-                f"Attribute {instance.Attribute} is not specified in {version}"
-            )
-
-        if instance.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES:
-            attr = SCOREPROP_ATTRIBUTE_EQUIVALENCES[instance.Attribute]
-        else:
-            attr = instance.Attribute
-        interpret_fun, format_fun, value_type = class_dict[attr]
-
-        return cls(
-            version=version,
-            attribute=attr,
-            value=instance.Value,
-            value_type=value_type,
-            format_fun=format_fun,
-            measure=getattr(instance, "Measure", measure if measure is not None else 1),
-            beat=getattr(instance, "Beat", beat if beat is not None else 1),
-            offset=getattr(
-                instance,
-                "Offset",
-                offset if offset is not None else FractionalSymbolicDuration(0),
-            ),
-            time_in_beats=getattr(
-                instance,
-                "TimeInBeats",
-                time_in_beats if time_in_beats is not None else 0.0,
-            ),
-        )
-
-
-SECTION_LINE = {
-    Version(1, 0, 0): {
-        "StartInBeatsUnfolded": (interpret_as_float, format_float, float),
-        "EndInBeatsUnfolded": (interpret_as_float, format_float, float),
-        "StartInBeatsOriginal": (interpret_as_float, format_float, float),
-        "EndInBeatsOriginal": (interpret_as_float, format_float, float),
-        "RepeatEndType": (interpret_as_list, format_list, list),
-    }
-}
-
-
-class MatchSection(MatchLine):
-    """
-    Class for specifiying structural information (i.e., sections).
-
-    section(StartInBeatsUnfolded,EndInBeatsUnfolded,StartInBeatsOriginal,EndInBeatsOriginal,RepeatEndType).
-
-    Parameters
-    ----------
-    version: Version,
-    start_in_beats_unfolded: float,
-    end_in_beats_unfolded: float,
-    start_in_beats_original: float,
-    end_in_beats_original: float,
-    repeat_end_type: List[str]
-    """
-
-    field_names = (
-        "StartInBeatsUnfolded",
-        "EndInBeatsUnfolded",
-        "StartInBeatsOriginal",
-        "EndInBeatsOriginal",
-        "RepeatEndType",
-    )
-
-    out_pattern = (
-        "section({StartInBeatsUnfolded},"
-        "{EndInBeatsUnfolded},{StartInBeatsOriginal},"
-        "{EndInBeatsOriginal},{RepeatEndType})."
-    )
-    pattern = re.compile(
-        r"section\("
-        r"(?P<StartInBeatsUnfolded>[^,]+),"
-        r"(?P<EndInBeatsUnfolded>[^,]+),"
-        r"(?P<StartInBeatsOriginal>[^,]+),"
-        r"(?P<EndInBeatsOriginal>[^,]+),"
-        r"\[(?P<RepeatEndType>.*)\]\)."
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        start_in_beats_unfolded: float,
-        end_in_beats_unfolded: float,
-        start_in_beats_original: float,
-        end_in_beats_original: float,
-        repeat_end_type: List[str],
-    ) -> None:
-
-        if version not in SECTION_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(SECTION_LINE.keys())}"
-            )
-        super().__init__(version)
-
-        self.field_types = tuple(
-            SECTION_LINE[version][fn][2] for fn in self.field_names
-        )
-        self.format_fun = dict(
-            [(fn, ft[1]) for fn, ft in SECTION_LINE[version].items()]
-        )
-
-        self.StartInBeatsUnfolded = start_in_beats_unfolded
-        self.EndInBeatsUnfolded = end_in_beats_unfolded
-        self.StartInBeatsOriginal = start_in_beats_original
-        self.EndInBeatsOriginal = end_in_beats_original
-        self.RepeatEndType = repeat_end_type
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSection:
-        if version not in SECTION_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(SECTION_LINE.keys())}"
-            )
-
-        match_pattern = cls.pattern.search(matchline, pos=pos)
-        class_dict = SECTION_LINE[version]
-
-        if match_pattern is not None:
-
-            kwargs = dict(
-                [
-                    (to_snake_case(fn), class_dict[fn][0](match_pattern.group(fn)))
-                    for fn in cls.field_names
-                ]
-            )
-
-            return cls(version=version, **kwargs)
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-
-STIME_LINE = {
-    Version(1, 0, 0): {
-        "Measure": (interpret_as_int, format_int, int),
-        "Beat": (interpret_as_int, format_int, int),
-        "Offset": (
-            interpret_as_fractional,
-            format_fractional,
-            FractionalSymbolicDuration,
-        ),
-        "OnsetInBeats": (interpret_as_float, format_float, float),
-        "AnnotationType": (interpret_as_list, format_list, list),
-    }
-}
-
-
-class MatchStime(BaseStimeLine):
-    def __init__(
-        self,
-        version: Version,
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        onset_in_beats: float,
-        annotation_type: List[str],
-    ) -> None:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        super().__init__(
-            version=version,
-            measure=measure,
-            beat=beat,
-            offset=offset,
-            onset_in_beats=onset_in_beats,
-            annotation_type=annotation_type,
-        )
-
-        self.field_types = tuple(STIME_LINE[version][fn][2] for fn in self.field_names)
-        self.format_fun = dict(
-            [(fn, STIME_LINE[version][fn][1]) for fn in self.field_names]
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchStime:
-
-        if version not in STIME_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(STIME_LINE.keys())}"
-            )
-
-        kwargs = get_kwargs_from_matchline(
-            matchline=matchline,
-            pattern=cls.pattern,
-            field_names=cls.field_names,
-            class_dict=STIME_LINE[version],
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(version=version, **kwargs)
-
-
-PTIME_LINE = {
-    Version(1, 0, 0): {
-        "Onsets": (interpret_as_list_int, format_list, list),
-    }
-}
-
-
-class MatchPtime(BasePtimeLine):
-    def __init__(
-        self,
-        version: Version,
-        onsets: List[int],
-    ) -> None:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        super().__init__(
-            version=version,
-            onsets=onsets,
-        )
-
-        self.field_types = tuple(PTIME_LINE[version][fn][2] for fn in self.field_names)
-        self.format_fun = dict(
-            [(fn, PTIME_LINE[version][fn][1]) for fn in self.field_names]
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchStime:
-
-        if version not in PTIME_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(STIME_LINE.keys())}"
-            )
-
-        kwargs = get_kwargs_from_matchline(
-            matchline=matchline,
-            pattern=cls.pattern,
-            field_names=cls.field_names,
-            class_dict=PTIME_LINE[version],
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(version=version, **kwargs)
-
-
-class MatchSnote(BaseSnoteLine):
-
-    format_fun = dict(
-        Anchor=format_string,
-        NoteName=lambda x: str(x.upper()),
-        Modifier=format_accidental_old,
-        Octave=format_int,
-        Measure=format_int,
-        Beat=format_int,
-        Offset=format_fractional,
-        Duration=format_fractional,
-        OnsetInBeats=format_float,
-        OffsetInBeats=format_float,
-        ScoreAttributesList=format_list,
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        anchor: str,
-        note_name: str,
-        modifier: str,
-        octave: Union[int, str],
-        measure: int,
-        beat: int,
-        offset: FractionalSymbolicDuration,
-        duration: FractionalSymbolicDuration,
-        onset_in_beats: float,
-        offset_in_beats: float,
-        score_attributes_list: List[str],
-    ) -> None:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-        super().__init__(
-            version=version,
-            anchor=anchor,
-            note_name=note_name,
-            modifier=modifier,
-            octave=octave,
-            measure=measure,
-            beat=beat,
-            offset=offset,
-            duration=duration,
-            onset_in_beats=onset_in_beats,
-            offset_in_beats=offset_in_beats,
-            score_attributes_list=score_attributes_list,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSnote:
-        """
-        Create a new MatchLine object from a string
-
-        Parameters
-        ----------
-        matchline : str
-            String with a matchline
-        pos : int (optional)
-            Position of the matchline in the input string. By default it is
-            assumed that the matchline starts at the beginning of the input
-            string.
-        version : Version (optional)
-            Version of the matchline. By default it is the latest version.
-
-        Returns
-        -------
-        a MatchSnote object
-        """
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            pos=pos,
-        )
-
-        return cls(version=version, **kwargs)
-
-    @classmethod
-    def from_instance(
-        cls,
-        instance: BaseSnoteLine,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSnote:
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseSnoteLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseSnoteLine`")
-
-        return cls(
-            version=version,
-            anchor=instance.Anchor,
-            note_name=instance.NoteName,
-            modifier=instance.Modifier,
-            octave=instance.Octave,
-            measure=instance.Measure,
-            beat=instance.Beat,
-            offset=instance.Offset,
-            duration=instance.Duration,
-            onset_in_beats=instance.OnsetInBeats,
-            offset_in_beats=instance.OffsetInBeats,
-            score_attributes_list=instance.ScoreAttributesList,
-        )
-
-
-NOTE_LINE = {
-    Version(1, 0, 0): {
-        "Id": (interpret_as_string, format_string, str),
-        "MidiPitch": (interpret_as_int, format_int, int),
-        "Onset": (interpret_as_int, format_int, int),
-        "Offset": (interpret_as_int, format_int, int),
-        "Velocity": (interpret_as_int, format_int, int),
-        "Channel": (interpret_as_int, format_int, int),
-        "Track": (interpret_as_int, format_int, int),
-    }
-}
-
-
-class MatchNote(BaseNoteLine):
-
-    field_names = (
-        "Id",
-        "MidiPitch",
-        "Onset",
-        "Offset",
-        "Velocity",
-        "Channel",
-        "Track",
-    )
-
-    out_pattern = (
-        "note({Id},{MidiPitch},{Onset},{Offset},{Velocity},{Channel},{Track})."
-    )
-
-    pattern = re.compile(
-        r"note\((?P<Id>[^,]+),"
-        r"(?P<MidiPitch>[^,]+),"
-        r"(?P<Onset>[^,]+),"
-        r"(?P<Offset>[^,]+),"
-        r"(?P<Velocity>[^,]+),"
-        r"(?P<Channel>[^,]+),"
-        r"(?P<Track>[^,]+)\)"
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        id: str,
-        midi_pitch: int,
-        onset: int,
-        offset: int,
-        velocity: int,
-        channel: int,
-        track: int,
-    ) -> None:
-
-        if version not in NOTE_LINE:
-            raise ValueError(
-                f"Unknown version {version}!. "
-                f"Supported versions are {list(NOTE_LINE.keys())}"
-            )
-
-        super().__init__(
-            version=version,
-            id=id,
-            midi_pitch=midi_pitch,
-            onset=onset,
-            offset=offset,
-            velocity=velocity,
-        )
-
-        self.Channel = channel
-        self.Track = track
-
-        self.field_types = tuple(NOTE_LINE[version][fn][2] for fn in self.field_names)
-        self.format_fun = dict(
-            [(fn, NOTE_LINE[version][fn][1]) for fn in self.field_names]
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        pos: int = 0,
-        version: Version = LATEST_VERSION,
-    ) -> MatchNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = get_kwargs_from_matchline(
-            matchline=matchline,
-            pattern=cls.pattern,
-            field_names=cls.field_names,
-            class_dict=NOTE_LINE[version],
-            pos=pos,
-        )
-
-        if kwargs is not None:
-            return cls(version=version, **kwargs)
-
-        else:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-    @classmethod
-    def from_instance(
-        cls,
-        instance: BaseNoteLine,
-        version: Version = LATEST_VERSION,
-    ) -> MatchNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseNoteLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseNoteLine`")
-
-        if instance.version < Version(1, 0, 0):
-
-            return cls(
-                version=version,
-                id=instance.Id,
-                midi_pitch=instance.MidiPitch,
-                onset=int(np.round(instance.Onset)),
-                offset=int(np.round(instance.Offset)),
-                velocity=instance.Velocity,
-                channel=1,
-                track=0,
-            )
-
-
-class MatchStimePtime(BaseStimePtimeLine):
-    def __init__(
-        self,
-        version: Version,
-        stime: MatchStime,
-        ptime: MatchPtime,
-    ) -> None:
-        super().__init__(
-            version=version,
-            stime=stime,
-            ptime=ptime,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSnoteNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            stime_class=MatchStime,
-            ptime_class=MatchPtime,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-
-class MatchSnoteNote(BaseSnoteNoteLine):
-    def __init__(
-        self,
-        version: Version,
-        snote: BaseSnoteLine,
-        note: BaseNoteLine,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            snote=snote,
-            note=note,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSnoteNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            snote_class=MatchSnote,
-            note_class=MatchNote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseSnoteNoteLine, version: Version
-    ) -> MatchSnoteNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseSnoteNoteLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseSnoteNoteLine`")
-
-        return cls(
-            version=version,
-            snote=MatchSnote.from_instance(instance.snote, version=version),
-            note=MatchNote.from_instance(instance.note, version=version),
-        )
-
-
-class MatchSnoteDeletion(BaseDeletionLine):
-    def __init__(self, version: Version, snote: MatchSnote) -> None:
-
-        super().__init__(
-            version=version,
-            snote=snote,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-    ) -> MatchSnoteDeletion:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            snote_class=MatchSnote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseDeletionLine, version: Version
-    ) -> MatchSnoteNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseDeletionLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseDeletionLine`")
-
-        return cls(
-            version=version,
-            snote=MatchSnote.from_instance(instance.snote, version=version),
-        )
-
-
-class MatchInsertionNote(BaseInsertionLine):
-    def __init__(self, version: Version, note: MatchNote) -> None:
-
-        super().__init__(
-            version=version,
-            note=note,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-    ) -> MatchInsertionNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            note_class=MatchNote,
-            version=version,
-        )
-
-        return cls(**kwargs)
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseInsertionLine, version: Version
-    ) -> MatchInsertionNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseInsertionLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseInsertionLine`")
-
-        return cls(
-            version=version,
-            note=MatchNote.from_instance(instance.note, version=version),
-        )
-
-
-class MatchOrnamentNote(BaseOrnamentLine):
-
-    field_names = (
-        "Anchor",
-        "OrnamentType",
-    )
-    field_types = (
-        str,
-        list,
-    )
-    format_fun = dict(Anchor=format_string, OrnamentType=format_list)
-    out_pattern = "ornament({Anchor},{OrnamentType})-{NoteLine}"
-    ornament_pattern: re.Pattern = re.compile(
-        r"ornament\((?P<Anchor>[^\)]*),\[(?P<OrnamentType>.*)\]\)-"
-    )
-
-    def __init__(
-        self,
-        version: Version,
-        anchor: str,
-        ornament_type: List[str],
-        note: BaseNoteLine,
-    ) -> None:
-        super().__init__(
-            version=version,
-            anchor=anchor,
-            note=note,
-        )
-        self.OrnamentType = ornament_type
-
-    @property
-    def matchline(self) -> str:
-        return self.out_pattern.format(
-            Anchor=self.format_fun[0]["Anchor"](self.Anchor),
-            OrnamentType=self.format_fun[0]["OrnamentType"](self.OrnamentType),
-            NoteLine=self.note.matchline,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-    ) -> MatchOrnamentNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        anchor_pattern = cls.ornament_pattern.search(matchline)
-
-        if anchor_pattern is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-        note = MatchNote.from_matchline(matchline, version=version)
-
-        return cls(
-            version=version,
-            note=note,
-            anchor=interpret_as_string(anchor_pattern.group("Anchor")),
-            ornament_type=interpret_as_list(anchor_pattern.group("OrnamentType")),
-        )
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseOrnamentLine, version: Version
-    ) -> MatchOrnamentNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseOrnamentLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseOrnamentLine`")
-
-        return cls(
-            version=version,
-            anchor=instance.Anchor,
-            note=MatchNote.from_instance(instance.note, version=version),
-            ornament_type=["trill"]
-            if instance.version < Version(1, 0, 0)
-            else instance.OrnamentType,
-        )
-
-
-class MatchSustainPedal(BaseSustainPedalLine):
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            time=time,
-            value=value,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-        pos: int = 0,
-    ) -> MatchSustainPedal:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            version=version,
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(**kwargs)
-
-    @classmethod
-    def from_instance(
-        cls, instance: BaseSustainPedalLine, version: Version
-    ) -> MatchOrnamentNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseSustainPedalLine):
-            raise ValueError(
-                "`instance` needs to be a subclass of `BaseSustainPedalLine`"
-            )
-
-        return cls(
-            version=version,
-            time=int(instance.Time),
-            value=int(instance.Value),
-        )
-
-
-class MatchSoftPedal(BaseSoftPedalLine):
-    def __init__(
-        self,
-        version: Version,
-        time: int,
-        value: int,
-    ) -> None:
-
-        super().__init__(
-            version=version,
-            time=time,
-            value=value,
-        )
-
-    @classmethod
-    def from_matchline(
-        cls,
-        matchline: str,
-        version: Version = LATEST_VERSION,
-        pos: int = 0,
-    ) -> MatchSoftPedal:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        kwargs = cls.prepare_kwargs_from_matchline(
-            matchline=matchline,
-            version=version,
-            pos=pos,
-        )
-
-        if kwargs is None:
-            raise MatchError("Input match line does not fit the expected pattern.")
-
-        return cls(**kwargs)
-
-    @classmethod
-    def from_instance(
-        cls,
-        instance: BaseSoftPedalLine,
-        version: Version,
-    ) -> MatchOrnamentNote:
-
-        if version < Version(1, 0, 0):
-            raise ValueError(f"{version} < Version(1, 0, 0)")
-
-        if not isinstance(instance, BaseSoftPedalLine):
-            raise ValueError("`instance` needs to be a subclass of `BaseSoftPedalLine`")
-
-        return cls(
-            version=version,
-            time=int(instance.Time),
-            value=int(instance.Value),
-        )
-
-
-FROM_MATCHLINE_METHODS = [
-    MatchSnoteNote.from_matchline,
-    MatchSnoteDeletion.from_matchline,
-    MatchInsertionNote.from_matchline,
-    MatchOrnamentNote.from_matchline,
-    MatchSustainPedal.from_matchline,
-    MatchSoftPedal.from_matchline,
-    MatchInfo.from_matchline,
-    MatchScoreProp.from_matchline,
-    MatchSection.from_matchline,
-    MatchStimePtime.from_matchline,
-]
-
-
-## Helper methods to build the corresponding line for each parameter
-
-
-def make_info(version: Version, attribute: str, value: Any) -> MatchInfo:
-    """
-    Get version line from attributes
-    """
-
-    if attribute == "matchFileVersion":
-        if version != value:
-            raise ValueError(
-                f"The specified version ({version}) should be the same as "
-                f"`value` ({value})"
-            )
-    class_dict = INFO_LINE[version]
-
-    _, format_fun, dtype = class_dict[attribute]
-
-    ml = MatchInfo(
-        version=version,
-        attribute=attribute,
-        value=value,
-        value_type=dtype,
-        format_fun=format_fun,
-    )
-
-    return ml
-
-
-def make_scoreprop(
-    version: Version,
-    attribute: str,
-    value: Any,
-    measure: int,
-    beat: int,
-    offset: FractionalSymbolicDuration,
-    time_in_beats: float,
-) -> MatchScoreProp:
-
-    class_dict = SCOREPROP_LINE[version]
-
-    _, format_fun, dtype = class_dict[attribute]
-
-    ml = MatchScoreProp(
-        version=version,
-        attribute=attribute,
-        value=value,
-        value_type=dtype,
-        format_fun=format_fun,
-        measure=measure,
-        beat=beat,
-        offset=offset,
-        time_in_beats=time_in_beats,
-    )
-
-    return ml
-
-
-def make_section(
-    version: Version,
-    start_in_beats_unfolded: float,
-    end_in_beats_unfolded: float,
-    start_in_beats_original: float,
-    end_in_beats_original: float,
-    repeat_end_type: Union[str, List[str]],
-) -> MatchSection:
-
-    ml = MatchSection(
-        version=version,
-        start_in_beats_unfolded=start_in_beats_unfolded,
-        start_in_beats_original=start_in_beats_original,
-        end_in_beats_unfolded=end_in_beats_unfolded,
-        end_in_beats_original=end_in_beats_original,
-        repeat_end_type=[repeat_end_type]
-        if isinstance(repeat_end_type, str)
-        else repeat_end_type,
-    )
-    return ml
-
-
-def to_v1(matchline: MatchLine, version: Version = LATEST_VERSION) -> MatchLine:
-    """
-    Convert matchline to version 1_x_x
-
-    Parameters
-    ----------
-    matchline : MatchLine
-        Matchline to be converted
-    version: Version
-        Target version. Default is `LATEST_VERSION`
-
-    Returns
-    -------
-    MatchLine
-         A new matchline with the equivalent of the input matchline in
-         the specified version.
-    """
-    from partitura.io.matchlines_v0 import MatchMeta
-
-    if isinstance(matchline, BaseInfoLine):
-
-        if (
-            matchline.Attribute in INFO_LINE[version]
-            or matchline.Attribute in INFO_ATTRIBUTE_EQUIVALENCES
-        ):
-            return MatchInfo.from_instance(instance=matchline, version=version)
-
-        if (
-            matchline.Attribute in SCOREPROP_LINE[version]
-            or matchline.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES
-        ):
-
-            return MatchScoreProp.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, MatchMeta):
-        return MatchScoreProp.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseSnoteNoteLine):
-        return MatchSnoteNote.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseInsertionLine):
-        return MatchInsertionNote.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseDeletionLine):
-        return MatchSnoteDeletion.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseOrnamentLine):
-        return MatchOrnamentNote.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseSustainPedalLine):
-        return MatchSustainPedal.from_instance(instance=matchline, version=version)
-
-    if isinstance(matchline, BaseSoftPedalLine):
-        return MatchSustainPedal.from_instance(instance=matchline, version=version)
-
-    else:
-        print(matchline.matchline)
-        raise MatchError(f"No equivalent line in version {version}")
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains definitions for Matchfile lines for version >1.0.0
+"""
+from __future__ import annotations
+
+import re
+
+import numpy as np
+
+from typing import Any, Callable, Tuple, Union, List, Optional
+
+from partitura.utils.music import (
+    ALTER_SIGNS,
+    ensure_pitch_spelling_format,
+)
+
+from partitura.io.matchfile_base import (
+    MatchLine,
+    MatchError,
+    Version,
+    BaseInfoLine,
+    BaseSnoteLine,
+    BaseStimeLine,
+    BasePtimeLine,
+    BaseStimePtimeLine,
+    BaseNoteLine,
+    BaseSnoteNoteLine,
+    BaseDeletionLine,
+    BaseInsertionLine,
+    BaseOrnamentLine,
+    BaseSustainPedalLine,
+    BaseSoftPedalLine,
+)
+
+from partitura.io.matchfile_utils import (
+    interpret_version,
+    format_version,
+    interpret_as_string,
+    format_string,
+    format_accidental_old,
+    interpret_as_float,
+    format_float,
+    interpret_as_int,
+    format_int,
+    FractionalSymbolicDuration,
+    format_fractional,
+    interpret_as_fractional,
+    interpret_as_list,
+    interpret_as_list_int,
+    format_list,
+    MatchTimeSignature,
+    interpret_as_time_signature,
+    format_time_signature,
+    MatchKeySignature,
+    interpret_as_key_signature,
+    format_key_signature_v1_0_0,
+    to_snake_case,
+    get_kwargs_from_matchline,
+)
+
+# Define current version of the match file format
+LATEST_MAJOR_VERSION = 1
+LATEST_MINOR_VERSION = 0
+LATEST_PATCH_VERSION = 0
+
+LATEST_VERSION = Version(
+    LATEST_MAJOR_VERSION,
+    LATEST_MINOR_VERSION,
+    LATEST_PATCH_VERSION,
+)
+
+
+# Dictionary of interpreter, formatters and datatypes for info lines
+# each entry in the dictionary is a tuple with
+# an intepreter (to parse the input), a formatter (for the output matchline)
+# and type
+
+INFO_LINE = {
+    Version(1, 0, 0): {
+        "matchFileVersion": (interpret_version, format_version, Version),
+        "piece": (interpret_as_string, format_string, str),
+        "scoreFileName": (interpret_as_string, format_string, str),
+        "scoreFilePath": (interpret_as_string, format_string, str),
+        "midiFileName": (interpret_as_string, format_string, str),
+        "midiFilePath": (interpret_as_string, format_string, str),
+        "audioFileName": (interpret_as_string, format_string, str),
+        "audioFilePath": (interpret_as_string, format_string, str),
+        "audioFirstNote": (interpret_as_float, format_float, float),
+        "audioLastNote": (interpret_as_float, format_float, float),
+        "performer": (interpret_as_string, format_string, str),
+        "composer": (interpret_as_string, format_string, str),
+        "midiClockUnits": (interpret_as_int, format_int, int),
+        "midiClockRate": (interpret_as_int, format_int, int),
+        "approximateTempo": (interpret_as_float, format_float, float),
+        "subtitle": (interpret_as_string, format_string, str),
+    }
+}
+
+INFO_ATTRIBUTE_EQUIVALENCES = dict(
+    midiFilename="midiFileName",
+)
+
+
+class MatchInfo(BaseInfoLine):
+    """
+    Main class specifying global information lines.
+
+    For version 1.0.0, these lines have the general structure:
+
+    `info(attribute,value).`
+
+    Parameters
+    ----------
+    version : Version
+        The version of the info line.
+    kwargs : keyword arguments
+        Keyword arguments specifying the type of line and its value.
+    """
+
+    def __init__(
+        self,
+        version: Version,
+        attribute: str,
+        value: Any,
+        value_type: type,
+        format_fun: Callable[Any, str],
+    ) -> None:
+
+        if version < Version(1, 0, 0):
+            raise ValueError("The version must be >= 1.0.0")
+
+        super().__init__(
+            version=version,
+            attribute=attribute,
+            value=value,
+            value_type=value_type,
+            format_fun=format_fun,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchInfo:
+        """
+        Create a new MatchLine object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchInfo instance
+        """
+        if version not in INFO_LINE:
+            raise ValueError(f"{version} is not specified for this class.")
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+
+        class_dict = INFO_LINE[version]
+
+        if match_pattern is not None:
+            attribute, value_str = match_pattern.groups()
+            if attribute not in class_dict:
+                raise ValueError(f"Attribute {attribute} is not specified in {version}")
+
+            interpret_fun, format_fun, value_type = class_dict[attribute]
+
+            value = interpret_fun(value_str)
+
+            return cls(
+                version=version,
+                attribute=attribute,
+                value=value,
+                value_type=value_type,
+                format_fun=format_fun,
+            )
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseInfoLine, version: Version = LATEST_VERSION
+    ) -> MatchInfo:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseInfoLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseInfoLine`")
+
+        class_dict = INFO_LINE[version]
+
+        if instance.Attribute in INFO_ATTRIBUTE_EQUIVALENCES:
+            attr = INFO_ATTRIBUTE_EQUIVALENCES[instance.Attribute]
+        else:
+            attr = instance.Attribute
+
+        if attr not in class_dict:
+            raise ValueError(f"Attribute {attr} is not specified in {version}")
+
+        interpret_fun, format_fun, value_type = class_dict[attr]
+
+        value = instance.Value
+
+        if attr == "subtitle" and isinstance(value, list):
+            value = "" if len(value) == 0 else str(value)
+        return cls(
+            version=version,
+            attribute=attr,
+            value=value,
+            value_type=value_type,
+            format_fun=format_fun,
+        )
+
+
+SCOREPROP_LINE = {
+    Version(1, 0, 0): {
+        "timeSignature": (
+            interpret_as_time_signature,
+            format_time_signature,
+            MatchTimeSignature,
+        ),
+        "keySignature": (
+            interpret_as_key_signature,
+            format_key_signature_v1_0_0,
+            MatchKeySignature,
+        ),
+        "beatSubDivision": (interpret_as_list_int, format_list, list),
+        "directions": (interpret_as_list, format_list, list),
+    }
+}
+
+SCOREPROP_ATTRIBUTE_EQUIVALENCES = dict(
+    beatSubdivision="beatSubDivision",
+)
+
+
+class MatchScoreProp(MatchLine):
+
+    field_names = (
+        "Attribute",
+        "Value",
+        "Measure",
+        "Beat",
+        "Offset",
+        "TimeInBeats",
+    )
+
+    out_pattern = (
+        "scoreprop({Attribute},{Value},{Measure}:{Beat},{Offset},{TimeInBeats})."
+    )
+
+    pattern = re.compile(
+        r"scoreprop\("
+        r"(?P<Attribute>[^,]+),"
+        r"(?P<Value>.+),"
+        r"(?P<Measure>[^,]+):(?P<Beat>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<TimeInBeats>[^,]+)\)\."
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        attribute: str,
+        value: Any,
+        value_type: type,
+        format_fun: Callable[Any, str],
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        time_in_beats: float,
+    ) -> None:
+
+        if version < Version(1, 0, 0):
+            raise ValueError("The version must be >= 1.0.0")
+
+        super().__init__(version)
+
+        self.field_types = (
+            str,
+            value_type,
+            int,
+            int,
+            FractionalSymbolicDuration,
+            float,
+        )
+
+        self.format_fun = dict(
+            Attribute=format_string,
+            Value=format_fun,
+            Measure=format_int,
+            Beat=format_int,
+            Offset=format_fractional,
+            TimeInBeats=format_float,
+        )
+
+        # set class attributes
+        self.Attribute = attribute
+        self.Value = value
+        self.Measure = measure
+        self.Beat = beat
+        self.Offset = offset
+        self.TimeInBeats = time_in_beats
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchScoreProp:
+        """
+        Create a new MatchScoreProp object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchScoreProp object
+        """
+
+        if version not in SCOREPROP_LINE:
+            raise ValueError(f"{version} is not specified for this class.")
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+
+        class_dict = SCOREPROP_LINE[version]
+
+        if match_pattern is not None:
+
+            (
+                attribute,
+                value_str,
+                measure_str,
+                beat_str,
+                offset_str,
+                time_in_beats_str,
+            ) = match_pattern.groups()
+
+            if attribute not in class_dict:
+                raise ValueError(f"Attribute {attribute} is not specified in {version}")
+
+            interpret_fun, format_fun, value_type = class_dict[attribute]
+
+            value = interpret_fun(value_str)
+
+            measure = interpret_as_int(measure_str)
+
+            beat = interpret_as_int(beat_str)
+
+            offset = interpret_as_fractional(offset_str)
+
+            time_in_beats = interpret_as_float(time_in_beats_str)
+
+            return cls(
+                version=version,
+                attribute=attribute,
+                value=value,
+                value_type=value_type,
+                format_fun=format_fun,
+                measure=measure,
+                beat=beat,
+                offset=offset,
+                time_in_beats=time_in_beats,
+            )
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+    @classmethod
+    def from_instance(
+        cls,
+        instance: MatchLine,
+        version: Version = LATEST_VERSION,
+        measure: Optional[int] = None,
+        beat: Optional[int] = None,
+        offset: Optional[FractionalSymbolicDuration] = None,
+        time_in_beats: Optional[float] = None,
+    ) -> MatchScoreProp:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, MatchLine):
+            raise ValueError("`instance` needs to be a subclass of `MatchLine`")
+
+        # ensure that at least the basic attributes are in the field names of the match line
+        if not (
+            "Attribute" in instance.field_names and "Value" in instance.field_names
+        ):
+            raise ValueError(
+                "`instance` must contain at least 'Attribute', 'Value' and 'TimeInBeats'"
+            )
+
+        class_dict = SCOREPROP_LINE[version]
+
+        if not (
+            instance.Attribute in class_dict
+            or instance.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES
+        ):
+            raise ValueError(
+                f"Attribute {instance.Attribute} is not specified in {version}"
+            )
+
+        if instance.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES:
+            attr = SCOREPROP_ATTRIBUTE_EQUIVALENCES[instance.Attribute]
+        else:
+            attr = instance.Attribute
+        interpret_fun, format_fun, value_type = class_dict[attr]
+
+        return cls(
+            version=version,
+            attribute=attr,
+            value=instance.Value,
+            value_type=value_type,
+            format_fun=format_fun,
+            measure=getattr(instance, "Measure", measure if measure is not None else 1),
+            beat=getattr(instance, "Beat", beat if beat is not None else 1),
+            offset=getattr(
+                instance,
+                "Offset",
+                offset if offset is not None else FractionalSymbolicDuration(0),
+            ),
+            time_in_beats=getattr(
+                instance,
+                "TimeInBeats",
+                time_in_beats if time_in_beats is not None else 0.0,
+            ),
+        )
+
+
+SECTION_LINE = {
+    Version(1, 0, 0): {
+        "StartInBeatsUnfolded": (interpret_as_float, format_float, float),
+        "EndInBeatsUnfolded": (interpret_as_float, format_float, float),
+        "StartInBeatsOriginal": (interpret_as_float, format_float, float),
+        "EndInBeatsOriginal": (interpret_as_float, format_float, float),
+        "RepeatEndType": (interpret_as_list, format_list, list),
+    }
+}
+
+
+class MatchSection(MatchLine):
+    """
+    Class for specifiying structural information (i.e., sections).
+
+    section(StartInBeatsUnfolded,EndInBeatsUnfolded,StartInBeatsOriginal,EndInBeatsOriginal,RepeatEndType).
+
+    Parameters
+    ----------
+    version: Version,
+    start_in_beats_unfolded: float,
+    end_in_beats_unfolded: float,
+    start_in_beats_original: float,
+    end_in_beats_original: float,
+    repeat_end_type: List[str]
+    """
+
+    field_names = (
+        "StartInBeatsUnfolded",
+        "EndInBeatsUnfolded",
+        "StartInBeatsOriginal",
+        "EndInBeatsOriginal",
+        "RepeatEndType",
+    )
+
+    out_pattern = (
+        "section({StartInBeatsUnfolded},"
+        "{EndInBeatsUnfolded},{StartInBeatsOriginal},"
+        "{EndInBeatsOriginal},{RepeatEndType})."
+    )
+    pattern = re.compile(
+        r"section\("
+        r"(?P<StartInBeatsUnfolded>[^,]+),"
+        r"(?P<EndInBeatsUnfolded>[^,]+),"
+        r"(?P<StartInBeatsOriginal>[^,]+),"
+        r"(?P<EndInBeatsOriginal>[^,]+),"
+        r"\[(?P<RepeatEndType>.*)\]\)."
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        start_in_beats_unfolded: float,
+        end_in_beats_unfolded: float,
+        start_in_beats_original: float,
+        end_in_beats_original: float,
+        repeat_end_type: List[str],
+    ) -> None:
+
+        if version not in SECTION_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(SECTION_LINE.keys())}"
+            )
+        super().__init__(version)
+
+        self.field_types = tuple(
+            SECTION_LINE[version][fn][2] for fn in self.field_names
+        )
+        self.format_fun = dict(
+            [(fn, ft[1]) for fn, ft in SECTION_LINE[version].items()]
+        )
+
+        self.StartInBeatsUnfolded = start_in_beats_unfolded
+        self.EndInBeatsUnfolded = end_in_beats_unfolded
+        self.StartInBeatsOriginal = start_in_beats_original
+        self.EndInBeatsOriginal = end_in_beats_original
+        self.RepeatEndType = repeat_end_type
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSection:
+        if version not in SECTION_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(SECTION_LINE.keys())}"
+            )
+
+        match_pattern = cls.pattern.search(matchline, pos=pos)
+        class_dict = SECTION_LINE[version]
+
+        if match_pattern is not None:
+
+            kwargs = dict(
+                [
+                    (to_snake_case(fn), class_dict[fn][0](match_pattern.group(fn)))
+                    for fn in cls.field_names
+                ]
+            )
+
+            return cls(version=version, **kwargs)
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+
+STIME_LINE = {
+    Version(1, 0, 0): {
+        "Measure": (interpret_as_int, format_int, int),
+        "Beat": (interpret_as_int, format_int, int),
+        "Offset": (
+            interpret_as_fractional,
+            format_fractional,
+            FractionalSymbolicDuration,
+        ),
+        "OnsetInBeats": (interpret_as_float, format_float, float),
+        "AnnotationType": (interpret_as_list, format_list, list),
+    }
+}
+
+
+class MatchStime(BaseStimeLine):
+    def __init__(
+        self,
+        version: Version,
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        onset_in_beats: float,
+        annotation_type: List[str],
+    ) -> None:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        super().__init__(
+            version=version,
+            measure=measure,
+            beat=beat,
+            offset=offset,
+            onset_in_beats=onset_in_beats,
+            annotation_type=annotation_type,
+        )
+
+        self.field_types = tuple(STIME_LINE[version][fn][2] for fn in self.field_names)
+        self.format_fun = dict(
+            [(fn, STIME_LINE[version][fn][1]) for fn in self.field_names]
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchStime:
+
+        if version not in STIME_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(STIME_LINE.keys())}"
+            )
+
+        kwargs = get_kwargs_from_matchline(
+            matchline=matchline,
+            pattern=cls.pattern,
+            field_names=cls.field_names,
+            class_dict=STIME_LINE[version],
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(version=version, **kwargs)
+
+
+PTIME_LINE = {
+    Version(1, 0, 0): {
+        "Onsets": (interpret_as_list_int, format_list, list),
+    }
+}
+
+
+class MatchPtime(BasePtimeLine):
+    def __init__(
+        self,
+        version: Version,
+        onsets: List[int],
+    ) -> None:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        super().__init__(
+            version=version,
+            onsets=onsets,
+        )
+
+        self.field_types = tuple(PTIME_LINE[version][fn][2] for fn in self.field_names)
+        self.format_fun = dict(
+            [(fn, PTIME_LINE[version][fn][1]) for fn in self.field_names]
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchStime:
+
+        if version not in PTIME_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(STIME_LINE.keys())}"
+            )
+
+        kwargs = get_kwargs_from_matchline(
+            matchline=matchline,
+            pattern=cls.pattern,
+            field_names=cls.field_names,
+            class_dict=PTIME_LINE[version],
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(version=version, **kwargs)
+
+
+class MatchSnote(BaseSnoteLine):
+
+    format_fun = dict(
+        Anchor=format_string,
+        NoteName=lambda x: str(x.upper()),
+        Modifier=format_accidental_old,
+        Octave=format_int,
+        Measure=format_int,
+        Beat=format_int,
+        Offset=format_fractional,
+        Duration=format_fractional,
+        OnsetInBeats=format_float,
+        OffsetInBeats=format_float,
+        ScoreAttributesList=format_list,
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        anchor: str,
+        note_name: str,
+        modifier: str,
+        octave: Union[int, str],
+        measure: int,
+        beat: int,
+        offset: FractionalSymbolicDuration,
+        duration: FractionalSymbolicDuration,
+        onset_in_beats: float,
+        offset_in_beats: float,
+        score_attributes_list: List[str],
+    ) -> None:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+        super().__init__(
+            version=version,
+            anchor=anchor,
+            note_name=note_name,
+            modifier=modifier,
+            octave=octave,
+            measure=measure,
+            beat=beat,
+            offset=offset,
+            duration=duration,
+            onset_in_beats=onset_in_beats,
+            offset_in_beats=offset_in_beats,
+            score_attributes_list=score_attributes_list,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSnote:
+        """
+        Create a new MatchLine object from a string
+
+        Parameters
+        ----------
+        matchline : str
+            String with a matchline
+        pos : int (optional)
+            Position of the matchline in the input string. By default it is
+            assumed that the matchline starts at the beginning of the input
+            string.
+        version : Version (optional)
+            Version of the matchline. By default it is the latest version.
+
+        Returns
+        -------
+        a MatchSnote object
+        """
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            pos=pos,
+        )
+
+        return cls(version=version, **kwargs)
+
+    @classmethod
+    def from_instance(
+        cls,
+        instance: BaseSnoteLine,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSnote:
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseSnoteLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseSnoteLine`")
+
+        return cls(
+            version=version,
+            anchor=instance.Anchor,
+            note_name=instance.NoteName,
+            modifier=instance.Modifier,
+            octave=instance.Octave,
+            measure=instance.Measure,
+            beat=instance.Beat,
+            offset=instance.Offset,
+            duration=instance.Duration,
+            onset_in_beats=instance.OnsetInBeats,
+            offset_in_beats=instance.OffsetInBeats,
+            score_attributes_list=instance.ScoreAttributesList,
+        )
+
+
+NOTE_LINE = {
+    Version(1, 0, 0): {
+        "Id": (interpret_as_string, format_string, str),
+        "MidiPitch": (interpret_as_int, format_int, int),
+        "Onset": (interpret_as_int, format_int, int),
+        "Offset": (interpret_as_int, format_int, int),
+        "Velocity": (interpret_as_int, format_int, int),
+        "Channel": (interpret_as_int, format_int, int),
+        "Track": (interpret_as_int, format_int, int),
+    }
+}
+
+
+class MatchNote(BaseNoteLine):
+
+    field_names = (
+        "Id",
+        "MidiPitch",
+        "Onset",
+        "Offset",
+        "Velocity",
+        "Channel",
+        "Track",
+    )
+
+    out_pattern = (
+        "note({Id},{MidiPitch},{Onset},{Offset},{Velocity},{Channel},{Track})."
+    )
+
+    pattern = re.compile(
+        r"note\((?P<Id>[^,]+),"
+        r"(?P<MidiPitch>[^,]+),"
+        r"(?P<Onset>[^,]+),"
+        r"(?P<Offset>[^,]+),"
+        r"(?P<Velocity>[^,]+),"
+        r"(?P<Channel>[^,]+),"
+        r"(?P<Track>[^,]+)\)"
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        id: str,
+        midi_pitch: int,
+        onset: int,
+        offset: int,
+        velocity: int,
+        channel: int,
+        track: int,
+    ) -> None:
+
+        if version not in NOTE_LINE:
+            raise ValueError(
+                f"Unknown version {version}!. "
+                f"Supported versions are {list(NOTE_LINE.keys())}"
+            )
+
+        super().__init__(
+            version=version,
+            id=id,
+            midi_pitch=midi_pitch,
+            onset=onset,
+            offset=offset,
+            velocity=velocity,
+        )
+
+        self.Channel = channel
+        self.Track = track
+
+        self.field_types = tuple(NOTE_LINE[version][fn][2] for fn in self.field_names)
+        self.format_fun = dict(
+            [(fn, NOTE_LINE[version][fn][1]) for fn in self.field_names]
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        pos: int = 0,
+        version: Version = LATEST_VERSION,
+    ) -> MatchNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = get_kwargs_from_matchline(
+            matchline=matchline,
+            pattern=cls.pattern,
+            field_names=cls.field_names,
+            class_dict=NOTE_LINE[version],
+            pos=pos,
+        )
+
+        if kwargs is not None:
+            return cls(version=version, **kwargs)
+
+        else:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+    @classmethod
+    def from_instance(
+        cls,
+        instance: BaseNoteLine,
+        version: Version = LATEST_VERSION,
+    ) -> MatchNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseNoteLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseNoteLine`")
+
+        if instance.version < Version(1, 0, 0):
+
+            return cls(
+                version=version,
+                id=instance.Id,
+                midi_pitch=instance.MidiPitch,
+                onset=int(np.round(instance.Onset)),
+                offset=int(np.round(instance.Offset)),
+                velocity=instance.Velocity,
+                channel=1,
+                track=0,
+            )
+
+
+class MatchStimePtime(BaseStimePtimeLine):
+    def __init__(
+        self,
+        version: Version,
+        stime: MatchStime,
+        ptime: MatchPtime,
+    ) -> None:
+        super().__init__(
+            version=version,
+            stime=stime,
+            ptime=ptime,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSnoteNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            stime_class=MatchStime,
+            ptime_class=MatchPtime,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+
+class MatchSnoteNote(BaseSnoteNoteLine):
+    def __init__(
+        self,
+        version: Version,
+        snote: BaseSnoteLine,
+        note: BaseNoteLine,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            snote=snote,
+            note=note,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSnoteNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            snote_class=MatchSnote,
+            note_class=MatchNote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseSnoteNoteLine, version: Version
+    ) -> MatchSnoteNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseSnoteNoteLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseSnoteNoteLine`")
+
+        return cls(
+            version=version,
+            snote=MatchSnote.from_instance(instance.snote, version=version),
+            note=MatchNote.from_instance(instance.note, version=version),
+        )
+
+
+class MatchSnoteDeletion(BaseDeletionLine):
+    def __init__(self, version: Version, snote: MatchSnote) -> None:
+
+        super().__init__(
+            version=version,
+            snote=snote,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+    ) -> MatchSnoteDeletion:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            snote_class=MatchSnote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseDeletionLine, version: Version
+    ) -> MatchSnoteNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseDeletionLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseDeletionLine`")
+
+        return cls(
+            version=version,
+            snote=MatchSnote.from_instance(instance.snote, version=version),
+        )
+
+
+class MatchInsertionNote(BaseInsertionLine):
+    def __init__(self, version: Version, note: MatchNote) -> None:
+
+        super().__init__(
+            version=version,
+            note=note,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+    ) -> MatchInsertionNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            note_class=MatchNote,
+            version=version,
+        )
+
+        return cls(**kwargs)
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseInsertionLine, version: Version
+    ) -> MatchInsertionNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseInsertionLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseInsertionLine`")
+
+        return cls(
+            version=version,
+            note=MatchNote.from_instance(instance.note, version=version),
+        )
+
+
+class MatchOrnamentNote(BaseOrnamentLine):
+
+    field_names = (
+        "Anchor",
+        "OrnamentType",
+    )
+    field_types = (
+        str,
+        list,
+    )
+    format_fun = dict(Anchor=format_string, OrnamentType=format_list)
+    out_pattern = "ornament({Anchor},{OrnamentType})-{NoteLine}"
+    ornament_pattern: re.Pattern = re.compile(
+        r"ornament\((?P<Anchor>[^\)]*),\[(?P<OrnamentType>.*)\]\)-"
+    )
+
+    def __init__(
+        self,
+        version: Version,
+        anchor: str,
+        ornament_type: List[str],
+        note: BaseNoteLine,
+    ) -> None:
+        super().__init__(
+            version=version,
+            anchor=anchor,
+            note=note,
+        )
+        self.OrnamentType = ornament_type
+
+    @property
+    def matchline(self) -> str:
+        return self.out_pattern.format(
+            Anchor=self.format_fun[0]["Anchor"](self.Anchor),
+            OrnamentType=self.format_fun[0]["OrnamentType"](self.OrnamentType),
+            NoteLine=self.note.matchline,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+    ) -> MatchOrnamentNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        anchor_pattern = cls.ornament_pattern.search(matchline)
+
+        if anchor_pattern is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+        note = MatchNote.from_matchline(matchline, version=version)
+
+        return cls(
+            version=version,
+            note=note,
+            anchor=interpret_as_string(anchor_pattern.group("Anchor")),
+            ornament_type=interpret_as_list(anchor_pattern.group("OrnamentType")),
+        )
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseOrnamentLine, version: Version
+    ) -> MatchOrnamentNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseOrnamentLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseOrnamentLine`")
+
+        return cls(
+            version=version,
+            anchor=instance.Anchor,
+            note=MatchNote.from_instance(instance.note, version=version),
+            ornament_type=["trill"]
+            if instance.version < Version(1, 0, 0)
+            else instance.OrnamentType,
+        )
+
+
+class MatchSustainPedal(BaseSustainPedalLine):
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            time=time,
+            value=value,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+        pos: int = 0,
+    ) -> MatchSustainPedal:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            version=version,
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(**kwargs)
+
+    @classmethod
+    def from_instance(
+        cls, instance: BaseSustainPedalLine, version: Version
+    ) -> MatchOrnamentNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseSustainPedalLine):
+            raise ValueError(
+                "`instance` needs to be a subclass of `BaseSustainPedalLine`"
+            )
+
+        return cls(
+            version=version,
+            time=int(instance.Time),
+            value=int(instance.Value),
+        )
+
+
+class MatchSoftPedal(BaseSoftPedalLine):
+    def __init__(
+        self,
+        version: Version,
+        time: int,
+        value: int,
+    ) -> None:
+
+        super().__init__(
+            version=version,
+            time=time,
+            value=value,
+        )
+
+    @classmethod
+    def from_matchline(
+        cls,
+        matchline: str,
+        version: Version = LATEST_VERSION,
+        pos: int = 0,
+    ) -> MatchSoftPedal:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        kwargs = cls.prepare_kwargs_from_matchline(
+            matchline=matchline,
+            version=version,
+            pos=pos,
+        )
+
+        if kwargs is None:
+            raise MatchError("Input match line does not fit the expected pattern.")
+
+        return cls(**kwargs)
+
+    @classmethod
+    def from_instance(
+        cls,
+        instance: BaseSoftPedalLine,
+        version: Version,
+    ) -> MatchOrnamentNote:
+
+        if version < Version(1, 0, 0):
+            raise ValueError(f"{version} < Version(1, 0, 0)")
+
+        if not isinstance(instance, BaseSoftPedalLine):
+            raise ValueError("`instance` needs to be a subclass of `BaseSoftPedalLine`")
+
+        return cls(
+            version=version,
+            time=int(instance.Time),
+            value=int(instance.Value),
+        )
+
+
+FROM_MATCHLINE_METHODS = [
+    MatchSnoteNote.from_matchline,
+    MatchSnoteDeletion.from_matchline,
+    MatchInsertionNote.from_matchline,
+    MatchOrnamentNote.from_matchline,
+    MatchSustainPedal.from_matchline,
+    MatchSoftPedal.from_matchline,
+    MatchInfo.from_matchline,
+    MatchScoreProp.from_matchline,
+    MatchSection.from_matchline,
+    MatchStimePtime.from_matchline,
+]
+
+
+## Helper methods to build the corresponding line for each parameter
+
+
+def make_info(version: Version, attribute: str, value: Any) -> MatchInfo:
+    """
+    Get version line from attributes
+    """
+
+    if attribute == "matchFileVersion":
+        if version != value:
+            raise ValueError(
+                f"The specified version ({version}) should be the same as "
+                f"`value` ({value})"
+            )
+    class_dict = INFO_LINE[version]
+
+    _, format_fun, dtype = class_dict[attribute]
+
+    ml = MatchInfo(
+        version=version,
+        attribute=attribute,
+        value=value,
+        value_type=dtype,
+        format_fun=format_fun,
+    )
+
+    return ml
+
+
+def make_scoreprop(
+    version: Version,
+    attribute: str,
+    value: Any,
+    measure: int,
+    beat: int,
+    offset: FractionalSymbolicDuration,
+    time_in_beats: float,
+) -> MatchScoreProp:
+
+    class_dict = SCOREPROP_LINE[version]
+
+    _, format_fun, dtype = class_dict[attribute]
+
+    ml = MatchScoreProp(
+        version=version,
+        attribute=attribute,
+        value=value,
+        value_type=dtype,
+        format_fun=format_fun,
+        measure=measure,
+        beat=beat,
+        offset=offset,
+        time_in_beats=time_in_beats,
+    )
+
+    return ml
+
+
+def make_section(
+    version: Version,
+    start_in_beats_unfolded: float,
+    end_in_beats_unfolded: float,
+    start_in_beats_original: float,
+    end_in_beats_original: float,
+    repeat_end_type: Union[str, List[str]],
+) -> MatchSection:
+
+    ml = MatchSection(
+        version=version,
+        start_in_beats_unfolded=start_in_beats_unfolded,
+        start_in_beats_original=start_in_beats_original,
+        end_in_beats_unfolded=end_in_beats_unfolded,
+        end_in_beats_original=end_in_beats_original,
+        repeat_end_type=[repeat_end_type]
+        if isinstance(repeat_end_type, str)
+        else repeat_end_type,
+    )
+    return ml
+
+
+def to_v1(matchline: MatchLine, version: Version = LATEST_VERSION) -> MatchLine:
+    """
+    Convert matchline to version 1_x_x
+
+    Parameters
+    ----------
+    matchline : MatchLine
+        Matchline to be converted
+    version: Version
+        Target version. Default is `LATEST_VERSION`
+
+    Returns
+    -------
+    MatchLine
+         A new matchline with the equivalent of the input matchline in
+         the specified version.
+    """
+    from partitura.io.matchlines_v0 import MatchMeta
+
+    if isinstance(matchline, BaseInfoLine):
+
+        if (
+            matchline.Attribute in INFO_LINE[version]
+            or matchline.Attribute in INFO_ATTRIBUTE_EQUIVALENCES
+        ):
+            return MatchInfo.from_instance(instance=matchline, version=version)
+
+        if (
+            matchline.Attribute in SCOREPROP_LINE[version]
+            or matchline.Attribute in SCOREPROP_ATTRIBUTE_EQUIVALENCES
+        ):
+
+            return MatchScoreProp.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, MatchMeta):
+        return MatchScoreProp.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseSnoteNoteLine):
+        return MatchSnoteNote.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseInsertionLine):
+        return MatchInsertionNote.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseDeletionLine):
+        return MatchSnoteDeletion.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseOrnamentLine):
+        return MatchOrnamentNote.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseSustainPedalLine):
+        return MatchSustainPedal.from_instance(instance=matchline, version=version)
+
+    if isinstance(matchline, BaseSoftPedalLine):
+        return MatchSustainPedal.from_instance(instance=matchline, version=version)
+
+    else:
+        print(matchline.matchline)
+        raise MatchError(f"No equivalent line in version {version}")
```

### Comparing `partitura-1.2.1/partitura/io/musescore.py` & `partitura-1.2.2/partitura/io/musescore.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,259 +1,258 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains functionality to use the MuseScore program as a
-backend for loading and rendering scores.
-"""
-
-import platform
-import warnings
-import glob
-import os
-import shutil
-import subprocess
-from pathlib import Path
-from tempfile import NamedTemporaryFile, TemporaryDirectory, gettempdir
-from typing import Optional, Union
-
-from partitura.io.importmusicxml import load_musicxml
-from partitura.io.exportmusicxml import save_musicxml
-from partitura.score import Score, ScoreLike
-
-from partitura.utils.misc import (
-    deprecated_alias,
-    deprecated_parameter,
-    PathLike,
-    concatenate_images,
-    PIL_EXISTS,
-)
-
-
-class MuseScoreNotFoundException(Exception):
-    pass
-
-
-class FileImportException(Exception):
-    pass
-
-
-def find_musescore3():
-    # # possible way to detect MuseScore... executable
-    # for p in os.environ['PATH'].split(':'):
-    #     c = glob.glob(os.path.join(p, 'MuseScore*'))
-    #     if c:
-    #         print(c)
-    #         break
-
-    result = shutil.which("musescore")
-
-    if result is None:
-        result = shutil.which("musescore3")
-
-    if result is None:
-        result = shutil.which("mscore")
-
-    if result is None:
-        result = shutil.which("mscore3")
-
-    if result is None:
-        if platform.system() == "Linux":
-            pass
-
-        elif platform.system() == "Darwin":
-
-            result = shutil.which("/Applications/MuseScore 3.app/Contents/MacOS/mscore")
-
-        elif platform.system() == "Windows":
-            result = shutil.which(r"C:\Program Files\MuseScore 3\bin\MuseScore3.exe")
-
-    return result
-
-
-@deprecated_alias(fn="filename")
-@deprecated_parameter("ensure_list")
-def load_via_musescore(
-    filename: PathLike,
-    validate: bool = False,
-    force_note_ids: Optional[Union[bool, str]] = True,
-) -> Score:
-    """Load a score through through the MuseScore program.
-
-    This function attempts to load the file in MuseScore, export it as
-    MusicXML, and then load the MusicXML. This should enable loading
-    of all file formats that for which MuseScore has import-support
-    (e.g. MIDI, and ABC, but currently not MEI).
-
-    Parameters
-    ----------
-    filename : str
-        Filename of the score to load
-    validate : bool, optional
-        When True the validity of the MusicXML generated by MuseScore is checked
-        against the MusicXML 3.1 specification before loading the file. An
-        exception will be raised when the MusicXML is invalid.
-        Defaults to False.
-    force_note_ids : bool, optional.
-        When True each Note in the returned Part(s) will have a newly
-        assigned unique id attribute. Existing note id attributes in
-        the MusicXML will be discarded.
-
-    Returns
-    -------
-    :class:`partitura.score.Part`, :class:`partitura.score.PartGroup`, \
-or a list of these
-        One or more part or partgroup objects
-
-    """
-
-    mscore_exec = find_musescore3()
-
-    if not mscore_exec:
-
-        raise MuseScoreNotFoundException()
-
-    xml_fh = os.path.splitext(os.path.basename(filename))[0] + ".musicxml"
-
-    cmd = [mscore_exec, "-o", xml_fh, filename]
-
-    try:
-
-        ps = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
-
-        if ps.returncode != 0:
-
-            raise FileImportException(
-                (
-                    "Command {} failed with code {}. MuseScore "
-                    "error messages:\n {}"
-                ).format(cmd, ps.returncode, ps.stderr.decode("UTF-8"))
-            )
-    except FileNotFoundError as f:
-
-        raise FileImportException(
-            'Executing "{}" returned  {}.'.format(" ".join(cmd), f)
-        )
-
-    score = load_musicxml(
-        filename=xml_fh,
-        validate=validate,
-        force_note_ids=force_note_ids,
-    )
-    
-    os.remove(xml_fh)
-    
-    return score
-
-
-@deprecated_alias(out_fn="out", part="score_data")
-def render_musescore(
-    score_data: ScoreLike,
-    fmt: str,
-    out: Optional[PathLike] = None,
-    dpi: Optional[int] = 90,
-) -> Optional[PathLike]:
-    """
-    Render a score-like object using musescore.
-
-    Parameters
-    ----------
-    score_data : ScoreLike
-        Score-like object to be rendered
-    fmt : {'png', 'pdf'}
-        Output image format
-    out : str or None, optional
-        The path of the image output file, if not specified, the
-        rendering will be saved to a temporary filename. Defaults to
-        None.
-    dpi : int, optional
-        Image resolution. This option is ignored when `fmt` is
-        'pdf'. Defaults to 90.
-
-    Returns
-    -------
-    out : Optional[PathLike]
-       Path to the output generated image (or None if no image was generated)
-    """
-    mscore_exec = find_musescore3()
-
-    if not mscore_exec:
-
-        return None
-
-    if fmt not in ("png", "pdf"):
-
-        warnings.warn("warning: unsupported output format")
-        return None
-
-    # with NamedTemporaryFile(suffix='.musicxml') as xml_fh, \
-    #      NamedTemporaryFile(suffix='.{}'.format(fmt)) as img_fh:
-    with TemporaryDirectory() as tmpdir:
-        xml_fh = Path(tmpdir) / "score.musicxml"
-        img_fh = Path(tmpdir) / f"score.{fmt}"
-
-        save_musicxml(score_data, xml_fh)
-
-        cmd = [
-            mscore_exec,
-            "-T",
-            "10",
-            "-r",
-            "{}".format(int(dpi)),
-            "-o",
-            os.fspath(img_fh),
-            os.fspath(xml_fh),
-        ]
-        try:
-
-            ps = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-
-            if ps.returncode != 0:
-                warnings.warn(
-                    "Command {} failed with code {}; stdout: {}; stderr: {}".format(
-                        cmd,
-                        ps.returncode,
-                        ps.stdout.decode("UTF-8"),
-                        ps.stderr.decode("UTF-8"),
-                    ),
-                    SyntaxWarning,
-                    stacklevel=2,
-                )
-                return None
-
-        except FileNotFoundError as f:
-
-            warnings.warn(
-                'Executing "{}" returned  {}.'.format(" ".join(cmd), f),
-                ImportWarning,
-                stacklevel=2,
-            )
-            return None
-
-        # LOGGER.error('Command "{}" returned with code {}; stdout: {}; stderr: {}'
-        #              .format(' '.join(cmd), ps.returncode, ps.stdout.decode('UTF-8'),
-        #                      ps.stderr.decode('UTF-8')))
-
-        if fmt == "png":
-
-            if PIL_EXISTS:
-                # get all generated image files
-                img_files = glob.glob(
-                    os.path.join(img_fh.parent, img_fh.stem + "-*.png")
-                )
-                concatenate_images(
-                    filenames=img_files,
-                    out=img_fh,
-                    concat_mode="vertical",
-                )
-            else:
-                # The first image seems to be blank (MuseScore adds an empy page)
-                img_fh = (img_fh.parent / (img_fh.stem + "-2")).with_suffix(
-                    img_fh.suffix
-                )
-
-        if img_fh.is_file():
-            if out is None:
-                out = os.path.join(gettempdir(), "partitura_render_tmp.png")
-            shutil.copy(img_fh, out)
-            return out
-
-        return None
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains functionality to use the MuseScore program as a
+backend for loading and rendering scores.
+"""
+
+import platform
+import warnings
+import glob
+import os
+import shutil
+import subprocess
+from pathlib import Path
+from tempfile import NamedTemporaryFile, TemporaryDirectory, gettempdir
+from typing import Optional, Union
+
+from partitura.io.importmusicxml import load_musicxml
+from partitura.io.exportmusicxml import save_musicxml
+from partitura.score import Score, ScoreLike
+
+from partitura.utils.misc import (
+    deprecated_alias,
+    deprecated_parameter,
+    PathLike,
+    concatenate_images,
+    PIL_EXISTS,
+)
+
+
+class MuseScoreNotFoundException(Exception):
+    pass
+
+
+class FileImportException(Exception):
+    pass
+
+
+def find_musescore3():
+    # # possible way to detect MuseScore... executable
+    # for p in os.environ['PATH'].split(':'):
+    #     c = glob.glob(os.path.join(p, 'MuseScore*'))
+    #     if c:
+    #         print(c)
+    #         break
+
+    result = shutil.which("musescore")
+
+    if result is None:
+        result = shutil.which("musescore3")
+
+    if result is None:
+        result = shutil.which("mscore")
+
+    if result is None:
+        result = shutil.which("mscore3")
+
+    if result is None:
+        if platform.system() == "Linux":
+            pass
+
+        elif platform.system() == "Darwin":
+
+            result = shutil.which("/Applications/MuseScore 3.app/Contents/MacOS/mscore")
+
+        elif platform.system() == "Windows":
+            result = shutil.which(r"C:\Program Files\MuseScore 3\bin\MuseScore3.exe")
+
+    return result
+
+
+@deprecated_alias(fn="filename")
+@deprecated_parameter("ensure_list")
+def load_via_musescore(
+    filename: PathLike,
+    validate: bool = False,
+    force_note_ids: Optional[Union[bool, str]] = True,
+) -> Score:
+    """Load a score through through the MuseScore program.
+
+    This function attempts to load the file in MuseScore, export it as
+    MusicXML, and then load the MusicXML. This should enable loading
+    of all file formats that for which MuseScore has import-support
+    (e.g. MIDI, and ABC, but currently not MEI).
+
+    Parameters
+    ----------
+    filename : str
+        Filename of the score to load
+    validate : bool, optional
+        When True the validity of the MusicXML generated by MuseScore is checked
+        against the MusicXML 3.1 specification before loading the file. An
+        exception will be raised when the MusicXML is invalid.
+        Defaults to False.
+    force_note_ids : bool, optional.
+        When True each Note in the returned Part(s) will have a newly
+        assigned unique id attribute. Existing note id attributes in
+        the MusicXML will be discarded.
+
+    Returns
+    -------
+    :class:`partitura.score.Part`, :class:`partitura.score.PartGroup`, \
+or a list of these
+        One or more part or partgroup objects
+
+    """
+
+    mscore_exec = find_musescore3()
+
+    if not mscore_exec:
+
+        raise MuseScoreNotFoundException()
+
+    xml_fh = os.path.splitext(os.path.basename(filename))[0] + ".musicxml"
+
+    cmd = [mscore_exec, "-o", xml_fh, filename]
+
+    try:
+
+        ps = subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
+
+        if ps.returncode != 0:
+
+            raise FileImportException(
+                (
+                    "Command {} failed with code {}. MuseScore " "error messages:\n {}"
+                ).format(cmd, ps.returncode, ps.stderr.decode("UTF-8"))
+            )
+    except FileNotFoundError as f:
+
+        raise FileImportException(
+            'Executing "{}" returned  {}.'.format(" ".join(cmd), f)
+        )
+
+    score = load_musicxml(
+        filename=xml_fh,
+        validate=validate,
+        force_note_ids=force_note_ids,
+    )
+
+    os.remove(xml_fh)
+
+    return score
+
+
+@deprecated_alias(out_fn="out", part="score_data")
+def render_musescore(
+    score_data: ScoreLike,
+    fmt: str,
+    out: Optional[PathLike] = None,
+    dpi: Optional[int] = 90,
+) -> Optional[PathLike]:
+    """
+    Render a score-like object using musescore.
+
+    Parameters
+    ----------
+    score_data : ScoreLike
+        Score-like object to be rendered
+    fmt : {'png', 'pdf'}
+        Output image format
+    out : str or None, optional
+        The path of the image output file, if not specified, the
+        rendering will be saved to a temporary filename. Defaults to
+        None.
+    dpi : int, optional
+        Image resolution. This option is ignored when `fmt` is
+        'pdf'. Defaults to 90.
+
+    Returns
+    -------
+    out : Optional[PathLike]
+       Path to the output generated image (or None if no image was generated)
+    """
+    mscore_exec = find_musescore3()
+
+    if not mscore_exec:
+
+        return None
+
+    if fmt not in ("png", "pdf"):
+
+        warnings.warn("warning: unsupported output format")
+        return None
+
+    # with NamedTemporaryFile(suffix='.musicxml') as xml_fh, \
+    #      NamedTemporaryFile(suffix='.{}'.format(fmt)) as img_fh:
+    with TemporaryDirectory() as tmpdir:
+        xml_fh = Path(tmpdir) / "score.musicxml"
+        img_fh = Path(tmpdir) / f"score.{fmt}"
+
+        save_musicxml(score_data, xml_fh)
+
+        cmd = [
+            mscore_exec,
+            "-T",
+            "10",
+            "-r",
+            "{}".format(int(dpi)),
+            "-o",
+            os.fspath(img_fh),
+            os.fspath(xml_fh),
+        ]
+        try:
+
+            ps = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+
+            if ps.returncode != 0:
+                warnings.warn(
+                    "Command {} failed with code {}; stdout: {}; stderr: {}".format(
+                        cmd,
+                        ps.returncode,
+                        ps.stdout.decode("UTF-8"),
+                        ps.stderr.decode("UTF-8"),
+                    ),
+                    SyntaxWarning,
+                    stacklevel=2,
+                )
+                return None
+
+        except FileNotFoundError as f:
+
+            warnings.warn(
+                'Executing "{}" returned  {}.'.format(" ".join(cmd), f),
+                ImportWarning,
+                stacklevel=2,
+            )
+            return None
+
+        # LOGGER.error('Command "{}" returned with code {}; stdout: {}; stderr: {}'
+        #              .format(' '.join(cmd), ps.returncode, ps.stdout.decode('UTF-8'),
+        #                      ps.stderr.decode('UTF-8')))
+
+        if fmt == "png":
+
+            if PIL_EXISTS:
+                # get all generated image files
+                img_files = glob.glob(
+                    os.path.join(img_fh.parent, img_fh.stem + "-*.png")
+                )
+                concatenate_images(
+                    filenames=img_files,
+                    out=img_fh,
+                    concat_mode="vertical",
+                )
+            else:
+                # The first image seems to be blank (MuseScore adds an empy page)
+                img_fh = (img_fh.parent / (img_fh.stem + "-2")).with_suffix(
+                    img_fh.suffix
+                )
+
+        if img_fh.is_file():
+            if out is None:
+                out = os.path.join(gettempdir(), "partitura_render_tmp.png")
+            shutil.copy(img_fh, out)
+            return out
+
+        return None
```

### Comparing `partitura-1.2.1/partitura/musicanalysis/key_identification.py` & `partitura-1.2.2/partitura/musicanalysis/key_identification.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,235 +1,235 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module implements Krumhansl and Schmuckler key estimation method.
-
-References
-----------
-.. [2] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
-       Oxford University Press, New York.
-"""
-import numpy as np
-from scipy.linalg import circulant
-from partitura.utils.music import ensure_notearray
-
-__all__ = ["estimate_key"]
-
-# List of labels for each key (Use enharmonics as needed).
-# Each tuple is (key root name, mode, fifths)
-# The key root name is equal to that with the smallest fifths in
-# the circle of fifths.
-KEYS = [
-    ("C", "major", 0),
-    ("Db", "major", -5),
-    ("D", "major", 2),
-    ("Eb", "major", -3),
-    ("E", "major", 4),
-    ("F", "major", -1),
-    ("F#", "major", 6),
-    ("G", "major", 1),
-    ("Ab", "major", -4),
-    ("A", "major", 3),
-    ("Bb", "major", -2),
-    ("B", "major", 5),
-    ("C", "minor", -3),
-    ("C#", "minor", 4),
-    ("D", "minor", -1),
-    ("D#", "minor", 6),
-    ("E", "minor", 1),
-    ("F", "minor", -4),
-    ("F#", "minor", 3),
-    ("G", "minor", -2),
-    ("G#", "minor", 5),
-    ("A", "minor", 0),
-    ("Bb", "minor", -5),
-    ("B", "minor", 2),
-]
-
-VALID_KEY_PROFILES = [
-    "krumhansl_kessler",
-    "kk",
-    "temperley",
-    "tp",
-    "kostka_payne",
-    "kp",
-]
-
-
-# Krumhansl--Kessler Key Profiles
-
-# From Krumhansl's "Cognitive Foundations of Musical Pitch" pp.30
-key_prof_maj_kk = np.array(
-    [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88]
-)
-
-key_prof_min_kk = np.array(
-    [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
-)
-
-# Temperley Key Profiles
-
-# CBMS (from "Music and Probability" Table 6.1, pp. 86)
-key_prof_maj_cbms = np.array(
-    [5.0, 2.0, 3.5, 2.0, 4.5, 4.0, 2.0, 4.5, 2.0, 3.5, 1.5, 4.0]
-)
-
-key_prof_min_cbms = np.array(
-    [5.0, 2.0, 3.5, 4.5, 2.0, 4.0, 2.0, 4.5, 3.5, 2.0, 1.5, 4.0]
-)
-
-# Kostka-Payne (from "Music and Probability" Table 6.1, pp. 86)
-key_prof_maj_kp = np.array(
-    [0.748, 0.060, 0.488, 0.082, 0.670, 0.460, 0.096, 0.715, 0.104, 0.366, 0.057, 0.400]
-)
-
-key_prof_min_kp = np.array(
-    [0.712, 0.048, 0.474, 0.618, 0.049, 0.460, 0.105, 0.747, 0.404, 0.067, 0.133, 0.330]
-)
-
-
-def build_key_profile_matrix(key_prof_maj, key_prof_min):
-    """
-    Generate Matrix of key profiles
-    """
-    # Normalize Key profiles
-    key_prof_maj /= np.sum(key_prof_maj)
-    key_prof_min /= np.sum(key_prof_min)
-
-    # Create matrix of key profiles
-    Key_prof_mat = np.vstack(
-        (circulant(key_prof_maj).transpose(), circulant(key_prof_min).transpose())
-    )
-
-    return Key_prof_mat
-
-
-# Key profile matrices
-KRUMHANSL_KESSLER = build_key_profile_matrix(key_prof_maj_kk, key_prof_min_kk)
-CMBS = build_key_profile_matrix(key_prof_maj_cbms, key_prof_min_cbms)
-KOSTKA_PAYNE = build_key_profile_matrix(key_prof_maj_kp, key_prof_min_kp)
-
-
-def estimate_key(note_info, method="krumhansl", *args, **kwargs):
-    """
-    Estimate key of a piece by comparing the pitch statistics of the
-    note array to key profiles [2]_, [3]_.
-
-    Parameters
-    ----------
-    note_info : structured array, `Part` or `PerformedPart`
-        Note information as a `Part` or `PerformedPart` instances or
-        as a structured array. If it is a structured array, it has to
-        contain the fields generated by the `note_array` properties
-        of `Part` or `PerformedPart` objects. If the array contains
-        onset and duration information of both score and performance,
-        (e.g., containing both `onset_beat` and `onset_sec`), the score
-        information will be preferred.
-    method : {'krumhansl'}
-        Method for estimating the key. For now 'krumhansl' is the only
-        supported method.
-    args, kwargs
-        Positional and Keyword arguments for the key estimation method
-
-    Returns
-    -------
-    str
-       String representing the key name (i.e., Root(alteration)(m if minor)).
-       See `partitura.utils.key_name_to_fifths_mode` and
-       `partitura.utils.fifths_mode_to_key_name`.
-
-    References
-    ----------
-    .. [2] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
-           Oxford University Press, New York.
-    .. [3] Temperley, D. (1999) "What's key for key? The Krumhansl-Schmuckler
-           key-finding algorithm reconsidered". Music Perception. 17(1),
-           pp. 65--100.
-
-    """
-
-    if method not in ("krumhansl",):
-        raise ValueError('For now the only valid method is "krumhansl"')
-
-    if method == "krumhansl":
-        kid = ks_kid
-
-        if "key_profiles" not in kwargs:
-            kwargs["key_profiles"] = "krumhansl_kessler"
-        else:
-            if kwargs["key_profiles"] not in VALID_KEY_PROFILES:
-                raise ValueError(
-                    "Invalid key_profiles. " 'Valid options are "ks", "cmbs" or "kp"'
-                )
-
-    note_array = ensure_notearray(note_info)
-
-    return kid(note_array, *args, **kwargs)
-
-
-def format_key(root, mode, fifths):
-    return "{}{}".format(root, "m" if mode == "minor" else "")
-
-
-def ks_kid(note_array, key_profiles=KRUMHANSL_KESSLER, return_sorted_keys=False):
-    """
-    Estimate key of a piece using the Krumhansl-Schmuckler
-    algorithm.
-    """
-    if isinstance(key_profiles, str):
-        if key_profiles in ("ks", "krumhansl_kessler"):
-            key_profiles = KRUMHANSL_KESSLER
-        elif key_profiles in ("temperley", "cmbs"):
-            key_profiles = CMBS
-        elif key_profiles in ("kp", "kostka_payne"):
-            key_profiles = KOSTKA_PAYNE
-
-        else:
-            raise ValueError(
-                "Invalid key_profiles. " 'Valid options are "ks", "cmbs" or "kp"'
-            )
-
-    corrs = _similarity_with_pitch_profile(
-        note_array=note_array, key_profiles=key_profiles, similarity_func=corr
-    )
-
-    if return_sorted_keys:
-        return [format_key(*KEYS[i]) for i in np.argsort(corrs)[::-1]]
-    else:
-        return format_key(*KEYS[corrs.argmax()])
-
-
-def corr(x, y):
-    return np.corrcoef(x, y)[0, 1]
-
-
-def _similarity_with_pitch_profile(
-    note_array,
-    key_profiles=KRUMHANSL_KESSLER,
-    similarity_func=corr,
-    normalize_distribution=False,
-):
-    from partitura.utils.music import get_time_units_from_note_array
-
-    _, duration_unit = get_time_units_from_note_array(note_array)
-    # Get pitch classes
-    pitch_classes = np.mod(note_array["pitch"], 12)
-
-    # Compute weighted key distribution
-    pitch_distribution = np.array(
-        [
-            note_array[duration_unit][np.where(pitch_classes == pc)[0]].sum()
-            for pc in range(12)
-        ]
-    )
-
-    if normalize_distribution:
-        # normalizing is unnecessary for computing the correlation, but might
-        # be necessary for other similarity metrics
-        pitch_distribution = pitch_distribution / float(pitch_distribution.sum())
-
-    # Compute correlation with key profiles
-    similarity = np.array(
-        [similarity_func(pitch_distribution, kp) for kp in key_profiles]
-    )
-
-    return similarity
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module implements Krumhansl and Schmuckler key estimation method.
+
+References
+----------
+.. [2] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
+       Oxford University Press, New York.
+"""
+import numpy as np
+from scipy.linalg import circulant
+from partitura.utils.music import ensure_notearray
+
+__all__ = ["estimate_key"]
+
+# List of labels for each key (Use enharmonics as needed).
+# Each tuple is (key root name, mode, fifths)
+# The key root name is equal to that with the smallest fifths in
+# the circle of fifths.
+KEYS = [
+    ("C", "major", 0),
+    ("Db", "major", -5),
+    ("D", "major", 2),
+    ("Eb", "major", -3),
+    ("E", "major", 4),
+    ("F", "major", -1),
+    ("F#", "major", 6),
+    ("G", "major", 1),
+    ("Ab", "major", -4),
+    ("A", "major", 3),
+    ("Bb", "major", -2),
+    ("B", "major", 5),
+    ("C", "minor", -3),
+    ("C#", "minor", 4),
+    ("D", "minor", -1),
+    ("D#", "minor", 6),
+    ("E", "minor", 1),
+    ("F", "minor", -4),
+    ("F#", "minor", 3),
+    ("G", "minor", -2),
+    ("G#", "minor", 5),
+    ("A", "minor", 0),
+    ("Bb", "minor", -5),
+    ("B", "minor", 2),
+]
+
+VALID_KEY_PROFILES = [
+    "krumhansl_kessler",
+    "kk",
+    "temperley",
+    "tp",
+    "kostka_payne",
+    "kp",
+]
+
+
+# Krumhansl--Kessler Key Profiles
+
+# From Krumhansl's "Cognitive Foundations of Musical Pitch" pp.30
+key_prof_maj_kk = np.array(
+    [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88]
+)
+
+key_prof_min_kk = np.array(
+    [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
+)
+
+# Temperley Key Profiles
+
+# CBMS (from "Music and Probability" Table 6.1, pp. 86)
+key_prof_maj_cbms = np.array(
+    [5.0, 2.0, 3.5, 2.0, 4.5, 4.0, 2.0, 4.5, 2.0, 3.5, 1.5, 4.0]
+)
+
+key_prof_min_cbms = np.array(
+    [5.0, 2.0, 3.5, 4.5, 2.0, 4.0, 2.0, 4.5, 3.5, 2.0, 1.5, 4.0]
+)
+
+# Kostka-Payne (from "Music and Probability" Table 6.1, pp. 86)
+key_prof_maj_kp = np.array(
+    [0.748, 0.060, 0.488, 0.082, 0.670, 0.460, 0.096, 0.715, 0.104, 0.366, 0.057, 0.400]
+)
+
+key_prof_min_kp = np.array(
+    [0.712, 0.048, 0.474, 0.618, 0.049, 0.460, 0.105, 0.747, 0.404, 0.067, 0.133, 0.330]
+)
+
+
+def build_key_profile_matrix(key_prof_maj, key_prof_min):
+    """
+    Generate Matrix of key profiles
+    """
+    # Normalize Key profiles
+    key_prof_maj /= np.sum(key_prof_maj)
+    key_prof_min /= np.sum(key_prof_min)
+
+    # Create matrix of key profiles
+    Key_prof_mat = np.vstack(
+        (circulant(key_prof_maj).transpose(), circulant(key_prof_min).transpose())
+    )
+
+    return Key_prof_mat
+
+
+# Key profile matrices
+KRUMHANSL_KESSLER = build_key_profile_matrix(key_prof_maj_kk, key_prof_min_kk)
+CMBS = build_key_profile_matrix(key_prof_maj_cbms, key_prof_min_cbms)
+KOSTKA_PAYNE = build_key_profile_matrix(key_prof_maj_kp, key_prof_min_kp)
+
+
+def estimate_key(note_info, method="krumhansl", *args, **kwargs):
+    """
+    Estimate key of a piece by comparing the pitch statistics of the
+    note array to key profiles [2]_, [3]_.
+
+    Parameters
+    ----------
+    note_info : structured array, `Part` or `PerformedPart`
+        Note information as a `Part` or `PerformedPart` instances or
+        as a structured array. If it is a structured array, it has to
+        contain the fields generated by the `note_array` properties
+        of `Part` or `PerformedPart` objects. If the array contains
+        onset and duration information of both score and performance,
+        (e.g., containing both `onset_beat` and `onset_sec`), the score
+        information will be preferred.
+    method : {'krumhansl'}
+        Method for estimating the key. For now 'krumhansl' is the only
+        supported method.
+    args, kwargs
+        Positional and Keyword arguments for the key estimation method
+
+    Returns
+    -------
+    str
+       String representing the key name (i.e., Root(alteration)(m if minor)).
+       See `partitura.utils.key_name_to_fifths_mode` and
+       `partitura.utils.fifths_mode_to_key_name`.
+
+    References
+    ----------
+    .. [2] Krumhansl, Carol L. (1990) "Cognitive foundations of musical pitch",
+           Oxford University Press, New York.
+    .. [3] Temperley, D. (1999) "What's key for key? The Krumhansl-Schmuckler
+           key-finding algorithm reconsidered". Music Perception. 17(1),
+           pp. 65--100.
+
+    """
+
+    if method not in ("krumhansl",):
+        raise ValueError('For now the only valid method is "krumhansl"')
+
+    if method == "krumhansl":
+        kid = ks_kid
+
+        if "key_profiles" not in kwargs:
+            kwargs["key_profiles"] = "krumhansl_kessler"
+        else:
+            if kwargs["key_profiles"] not in VALID_KEY_PROFILES:
+                raise ValueError(
+                    "Invalid key_profiles. " 'Valid options are "ks", "cmbs" or "kp"'
+                )
+
+    note_array = ensure_notearray(note_info)
+
+    return kid(note_array, *args, **kwargs)
+
+
+def format_key(root, mode, fifths):
+    return "{}{}".format(root, "m" if mode == "minor" else "")
+
+
+def ks_kid(note_array, key_profiles=KRUMHANSL_KESSLER, return_sorted_keys=False):
+    """
+    Estimate key of a piece using the Krumhansl-Schmuckler
+    algorithm.
+    """
+    if isinstance(key_profiles, str):
+        if key_profiles in ("ks", "krumhansl_kessler"):
+            key_profiles = KRUMHANSL_KESSLER
+        elif key_profiles in ("temperley", "cmbs"):
+            key_profiles = CMBS
+        elif key_profiles in ("kp", "kostka_payne"):
+            key_profiles = KOSTKA_PAYNE
+
+        else:
+            raise ValueError(
+                "Invalid key_profiles. " 'Valid options are "ks", "cmbs" or "kp"'
+            )
+
+    corrs = _similarity_with_pitch_profile(
+        note_array=note_array, key_profiles=key_profiles, similarity_func=corr
+    )
+
+    if return_sorted_keys:
+        return [format_key(*KEYS[i]) for i in np.argsort(corrs)[::-1]]
+    else:
+        return format_key(*KEYS[corrs.argmax()])
+
+
+def corr(x, y):
+    return np.corrcoef(x, y)[0, 1]
+
+
+def _similarity_with_pitch_profile(
+    note_array,
+    key_profiles=KRUMHANSL_KESSLER,
+    similarity_func=corr,
+    normalize_distribution=False,
+):
+    from partitura.utils.music import get_time_units_from_note_array
+
+    _, duration_unit = get_time_units_from_note_array(note_array)
+    # Get pitch classes
+    pitch_classes = np.mod(note_array["pitch"], 12)
+
+    # Compute weighted key distribution
+    pitch_distribution = np.array(
+        [
+            note_array[duration_unit][np.where(pitch_classes == pc)[0]].sum()
+            for pc in range(12)
+        ]
+    )
+
+    if normalize_distribution:
+        # normalizing is unnecessary for computing the correlation, but might
+        # be necessary for other similarity metrics
+        pitch_distribution = pitch_distribution / float(pitch_distribution.sum())
+
+    # Compute correlation with key profiles
+    similarity = np.array(
+        [similarity_func(pitch_distribution, kp) for kp in key_profiles]
+    )
+
+    return similarity
```

### Comparing `partitura-1.2.1/partitura/musicanalysis/meter.py` & `partitura-1.2.2/partitura/musicanalysis/meter.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,342 +1,342 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module implements methods for Meter numerator, Beat, and Tempo estimation.
-
-Implementation adapted from Jakob Woegerbauer
-based on a model published by Simon Dixon.[1]
-
-References
-----------
-
-.. [1] Simon Dixon (2001), Automatic extraction of
-    tempo and beat from expressive performances.
-    Journal of New Music Research, 30(1):39–58
-"""
-
-import warnings
-import numpy as np
-
-# import scipy.spatial.distance as distance
-# from scipy.interpolate import interp1d
-
-from partitura.utils import get_time_units_from_note_array, ensure_notearray, add_field
-
-
-# Scaling factors
-MAX = 9999999999999
-MIN_INTERVAL = 0.01
-MAX_INTERVAL = 2  # in seconds
-CLUSTER_WIDTH = 1 / 12  # in seconds
-N_CLUSTERS = 100
-INIT_DURATION = 10  # in seconds
-TIMEOUT = 10  # in seconds
-TOLERANCE_POST = 0.4  # propotion of beat_interval
-TOLERANCE_PRE = 0.2  # proportion of beat_interval
-TOLERANCE_INNER = 1 / 12
-CORRECTION_FACTOR = 1 / 4  # higher => more correction (speed changes)
-MAX_AGENTS = 100  # delete low-scoring agents when there are more than MAX_AGENTS
-CHORD_SPREAD_TIME = 1 / 12  # for onset aggregation
-
-
-class MultipleAgents:
-    """
-    Class to compute inter onset interval clusters
-    and to instantiate a number of agents to
-    approximate beat positions.
-    """
-
-    def run(self, onsets, salience):
-        self.clusters = []
-        self.agents = []
-        onsets = np.array(onsets)
-        salience = np.array(salience)
-        self.setup_clusters(onsets)
-        self.init_tracking(onsets, salience)
-        self.track(onsets, salience)
-
-    def getTempo(self):
-        if len(self.agents) == 0:
-            return 120
-        return self.agents[0].getTempo()
-
-    def getNum(self):
-        if len(self.agents) == 0:
-            return 4
-        return self.agents[0].getTimeSignatureNum()
-
-    def getBeats(self):
-        if len(self.agents) > 0:
-            return self.agents[0].history
-        return []
-
-    def setup_clusters(self, onsets):
-        # create inter-onset interval clusters
-        self.clusters = []
-        for i in range(len(onsets)):
-            for j in range(i + 1, len(onsets)):
-                ioi = onsets[j] - onsets[i]
-                if ioi < MIN_INTERVAL:
-                    continue
-                if ioi > MAX_INTERVAL:
-                    break
-                c_min = False
-                for c in self.clusters:
-                    k = c.getK(ioi)
-                    if k:
-                        c_min = c
-                if c_min:
-                    c_min.addIoi(ioi)
-                else:
-                    self.clusters.append(Cluster(ioi))
-
-        # merge clusters
-        i = 0
-        while i < len(self.clusters):
-            c_i = self.clusters[i]
-            i = i + 1
-            j = i
-            while j < len(self.clusters):
-                if abs(c_i.interval - self.clusters[j].interval) < CLUSTER_WIDTH:
-                    c_i.addIoi(self.clusters[j].iois)
-                    self.clusters.remove(self.clusters[j])
-                else:
-                    j += 1
-
-        # sanitize
-        for c in self.clusters:
-            if c.interval <= 0:
-                continue
-            while c.interval < MIN_INTERVAL:
-                c.interval *= 2
-            while c.interval > MAX_INTERVAL:
-                c.interval /= 2
-
-        # merge again
-        i = 0
-        while i < len(self.clusters):
-            c_i = self.clusters[i]
-            i = i + 1
-            j = i
-            while j < len(self.clusters):
-                if abs(c_i.interval - self.clusters[j].interval) < CLUSTER_WIDTH:
-                    c_i.addIoi(self.clusters[j].iois)
-                    self.clusters.remove(self.clusters[j])
-                else:
-                    j += 1
-
-        # calculate cluster scores
-        for c_i in self.clusters:
-            for c_j in self.clusters:
-                n = round(c_j.interval / c_i.interval)
-                if abs(c_i.interval - n * c_j.interval) < CLUSTER_WIDTH:
-                    c_i.score += Cluster.relationship_factor(n) * len(c_j.iois)
-
-        self.clusters = sorted(self.clusters, key=lambda x: x.score, reverse=True)[
-            :N_CLUSTERS
-        ]
-
-    def init_tracking(self, onsets, salience):
-        self.agents = []
-        for c in self.clusters:
-            i = 0
-            while i < len(onsets) and onsets[i] < INIT_DURATION:
-                a = Agent()
-                a.beat_interval = c.interval
-                a.history.append((onsets[i], salience[i]))
-                a.prediction = onsets[i] + c.interval
-                a.score = salience[i]
-                self.agents.append(a)
-                i += 1
-
-    def track(self, onsets, salience):
-        for e_i in range(len(onsets)):
-            e = onsets[e_i]
-            new_agents = []
-            remove_agents = []
-            for a in self.agents:
-                if e - a.lastBeat() > TIMEOUT:
-                    remove_agents.append(a)
-                else:
-                    while a.prediction + TOLERANCE_POST * a.beat_interval < e:
-                        a.history.append((a.prediction, 0))
-                        a.prediction += a.beat_interval
-                    if (
-                        a.prediction - TOLERANCE_PRE * a.beat_interval <= e
-                        and e <= a.prediction + TOLERANCE_POST * a.beat_interval
-                    ):
-                        if abs(a.prediction - e) > TOLERANCE_INNER:
-                            a_new = Agent()
-                            a_new.beat_interval = a.beat_interval
-                            a_new.history = a.history[:]
-                            a_new.prediction = a.prediction
-                            a_new.score = a.score
-                            new_agents.append(a_new)
-                        err = e - a.prediction
-                        a.beat_interval = a.beat_interval + err * CORRECTION_FACTOR
-                        a.prediction = e + a.beat_interval
-                        a.history.append((e, salience[e_i]))
-                        a.score += (1 - abs(err / a.beat_interval) / 2.0) * salience[
-                            e_i
-                        ]
-
-            for a in remove_agents:
-                self.agents.remove(a)
-            self.agents = self.agents + new_agents
-
-            # remove duplicate agents
-            duplicate = np.zeros(len(self.agents))
-            agents_all = self.agents[:]
-            self.agents = []
-            for i in range(len(agents_all)):
-                for j in range(i + 1, len(agents_all)):
-                    if duplicate[i] > 0 or duplicate[j] > 0:
-                        continue
-
-                    if (
-                        abs(agents_all[i].beat_interval - agents_all[j].beat_interval)
-                        < 0.01
-                        and abs(agents_all[i].lastBeat() - agents_all[j].lastBeat())
-                        < 0.02
-                    ):
-                        if agents_all[i].score > agents_all[j].score:
-                            duplicate[j] += 1
-                        else:
-                            duplicate[i] += 1
-                            break
-
-            self.agents = sorted(
-                np.asarray(agents_all)[(duplicate < 1)].tolist(),
-                key=lambda x: x.score,
-                reverse=True,
-            )[:MAX_AGENTS]
-
-        self.agents = sorted(self.agents, key=lambda x: x.score, reverse=True)
-
-
-class Cluster:
-    """
-    Class for inter onset interval clusters.
-
-    Parameters
-    ----------
-    ioi : float
-        an initial inter onset interval
-
-    """
-
-    def __init__(self, ioi) -> None:
-        self.iois = np.zeros(0)
-        self.score = 0
-        self.interval = 0
-        self.addIoi(ioi)
-
-    def getK(self, ioi):
-        diff = abs(self.interval - ioi)
-        if diff < CLUSTER_WIDTH:
-            return diff
-        return False
-
-    def addIoi(self, ioi):
-        self.iois = np.append(self.iois, ioi)
-        self.interval = np.sum(self.iois) / len(self.iois)
-
-    @staticmethod
-    def relationship_factor(d):
-        if 1 <= d and d <= 4:
-            return 6 - d
-        elif 5 <= d and d <= 8:
-            return 1
-        return 0
-
-
-class Agent:
-    """
-    Class for beat induction agents.
-    """
-
-    def __init__(self) -> None:
-        self.beat_interval = 0
-        self.prediction = 0
-        self.history = []
-        self.score = 0
-
-    def lastBeat(self):
-        i = len(self.history) - 1
-        while i > 0 and self.history[i][1] == 0:
-            i -= 1
-        return self.history[i][0]
-
-    def getTempo(self):
-        return (
-            60.0 * (len(self.history) - 1) / (self.history[-1][0] - self.history[0][0])
-        )
-
-    def getTimeSignatureNum(self):
-        possibleNums = [2, 3, 4, 6, 9, 12, 24]
-        bestVal = {num: 0 for num in possibleNums}
-        salience = list(zip(*self.history))[1]
-        sumSalience = sum(salience)
-        f = 1.005
-        for num in possibleNums:
-            for startIdx in range(num):
-                dbs = len(salience[startIdx::num])
-                if dbs > 1:
-                    downbeatSalience = sum(salience[startIdx::num]) / dbs
-                    sumSalience = sum(salience[: (dbs - 1) * num])
-                    otherSalience = (sumSalience - downbeatSalience * dbs) / (
-                        (num - 1) * (dbs - 1)
-                    )
-                else:
-                    downbeatSalience = 0
-                    otherSalience = 1
-
-                ratio = downbeatSalience / otherSalience
-                bestVal[num] = max(bestVal[num], ratio)
-
-        bestNum = max(bestVal, key=bestVal.get)
-
-        return bestNum
-
-
-def estimate_time(note_info):
-    """
-    Estimate tempo, meter (currently only time signature numerator), and beats
-
-    Parameters
-    ----------
-    note_info : structured array, `Part` or `PerformedPart`
-        Note information as a `Part` or `PerformedPart` instances or
-        as a structured array. If it is a structured array, it has to
-        contain the fields generated by the `note_array` properties
-        of `Part` or `PerformedPart` objects. If the array contains
-        onset and duration information of both score and performance,
-        (e.g., containing both `onset_beat` and `onset_sec`), the score
-        information will be preferred.
-
-    Returns
-    -------
-    dict
-        Tempo, meter, and beat information
-    """
-
-    note_array = ensure_notearray(note_info)
-    onset_kw, _ = get_time_units_from_note_array(note_array)
-    onsets_raw = note_array[onset_kw]
-
-    # aggregate notes in clusters
-    aggregated_notes = [(0, 0)]
-    for note_on in onsets_raw:
-        prev_note_on = aggregated_notes[-1][0]
-        prev_note_salience = aggregated_notes[-1][1]
-        if abs(note_on - prev_note_on) < CHORD_SPREAD_TIME:
-            aggregated_notes[-1] = (note_on, prev_note_salience + 1)
-        else:
-            aggregated_notes.append((note_on, 1))
-
-    onsets, saliences = list(zip(*aggregated_notes))
-
-    ma = MultipleAgents()
-    ma.run(onsets, saliences)
-
-    return dict(tempo=ma.getTempo(), meter_numerator=ma.getNum(), beats=ma.getBeats())
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module implements methods for Meter numerator, Beat, and Tempo estimation.
+
+Implementation adapted from Jakob Woegerbauer
+based on a model published by Simon Dixon.[1]
+
+References
+----------
+
+.. [1] Simon Dixon (2001), Automatic extraction of
+    tempo and beat from expressive performances.
+    Journal of New Music Research, 30(1):39–58
+"""
+
+import warnings
+import numpy as np
+
+# import scipy.spatial.distance as distance
+# from scipy.interpolate import interp1d
+
+from partitura.utils import get_time_units_from_note_array, ensure_notearray, add_field
+
+
+# Scaling factors
+MAX = 9999999999999
+MIN_INTERVAL = 0.01
+MAX_INTERVAL = 2  # in seconds
+CLUSTER_WIDTH = 1 / 12  # in seconds
+N_CLUSTERS = 100
+INIT_DURATION = 10  # in seconds
+TIMEOUT = 10  # in seconds
+TOLERANCE_POST = 0.4  # propotion of beat_interval
+TOLERANCE_PRE = 0.2  # proportion of beat_interval
+TOLERANCE_INNER = 1 / 12
+CORRECTION_FACTOR = 1 / 4  # higher => more correction (speed changes)
+MAX_AGENTS = 100  # delete low-scoring agents when there are more than MAX_AGENTS
+CHORD_SPREAD_TIME = 1 / 12  # for onset aggregation
+
+
+class MultipleAgents:
+    """
+    Class to compute inter onset interval clusters
+    and to instantiate a number of agents to
+    approximate beat positions.
+    """
+
+    def run(self, onsets, salience):
+        self.clusters = []
+        self.agents = []
+        onsets = np.array(onsets)
+        salience = np.array(salience)
+        self.setup_clusters(onsets)
+        self.init_tracking(onsets, salience)
+        self.track(onsets, salience)
+
+    def getTempo(self):
+        if len(self.agents) == 0:
+            return 120
+        return self.agents[0].getTempo()
+
+    def getNum(self):
+        if len(self.agents) == 0:
+            return 4
+        return self.agents[0].getTimeSignatureNum()
+
+    def getBeats(self):
+        if len(self.agents) > 0:
+            return self.agents[0].history
+        return []
+
+    def setup_clusters(self, onsets):
+        # create inter-onset interval clusters
+        self.clusters = []
+        for i in range(len(onsets)):
+            for j in range(i + 1, len(onsets)):
+                ioi = onsets[j] - onsets[i]
+                if ioi < MIN_INTERVAL:
+                    continue
+                if ioi > MAX_INTERVAL:
+                    break
+                c_min = False
+                for c in self.clusters:
+                    k = c.getK(ioi)
+                    if k:
+                        c_min = c
+                if c_min:
+                    c_min.addIoi(ioi)
+                else:
+                    self.clusters.append(Cluster(ioi))
+
+        # merge clusters
+        i = 0
+        while i < len(self.clusters):
+            c_i = self.clusters[i]
+            i = i + 1
+            j = i
+            while j < len(self.clusters):
+                if abs(c_i.interval - self.clusters[j].interval) < CLUSTER_WIDTH:
+                    c_i.addIoi(self.clusters[j].iois)
+                    self.clusters.remove(self.clusters[j])
+                else:
+                    j += 1
+
+        # sanitize
+        for c in self.clusters:
+            if c.interval <= 0:
+                continue
+            while c.interval < MIN_INTERVAL:
+                c.interval *= 2
+            while c.interval > MAX_INTERVAL:
+                c.interval /= 2
+
+        # merge again
+        i = 0
+        while i < len(self.clusters):
+            c_i = self.clusters[i]
+            i = i + 1
+            j = i
+            while j < len(self.clusters):
+                if abs(c_i.interval - self.clusters[j].interval) < CLUSTER_WIDTH:
+                    c_i.addIoi(self.clusters[j].iois)
+                    self.clusters.remove(self.clusters[j])
+                else:
+                    j += 1
+
+        # calculate cluster scores
+        for c_i in self.clusters:
+            for c_j in self.clusters:
+                n = round(c_j.interval / c_i.interval)
+                if abs(c_i.interval - n * c_j.interval) < CLUSTER_WIDTH:
+                    c_i.score += Cluster.relationship_factor(n) * len(c_j.iois)
+
+        self.clusters = sorted(self.clusters, key=lambda x: x.score, reverse=True)[
+            :N_CLUSTERS
+        ]
+
+    def init_tracking(self, onsets, salience):
+        self.agents = []
+        for c in self.clusters:
+            i = 0
+            while i < len(onsets) and onsets[i] < INIT_DURATION:
+                a = Agent()
+                a.beat_interval = c.interval
+                a.history.append((onsets[i], salience[i]))
+                a.prediction = onsets[i] + c.interval
+                a.score = salience[i]
+                self.agents.append(a)
+                i += 1
+
+    def track(self, onsets, salience):
+        for e_i in range(len(onsets)):
+            e = onsets[e_i]
+            new_agents = []
+            remove_agents = []
+            for a in self.agents:
+                if e - a.lastBeat() > TIMEOUT:
+                    remove_agents.append(a)
+                else:
+                    while a.prediction + TOLERANCE_POST * a.beat_interval < e:
+                        a.history.append((a.prediction, 0))
+                        a.prediction += a.beat_interval
+                    if (
+                        a.prediction - TOLERANCE_PRE * a.beat_interval <= e
+                        and e <= a.prediction + TOLERANCE_POST * a.beat_interval
+                    ):
+                        if abs(a.prediction - e) > TOLERANCE_INNER:
+                            a_new = Agent()
+                            a_new.beat_interval = a.beat_interval
+                            a_new.history = a.history[:]
+                            a_new.prediction = a.prediction
+                            a_new.score = a.score
+                            new_agents.append(a_new)
+                        err = e - a.prediction
+                        a.beat_interval = a.beat_interval + err * CORRECTION_FACTOR
+                        a.prediction = e + a.beat_interval
+                        a.history.append((e, salience[e_i]))
+                        a.score += (1 - abs(err / a.beat_interval) / 2.0) * salience[
+                            e_i
+                        ]
+
+            for a in remove_agents:
+                self.agents.remove(a)
+            self.agents = self.agents + new_agents
+
+            # remove duplicate agents
+            duplicate = np.zeros(len(self.agents))
+            agents_all = self.agents[:]
+            self.agents = []
+            for i in range(len(agents_all)):
+                for j in range(i + 1, len(agents_all)):
+                    if duplicate[i] > 0 or duplicate[j] > 0:
+                        continue
+
+                    if (
+                        abs(agents_all[i].beat_interval - agents_all[j].beat_interval)
+                        < 0.01
+                        and abs(agents_all[i].lastBeat() - agents_all[j].lastBeat())
+                        < 0.02
+                    ):
+                        if agents_all[i].score > agents_all[j].score:
+                            duplicate[j] += 1
+                        else:
+                            duplicate[i] += 1
+                            break
+
+            self.agents = sorted(
+                np.asarray(agents_all)[(duplicate < 1)].tolist(),
+                key=lambda x: x.score,
+                reverse=True,
+            )[:MAX_AGENTS]
+
+        self.agents = sorted(self.agents, key=lambda x: x.score, reverse=True)
+
+
+class Cluster:
+    """
+    Class for inter onset interval clusters.
+
+    Parameters
+    ----------
+    ioi : float
+        an initial inter onset interval
+
+    """
+
+    def __init__(self, ioi) -> None:
+        self.iois = np.zeros(0)
+        self.score = 0
+        self.interval = 0
+        self.addIoi(ioi)
+
+    def getK(self, ioi):
+        diff = abs(self.interval - ioi)
+        if diff < CLUSTER_WIDTH:
+            return diff
+        return False
+
+    def addIoi(self, ioi):
+        self.iois = np.append(self.iois, ioi)
+        self.interval = np.sum(self.iois) / len(self.iois)
+
+    @staticmethod
+    def relationship_factor(d):
+        if 1 <= d and d <= 4:
+            return 6 - d
+        elif 5 <= d and d <= 8:
+            return 1
+        return 0
+
+
+class Agent:
+    """
+    Class for beat induction agents.
+    """
+
+    def __init__(self) -> None:
+        self.beat_interval = 0
+        self.prediction = 0
+        self.history = []
+        self.score = 0
+
+    def lastBeat(self):
+        i = len(self.history) - 1
+        while i > 0 and self.history[i][1] == 0:
+            i -= 1
+        return self.history[i][0]
+
+    def getTempo(self):
+        return (
+            60.0 * (len(self.history) - 1) / (self.history[-1][0] - self.history[0][0])
+        )
+
+    def getTimeSignatureNum(self):
+        possibleNums = [2, 3, 4, 6, 9, 12, 24]
+        bestVal = {num: 0 for num in possibleNums}
+        salience = list(zip(*self.history))[1]
+        sumSalience = sum(salience)
+        f = 1.005
+        for num in possibleNums:
+            for startIdx in range(num):
+                dbs = len(salience[startIdx::num])
+                if dbs > 1:
+                    downbeatSalience = sum(salience[startIdx::num]) / dbs
+                    sumSalience = sum(salience[: (dbs - 1) * num])
+                    otherSalience = (sumSalience - downbeatSalience * dbs) / (
+                        (num - 1) * (dbs - 1)
+                    )
+                else:
+                    downbeatSalience = 0
+                    otherSalience = 1
+
+                ratio = downbeatSalience / otherSalience
+                bestVal[num] = max(bestVal[num], ratio)
+
+        bestNum = max(bestVal, key=bestVal.get)
+
+        return bestNum
+
+
+def estimate_time(note_info):
+    """
+    Estimate tempo, meter (currently only time signature numerator), and beats
+
+    Parameters
+    ----------
+    note_info : structured array, `Part` or `PerformedPart`
+        Note information as a `Part` or `PerformedPart` instances or
+        as a structured array. If it is a structured array, it has to
+        contain the fields generated by the `note_array` properties
+        of `Part` or `PerformedPart` objects. If the array contains
+        onset and duration information of both score and performance,
+        (e.g., containing both `onset_beat` and `onset_sec`), the score
+        information will be preferred.
+
+    Returns
+    -------
+    dict
+        Tempo, meter, and beat information
+    """
+
+    note_array = ensure_notearray(note_info)
+    onset_kw, _ = get_time_units_from_note_array(note_array)
+    onsets_raw = note_array[onset_kw]
+
+    # aggregate notes in clusters
+    aggregated_notes = [(0, 0)]
+    for note_on in onsets_raw:
+        prev_note_on = aggregated_notes[-1][0]
+        prev_note_salience = aggregated_notes[-1][1]
+        if abs(note_on - prev_note_on) < CHORD_SPREAD_TIME:
+            aggregated_notes[-1] = (note_on, prev_note_salience + 1)
+        else:
+            aggregated_notes.append((note_on, 1))
+
+    onsets, saliences = list(zip(*aggregated_notes))
+
+    ma = MultipleAgents()
+    ma.run(onsets, saliences)
+
+    return dict(tempo=ma.getTempo(), meter_numerator=ma.getNum(), beats=ma.getBeats())
```

### Comparing `partitura-1.2.1/partitura/musicanalysis/note_features.py` & `partitura-1.2.2/partitura/musicanalysis/note_features.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,1051 +1,1051 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods to compute note-level features.
-"""
-import sys
-import warnings
-import numpy as np
-from scipy.interpolate import interp1d
-import partitura.score as score
-
-import types
-from typing import List, Union, Tuple
-from partitura.utils import ensure_notearray, ensure_rest_array
-
-__all__ = [
-    "list_note_feats_functions",
-    "make_note_features",
-    "make_note_feats",
-    "full_note_array",
-    "compute_note_array",
-    "full_note_array",
-    "make_rest_feats",
-    "make_rest_features",
-]
-
-
-class InvalidNoteFeatureException(Exception):
-    pass
-
-
-def print_note_feats_functions():
-    """Print a list of all featurefunction names defined in this module,
-    with descriptions where available.
-
-    """
-    module = sys.modules[__name__]
-    doc_indent = 4
-    for name in list_note_feats_functions():
-        print("* {}".format(name))
-        member = getattr(sys.modules[__name__], name)
-        if member.__doc__:
-            print(
-                " " * doc_indent + member.__doc__.replace("\n", " " * doc_indent + "\n")
-            )
-
-
-def list_note_feats_functions():
-    """Return a list of all feature function names defined in this module.
-
-    The feature function names listed here can be specified by name in
-    the `make_feature` function. For example:
-
-    >>> feature, names = make_note_feats(part, ['metrical_feature', 'articulation_feature'])
-
-    Returns
-    -------
-    list
-        A list of strings
-
-    """
-    module = sys.modules[__name__]
-    bfs = []
-    exclude = {"make_feature"}
-    for name in dir(module):
-        if name in exclude:
-            continue
-        member = getattr(sys.modules[__name__], name)
-        if isinstance(member, types.FunctionType) and name.endswith("_feature"):
-            bfs.append(name)
-    return bfs
-
-
-def make_note_features(
-    part: Union[score.Part, score.PartGroup, List],
-    feature_functions: Union[List, str],
-    add_idx: bool = False,
-) -> Tuple[np.ndarray, List]:
-
-    """Compute the specified feature functions for a part.
-
-    The function returns the computed feature functions as a N x M
-    array, where N equals `len(part.notes_tied)` and M equals the
-    total number of descriptors of all feature functions that occur in
-    part.
-
-    Furthermore the function returns the names of the feature functions.
-    A list of strings of size M. The names have the name of the
-    function prepended to the name of the descriptor. For example if a
-    function named `abc_feature` returns descriptors `a`, `b`, and `c`,
-    then the list of names returned by `make_feature(part,
-    ['abc_feature'])` will be ['abc_feature.a', 'abc_feature.b',
-    'abc_feature.c'].
-
-    Parameters
-    ----------
-    part : Part
-        The score as a Part instance
-    feature_functions : list or str
-        A list of feature functions. Elements of the list can be either
-        the functions themselves or the names of a feature function as
-        strings (or a mix), or the keywork "all". The feature functions specified by name are
-        looked up in the `featuremixer.featurefunctions` module.
-
-    Returns
-    -------
-    feature : ndarray
-        The feature functions
-    names : list
-        The feature names
-    """
-    if isinstance(part, score.Score):
-        part = score.merge_parts(part.parts)
-    else:
-        part = score.merge_parts(part)
-    na = ensure_notearray(
-        part,
-        include_metrical_position=True,
-        include_grace_notes=True,
-        include_time_signature=True,
-    )
-    acc = []
-    if isinstance(feature_functions, str) and feature_functions == "all":
-        feature_functions = list_note_feats_functions()
-    elif not isinstance(feature_functions, list):
-        raise TypeError(
-            "feature_functions variable {} needs to be list or all".format(
-                feature_functions
-            )
-        )
-
-    for bf in feature_functions:
-        if isinstance(bf, str):
-            # get function by name from module
-            func = getattr(sys.modules[__name__], bf)
-        elif isinstance(bf, types.FunctionType):
-            func = bf
-        else:
-            warnings.warn("Ignoring unknown feature function {}".format(bf))
-        bf, bn = func(na, part)
-        # check if the size and number of the feature function are correct
-        if bf.size != 0:
-            if bf.shape[1] != len(bn):
-                msg = (
-                    "number of feature names {} does not equal "
-                    "number of feature {}".format(len(bn), bf.shape[1])
-                )
-                raise InvalidNoteFeatureException(msg)
-            n_notes = len(part.notes_tied)
-            if len(bf) != n_notes:
-                msg = (
-                    "length of feature {} does not equal "
-                    "number of notes {}".format(len(bf), n_notes)
-                )
-                raise InvalidNoteFeatureException(msg)
-
-            if np.any(np.logical_or(np.isnan(bf), np.isinf(bf))):
-                problematic = np.unique(
-                    np.where(np.logical_or(np.isnan(bf), np.isinf(bf)))[1]
-                )
-                msg = "NaNs or Infs found in the following feature: {} ".format(
-                    ", ".join(np.array(bn)[problematic])
-                )
-                raise InvalidNoteFeatureException(msg)
-
-            # prefix feature names by function name
-            bn = ["{}.{}".format(func.__name__, n) for n in bn]
-
-            acc.append((bf, bn))
-
-    if add_idx:
-        _data, _names = zip(*acc)
-        feature_data = np.column_stack(_data)
-        feature_data_list = [list(f) + [i] for f, i in zip(feature_data, na["id"])]
-        feature_names = [n for ns in _names for n in ns] + ["id"]
-        feature_names_dtypes = list(
-            zip(feature_names, ["f4"] * (len(feature_names) - 1) + ["U256"])
-        )
-        feature_data_struct = np.array(
-            [tuple(f) for f in feature_data_list], dtype=feature_names_dtypes
-        )
-        return feature_data_struct
-    else:
-        _data, _names = zip(*acc)
-        feature_data = np.column_stack(_data)
-        feature_names = [n for ns in _names for n in ns]
-        return feature_data, feature_names
-
-
-def make_rest_features(
-    part: Union[score.Part, score.PartGroup, List],
-    feature_functions: Union[List, str],
-    add_idx: bool = False,
-) -> Tuple[np.ndarray, List]:
-    """Compute the specified feature functions for a part.
-
-    The function returns the computed feature functions as a N x M
-    array, where N equals `len(part.rests)` and M equals the
-    total number of descriptors of all feature functions that occur in
-    part.
-
-    Parameters
-    ----------
-    part : Part
-        The score as a Part instance
-    feature_functions : list or str
-        A list of feature functions. Elements of the list can be either
-        the functions themselves or the names of a feature function as
-        strings (or a mix), or the keywork "all". The feature functions specified by name are
-        looked up in the `featuremixer.featurefunctions` module.
-
-    Returns
-    -------
-    feature : ndarray
-        The feature functions
-    names : list
-        The feature names
-    """
-    if isinstance(part, score.Score):
-        part = score.merge_parts(part.parts)
-    else:
-        part = score.merge_parts(part)
-    na = ensure_rest_array(
-        part,
-        include_metrical_position=True,
-        include_grace_notes=True,
-        include_time_signature=True,
-    )
-    if na.size == 0:
-        return np.array([])
-
-    acc = []
-    if isinstance(feature_functions, str) and feature_functions == "all":
-        feature_functions = list_note_feats_functions()
-    elif not isinstance(feature_functions, list):
-        raise TypeError(
-            "feature_functions variable {} needs to be list or all".format(
-                feature_functions
-            )
-        )
-
-    for bf in feature_functions:
-        if isinstance(bf, str):
-            # get function by name from module
-            func = getattr(sys.modules[__name__], bf)
-        elif isinstance(bf, types.FunctionType):
-            func = bf
-        else:
-            warnings.warn("Ignoring unknown feature function {}".format(bf))
-        bf, bn = func(na, part)
-        # check if the size and number of the feature function are correct
-        if bf.size != 0:
-            if bf.shape[1] != len(bn):
-                msg = (
-                    "number of feature names {} does not equal "
-                    "number of feature {}".format(len(bn), bf.shape[1])
-                )
-                raise InvalidNoteFeatureException(msg)
-            n_notes = len(part.rests)
-            if len(bf) != n_notes:
-                msg = (
-                    "length of feature {} does not equal "
-                    "number of notes {}".format(len(bf), n_notes)
-                )
-                raise InvalidNoteFeatureException(msg)
-
-            if np.any(np.logical_or(np.isnan(bf), np.isinf(bf))):
-                problematic = np.unique(
-                    np.where(np.logical_or(np.isnan(bf), np.isinf(bf)))[1]
-                )
-                msg = "NaNs or Infs found in the following feature: {} ".format(
-                    ", ".join(np.array(bn)[problematic])
-                )
-                raise InvalidNoteFeatureException(msg)
-
-            # prefix feature names by function name
-            bn = ["{}.{}".format(func.__name__, n) for n in bn]
-
-            acc.append((bf, bn))
-
-    if add_idx:
-        _data, _names = zip(*acc)
-        feature_data = np.column_stack(_data)
-        feature_data_list = [list(f) + [i] for f, i in zip(feature_data, na["id"])]
-        feature_names = [n for ns in _names for n in ns] + ["id"]
-        feature_names_dtypes = list(
-            zip(feature_names, ["f4"] * (len(feature_names) - 1) + ["U256"])
-        )
-        feature_data_struct = np.array(
-            [tuple(f) for f in feature_data_list], dtype=feature_names_dtypes
-        )
-        return feature_data_struct
-    else:
-        _data, _names = zip(*acc)
-        feature_data = np.column_stack(_data)
-        feature_names = [n for ns in _names for n in ns]
-        return feature_data, feature_names
-
-
-# alias
-make_note_feats = make_note_features
-make_rest_feats = make_rest_features
-
-
-def compute_note_array(
-    part,
-    include_pitch_spelling=False,
-    include_key_signature=False,
-    include_time_signature=False,
-    include_metrical_position=False,
-    include_grace_notes=False,
-    feature_functions=None,
-):
-    """
-    Create an extended note array from this part.
-
-    1) Without arguments this returns a structured array of onsets, offsets,
-    pitch, and ID information: equivalent to part.note_array()
-
-    2) With any of the flag arguments set to true, a column with the specified
-    information will be added to the array: equivalent t0 part.note_array(*flags)
-
-    3) With a list of strings or functions as feature_functions argument,
-    a column (or multiple columns) with the specified information will
-    be added to the array.
-    See also:
-    >>> make_note_features(part)
-    For a list of features see:
-    >>> list_note_feats_functions()
-
-    Parameters
-    ----------
-
-    include_pitch_spelling : bool (optional)
-        If `True`, includes pitch spelling information for each
-        note. Default is False
-    include_key_signature : bool (optional)
-        If `True`, includes key signature information, i.e.,
-        the key signature at the onset time of each note (all
-        notes starting at the same time have the same key signature).
-        Default is False
-    include_time_signature : bool (optional)
-        If `True`,  includes time signature information, i.e.,
-        the time signature at the onset time of each note (all
-        notes starting at the same time have the same time signature).
-        Default is False
-    include_metrical_position : bool (optional)
-        If `True`,  includes metrical position information, i.e.,
-        the position of the onset time of each note with respect to its
-        measure (all notes starting at the same time have the same metrical
-        position).
-        Default is False
-    include_grace_notes : bool (optional)
-        If `True`,  includes grace note information, i.e. if a note is a
-        grace note and the grace type "" for non grace notes).
-        Default is False
-    feature_functions : list or str
-        A list of feature functions. Elements of the list can be either
-        the functions themselves or the names of a feature function as
-        strings (or a mix). The feature functions specified by name are
-        looked up in the `featuremixer.featurefunctions` module.
-
-    Returns:
-
-    note_array : structured array
-    """
-    if isinstance(part, score.Score):
-        part = score.merge_parts(part.parts)
-    else:
-        part = score.merge_parts(part)
-    na = ensure_notearray(
-        part,
-        include_pitch_spelling=include_pitch_spelling,
-        include_key_signature=include_key_signature,
-        include_time_signature=include_time_signature,
-        include_metrical_position=include_metrical_position,
-        include_grace_notes=include_grace_notes,
-    )
-
-    if feature_functions is not None:
-        feature_data_struct = make_note_feats(part, feature_functions, add_idx=True)
-        note_array_joined = np.lib.recfunctions.join_by("id", na, feature_data_struct)
-        note_array = note_array_joined.data
-    else:
-        note_array = na
-    return note_array
-
-
-def full_note_array(part):
-    """
-    Create a note array with all available information.
-    """
-    return compute_note_array(
-        part,
-        include_pitch_spelling=True,
-        include_key_signature=True,
-        include_time_signature=True,
-        include_metrical_position=True,
-        include_grace_notes=True,
-        feature_functions="all",
-    )
-
-
-def polynomial_pitch_feature(na, part):
-    """Normalize pitch feature."""
-    pitches = na["pitch"].astype(float)
-    feature_names = ["pitch"]
-    max_pitch = 127
-    W = pitches / max_pitch
-    return np.expand_dims(W, axis=1), feature_names
-
-
-def duration_feature(na, part):
-    """Duration feature.
-
-    Parameters
-    ----------
-    na : structured array
-        The Note array for Unified part.
-    """
-
-    feature_names = ["duration"]
-    durations_beat = na["duration_beat"]
-    W = durations_beat
-    W.shape = (-1, 1)
-    return W, feature_names
-
-
-def onset_feature(na, part):
-    """Onset feature
-
-    Returns:
-    * onset : the onset of the note in beats
-    * score_position : position of the note in the score between 0 (the beginning of the piece) and 1 (the end of the piece)
-
-    TODO:
-    * rel_position_repetition
-    """
-    feature_names = ["onset", "score_position"]
-
-    onsets_beat = na["onset_beat"]
-    rel_position = normalize(onsets_beat, method="minmax")
-
-    W = np.column_stack((onsets_beat, rel_position))
-
-    return W, feature_names
-
-
-def relative_score_position_feature(na, part):
-    W, names = onset_feature(na, part)
-    return W[:, 1:], names[1:]
-
-
-def grace_feature(na, part):
-    """Grace feature.
-
-    Returns:
-    * grace_note : 1 when the note is a grace note, 0 otherwise
-    * n_grace : the length of the grace note sequence to which
-                this note belongs (0 for non-grace notes)
-    * grace_pos : the (1-based) position of the grace note in
-                  the sequence (0 for non-grace notes)
-
-    """
-
-    feature_names = ["grace_note", "n_grace", "grace_pos"]
-
-    W = np.zeros((len(na), 3))
-    W[:, 0] = na["is_grace"]
-    grace_notes = na[np.nonzero(na["is_grace"])]
-    notes = (
-        {n.id: n for n in part.notes_tied}
-        if not np.all(na["pitch"] == 0)
-        else {n.id: n for n in part.rests}
-    )
-    indices = np.nonzero(na["is_grace"])[0]
-    for i, index in enumerate(indices):
-        grace = grace_notes[i]
-        n_grace = np.count_nonzero(grace_notes["onset_beat"] == grace["onset_beat"])
-        W[index, 1] = n_grace
-        W[index, 2] = n_grace - sum(1 for _ in notes[grace["id"]].iter_grace_seq()) + 1
-    return W, feature_names
-
-
-def loudness_direction_feature(na, part):
-    """The loudness directions in part.
-
-    This function returns a varying number of descriptors, depending
-    on which directions are present. Some directions are grouped
-    together. For example 'decrescendo' and 'diminuendo' are encoded
-    together in a descriptor 'loudness_decr'. The descriptor names of
-    textual directions such as 'adagio' are the verbatim directions.
-
-    Some possible descriptors:
-    * p : piano
-    * f : forte
-    * pp : pianissimo
-    * loudness_incr : crescendo direction
-    * loudness_decr : decrescendo or diminuendo direction
-
-    """
-
-    onsets = na["onset_div"]
-    N = len(onsets)
-
-    directions = list(part.iter_all(score.LoudnessDirection, include_subclasses=True))
-
-    def to_name(d):
-        if isinstance(d, score.ConstantLoudnessDirection):
-            return d.text
-        elif isinstance(d, score.ImpulsiveLoudnessDirection):
-            return d.text
-        elif isinstance(d, score.IncreasingLoudnessDirection):
-            return "loudness_incr"
-        elif isinstance(d, score.DecreasingLoudnessDirection):
-            return "loudness_decr"
-
-    feature_by_name = {}
-    for d in directions:
-        j, bf = feature_by_name.setdefault(
-            to_name(d), (len(feature_by_name), np.zeros(N))
-        )
-        bf += feature_function_activation(d)(onsets)
-
-    W = np.empty((len(onsets), len(feature_by_name)))
-    names = [None] * len(feature_by_name)
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def tempo_direction_feature(na, part):
-    """The tempo directions in part.
-
-    This function returns a varying number of descriptors, depending
-    on which directions are present. Some directions are grouped
-    together. For example 'adagio' and 'molto adagio' are encoded
-    together in a descriptor 'adagio'.
-
-    Some possible descriptors:
-    * adagio : directions like 'adagio', 'molto adagio'
-
-    """
-    onsets = na["onset_div"]
-    N = len(onsets)
-
-    directions = list(part.iter_all(score.TempoDirection, include_subclasses=True))
-
-    def to_name(d):
-        if isinstance(d, score.ResetTempoDirection):
-            ref = d.reference_tempo
-            if ref:
-                return ref.text
-            else:
-                return d.text
-        elif isinstance(d, score.ConstantTempoDirection):
-            return d.text
-        elif isinstance(d, score.IncreasingTempoDirection):
-            return "tempo_incr"
-        elif isinstance(d, score.DecreasingTempoDirection):
-            return "tempo_decr"
-
-    feature_by_name = {}
-    for d in directions:
-        j, bf = feature_by_name.setdefault(
-            to_name(d), (len(feature_by_name), np.zeros(N))
-        )
-        bf += feature_function_activation(d)(onsets)
-
-    W = np.empty((len(onsets), len(feature_by_name)))
-    names = [None] * len(feature_by_name)
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def articulation_direction_feature(na, part):
-    """ """
-    onsets = na["onset_div"]
-    N = len(onsets)
-
-    directions = list(
-        part.iter_all(score.ArticulationDirection, include_subclasses=True)
-    )
-
-    def to_name(d):
-        return d.text
-
-    feature_by_name = {}
-
-    for d in directions:
-        j, bf = feature_by_name.setdefault(
-            to_name(d), (len(feature_by_name), np.zeros(N))
-        )
-        bf += feature_function_activation(d)(onsets)
-
-    W = np.empty((len(onsets), len(feature_by_name)))
-    names = [None] * len(feature_by_name)
-
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def feature_function_activation(direction):
-    epsilon = 1e-6
-
-    if isinstance(
-        direction, (score.DynamicLoudnessDirection, score.DynamicTempoDirection)
-    ):
-        # a dynamic direction will be encoded as a ramp from d.start.t to
-        # d.end.t, and then a step from d.end.t to the start of the next
-        # constant direction.
-
-        # There are two potential issues:
-
-        # Issue 1. d.end is None (e.g. just a ritardando without dashes). In this case
-        if direction.end:
-            direction_end = direction.end.t
-        else:
-            # assume the end of d is the end of the measure:
-            measure = next(direction.start.iter_prev(score.Measure, eq=True), None)
-            if measure:
-                direction_end = measure.start.t
-            else:
-                # no measure, unlikely, but not impossible.
-                direction_end = direction.start.t
-
-        if isinstance(direction, score.TempoDirection):
-            next_dir = next(
-                direction.start.iter_next(score.ConstantTempoDirection), None
-            )
-        if isinstance(direction, score.ArticulationDirection):
-            next_dir = next(
-                direction.start.iter_next(score.ConstantArticulationDirection), None
-            )
-        else:
-            next_dir = next(
-                direction.start.iter_next(score.ConstantLoudnessDirection), None
-            )
-
-        if next_dir:
-            # TODO: what do we do when next_dir is too far away?
-            sustained_end = next_dir.start.t
-        else:
-            # Issue 2. there is no next constant direction. In that case the
-            # feature function will be a ramp with a quarter note ramp
-            sustained_end = direction_end + direction.start.quarter
-
-        x = [direction.start.t, direction_end - epsilon, sustained_end - epsilon]
-        y = [0, 1, 1]
-
-    elif isinstance(
-        direction,
-        (
-            score.ConstantLoudnessDirection,
-            score.ConstantArticulationDirection,
-            score.ConstantTempoDirection,
-        ),
-    ):
-        x = [
-            direction.start.t - epsilon,
-            direction.start.t,
-            direction.end.t - epsilon,
-            direction.end.t,
-        ]
-        y = [0, 1, 1, 0]
-
-    else:  # impulsive
-        x = [
-            direction.start.t - epsilon,
-            direction.start.t,
-            direction.start.t + epsilon,
-        ]
-        y = [0, 1, 0]
-
-    return interp1d(x, y, bounds_error=False, fill_value=0)
-
-
-def slur_feature(na, part):
-    """Slur feature.
-
-    Returns:
-    * slur_incr : a ramp function that increases from 0
-                  to 1 over the course of the slur
-    * slur_decr : a ramp function that decreases from 1
-                  to 0 over the course of the slur
-
-    """
-    names = ["slur_incr", "slur_decr"]
-    onsets = na["onset_div"]
-    slurs = part.iter_all(score.Slur)
-    W = np.zeros((len(onsets), 2))
-
-    for slur in slurs:
-        if not slur.end:
-            continue
-        x = [slur.start.t, slur.end.t]
-        y_inc = [0, 1]
-        y_dec = [1, 0]
-        W[:, 0] += interp1d(x, y_inc, bounds_error=False, fill_value=0)(onsets)
-        W[:, 1] += interp1d(x, y_dec, bounds_error=False, fill_value=0)(onsets)
-    # Filter out NaN values
-    W[np.isnan(W)] = 0.0
-    return W, names
-
-
-def articulation_feature(na, part):
-    """Articulation feature.
-
-    This feature returns articulation-related note annotations, such as accents, legato, and tenuto.
-
-    Possible descriptors:
-    * accent : 1 when the note has an annotated accent sign
-    * legato : 1 when the note has an annotated legato sign
-    * staccato : 1 when the note has an annotated staccato sign
-    ...
-
-    """
-    names = [
-        "accent",
-        "strong-accent",
-        "staccato",
-        "tenuto",
-        "detached-legato",
-        "staccatissimo",
-        "spiccato",
-        "scoop",
-        "plop",
-        "doit",
-        "falloff",
-        "breath-mark",
-        "caesura",
-        "stress",
-        "unstress",
-        "soft-accent",
-    ]
-    feature_by_name = {}
-    notes = part.notes_tied if not np.all(na["pitch"] == 0) else part.rests
-    N = len(notes)
-    for i, n in enumerate(notes):
-        if n.articulations:
-            for art in n.articulations:
-                if art in names:
-                    j, bf = feature_by_name.setdefault(
-                        art, (len(feature_by_name), np.zeros(N))
-                    )
-                    bf[i] = 1
-
-    M = len(feature_by_name)
-    W = np.empty((N, M))
-    names = [None] * M
-
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def ornament_feature(na, part):
-    """Ornament feature.
-
-    This feature returns ornamentation note annotations,such as trills.
-
-    Possible descriptors:
-    * trill : 1 when the note has an annotated trill
-    * mordent : 1 when the note has an annotated mordent
-    ...
-
-    """
-    names = [
-        "trill-mark",
-        "turn",
-        "delayed-turn",
-        "inverted-turn",
-        "delayed-inverted-turn",
-        "vertical-turn",
-        "inverted-vertical-turn",
-        "shake",
-        "wavy-line",
-        "mordent",
-        "inverted-mordent",
-        "schleifer",
-        "tremolo",
-        "haydn",
-        "other-ornament",
-    ]
-    feature_by_name = {}
-    notes = part.notes_tied
-    N = len(notes)
-    for i, n in enumerate(notes):
-        if n.ornaments:
-            for art in n.ornaments:
-                if art in names:
-                    j, bf = feature_by_name.setdefault(
-                        art, (len(feature_by_name), np.zeros(N))
-                    )
-                    bf[i] = 1
-
-    M = len(feature_by_name)
-    W = np.empty((N, M))
-    names = [None] * M
-
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def staff_feature(na, part):
-    """Staff feature"""
-    names = ["staff"]
-    notes = {n.id: n.staff for n in part.notes_tied}
-    N = len(notes)
-    W = np.empty((N, 1))
-    for i, n in enumerate(na):
-        W[i, 0] = notes[n["id"]]
-
-    return W, names
-
-
-# # for a subset of the articulations do e.g.
-# def staccato_feature(part):
-#     W, names = articulation_feature(part)
-#     if 'staccato' in names:
-#         i = names.index('staccato')
-#         return W[:, i:i + 1], ['staccato']
-#     else:
-#         return np.empty(len(W)), []
-
-
-def fermata_feature(na, part):
-    """Fermata feature.
-
-    Returns:
-    * fermata : 1 when the note coincides with a fermata sign.
-
-    """
-    names = ["fermata"]
-    onsets = na["onset_div"]
-    W = np.zeros((len(onsets), 1))
-    for ferm in part.iter_all(score.Fermata):
-        W[onsets == ferm.start.t, 0] = 1
-    return W, names
-
-
-def metrical_feature(na, part):
-    """Metrical feature
-
-    This feature encodes the metrical position in the bar. For example
-    the first beat in a 3/4 meter is encoded in a binary descriptor
-    'metrical_3_4_0', the fifth beat in a 6/8 meter as
-    'metrical_6_8_4', etc. Any positions that do not fall on a beat
-    are encoded in a feature suffixed '_weak'. For example a note
-    starting on the second 8th note in a bar of 4/4 meter will have a
-    non-zero value in the 'metrical_4_4_weak' descriptor.
-
-    """
-    notes = part.notes_tied if not np.all(na["pitch"] == 0) else part.rests
-    ts_map = part.time_signature_map
-    bm = part.beat_map
-    feature_by_name = {}
-    eps = 10**-6
-
-    for i, n in enumerate(notes):
-
-        beats, beat_type, mus_beats = ts_map(n.start.t).astype(int)
-        measure = next(n.start.iter_prev(score.Measure, eq=True), None)
-
-        if measure:
-            measure_start = measure.start.t
-        else:
-            measure_start = 0
-
-        pos = bm(n.start.t) - bm(measure_start)
-
-        if pos % 1 < eps:
-            name = "metrical_{}_{}_{}".format(beats, beat_type, int(pos))
-        else:
-            name = "metrical_{}_{}_weak".format(beats, beat_type)
-
-        j, bf = feature_by_name.setdefault(
-            name, (len(feature_by_name), np.zeros(len(notes)))
-        )
-        bf[i] = 1
-
-    W = np.empty((len(notes), len(feature_by_name)))
-    names = [None] * len(feature_by_name)
-    for name, (j, bf) in feature_by_name.items():
-        W[:, j] = bf
-        names[j] = name
-
-    return W, names
-
-
-def metrical_strength_feature(na, part):
-    """Metrical strength feature
-
-    This feature encodes the beat phase (relative position of a note within
-    the measure), as well as metrical strength of common time signatures.
-    """
-    names = [
-        "beat_phase",
-        "metrical_strength_downbeat",
-        "metrical_strength_secondary",
-        "metrical_strength_weak",
-    ]
-
-    relod = na["rel_onset_div"].astype(float)
-    totmd = na["tot_measure_div"].astype(float)
-    W = np.zeros((len(na), len(names)))
-    W[:, 0] = np.divide(relod, totmd)  # Onset Phase
-    W[:, 1] = na["is_downbeat"].astype(float)
-    W[:, 2][W[:, 0] == 0.5] = 1.00
-    W[:, 3][np.nonzero(np.add(W[:, 1], W[:, 0]) == 1.00)]
-    return W, names
-
-
-def time_signature_feature(na, part):
-    """TIme Signature feature
-    This feature encodes the time signature of the note in two sets of one-hot vectors,
-    a one hot encoding of number of beats and a one hot encoding of beat type
-    """
-
-    ts_map = part.time_signature_map
-    possible_beats = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, "other"]
-    possible_beat_types = [1, 2, 4, 8, 16, "other"]
-    W_beats = np.zeros((len(na), len(possible_beats)))
-    W_types = np.zeros((len(na), len(possible_beat_types)))
-
-    names = ["time_signature_num_{0}".format(b) for b in possible_beats] + [
-        "time_signature_den_{0}".format(b) for b in possible_beat_types
-    ]
-
-    for i, n in enumerate(na):
-        beats, beat_type, mus_beats = ts_map(n["onset_div"]).astype(int)
-
-        if beats in possible_beats:
-            W_beats[i, beats - 1] = 1
-        else:
-            W_beats[i, -1] = 1
-
-        if beat_type in possible_beat_types:
-            W_types[i, possible_beat_types.index(beat_type)] = 1
-        else:
-            W_types[i, -1] = 1
-
-    W = np.column_stack((W_beats, W_types))
-
-    return W, names
-
-
-def vertical_neighbor_feature(na, part):
-    """Vertical neighbor feature.
-
-    Describes various aspects of simultaneously starting notes.
-
-    Returns:
-    * n_total :
-    * n_above :
-    * n_below :
-    * highest_pitch :
-    * lowest_pitch :
-    * pitch_range :
-
-    """
-    # the list of descriptors
-    names = [
-        "n_total",
-        "n_above",
-        "n_below",
-        "highest_pitch",
-        "lowest_pitch",
-        "pitch_range",
-    ]
-    W = np.empty((len(na), len(names)))
-    for i, n in enumerate(na):
-        neighbors = na[np.where(na["onset_beat"] == n["onset_beat"])]["pitch"]
-        max_pitch = np.max(neighbors)
-        min_pitch = np.min(neighbors)
-        W[i, 0] = len(neighbors) - 1
-        W[i, 1] = np.sum(neighbors > n["pitch"])
-        W[i, 2] = np.sum(neighbors < n["pitch"])
-        W[i, 3] = max_pitch
-        W[i, 4] = min_pitch
-        W[i, 5] = max_pitch - min_pitch
-    return W, names
-
-
-def normalize(data, method="minmax"):
-    """
-    Normalize data in one of several ways.
-
-    The available normalization methods are:
-
-    * minmax
-      Rescale `data` to the range `[0, 1]` by subtracting the minimum
-      and dividing by the range. If `data` is a 2d array, each column is
-      rescaled to `[0, 1]`.
-
-    * tanh
-      Rescale `data` to the interval `(-1, 1)` using `tanh`. Note that
-      if `data` is non-negative, the output interval will be `[0, 1)`.
-
-    * tanh_unity
-      Like "soft", but rather than rescaling strictly to the range (-1,
-      1), following will hold:
-
-      normalized = normalize(data, method="tanh_unity")
-      np.where(data==1) == np.where(normalized==1)
-
-      That is, the normalized data will equal one wherever the original data
-      equals one. The target interval is `(-1/np.tanh(1), 1/np.tanh(1))`.
-
-    Parameters
-    ----------
-    data: ndarray
-        Data to be normalized
-    method: {'minmax', 'tanh', 'tanh_unity'}, optional
-        The normalization method. Defaults to 'minmax'.
-
-    Returns
-    -------
-    ndarray
-        Normalized copy of the data
-    """
-
-    """Normalize the data in `data`. There are several normalization
-
-    """
-    if method == "minmax":
-        vmin = np.min(data, 0)
-        vmax = np.max(data, 0)
-
-        if np.isclose(vmin, vmax):
-            # Return all values as 0 or as 1?
-            return np.zeros_like(data)
-        else:
-            return (data - vmin) / (vmax - vmin)
-    elif method == "tanh":
-        return np.tanh(data)
-    elif method == "tanh_unity":
-        return np.tanh(data) / np.tanh(1)
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods to compute note-level features.
+"""
+import sys
+import warnings
+import numpy as np
+from scipy.interpolate import interp1d
+import partitura.score as score
+
+import types
+from typing import List, Union, Tuple
+from partitura.utils import ensure_notearray, ensure_rest_array
+
+__all__ = [
+    "list_note_feats_functions",
+    "make_note_features",
+    "make_note_feats",
+    "full_note_array",
+    "compute_note_array",
+    "full_note_array",
+    "make_rest_feats",
+    "make_rest_features",
+]
+
+
+class InvalidNoteFeatureException(Exception):
+    pass
+
+
+def print_note_feats_functions():
+    """Print a list of all featurefunction names defined in this module,
+    with descriptions where available.
+
+    """
+    module = sys.modules[__name__]
+    doc_indent = 4
+    for name in list_note_feats_functions():
+        print("* {}".format(name))
+        member = getattr(sys.modules[__name__], name)
+        if member.__doc__:
+            print(
+                " " * doc_indent + member.__doc__.replace("\n", " " * doc_indent + "\n")
+            )
+
+
+def list_note_feats_functions():
+    """Return a list of all feature function names defined in this module.
+
+    The feature function names listed here can be specified by name in
+    the `make_feature` function. For example:
+
+    >>> feature, names = make_note_feats(part, ['metrical_feature', 'articulation_feature'])
+
+    Returns
+    -------
+    list
+        A list of strings
+
+    """
+    module = sys.modules[__name__]
+    bfs = []
+    exclude = {"make_feature"}
+    for name in dir(module):
+        if name in exclude:
+            continue
+        member = getattr(sys.modules[__name__], name)
+        if isinstance(member, types.FunctionType) and name.endswith("_feature"):
+            bfs.append(name)
+    return bfs
+
+
+def make_note_features(
+    part: Union[score.Part, score.PartGroup, List],
+    feature_functions: Union[List, str],
+    add_idx: bool = False,
+) -> Tuple[np.ndarray, List]:
+
+    """Compute the specified feature functions for a part.
+
+    The function returns the computed feature functions as a N x M
+    array, where N equals `len(part.notes_tied)` and M equals the
+    total number of descriptors of all feature functions that occur in
+    part.
+
+    Furthermore the function returns the names of the feature functions.
+    A list of strings of size M. The names have the name of the
+    function prepended to the name of the descriptor. For example if a
+    function named `abc_feature` returns descriptors `a`, `b`, and `c`,
+    then the list of names returned by `make_feature(part,
+    ['abc_feature'])` will be ['abc_feature.a', 'abc_feature.b',
+    'abc_feature.c'].
+
+    Parameters
+    ----------
+    part : Part
+        The score as a Part instance
+    feature_functions : list or str
+        A list of feature functions. Elements of the list can be either
+        the functions themselves or the names of a feature function as
+        strings (or a mix), or the keywork "all". The feature functions specified by name are
+        looked up in the `featuremixer.featurefunctions` module.
+
+    Returns
+    -------
+    feature : ndarray
+        The feature functions
+    names : list
+        The feature names
+    """
+    if isinstance(part, score.Score):
+        part = score.merge_parts(part.parts)
+    else:
+        part = score.merge_parts(part)
+    na = ensure_notearray(
+        part,
+        include_metrical_position=True,
+        include_grace_notes=True,
+        include_time_signature=True,
+    )
+    acc = []
+    if isinstance(feature_functions, str) and feature_functions == "all":
+        feature_functions = list_note_feats_functions()
+    elif not isinstance(feature_functions, list):
+        raise TypeError(
+            "feature_functions variable {} needs to be list or all".format(
+                feature_functions
+            )
+        )
+
+    for bf in feature_functions:
+        if isinstance(bf, str):
+            # get function by name from module
+            func = getattr(sys.modules[__name__], bf)
+        elif isinstance(bf, types.FunctionType):
+            func = bf
+        else:
+            warnings.warn("Ignoring unknown feature function {}".format(bf))
+        bf, bn = func(na, part)
+        # check if the size and number of the feature function are correct
+        if bf.size != 0:
+            if bf.shape[1] != len(bn):
+                msg = (
+                    "number of feature names {} does not equal "
+                    "number of feature {}".format(len(bn), bf.shape[1])
+                )
+                raise InvalidNoteFeatureException(msg)
+            n_notes = len(part.notes_tied)
+            if len(bf) != n_notes:
+                msg = (
+                    "length of feature {} does not equal "
+                    "number of notes {}".format(len(bf), n_notes)
+                )
+                raise InvalidNoteFeatureException(msg)
+
+            if np.any(np.logical_or(np.isnan(bf), np.isinf(bf))):
+                problematic = np.unique(
+                    np.where(np.logical_or(np.isnan(bf), np.isinf(bf)))[1]
+                )
+                msg = "NaNs or Infs found in the following feature: {} ".format(
+                    ", ".join(np.array(bn)[problematic])
+                )
+                raise InvalidNoteFeatureException(msg)
+
+            # prefix feature names by function name
+            bn = ["{}.{}".format(func.__name__, n) for n in bn]
+
+            acc.append((bf, bn))
+
+    if add_idx:
+        _data, _names = zip(*acc)
+        feature_data = np.column_stack(_data)
+        feature_data_list = [list(f) + [i] for f, i in zip(feature_data, na["id"])]
+        feature_names = [n for ns in _names for n in ns] + ["id"]
+        feature_names_dtypes = list(
+            zip(feature_names, ["f4"] * (len(feature_names) - 1) + ["U256"])
+        )
+        feature_data_struct = np.array(
+            [tuple(f) for f in feature_data_list], dtype=feature_names_dtypes
+        )
+        return feature_data_struct
+    else:
+        _data, _names = zip(*acc)
+        feature_data = np.column_stack(_data)
+        feature_names = [n for ns in _names for n in ns]
+        return feature_data, feature_names
+
+
+def make_rest_features(
+    part: Union[score.Part, score.PartGroup, List],
+    feature_functions: Union[List, str],
+    add_idx: bool = False,
+) -> Tuple[np.ndarray, List]:
+    """Compute the specified feature functions for a part.
+
+    The function returns the computed feature functions as a N x M
+    array, where N equals `len(part.rests)` and M equals the
+    total number of descriptors of all feature functions that occur in
+    part.
+
+    Parameters
+    ----------
+    part : Part
+        The score as a Part instance
+    feature_functions : list or str
+        A list of feature functions. Elements of the list can be either
+        the functions themselves or the names of a feature function as
+        strings (or a mix), or the keywork "all". The feature functions specified by name are
+        looked up in the `featuremixer.featurefunctions` module.
+
+    Returns
+    -------
+    feature : ndarray
+        The feature functions
+    names : list
+        The feature names
+    """
+    if isinstance(part, score.Score):
+        part = score.merge_parts(part.parts)
+    else:
+        part = score.merge_parts(part)
+    na = ensure_rest_array(
+        part,
+        include_metrical_position=True,
+        include_grace_notes=True,
+        include_time_signature=True,
+    )
+    if na.size == 0:
+        return np.array([])
+
+    acc = []
+    if isinstance(feature_functions, str) and feature_functions == "all":
+        feature_functions = list_note_feats_functions()
+    elif not isinstance(feature_functions, list):
+        raise TypeError(
+            "feature_functions variable {} needs to be list or all".format(
+                feature_functions
+            )
+        )
+
+    for bf in feature_functions:
+        if isinstance(bf, str):
+            # get function by name from module
+            func = getattr(sys.modules[__name__], bf)
+        elif isinstance(bf, types.FunctionType):
+            func = bf
+        else:
+            warnings.warn("Ignoring unknown feature function {}".format(bf))
+        bf, bn = func(na, part)
+        # check if the size and number of the feature function are correct
+        if bf.size != 0:
+            if bf.shape[1] != len(bn):
+                msg = (
+                    "number of feature names {} does not equal "
+                    "number of feature {}".format(len(bn), bf.shape[1])
+                )
+                raise InvalidNoteFeatureException(msg)
+            n_notes = len(part.rests)
+            if len(bf) != n_notes:
+                msg = (
+                    "length of feature {} does not equal "
+                    "number of notes {}".format(len(bf), n_notes)
+                )
+                raise InvalidNoteFeatureException(msg)
+
+            if np.any(np.logical_or(np.isnan(bf), np.isinf(bf))):
+                problematic = np.unique(
+                    np.where(np.logical_or(np.isnan(bf), np.isinf(bf)))[1]
+                )
+                msg = "NaNs or Infs found in the following feature: {} ".format(
+                    ", ".join(np.array(bn)[problematic])
+                )
+                raise InvalidNoteFeatureException(msg)
+
+            # prefix feature names by function name
+            bn = ["{}.{}".format(func.__name__, n) for n in bn]
+
+            acc.append((bf, bn))
+
+    if add_idx:
+        _data, _names = zip(*acc)
+        feature_data = np.column_stack(_data)
+        feature_data_list = [list(f) + [i] for f, i in zip(feature_data, na["id"])]
+        feature_names = [n for ns in _names for n in ns] + ["id"]
+        feature_names_dtypes = list(
+            zip(feature_names, ["f4"] * (len(feature_names) - 1) + ["U256"])
+        )
+        feature_data_struct = np.array(
+            [tuple(f) for f in feature_data_list], dtype=feature_names_dtypes
+        )
+        return feature_data_struct
+    else:
+        _data, _names = zip(*acc)
+        feature_data = np.column_stack(_data)
+        feature_names = [n for ns in _names for n in ns]
+        return feature_data, feature_names
+
+
+# alias
+make_note_feats = make_note_features
+make_rest_feats = make_rest_features
+
+
+def compute_note_array(
+    part,
+    include_pitch_spelling=False,
+    include_key_signature=False,
+    include_time_signature=False,
+    include_metrical_position=False,
+    include_grace_notes=False,
+    feature_functions=None,
+):
+    """
+    Create an extended note array from this part.
+
+    1) Without arguments this returns a structured array of onsets, offsets,
+    pitch, and ID information: equivalent to part.note_array()
+
+    2) With any of the flag arguments set to true, a column with the specified
+    information will be added to the array: equivalent t0 part.note_array(*flags)
+
+    3) With a list of strings or functions as feature_functions argument,
+    a column (or multiple columns) with the specified information will
+    be added to the array.
+    See also:
+    >>> make_note_features(part)
+    For a list of features see:
+    >>> list_note_feats_functions()
+
+    Parameters
+    ----------
+
+    include_pitch_spelling : bool (optional)
+        If `True`, includes pitch spelling information for each
+        note. Default is False
+    include_key_signature : bool (optional)
+        If `True`, includes key signature information, i.e.,
+        the key signature at the onset time of each note (all
+        notes starting at the same time have the same key signature).
+        Default is False
+    include_time_signature : bool (optional)
+        If `True`,  includes time signature information, i.e.,
+        the time signature at the onset time of each note (all
+        notes starting at the same time have the same time signature).
+        Default is False
+    include_metrical_position : bool (optional)
+        If `True`,  includes metrical position information, i.e.,
+        the position of the onset time of each note with respect to its
+        measure (all notes starting at the same time have the same metrical
+        position).
+        Default is False
+    include_grace_notes : bool (optional)
+        If `True`,  includes grace note information, i.e. if a note is a
+        grace note and the grace type "" for non grace notes).
+        Default is False
+    feature_functions : list or str
+        A list of feature functions. Elements of the list can be either
+        the functions themselves or the names of a feature function as
+        strings (or a mix). The feature functions specified by name are
+        looked up in the `featuremixer.featurefunctions` module.
+
+    Returns:
+
+    note_array : structured array
+    """
+    if isinstance(part, score.Score):
+        part = score.merge_parts(part.parts)
+    else:
+        part = score.merge_parts(part)
+    na = ensure_notearray(
+        part,
+        include_pitch_spelling=include_pitch_spelling,
+        include_key_signature=include_key_signature,
+        include_time_signature=include_time_signature,
+        include_metrical_position=include_metrical_position,
+        include_grace_notes=include_grace_notes,
+    )
+
+    if feature_functions is not None:
+        feature_data_struct = make_note_feats(part, feature_functions, add_idx=True)
+        note_array_joined = np.lib.recfunctions.join_by("id", na, feature_data_struct)
+        note_array = note_array_joined.data
+    else:
+        note_array = na
+    return note_array
+
+
+def full_note_array(part):
+    """
+    Create a note array with all available information.
+    """
+    return compute_note_array(
+        part,
+        include_pitch_spelling=True,
+        include_key_signature=True,
+        include_time_signature=True,
+        include_metrical_position=True,
+        include_grace_notes=True,
+        feature_functions="all",
+    )
+
+
+def polynomial_pitch_feature(na, part):
+    """Normalize pitch feature."""
+    pitches = na["pitch"].astype(float)
+    feature_names = ["pitch"]
+    max_pitch = 127
+    W = pitches / max_pitch
+    return np.expand_dims(W, axis=1), feature_names
+
+
+def duration_feature(na, part):
+    """Duration feature.
+
+    Parameters
+    ----------
+    na : structured array
+        The Note array for Unified part.
+    """
+
+    feature_names = ["duration"]
+    durations_beat = na["duration_beat"]
+    W = durations_beat
+    W.shape = (-1, 1)
+    return W, feature_names
+
+
+def onset_feature(na, part):
+    """Onset feature
+
+    Returns:
+    * onset : the onset of the note in beats
+    * score_position : position of the note in the score between 0 (the beginning of the piece) and 1 (the end of the piece)
+
+    TODO:
+    * rel_position_repetition
+    """
+    feature_names = ["onset", "score_position"]
+
+    onsets_beat = na["onset_beat"]
+    rel_position = normalize(onsets_beat, method="minmax")
+
+    W = np.column_stack((onsets_beat, rel_position))
+
+    return W, feature_names
+
+
+def relative_score_position_feature(na, part):
+    W, names = onset_feature(na, part)
+    return W[:, 1:], names[1:]
+
+
+def grace_feature(na, part):
+    """Grace feature.
+
+    Returns:
+    * grace_note : 1 when the note is a grace note, 0 otherwise
+    * n_grace : the length of the grace note sequence to which
+                this note belongs (0 for non-grace notes)
+    * grace_pos : the (1-based) position of the grace note in
+                  the sequence (0 for non-grace notes)
+
+    """
+
+    feature_names = ["grace_note", "n_grace", "grace_pos"]
+
+    W = np.zeros((len(na), 3))
+    W[:, 0] = na["is_grace"]
+    grace_notes = na[np.nonzero(na["is_grace"])]
+    notes = (
+        {n.id: n for n in part.notes_tied}
+        if not np.all(na["pitch"] == 0)
+        else {n.id: n for n in part.rests}
+    )
+    indices = np.nonzero(na["is_grace"])[0]
+    for i, index in enumerate(indices):
+        grace = grace_notes[i]
+        n_grace = np.count_nonzero(grace_notes["onset_beat"] == grace["onset_beat"])
+        W[index, 1] = n_grace
+        W[index, 2] = n_grace - sum(1 for _ in notes[grace["id"]].iter_grace_seq()) + 1
+    return W, feature_names
+
+
+def loudness_direction_feature(na, part):
+    """The loudness directions in part.
+
+    This function returns a varying number of descriptors, depending
+    on which directions are present. Some directions are grouped
+    together. For example 'decrescendo' and 'diminuendo' are encoded
+    together in a descriptor 'loudness_decr'. The descriptor names of
+    textual directions such as 'adagio' are the verbatim directions.
+
+    Some possible descriptors:
+    * p : piano
+    * f : forte
+    * pp : pianissimo
+    * loudness_incr : crescendo direction
+    * loudness_decr : decrescendo or diminuendo direction
+
+    """
+
+    onsets = na["onset_div"]
+    N = len(onsets)
+
+    directions = list(part.iter_all(score.LoudnessDirection, include_subclasses=True))
+
+    def to_name(d):
+        if isinstance(d, score.ConstantLoudnessDirection):
+            return d.text
+        elif isinstance(d, score.ImpulsiveLoudnessDirection):
+            return d.text
+        elif isinstance(d, score.IncreasingLoudnessDirection):
+            return "loudness_incr"
+        elif isinstance(d, score.DecreasingLoudnessDirection):
+            return "loudness_decr"
+
+    feature_by_name = {}
+    for d in directions:
+        j, bf = feature_by_name.setdefault(
+            to_name(d), (len(feature_by_name), np.zeros(N))
+        )
+        bf += feature_function_activation(d)(onsets)
+
+    W = np.empty((len(onsets), len(feature_by_name)))
+    names = [None] * len(feature_by_name)
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def tempo_direction_feature(na, part):
+    """The tempo directions in part.
+
+    This function returns a varying number of descriptors, depending
+    on which directions are present. Some directions are grouped
+    together. For example 'adagio' and 'molto adagio' are encoded
+    together in a descriptor 'adagio'.
+
+    Some possible descriptors:
+    * adagio : directions like 'adagio', 'molto adagio'
+
+    """
+    onsets = na["onset_div"]
+    N = len(onsets)
+
+    directions = list(part.iter_all(score.TempoDirection, include_subclasses=True))
+
+    def to_name(d):
+        if isinstance(d, score.ResetTempoDirection):
+            ref = d.reference_tempo
+            if ref:
+                return ref.text
+            else:
+                return d.text
+        elif isinstance(d, score.ConstantTempoDirection):
+            return d.text
+        elif isinstance(d, score.IncreasingTempoDirection):
+            return "tempo_incr"
+        elif isinstance(d, score.DecreasingTempoDirection):
+            return "tempo_decr"
+
+    feature_by_name = {}
+    for d in directions:
+        j, bf = feature_by_name.setdefault(
+            to_name(d), (len(feature_by_name), np.zeros(N))
+        )
+        bf += feature_function_activation(d)(onsets)
+
+    W = np.empty((len(onsets), len(feature_by_name)))
+    names = [None] * len(feature_by_name)
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def articulation_direction_feature(na, part):
+    """ """
+    onsets = na["onset_div"]
+    N = len(onsets)
+
+    directions = list(
+        part.iter_all(score.ArticulationDirection, include_subclasses=True)
+    )
+
+    def to_name(d):
+        return d.text
+
+    feature_by_name = {}
+
+    for d in directions:
+        j, bf = feature_by_name.setdefault(
+            to_name(d), (len(feature_by_name), np.zeros(N))
+        )
+        bf += feature_function_activation(d)(onsets)
+
+    W = np.empty((len(onsets), len(feature_by_name)))
+    names = [None] * len(feature_by_name)
+
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def feature_function_activation(direction):
+    epsilon = 1e-6
+
+    if isinstance(
+        direction, (score.DynamicLoudnessDirection, score.DynamicTempoDirection)
+    ):
+        # a dynamic direction will be encoded as a ramp from d.start.t to
+        # d.end.t, and then a step from d.end.t to the start of the next
+        # constant direction.
+
+        # There are two potential issues:
+
+        # Issue 1. d.end is None (e.g. just a ritardando without dashes). In this case
+        if direction.end:
+            direction_end = direction.end.t
+        else:
+            # assume the end of d is the end of the measure:
+            measure = next(direction.start.iter_prev(score.Measure, eq=True), None)
+            if measure:
+                direction_end = measure.start.t
+            else:
+                # no measure, unlikely, but not impossible.
+                direction_end = direction.start.t
+
+        if isinstance(direction, score.TempoDirection):
+            next_dir = next(
+                direction.start.iter_next(score.ConstantTempoDirection), None
+            )
+        if isinstance(direction, score.ArticulationDirection):
+            next_dir = next(
+                direction.start.iter_next(score.ConstantArticulationDirection), None
+            )
+        else:
+            next_dir = next(
+                direction.start.iter_next(score.ConstantLoudnessDirection), None
+            )
+
+        if next_dir:
+            # TODO: what do we do when next_dir is too far away?
+            sustained_end = next_dir.start.t
+        else:
+            # Issue 2. there is no next constant direction. In that case the
+            # feature function will be a ramp with a quarter note ramp
+            sustained_end = direction_end + direction.start.quarter
+
+        x = [direction.start.t, direction_end - epsilon, sustained_end - epsilon]
+        y = [0, 1, 1]
+
+    elif isinstance(
+        direction,
+        (
+            score.ConstantLoudnessDirection,
+            score.ConstantArticulationDirection,
+            score.ConstantTempoDirection,
+        ),
+    ):
+        x = [
+            direction.start.t - epsilon,
+            direction.start.t,
+            direction.end.t - epsilon,
+            direction.end.t,
+        ]
+        y = [0, 1, 1, 0]
+
+    else:  # impulsive
+        x = [
+            direction.start.t - epsilon,
+            direction.start.t,
+            direction.start.t + epsilon,
+        ]
+        y = [0, 1, 0]
+
+    return interp1d(x, y, bounds_error=False, fill_value=0)
+
+
+def slur_feature(na, part):
+    """Slur feature.
+
+    Returns:
+    * slur_incr : a ramp function that increases from 0
+                  to 1 over the course of the slur
+    * slur_decr : a ramp function that decreases from 1
+                  to 0 over the course of the slur
+
+    """
+    names = ["slur_incr", "slur_decr"]
+    onsets = na["onset_div"]
+    slurs = part.iter_all(score.Slur)
+    W = np.zeros((len(onsets), 2))
+
+    for slur in slurs:
+        if not slur.end:
+            continue
+        x = [slur.start.t, slur.end.t]
+        y_inc = [0, 1]
+        y_dec = [1, 0]
+        W[:, 0] += interp1d(x, y_inc, bounds_error=False, fill_value=0)(onsets)
+        W[:, 1] += interp1d(x, y_dec, bounds_error=False, fill_value=0)(onsets)
+    # Filter out NaN values
+    W[np.isnan(W)] = 0.0
+    return W, names
+
+
+def articulation_feature(na, part):
+    """Articulation feature.
+
+    This feature returns articulation-related note annotations, such as accents, legato, and tenuto.
+
+    Possible descriptors:
+    * accent : 1 when the note has an annotated accent sign
+    * legato : 1 when the note has an annotated legato sign
+    * staccato : 1 when the note has an annotated staccato sign
+    ...
+
+    """
+    names = [
+        "accent",
+        "strong-accent",
+        "staccato",
+        "tenuto",
+        "detached-legato",
+        "staccatissimo",
+        "spiccato",
+        "scoop",
+        "plop",
+        "doit",
+        "falloff",
+        "breath-mark",
+        "caesura",
+        "stress",
+        "unstress",
+        "soft-accent",
+    ]
+    feature_by_name = {}
+    notes = part.notes_tied if not np.all(na["pitch"] == 0) else part.rests
+    N = len(notes)
+    for i, n in enumerate(notes):
+        if n.articulations:
+            for art in n.articulations:
+                if art in names:
+                    j, bf = feature_by_name.setdefault(
+                        art, (len(feature_by_name), np.zeros(N))
+                    )
+                    bf[i] = 1
+
+    M = len(feature_by_name)
+    W = np.empty((N, M))
+    names = [None] * M
+
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def ornament_feature(na, part):
+    """Ornament feature.
+
+    This feature returns ornamentation note annotations,such as trills.
+
+    Possible descriptors:
+    * trill : 1 when the note has an annotated trill
+    * mordent : 1 when the note has an annotated mordent
+    ...
+
+    """
+    names = [
+        "trill-mark",
+        "turn",
+        "delayed-turn",
+        "inverted-turn",
+        "delayed-inverted-turn",
+        "vertical-turn",
+        "inverted-vertical-turn",
+        "shake",
+        "wavy-line",
+        "mordent",
+        "inverted-mordent",
+        "schleifer",
+        "tremolo",
+        "haydn",
+        "other-ornament",
+    ]
+    feature_by_name = {}
+    notes = part.notes_tied
+    N = len(notes)
+    for i, n in enumerate(notes):
+        if n.ornaments:
+            for art in n.ornaments:
+                if art in names:
+                    j, bf = feature_by_name.setdefault(
+                        art, (len(feature_by_name), np.zeros(N))
+                    )
+                    bf[i] = 1
+
+    M = len(feature_by_name)
+    W = np.empty((N, M))
+    names = [None] * M
+
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def staff_feature(na, part):
+    """Staff feature"""
+    names = ["staff"]
+    notes = {n.id: n.staff for n in part.notes_tied}
+    N = len(notes)
+    W = np.empty((N, 1))
+    for i, n in enumerate(na):
+        W[i, 0] = notes[n["id"]]
+
+    return W, names
+
+
+# # for a subset of the articulations do e.g.
+# def staccato_feature(part):
+#     W, names = articulation_feature(part)
+#     if 'staccato' in names:
+#         i = names.index('staccato')
+#         return W[:, i:i + 1], ['staccato']
+#     else:
+#         return np.empty(len(W)), []
+
+
+def fermata_feature(na, part):
+    """Fermata feature.
+
+    Returns:
+    * fermata : 1 when the note coincides with a fermata sign.
+
+    """
+    names = ["fermata"]
+    onsets = na["onset_div"]
+    W = np.zeros((len(onsets), 1))
+    for ferm in part.iter_all(score.Fermata):
+        W[onsets == ferm.start.t, 0] = 1
+    return W, names
+
+
+def metrical_feature(na, part):
+    """Metrical feature
+
+    This feature encodes the metrical position in the bar. For example
+    the first beat in a 3/4 meter is encoded in a binary descriptor
+    'metrical_3_4_0', the fifth beat in a 6/8 meter as
+    'metrical_6_8_4', etc. Any positions that do not fall on a beat
+    are encoded in a feature suffixed '_weak'. For example a note
+    starting on the second 8th note in a bar of 4/4 meter will have a
+    non-zero value in the 'metrical_4_4_weak' descriptor.
+
+    """
+    notes = part.notes_tied if not np.all(na["pitch"] == 0) else part.rests
+    ts_map = part.time_signature_map
+    bm = part.beat_map
+    feature_by_name = {}
+    eps = 10**-6
+
+    for i, n in enumerate(notes):
+
+        beats, beat_type, mus_beats = ts_map(n.start.t).astype(int)
+        measure = next(n.start.iter_prev(score.Measure, eq=True), None)
+
+        if measure:
+            measure_start = measure.start.t
+        else:
+            measure_start = 0
+
+        pos = bm(n.start.t) - bm(measure_start)
+
+        if pos % 1 < eps:
+            name = "metrical_{}_{}_{}".format(beats, beat_type, int(pos))
+        else:
+            name = "metrical_{}_{}_weak".format(beats, beat_type)
+
+        j, bf = feature_by_name.setdefault(
+            name, (len(feature_by_name), np.zeros(len(notes)))
+        )
+        bf[i] = 1
+
+    W = np.empty((len(notes), len(feature_by_name)))
+    names = [None] * len(feature_by_name)
+    for name, (j, bf) in feature_by_name.items():
+        W[:, j] = bf
+        names[j] = name
+
+    return W, names
+
+
+def metrical_strength_feature(na, part):
+    """Metrical strength feature
+
+    This feature encodes the beat phase (relative position of a note within
+    the measure), as well as metrical strength of common time signatures.
+    """
+    names = [
+        "beat_phase",
+        "metrical_strength_downbeat",
+        "metrical_strength_secondary",
+        "metrical_strength_weak",
+    ]
+
+    relod = na["rel_onset_div"].astype(float)
+    totmd = na["tot_measure_div"].astype(float)
+    W = np.zeros((len(na), len(names)))
+    W[:, 0] = np.divide(relod, totmd)  # Onset Phase
+    W[:, 1] = na["is_downbeat"].astype(float)
+    W[:, 2][W[:, 0] == 0.5] = 1.00
+    W[:, 3][np.nonzero(np.add(W[:, 1], W[:, 0]) == 1.00)]
+    return W, names
+
+
+def time_signature_feature(na, part):
+    """TIme Signature feature
+    This feature encodes the time signature of the note in two sets of one-hot vectors,
+    a one hot encoding of number of beats and a one hot encoding of beat type
+    """
+
+    ts_map = part.time_signature_map
+    possible_beats = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, "other"]
+    possible_beat_types = [1, 2, 4, 8, 16, "other"]
+    W_beats = np.zeros((len(na), len(possible_beats)))
+    W_types = np.zeros((len(na), len(possible_beat_types)))
+
+    names = ["time_signature_num_{0}".format(b) for b in possible_beats] + [
+        "time_signature_den_{0}".format(b) for b in possible_beat_types
+    ]
+
+    for i, n in enumerate(na):
+        beats, beat_type, mus_beats = ts_map(n["onset_div"]).astype(int)
+
+        if beats in possible_beats:
+            W_beats[i, beats - 1] = 1
+        else:
+            W_beats[i, -1] = 1
+
+        if beat_type in possible_beat_types:
+            W_types[i, possible_beat_types.index(beat_type)] = 1
+        else:
+            W_types[i, -1] = 1
+
+    W = np.column_stack((W_beats, W_types))
+
+    return W, names
+
+
+def vertical_neighbor_feature(na, part):
+    """Vertical neighbor feature.
+
+    Describes various aspects of simultaneously starting notes.
+
+    Returns:
+    * n_total :
+    * n_above :
+    * n_below :
+    * highest_pitch :
+    * lowest_pitch :
+    * pitch_range :
+
+    """
+    # the list of descriptors
+    names = [
+        "n_total",
+        "n_above",
+        "n_below",
+        "highest_pitch",
+        "lowest_pitch",
+        "pitch_range",
+    ]
+    W = np.empty((len(na), len(names)))
+    for i, n in enumerate(na):
+        neighbors = na[np.where(na["onset_beat"] == n["onset_beat"])]["pitch"]
+        max_pitch = np.max(neighbors)
+        min_pitch = np.min(neighbors)
+        W[i, 0] = len(neighbors) - 1
+        W[i, 1] = np.sum(neighbors > n["pitch"])
+        W[i, 2] = np.sum(neighbors < n["pitch"])
+        W[i, 3] = max_pitch
+        W[i, 4] = min_pitch
+        W[i, 5] = max_pitch - min_pitch
+    return W, names
+
+
+def normalize(data, method="minmax"):
+    """
+    Normalize data in one of several ways.
+
+    The available normalization methods are:
+
+    * minmax
+      Rescale `data` to the range `[0, 1]` by subtracting the minimum
+      and dividing by the range. If `data` is a 2d array, each column is
+      rescaled to `[0, 1]`.
+
+    * tanh
+      Rescale `data` to the interval `(-1, 1)` using `tanh`. Note that
+      if `data` is non-negative, the output interval will be `[0, 1)`.
+
+    * tanh_unity
+      Like "soft", but rather than rescaling strictly to the range (-1,
+      1), following will hold:
+
+      normalized = normalize(data, method="tanh_unity")
+      np.where(data==1) == np.where(normalized==1)
+
+      That is, the normalized data will equal one wherever the original data
+      equals one. The target interval is `(-1/np.tanh(1), 1/np.tanh(1))`.
+
+    Parameters
+    ----------
+    data: ndarray
+        Data to be normalized
+    method: {'minmax', 'tanh', 'tanh_unity'}, optional
+        The normalization method. Defaults to 'minmax'.
+
+    Returns
+    -------
+    ndarray
+        Normalized copy of the data
+    """
+
+    """Normalize the data in `data`. There are several normalization
+
+    """
+    if method == "minmax":
+        vmin = np.min(data, 0)
+        vmax = np.max(data, 0)
+
+        if np.isclose(vmin, vmax):
+            # Return all values as 0 or as 1?
+            return np.zeros_like(data)
+        else:
+            return (data - vmin) / (vmax - vmin)
+    elif method == "tanh":
+        return np.tanh(data)
+    elif method == "tanh_unity":
+        return np.tanh(data) / np.tanh(1)
```

### Comparing `partitura-1.2.1/partitura/musicanalysis/performance_codec.py` & `partitura-1.2.2/tests/test_utils.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,636 +1,563 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module implements a codec to encode and decode expressive performances to a set of
-expressive parameters.
-"""
-import numpy as np
-import numpy.lib.recfunctions as rfn
-try:
-    import torch
-except ImportError:
-    # Dummy module to avoid ImportErrors
-    class DummyTorch(object):
-        Tensor = np.ndarray
-
-        def __init__(self):
-            pass
-
-    torch = DummyTorch()
-
-
-from partitura.score import Part
-from partitura.performance import PerformedPart
-from scipy.interpolate import interp1d
-
-__all__ = ["encode_performance", "decode_performance"]
-
-
-def encode_performance(
-    part: Part,
-    ppart: PerformedPart,
-    alignment: list,
-    return_u_onset_idx=False,
-):
-    """
-    Encode expressive parameters from a matched performance
-
-
-    Parameters
-    ----------
-    part : partitura.Part
-        The score full either load from a match file.
-    ppart : partitura.PerformedPart
-        A list of Dictionaries
-    alignment : list
-        The score--performance alignment, a list of dictionaries
-    return_u_onset_idx : bool
-        Return the indices of the unique score onsets
-
-    Returns
-    -------
-    parameters : structured array
-        A performance array with 4 fields: beat_period, velocity,
-        timing, and rticulation_log.
-    snote_ids : dict
-        A dict of snote_ids corresponding to performance notes.
-    unique_onset_idxs : list (optional)
-        List of unique onset ids. Returned only when return_u_onset_idx
-        is set to True.
-    """
-
-    m_score, snote_ids = to_matched_score(part, ppart, alignment)
-
-    # Get time-related parameters
-    (time_params, unique_onset_idxs) = encode_tempo(
-        score_onsets=m_score["onset"],
-        performed_onsets=m_score["p_onset"],
-        score_durations=m_score["duration"],
-        performed_durations=m_score["p_duration"],
-        return_u_onset_idx=True,
-    )
-
-    # Get dynamics-related parameters
-    dynamics_params = np.array(m_score["velocity"] / 127.0, dtype=[("velocity", "f4")])
-
-    # Fixing random error
-    parameters = time_params
-    parameters["velocity"] = dynamics_params["velocity"]
-
-    if return_u_onset_idx:
-        return parameters, snote_ids, unique_onset_idxs
-    else:
-        return parameters, snote_ids
-
-
-def decode_performance(
-    part: Part,
-    performance_array: np.ndarray,
-    snote_ids=None,
-    part_id=None,
-    part_name=None,
-    return_alignment=False,
-    *args,
-    **kwargs
-) -> PerformedPart:
-    """
-    Given a Part (score) and a performance array return a PerformedPart.
-
-    Parameters
-    ----------
-    part : partitura.score.Part
-        A partitura Part representing a score
-    performance_array : structured array
-        A performed array related to the part.
-    snote_ids : list
-    part_id : str
-    part_name : str
-    return_alignment : bool
-        True returns alignment list of dicts.
-
-    Returns
-    -------
-    ppart : partitura.performance.PerformedPart
-        A partitura PerformedPart.
-    alignment: list (optional)
-        A list of dicts for the alignment.
-    """
-
-    snotes = part.notes_tied
-
-    if snote_ids is None:
-        snote_ids = [n.id for n in snotes]
-
-    # sort
-    snote_dict = dict((n.id, n) for n in snotes)
-    snote_info = np.array(
-        [
-            (
-                snote_dict[i].midi_pitch,
-                snote_dict[i].start.t,
-                snote_dict[i].start.t + snote_dict[i].duration_tied,
-            )
-            for i in snote_ids
-        ],
-        dtype=[("pitch", "i4"), ("onset", "f4"), ("offset", "f4")],
-    )
-    sort_idx = np.lexsort((snote_info["pitch"], snote_info["onset"]))
-
-    bm = part.beat_map
-    onsets = bm(snote_info["onset"])[sort_idx]
-    durations = (bm(snote_info["offset"]) - bm(snote_info["onset"]))[sort_idx]
-    pitches = snote_info["pitch"][sort_idx]
-
-    pitches = np.clip(pitches, 1, 127)
-
-    dynamics_params = performance_array["velocity"][sort_idx]
-    time_params = performance_array[
-        list(("beat_period", "timing", "articulation_log"))
-    ][sort_idx]
-
-    onsets_durations = decode_time(
-        score_onsets=onsets,
-        score_durations=durations,
-        parameters=time_params,
-        *args,
-        **kwargs
-    )
-
-    velocities = np.round(dynamics_params * 127.0)
-
-    velocities = np.clip(velocities, 1, 127)
-
-    notes = []
-    for nid, (onset, duration), velocity, pitch in zip(
-        snote_ids, onsets_durations, velocities, pitches
-    ):
-        notes.append(
-            dict(
-                id=nid,
-                midi_pitch=int(pitch),
-                note_on=onset,
-                note_off=onset + duration,
-                sound_off=onset + duration,
-                velocity=int(velocity),
-            )
-        )
-    # * rescale according to default values?
-    ppart = PerformedPart(id=part_id, part_name=part_name, notes=notes)
-
-    if return_alignment:
-        alignment = []
-        for snote, pnote in zip(part.notes_tied, ppart.notes):
-            alignment.append(
-                dict(label="match", score_id=snote.id, performance_id=pnote["id"])
-            )
-
-        return ppart, alignment
-    else:
-
-        return ppart
-
-
-def decode_time(score_onsets, score_durations, parameters, *args, **kwargs):
-    """
-    Decode a performance into onsets and durations in seconds
-    for each note in the score.
-    """
-    score_onsets = score_onsets.astype(float, copy=False)
-    score_durations = score_durations.astype(float, copy=False)
-
-    score_info = get_unique_seq(
-        onsets=score_onsets,
-        offsets=score_onsets + score_durations,
-        unique_onset_idxs=None,
-        return_diff=True,
-    )
-    unique_onset_idxs = score_info["unique_onset_idxs"]
-    diff_u_onset_score = score_info["diff_u_onset"]
-
-    time_param = np.array(
-        [tuple([np.mean(parameters["beat_period"][uix])]) for uix in unique_onset_idxs],
-        dtype=[("beat_period", "f4")],
-    )
-
-    beat_period = time_param["beat_period"]
-
-    ioi_perf = diff_u_onset_score * beat_period
-
-    eq_onset = np.cumsum(np.r_[0, ioi_perf])
-
-    performance = np.zeros((len(score_onsets), 2))
-
-    for i, jj in enumerate(unique_onset_idxs):
-        # decode onset
-        performance[jj, 0] = eq_onset[i] - parameters["timing"][jj]
-        # decode duration
-        performance[jj, 1] = decode_articulation(
-            score_durations=score_durations[jj],
-            articulation_parameter=parameters["articulation_log"][jj],
-            beat_period=beat_period[i],
-        )
-
-    performance[:, 0] -= np.min(performance[:, 0])
-
-    return performance
-
-
-def decode_articulation(score_durations, articulation_parameter, beat_period):
-    """
-    Decode articulation
-    """
-    art_ratio = 2 ** articulation_parameter
-    dur = art_ratio * score_durations * beat_period
-
-    return dur
-
-
-def encode_tempo(
-    score_onsets: np.ndarray,
-    performed_onsets: np.ndarray,
-    score_durations,
-    performed_durations,
-    return_u_onset_idx: bool = False,
-) -> np.ndarray:
-    """
-    Compute time-related performance parameters from a performance
-    """
-    if score_onsets.shape != performed_onsets.shape:
-        raise ValueError("The performance and the score should be of " "the same size")
-
-    # use float64, float32 led to problems that x == x + eps evaluated to True
-    # Maybe replace by np.isclose
-    score_onsets = score_onsets.astype(float, copy=False)
-    performed_onsets = performed_onsets.astype(float, copy=False)
-    score_durations = score_durations.astype(float, copy=False)
-    performed_durations = performed_durations.astype(float, copy=False)
-    score = np.column_stack((score_onsets, score_durations))
-    performance = np.column_stack((performed_onsets, performed_durations))
-
-    # Compute beat period
-    beat_period, s_onsets, unique_onset_idxs = tempo_by_average(
-        score_onsets=score[:, 0],
-        performed_onsets=performance[:, 0],
-        score_durations=score[:, 1],
-        performed_durations=performance[:, 1],
-        return_onset_idxs=True,
-    )
-
-    # Compute equivalent onsets
-    eq_onsets = (
-        np.cumsum(np.r_[0, beat_period[:-1] * np.diff(s_onsets)])
-        + performance[unique_onset_idxs[0], 0].mean()
-    )
-
-    # Compute tempo parameter
-    # TODO fix normalization
-    tempo_params = [beat_period]
-
-    # Compute articulation parameter
-    articulation_param = encode_articulation(
-        score_durations=score[:, 1],
-        performed_durations=performance[:, 1],
-        unique_onset_idxs=unique_onset_idxs,
-        beat_period=beat_period,
-    )
-
-    # Initialize array of parameters
-    parameter_names = ["beat_period", "velocity", "timing", "articulation_log"]
-    parameters = np.zeros(len(score), dtype=[(pn, "f4") for pn in parameter_names])
-    parameters["articulation_log"] = articulation_param
-    for i, jj in enumerate(unique_onset_idxs):
-        parameters["beat_period"][jj] = tempo_params[0][i]
-        # Defined as in Eq. (3.9) in Thesis (pp. 34)
-        parameters["timing"][jj] = eq_onsets[i] - performance[jj, 0]
-
-    if return_u_onset_idx:
-        return parameters, unique_onset_idxs
-    else:
-        return parameters
-
-
-def tempo_by_average(
-    score_onsets,
-    performed_onsets,
-    score_durations,
-    performed_durations,
-    unique_onset_idxs=None,
-    input_onsets=None,
-    return_onset_idxs=False,
-):
-    """
-    Computes a tempo curve using the average of the onset times of all
-    notes belonging to the same score onset.
-    Parameters
-    ----------
-    score_onsets : np.ndarray
-        Onset in beats of each note in the score.
-    performed_onsets : np.ndarray
-        Performed onsets in seconds of each note in the score.
-    score_durations : np.ndarray
-        Duration in beats of each note in the score.
-    performed_durations : np.ndarray
-        Performed duration in seconds of each note in the score.
-    unique_onset_idxs : np.ndarray or None (optional)
-        Indices of the notes with the same score onset. (By default is None,
-        and is therefore, inferred from `score_onsets`).
-    input_onsets : np.ndarray or None
-        Input onset times in beats at which the tempo curve is to be
-        sampled (by default is None, which means that the tempo curve
-        is returned for each unique score onset)
-    return_onset_idxs : bool
-        Return the indices of the unique score onsets (Default is False)
-    Returns
-    -------
-    tempo_curve : np.ndarray
-        Tempo curve in seconds per beat (spb). If `input_onsets` was provided,
-        this array contains the value of the tempo in spb for each onset
-        in `input_onsets`. Otherwise, this array contains the value of the
-        tempo in spb for each unique score onset.
-    input_onsets : np.ndarray
-        The score onsets corresponding to each value of the tempo curve.
-    unique_onset_idxs: list
-        Each element of the list is an array of the indices of the score
-        corresponding to the elements in `tempo_curve`. Only returned if
-        `return_onset_idxs` is True.
-    """
-    # use float64, float32 led to problems that x == x + eps evaluated
-    # to True
-    score_onsets = np.array(score_onsets).astype(float, copy=False)
-    performed_onsets = np.array(performed_onsets).astype(float, copy=False)
-    score_durations = np.array(score_durations).astype(float, copy=False)
-    performed_durations = np.array(performed_durations).astype(float, copy=False)
-
-    # Get unique onsets if no provided
-    if unique_onset_idxs is None:
-        # Get indices of the unique onsets (quantize score onsets)
-        unique_onset_idxs = get_unique_onset_idxs((1e4 * score_onsets).astype(int))
-
-    # Get score information
-    score_info = get_unique_seq(
-        onsets=score_onsets,
-        offsets=score_onsets + score_durations,
-        unique_onset_idxs=unique_onset_idxs,
-    )
-    # Get performance information
-    perf_info = get_unique_seq(
-        onsets=performed_onsets,
-        offsets=performed_onsets + performed_durations,
-        unique_onset_idxs=unique_onset_idxs,
-    )
-
-    # unique score onsets
-    unique_s_onsets = score_info["u_onset"]
-    # equivalent onsets
-    eq_onsets = perf_info["u_onset"]
-
-    # Monotonize times
-    eq_onset_mt, unique_s_onsets_mt = monotonize_times(
-        eq_onsets, deltas=unique_s_onsets
-    )
-
-    # Estimate Beat Period
-    perf_iois = np.diff(eq_onset_mt)
-    s_iois = np.diff(unique_s_onsets_mt)
-    beat_period = perf_iois / s_iois
-
-    tempo_fun = interp1d(
-        unique_s_onsets_mt[:-1],
-        beat_period,
-        kind="zero",
-        bounds_error=False,
-        fill_value=(beat_period[0], beat_period[-1]),
-    )
-
-    if input_onsets is None:
-        input_onsets = unique_s_onsets[:-1]
-
-    tempo_curve = tempo_fun(input_onsets)
-
-    if return_onset_idxs:
-        return tempo_curve, input_onsets, unique_onset_idxs
-    else:
-        return tempo_curve, input_onsets
-
-
-def get_unique_seq(onsets, offsets, unique_onset_idxs=None, return_diff=False):
-    """
-    Get unique onsets of a sequence of notes
-    """
-    eps = np.finfo(float).eps
-
-    first_time = np.min(onsets)
-
-    # ensure last score time is later than last onset
-    last_time = max(np.max(onsets) + eps, np.max(offsets))
-
-    total_dur = last_time - first_time
-
-    if unique_onset_idxs is None:
-        # unique_onset_idxs = unique_onset_idx(score[:, 0])
-        unique_onset_idxs = get_unique_onset_idxs(onsets)
-
-    u_onset = np.array([np.mean(onsets[uix]) for uix in unique_onset_idxs])
-    # add last offset, so we have as many IOIs as notes
-    u_onset = np.r_[u_onset, last_time]
-
-    output_dict = dict(
-        u_onset=u_onset, total_dur=total_dur, unique_onset_idxs=unique_onset_idxs
-    )
-
-    if return_diff:
-        output_dict["diff_u_onset"] = np.diff(u_onset)
-
-    return output_dict
-
-
-def get_unique_onset_idxs(
-    onsets, eps: float = 1e-6, return_unique_onsets: bool = False
-):
-    """
-    Get unique onsets and their indices.
-    Parameters
-    ----------
-    onsets : np.ndarray
-        Score onsets in beats.
-    eps : float
-        Small epsilon (for dealing with quantization in symbolic scores).
-        This is particularly useful for dealing with triplets and other
-        similar rhytmical structures that do not have a finite decimal
-        representation.
-    return_unique_onsets : bool (optional)
-        If `True`, returns the unique score onsets.
-    Returns
-    -------
-    unique_onset_idxs : np.ndarray
-        Indices of the unique onsets in the score.
-    unique_onsets : np.ndarray
-        Unique score onsets
-    """
-    # Do not assume that the onsets are sorted
-    # (use a stable sorting algorithm for preserving the order
-    # of elements with the same onset, which is useful e.g. if the
-    # notes within a same onset are ordered by pitch)
-    sort_idx = np.argsort(onsets, kind="mergesort")
-    split_idx = np.where(np.diff(onsets[sort_idx]) > eps)[0] + 1
-    unique_onset_idxs = np.split(sort_idx, split_idx)
-
-    if return_unique_onsets:
-        # Instead of np.unique(onsets)
-        unique_onsets = np.array([onsets[uix].mean() for uix in unique_onset_idxs])
-
-        return unique_onset_idxs, unique_onsets
-    else:
-        return unique_onset_idxs
-
-
-def to_matched_score(part, ppart, alignment):
-    """
-    Returns a mixed score-performance note array
-    consisting of matched notes in the alignment.
-
-    Args:
-        part (partitura.Part): a part object
-        ppart (partitura.PerformedPart): a performedpart object
-        alignment (List(Dict)): an alignment
-
-    Returns:
-        np.ndarray: a minimal, aligned 
-        score-performance note array
-    """
-    
-    # remove repetitions from aligment note ids
-    for a in alignment:
-        if a["label"] == "match":
-            a["score_id"] = str(a["score_id"])
-
-    part_by_id = dict((n.id, n) for n in part.notes_tied)
-    ppart_by_id = dict((n["id"], n) for n in ppart.notes)
-
-    # pair matched score and performance notes
-
-    note_pairs = [
-        (part_by_id[a["score_id"]], ppart_by_id[a["performance_id"]])
-        for a in alignment
-        if (a["label"] == "match" and a["score_id"] in part_by_id)
-    ]
-
-    ms = []
-    # sort according to onset (primary) and pitch (secondary)
-    pitch_onset = [(sn.midi_pitch, sn.start.t) for sn, _ in note_pairs]
-    sort_order = np.lexsort(list(zip(*pitch_onset)))
-    beat_map = part.beat_map
-    snote_ids = []
-    for i in sort_order:
-
-        sn, n = note_pairs[i]
-        sn_on, sn_off = beat_map([sn.start.t, sn.start.t + sn.duration_tied])
-        sn_dur = sn_off - sn_on
-        # hack for notes with negative durations
-        n_dur = max(n["sound_off"] - n["note_on"], 60 / 200 * 0.25)
-        ms.append((sn_on, sn_dur, sn.midi_pitch, n["note_on"], n_dur, n["velocity"]))
-        snote_ids.append(sn.id)
-
-    fields = [
-        ("onset", "f4"),
-        ("duration", "f4"),
-        ("pitch", "i4"),
-        ("p_onset", "f4"),
-        ("p_duration", "f4"),
-        ("velocity", "i4"),
-    ]
-
-    return np.array(ms, dtype=fields), snote_ids
-
-
-def encode_articulation(
-    score_durations, performed_durations, unique_onset_idxs, beat_period
-):
-    """
-    Encode articulation
-    """
-    articulation = np.zeros_like(score_durations)
-    for idx, bp in zip(unique_onset_idxs, beat_period):
-
-        sd = score_durations[idx]
-        pd = performed_durations[idx]
-
-        # indices of notes with duration 0 (grace notes)
-        grace_mask = sd <= 0
-
-        # Grace notes have an articulation ratio of 1
-        sd[grace_mask] = 1
-        pd[grace_mask] = bp
-        # Compute log articulation ratio
-        articulation[idx] = np.log2(pd / (bp * sd))
-
-    return articulation
-
-
-def monotonize_times(s, deltas=None):
-    """Interpolate linearly over as many points in `s` as necessary to
-    obtain a monotonic sequence. The minimum and maximum of `s` are
-    prepended and appended, respectively, to ensure monotonicity at
-    the bounds of `s`.
-    Parameters
-    ----------
-    s : ndarray
-        a sequence of numbers
-    strict : bool
-        when True, return a strictly monotonic sequence (default: True)
-    Returns
-    -------
-    ndarray
-       a monotonic sequence that has been linearly interpolated using a subset of s
-    """
-    eps = np.finfo(float).eps
-
-    _s = np.r_[np.min(s) - eps, s, np.max(s) + eps]
-    if deltas is not None:
-        _deltas = np.r_[np.min(deltas) - eps, deltas, np.max(deltas) + eps]
-    else:
-        _deltas = None
-    mask = np.ones(_s.shape[0], dtype=bool)
-    mask[0] = mask[-1] = False
-    idx = np.arange(_s.shape[0])
-    s_mono = interp1d(idx[mask], _s[mask])(idx[1:-1])
-    return _s[mask], _deltas[mask]
-
-
-def notewise_to_onsetwise(notewise_inputs, unique_onset_idxs):
-    """Agregate basis functions per onset"""
-    if isinstance(notewise_inputs, np.ndarray):
-        if notewise_inputs.ndim == 1:
-            shape = len(unique_onset_idxs)
-        else:
-            shape = (len(unique_onset_idxs),) + notewise_inputs.shape[1:]
-        onsetwise_inputs = np.zeros(shape, dtype=notewise_inputs.dtype)
-    elif isinstance(notewise_inputs, torch.Tensor):
-        onsetwise_inputs = torch.zeros(
-            (len(unique_onset_idxs), notewise_inputs.shape[1]),
-            dtype=notewise_inputs.dtype,
-        )
-
-    for i, uix in enumerate(unique_onset_idxs):
-        try:
-            onsetwise_inputs[i] = notewise_inputs[uix].mean(0)
-        except TypeError:
-            for tn in notewise_inputs.dtype.names:
-                onsetwise_inputs[i][tn] = notewise_inputs[uix][tn].mean()
-    return onsetwise_inputs
-
-
-def onsetwise_to_notewise(onsetwise_input, unique_onset_idxs):
-    """Expand onsetwise predictions for each note"""
-    n_notes = sum([len(uix) for uix in unique_onset_idxs])
-    if isinstance(onsetwise_input, np.ndarray):
-        if onsetwise_input.ndim == 1:
-            shape = n_notes
-        else:
-            shape = (n_notes,) + onsetwise_input.shape[1:]
-        notewise_inputs = np.zeros(shape, dtype=onsetwise_input.dtype)
-    elif isinstance(onsetwise_input, torch.Tensor):
-        notewise_inputs = torch.zeros(n_notes, dtype=onsetwise_input.dtype)
-    for i, uix in enumerate(unique_onset_idxs):
-        notewise_inputs[uix] = onsetwise_input[[i]]
-    return notewise_inputs
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains tests for the utility methods.
+"""
+import unittest
+import partitura
+import numpy as np
+
+from partitura.utils import music
+from tests import MATCH_IMPORT_EXPORT_TESTFILES, VOSA_TESTFILES, MOZART_VARIATION_FILES
+
+from scipy.interpolate import interp1d as scinterp1d
+from partitura.utils.generic import interp1d as pinterp1d
+
+RNG = np.random.RandomState(1984)
+
+
+class TestGetMatchedNotes(unittest.TestCase):
+    def test_get_matched_notes(self):
+        for fn in MATCH_IMPORT_EXPORT_TESTFILES:
+            perf, alignment, scr = partitura.load_match(
+                filename=fn,
+                create_score=True,
+            )
+            perf_note_array = perf.note_array()
+            scr_note_array = scr.note_array()
+            matched_idxs = music.get_matched_notes(
+                spart_note_array=scr_note_array,
+                ppart_note_array=perf_note_array,
+                alignment=alignment,
+            )
+            scr_pitch = scr_note_array["pitch"][matched_idxs[:, 0]]
+            perf_pitch = perf_note_array["pitch"][matched_idxs[:, 1]]
+
+            self.assertTrue(np.all(scr_pitch == perf_pitch))
+
+
+class TestGetTimeMapsFromAlignment(unittest.TestCase):
+    def test_get_time_maps_from_alignment(self):
+        for fn in VOSA_TESTFILES:
+            scr = partitura.load_musicxml(fn)
+            note_ids = scr.note_array()["id"]
+            beats_per_minute = 60 / RNG.uniform(0.3, 3, size=2)
+
+            for bpm in beats_per_minute:
+                ppart = music.performance_from_part(part=scr[0], bpm=bpm)
+                alignment = [
+                    dict(label="match", score_id=sid, performance_id=sid)
+                    for sid in note_ids
+                ]
+
+                (
+                    ptime_to_stime_map,
+                    stime_to_ptime_map,
+                ) = music.get_time_maps_from_alignment(
+                    spart_or_note_array=scr[0],
+                    ppart_or_note_array=ppart,
+                    alignment=alignment,
+                    remove_ornaments=True,
+                )
+
+                score_onsets = np.arange(4, 0.5)
+                performed_onsets = 60 / bpm * score_onsets
+
+                self.assertTrue(
+                    np.all(score_onsets == ptime_to_stime_map(performed_onsets))
+                )
+                self.assertTrue(
+                    np.all(performed_onsets == stime_to_ptime_map(score_onsets))
+                )
+
+
+class TestPerformanceFromPart(unittest.TestCase):
+    def test_performance_from_part(self):
+        for fn in VOSA_TESTFILES:
+            scr = partitura.load_musicxml(fn)
+            beats_per_minute = 60 / RNG.uniform(0.3, 3, size=2)
+            midi_velocity = RNG.randint(30, 127, size=2)
+            for bpm, vel in zip(beats_per_minute, midi_velocity):
+                ppart = music.performance_from_part(part=scr[0], bpm=bpm, velocity=vel)
+
+                # assert that both objects have the same number of notes
+                self.assertEqual(len(scr[0].notes_tied), len(ppart.notes))
+
+                snote_array = scr[0].note_array()
+                pnote_array = ppart.note_array()
+
+                # check MIDI velocities
+                self.assertTrue(np.all(pnote_array["velocity"] == vel))
+
+                alignment = [
+                    dict(label="match", score_id=sid, performance_id=sid)
+                    for sid in snote_array["id"]
+                ]
+
+                matched_idxs = music.get_matched_notes(
+                    spart_note_array=snote_array,
+                    ppart_note_array=pnote_array,
+                    alignment=alignment,
+                )
+
+                # check pitch
+                self.assertTrue(
+                    np.all(
+                        pnote_array["pitch"][matched_idxs[:, 1]]
+                        == snote_array["pitch"][matched_idxs[:, 0]]
+                    )
+                )
+                # check durations
+                self.assertTrue(
+                    np.allclose(
+                        pnote_array["duration_sec"],
+                        snote_array["duration_beat"] * (60 / bpm),
+                    )
+                )
+
+                pnote_array = pnote_array[matched_idxs[:, 1]]
+                snote_array = snote_array[matched_idxs[:, 0]]
+
+                unique_onsets = np.unique(snote_array["onset_beat"])
+                unique_onset_idxs = [
+                    np.where(snote_array["onset_beat"] == uo)[0] for uo in unique_onsets
+                ]
+
+                # check performed onsets
+                perf_onsets = np.array(
+                    [
+                        np.mean(pnote_array["onset_sec"][uix])
+                        for uix in unique_onset_idxs
+                    ]
+                )
+
+                beat_period = np.diff(perf_onsets) / np.diff(unique_onsets)
+
+                # check that that the performance corresponds to the expected tempo
+                self.assertTrue(np.allclose(60 / beat_period, bpm))
+
+    def get_tempo_curve(self, score_onsets, performance_onsets):
+        """
+        Get tempo curve
+        """
+        unique_sonsets = np.unique(score_onsets)
+        # Ensure that everything is sorted (I'm just paranoid ;)
+        unique_sonsets.sort()
+        unique_ponsets = np.unique(performance_onsets)
+        # Ensure that everything is sorted
+        unique_ponsets.sort()
+
+        bp = np.diff(unique_ponsets) / np.diff(unique_sonsets)
+
+        # Beats per minute for each of the unique onsets
+        # the last bpm is just assuming that the tempo remains
+        # constant after the last onset.
+        bpm = np.r_[60 / bp, 60 / bp[-1]]
+
+        return bpm
+
+    def test_performance_notearray_from_score_notearray_bpm(self):
+        """
+        Test possibilities for bpm argument in
+        utils.music.performance_notearray_from_score_notearray
+        """
+        score = partitura.load_score(MOZART_VARIATION_FILES["musicxml"])
+
+        score_note_array = score.note_array()
+
+        unique_onsets = np.unique(score_note_array["onset_beat"])
+        unique_onsets.sort()
+        # Test constant tempo
+        bpm = 30
+        velocity = 65
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            bpm=bpm,
+            velocity=velocity,
+        )
+
+        self.assertTrue(
+            np.allclose(
+                self.get_tempo_curve(
+                    score_note_array["onset_beat"],
+                    perf_note_array["onset_sec"],
+                ),
+                bpm,
+            )
+        )
+
+        # Test callable tempo
+        def bpm_fun(onset):
+            """
+            Test function the first half of the piece will be played
+            twice as fast
+            """
+            if isinstance(onset, (int, float)):
+                onset = np.array([onset])
+
+            bpm = np.zeros(len(onset), dtype=float)
+
+            midpoint = (unique_onsets.max() - unique_onsets.min()) / 2
+            bpm[np.where(onset <= midpoint)[0]] = 120
+            bpm[np.where(onset > midpoint)[0]] = 60
+
+            return bpm
+
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            bpm=bpm_fun,
+            velocity=velocity,
+        )
+
+        bpm = self.get_tempo_curve(
+            score_note_array["onset_beat"],
+            perf_note_array["onset_sec"],
+        )
+
+        midpoint = (unique_onsets.max() - unique_onsets.min()) / 2
+
+        self.assertTrue(
+            np.allclose(
+                bpm[np.where(unique_onsets <= midpoint)[0]],
+                120,
+            )
+        )
+
+        self.assertTrue(np.allclose(bpm[np.where(unique_onsets > midpoint)[0]], 60))
+
+        # Test tempo as an array
+        bpm_expected = 40 * RNG.rand(len(unique_onsets)) + 30
+
+        # Test using 1d array
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            bpm=np.column_stack((unique_onsets, bpm_expected)),
+            velocity=velocity,
+        )
+
+        bpm_predicted = self.get_tempo_curve(
+            score_note_array["onset_beat"],
+            perf_note_array["onset_sec"],
+        )
+
+        # do not consider the last element, since get_tempo_curve only computes
+        # the tempo up to the last onset (otherwise offsets need to be considered)
+        self.assertTrue(np.allclose(bpm_expected[:-1], bpm_predicted[:-1], atol=1e-3))
+
+        try:
+            # This should trigger an error because bpm_expected is a 1D array
+            perf_note_array = music.performance_notearray_from_score_notearray(
+                snote_array=score_note_array,
+                bpm=bpm_expected,
+                velocity=velocity,
+            )
+            self.assertTrue(False)
+
+        except ValueError:
+            # We are expecting the previous code to trigger an error
+            self.assertTrue(True)
+
+    def get_velocity_curves(self, velocity, score_onsets):
+        """
+        Get velocity curve by aggregating MIDI velocity values for
+        each onset
+        """
+        unique_onsets = np.unique(score_onsets)
+        # Ensure that everything is sorted (I'm just paranoid ;)
+        unique_onsets.sort()
+
+        unique_onset_idxs = [np.where(score_onsets == uo)[0] for uo in unique_onsets]
+        velocity_curve = np.array([velocity[ui].mean() for ui in unique_onset_idxs])
+
+        return velocity_curve
+
+    def test_performance_notearray_from_score_notearray_velocity(self):
+        """
+        Test velocity arguments in
+        utils.music.performance_notearray_from_score_notearray
+        """
+        score = partitura.load_score(MOZART_VARIATION_FILES["musicxml"])
+
+        score_note_array = score.note_array()
+
+        unique_onsets = np.unique(score_note_array["onset_beat"])
+        unique_onsets.sort()
+
+        # Test constant velocity
+        bpm = 120
+        velocity = 65
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            bpm=bpm,
+            velocity=velocity,
+        )
+
+        self.assertTrue(all(perf_note_array["velocity"] == velocity))
+
+        # Test callable velocity
+        def vel_fun(onset):
+            """
+            Test function the first half of the piece will be played
+            twice as loud
+            """
+            if isinstance(onset, (int, float)):
+                onset = np.array([onset])
+
+            vel = np.zeros(len(onset), dtype=float)
+
+            midpoint = (unique_onsets.max() - unique_onsets.min()) / 2
+            vel[np.where(onset <= midpoint)[0]] = 120
+            vel[np.where(onset > midpoint)[0]] = 60
+
+            return vel
+
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            bpm=bpm,
+            velocity=vel_fun,
+        )
+
+        vel = self.get_velocity_curves(
+            perf_note_array["velocity"], score_note_array["onset_beat"]
+        )
+
+        midpoint = (unique_onsets.max() - unique_onsets.min()) / 2
+
+        self.assertTrue(
+            np.allclose(
+                vel[np.where(unique_onsets <= midpoint)[0]],
+                120,
+            )
+        )
+
+        self.assertTrue(np.allclose(vel[np.where(unique_onsets > midpoint)[0]], 60))
+
+        # Test tempo as an array
+        vel_expected = np.round(40 * RNG.rand(len(unique_onsets)) + 30)
+
+        # Test using 1d array
+        perf_note_array = music.performance_notearray_from_score_notearray(
+            snote_array=score_note_array,
+            velocity=np.column_stack((unique_onsets, vel_expected)),
+            bpm=bpm,
+        )
+
+        vel_predicted = self.get_velocity_curves(
+            perf_note_array["velocity"],
+            score_note_array["onset_beat"],
+        )
+
+        self.assertTrue(np.allclose(vel_expected, vel_predicted, atol=1e-3))
+
+        try:
+            # This should trigger an error because vel_expected is a 1D array
+            perf_note_array = music.performance_notearray_from_score_notearray(
+                snote_array=score_note_array,
+                bpm=bpm,
+                velocity=vel_expected,
+            )
+            self.assertTrue(False)
+
+        except ValueError:
+            # We are expecting the previous code to trigger an error
+            self.assertTrue(True)
+
+    def test_generate_random_performance_note_array(self):
+        """
+        Test `generate_random_performance_note_array` method
+        """
+        n_notes = 100
+        duration = 15
+        max_note_duration = 9
+        min_note_duration = 1
+        max_velocity = 75
+        min_velocity = 30
+        random_note_array = music.generate_random_performance_note_array(
+            num_notes=n_notes,
+            rng=1234,
+            duration=duration,
+            max_note_duration=max_note_duration,
+            min_note_duration=min_note_duration,
+            max_velocity=max_velocity,
+            min_velocity=min_velocity,
+            return_performance=False,
+        )
+
+        # Assert that the output is a numpy array
+        self.assertTrue(isinstance(random_note_array, np.ndarray))
+        # Test that the generated array has the specified number of notes
+        self.assertTrue(len(random_note_array) == n_notes)
+
+        offsets = random_note_array["onset_sec"] + random_note_array["duration_sec"]
+
+        # Test that the note array has the specified duration
+        self.assertTrue(np.isclose(offsets.max(), duration))
+
+        # Test that the generated durations and velocities are within the
+        # specified bounds
+        self.assertTrue(np.all(random_note_array["duration_sec"] <= max_note_duration))
+        self.assertTrue(np.all(random_note_array["duration_sec"] >= min_note_duration))
+        self.assertTrue(np.all(random_note_array["velocity"] >= min_velocity))
+        self.assertTrue(np.all(random_note_array["velocity"] <= max_velocity))
+
+        # Test that the output is a Performance instance
+        random_performance = music.generate_random_performance_note_array(
+            num_notes=n_notes,
+            duration=duration,
+            max_note_duration=max_note_duration,
+            min_note_duration=min_note_duration,
+            max_velocity=max_velocity,
+            min_velocity=min_velocity,
+            return_performance=True,
+        )
+
+        self.assertTrue(
+            isinstance(random_performance, partitura.performance.Performance)
+        )
+
+    def test_sliceperf(self):
+
+        perf = partitura.load_performance_midi(MOZART_VARIATION_FILES["midi"])
+        ppart = perf[0]
+        ppart.sustain_pedal_threshold = 127
+
+        note_array = ppart.note_array()
+
+        start_time = 10
+        end_time = 20
+
+        idx = np.where(
+            np.logical_and(
+                note_array["onset_sec"] >= start_time,
+                note_array["onset_sec"] <= end_time,
+            )
+        )
+
+        target_note_array = note_array[idx]
+
+        ppart_slice = music.slice_ppart_by_time(
+            ppart=ppart,
+            start_time=start_time,
+            end_time=end_time,
+            clip_note_off=False,
+            reindex_notes=False,
+        )
+
+        slice_note_array = ppart_slice.note_array()
+
+        self.assertTrue(len(target_note_array) == len(slice_note_array))
+        self.assertTrue(slice_note_array["onset_sec"].max() <= (end_time - start_time))
+        self.assertTrue(
+            np.isclose(
+                target_note_array["onset_sec"].min() - start_time,
+                slice_note_array["onset_sec"].min(),
+            )
+        )
+        self.assertTrue(
+            np.isclose(
+                target_note_array["onset_sec"].max() - start_time,
+                slice_note_array["onset_sec"].max(),
+            )
+        )
+
+
+class TestGenericUtils(unittest.TestCase):
+    def test_interp1d(self):
+        """
+        Test `interp1d`
+        """
+
+        # Test that the we get the same results as with
+        # scipy
+        rng = np.random.RandomState(1984)
+
+        x = rng.randn(100)
+        y = 3 * x + 1
+
+        sinterp = scinterp1d(x=x, y=y)
+
+        pinterp = pinterp1d(x=x, y=y)
+
+        y_scipy = sinterp(x)
+        y_partitura = pinterp(x)
+
+        self.assertTrue(np.all(y_scipy == y_partitura))
+
+        # Test that we don't get an error with inputs
+        # with length 1
+
+        x = rng.randn(1)
+        y = rng.randn(1)
+
+        pinterp = pinterp1d(x=x, y=y)
+
+        x_test = rng.randn(1000)
+
+        y_partitura = pinterp(x_test)
+
+        self.assertTrue(y_partitura.shape == x_test.shape)
+        self.assertTrue(np.all(y_partitura == y))
+
+        # setting the axis when the input has length 1
+        x = rng.randn(1)
+        y = rng.randn(1, 5)
+        pinterp = pinterp1d(x=x, y=y)
+
+        y_partitura = pinterp(x_test)
+
+        self.assertTrue(y_partitura.shape == (len(x_test), y.shape[1]))
+        self.assertTrue(np.all(y_partitura == y))
+
+        # Test setting dtype of the output
+
+        dtypes = (
+            float,
+            int,
+            np.int8,
+            np.int16,
+            np.float32,
+            np.int64,
+            np.float16,
+            np.float32,
+            np.float64,
+            # np.float128,
+        )
+
+        for dtype in dtypes:
+
+            x = rng.randn(100)
+            y = rng.randn(100)
+
+            pinterp = pinterp1d(x=x, y=y, dtype=dtype)
+
+            y_partitura = pinterp(x)
+            # assert that the dtype of the array is correct
+            self.assertTrue(y_partitura.dtype == dtype)
+            # assert that the result is the same as casting the expected
+            # output as the specified dtype
+            self.assertTrue(np.allclose(y_partitura, y.astype(dtype)))
+
+        # Test setting outputs of sizes larger than 1
+
+        x = rng.randn(100)
+        y = rng.randn(100, 2)
+
+        sinterp = scinterp1d(
+            x,
+            y,
+            axis=0,
+            kind="previous",
+            bounds_error=False,
+            fill_value="extrapolate",
+        )
+
+        pinterp = pinterp1d(
+            x,
+            y,
+            axis=0,
+            kind="previous",
+            bounds_error=False,
+            fill_value="extrapolate",
+        )
+
+        self.assertTrue(np.all(sinterp(x) == pinterp(x)))
```

### Comparing `partitura-1.2.1/partitura/musicanalysis/pitch_spelling.py` & `partitura-1.2.2/partitura/musicanalysis/pitch_spelling.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,330 +1,330 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-"""
-This module contains methods for estimation pitch spelling using the ps13 algorithm.
-
-References
-----------
-.. [4] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
-       of New Music Research, 35(2):121.
-"""
-import numpy as np
-from collections import namedtuple
-from partitura.utils import ensure_notearray, get_time_units_from_note_array
-
-# from partitura.musicanalysis.utils import prepare_notearray
-
-
-__all__ = ["estimate_spelling"]
-
-ChromamorpheticPitch = namedtuple(
-    "ChromamorpheticPitch", "chromatic_pitch morphetic_pitch"
-)
-
-STEPS = np.array(["A", "B", "C", "D", "E", "F", "G"])
-UND_CHROMA = np.array([0, 2, 3, 5, 7, 8, 10], dtype=int)
-ALTER = np.array(["n", "#", "b"])
-
-
-def estimate_spelling(note_info, method="ps13s1", **kwargs):
-    """Estimate pitch spelling using the ps13 algorithm [4]_, [5]_.
-
-    Parameters
-    ----------
-    note_info : structured array, `Part` or `PerformedPart`
-        Note information as a `Part` or `PerformedPart` instances or
-        as a structured array. If it is a structured array, it has to
-        contain the fields generated by the `note_array` properties
-        of `Part` or `PerformedPart` objects. If the array contains
-        onset and duration information of both score and performance,
-        (e.g., containing both `onset_beat` and `onset_sec`), the score
-        information will be preferred.
-    method : {'ps13s1'}
-         Pitch spelling algorithm. More methods will be added.
-    **kwargs
-        Keyword arguments for the algorithm specified in `method`.
-
-    Returns
-    -------
-    spelling : structured array
-        Array with pitch spellings. The fields are 'step', 'alter' and
-        'octave'
-
-    References
-    ----------
-    .. [4] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
-           of New Music Research, 35(2):121.
-    .. [5] Meredith, D. (2019). "RecurSIA-RRT: Recursive translatable
-           point-set pattern discovery with removal of redundant translators".
-           12th International Workshop on Machine Learning and Music. Würzburg,
-           Germany.
-
-    """
-    if method == "ps13s1":
-        ps = ps13s1
-    step, alter, octave = ps(ensure_notearray(note_info), **kwargs)
-
-    spelling = np.empty(
-        len(step), dtype=[("step", "U1"), ("alter", int), ("octave", int)]
-    )
-
-    spelling["step"] = step
-    spelling["alter"] = alter
-    spelling["octave"] = octave
-
-    return spelling
-
-
-def ps13s1(note_array, K_pre=10, K_post=40):
-    """
-    ps13s1 Pitch Spelling Algorithm
-    """
-
-    onset_unit, _ = get_time_units_from_note_array(note_array)
-    pitch_sort_idx = note_array["pitch"].argsort()
-
-    onset_sort_idx = np.argsort(
-        note_array[pitch_sort_idx][onset_unit], kind="mergesort"
-    )
-
-    sort_idx = pitch_sort_idx[onset_sort_idx]
-
-    re_idx = sort_idx.argsort()  # o_idx[sort_idx]
-
-    sorted_ocp = np.column_stack(
-        (
-            note_array[sort_idx][onset_unit],
-            chromatic_pitch_from_midi(note_array[sort_idx]["pitch"]),
-        )
-    )
-
-    # n = len(sorted_ocp)
-    # ChromaList
-    chroma_array = compute_chroma_array(sorted_ocp=sorted_ocp)
-    # ChromaVectorList
-    chroma_vector_array = compute_chroma_vector_array(
-        chroma_array=chroma_array, K_pre=K_pre, K_post=K_post
-    )
-    morph_array = compute_morph_array(
-        chroma_array=chroma_array, chroma_vector_array=chroma_vector_array
-    )
-
-    morphetic_pitch = compute_morphetic_pitch(sorted_ocp, morph_array)
-
-    step, alter, octave = p2pn(
-        sorted_ocp[:, 1],
-        morphetic_pitch.reshape(
-            -1,
-        ),
-    )
-    # sort back pitch names
-    step = step[re_idx]
-    alter = alter[re_idx]
-    octave = octave[re_idx]
-
-    return step, alter, octave
-
-
-def chromatic_pitch_from_midi(midi_pitch):
-    return midi_pitch - 21
-
-
-def chroma_from_chromatic_pitch(chromatic_pitch):
-    return np.mod(chromatic_pitch, 12)
-
-
-def pitch_class_from_chroma(chroma):
-    return np.mod(chroma - 3, 12)
-
-
-def compute_chroma_array(sorted_ocp):
-    return chroma_from_chromatic_pitch(sorted_ocp[:, 1]).astype(int)
-
-
-def compute_chroma_vector_array(chroma_array, K_pre, K_post):
-    """
-    Computes the chroma frequency distribution within the context surrounding
-    each note.
-    """
-    n = len(chroma_array)
-    chroma_vector = np.zeros(12, dtype=int)
-
-    for i in range(np.minimum(n, K_post)):
-        chroma_vector[chroma_array[i]] = 1 + chroma_vector[chroma_array[i]]
-
-    chroma_vector_list = [chroma_vector.copy()]
-
-    for i in range(1, n):
-        if i + K_post <= n:
-            chroma_vector[chroma_array[i + K_post - 1]] = (
-                1 + chroma_vector[chroma_array[i + K_post - 1]]
-            )
-
-        if i - K_pre > 0:
-            chroma_vector[chroma_array[i - K_pre - 1]] = (
-                chroma_vector[chroma_array[i - K_pre - 1]] - 1
-            )
-
-        chroma_vector_list.append(chroma_vector.copy())
-
-    return np.array(chroma_vector_list)
-
-
-def compute_morph_array(chroma_array, chroma_vector_array):
-
-    n = len(chroma_array)
-    # Line 1: Initialize morph array
-    morph_array = np.empty(n, dtype=int)
-
-    # Compute m0
-    # Line 2
-    init_morph = np.array([0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6], dtype=int)
-    # Line 3
-    c0 = chroma_array[0]
-    # Line 4
-    m0 = init_morph[c0]
-
-    # Line 5
-    morph_int = np.array([0, 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6], dtype=int)
-
-    # Lines 6-8
-    tonic_morph_for_tonic_chroma = np.mod(
-        m0 - morph_int[np.mod(c0 - np.arange(12), 12)], 7
-    )
-
-    # Line 10
-    tonic_chroma_set_for_morph = [[] for i in range(7)]
-
-    # Line 11
-    morph_strength = np.zeros(7, dtype=int)
-
-    # Line 12
-    for j in range(n):
-        # Lines 13-15 (skipped line 9, since we do not need to
-        # initialize morph_for_tonic_chroma)
-        morph_for_tonic_chroma = np.mod(
-            morph_int[np.mod(chroma_array[j] - np.arange(12), 12)]
-            + tonic_morph_for_tonic_chroma,
-            7,
-        )
-        # Lines 16-17
-        tonic_chroma_set_for_morph = [[] for i in range(7)]
-
-        # Line 18
-        for m in range(7):
-            # Line 19
-            for ct in range(12):
-                # Line 20
-                if morph_for_tonic_chroma[ct] == m:
-                    # Line 21
-                    tonic_chroma_set_for_morph[m].append(ct)
-
-        # Line 22
-        for m in range(7):
-            # Line 23
-            morph_strength[m] = sum(
-                [chroma_vector_array[j, ct] for ct in tonic_chroma_set_for_morph[m]]
-            )
-
-        # Line 24
-        morph_array[j] = np.argmax(morph_strength)
-
-    return morph_array
-
-
-def compute_ocm_chord_list(sorted_ocp, chroma_array, morph_array):
-
-    # Lines 1-3
-    ocm_array = np.column_stack((sorted_ocp[:, 0], chroma_array, morph_array)).astype(
-        int
-    )
-
-    # Alternative implementation of lines 4--9
-    unique_onsets = np.unique(ocm_array[:, 0])
-    unique_onset_idxs = [np.where(ocm_array[:, 0] == u) for u in unique_onsets]
-    ocm_chord_list = [ocm_array[uix] for uix in unique_onset_idxs]
-
-    return ocm_chord_list
-
-
-def compute_morphetic_pitch(sorted_ocp, morph_array):
-    """
-    Compute morphetic pitch
-
-    Parameters
-    ----------
-    sorted_ocp : array
-       Sorted array of (onset in beats, chromatic pitch)
-    morph_array : array
-       Array of morphs
-
-    Returns
-    -------
-    morphetic_pitch : array
-        Morphetic pitch of the notes
-    """
-    n = len(sorted_ocp)
-    chromatic_pitch = sorted_ocp[:, 1]
-    morph = morph_array.reshape(-1, 1)
-
-    morph_oct_1 = np.floor(chromatic_pitch / 12.0).astype(int)
-
-    morph_octs = np.column_stack((morph_oct_1, morph_oct_1 + 1, morph_oct_1 - 1))
-
-    chroma = np.mod(chromatic_pitch, 12)
-
-    mps = morph_octs + (morph / 7)
-
-    cp = (morph_oct_1 + (chroma / 12)).reshape(-1, 1)
-
-    diffs = abs(cp - mps)
-
-    best_morph_oct = morph_octs[np.arange(n), diffs.argmin(1)]
-
-    morphetic_pitch = (
-        morph.reshape(
-            -1,
-        )
-        + 7 * best_morph_oct
-    )
-
-    return morphetic_pitch
-
-
-def p2pn(c_pitch, m_pitch):
-    """
-    Chromamorphetic pitch to pitch name
-
-    Parameters
-    ----------
-    c_pitch : int or array
-        Chromatic pitch.
-    m_pitch : int or array
-        Morphetic pitch.
-
-    Returns
-    -------
-    step : str or array
-        Note name (step)
-    alter : int or array
-        Alteration(s) of the notes. 1 is sharp, -1 is flat and 0 is natural
-    octave : int or array
-        Octave
-    """
-    morph = np.mod(m_pitch, 7)
-
-    step = STEPS[morph]
-    undisplaced_chroma = UND_CHROMA[morph]
-
-    # displacement in paper
-    alter = c_pitch - 12 * np.floor(m_pitch / 7.0) - undisplaced_chroma
-
-    asa_octave = np.floor(m_pitch / 7)
-
-    if isinstance(morph, (int, float)):
-        if morph > 1:
-            asa_octave += 1
-    else:
-        asa_octave[morph > 1] += 1
-
-    return step, alter, asa_octave
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+"""
+This module contains methods for estimation pitch spelling using the ps13 algorithm.
+
+References
+----------
+.. [4] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
+       of New Music Research, 35(2):121.
+"""
+import numpy as np
+from collections import namedtuple
+from partitura.utils import ensure_notearray, get_time_units_from_note_array
+
+# from partitura.musicanalysis.utils import prepare_notearray
+
+
+__all__ = ["estimate_spelling"]
+
+ChromamorpheticPitch = namedtuple(
+    "ChromamorpheticPitch", "chromatic_pitch morphetic_pitch"
+)
+
+STEPS = np.array(["A", "B", "C", "D", "E", "F", "G"])
+UND_CHROMA = np.array([0, 2, 3, 5, 7, 8, 10], dtype=int)
+ALTER = np.array(["n", "#", "b"])
+
+
+def estimate_spelling(note_info, method="ps13s1", **kwargs):
+    """Estimate pitch spelling using the ps13 algorithm [4]_, [5]_.
+
+    Parameters
+    ----------
+    note_info : structured array, `Part` or `PerformedPart`
+        Note information as a `Part` or `PerformedPart` instances or
+        as a structured array. If it is a structured array, it has to
+        contain the fields generated by the `note_array` properties
+        of `Part` or `PerformedPart` objects. If the array contains
+        onset and duration information of both score and performance,
+        (e.g., containing both `onset_beat` and `onset_sec`), the score
+        information will be preferred.
+    method : {'ps13s1'}
+         Pitch spelling algorithm. More methods will be added.
+    **kwargs
+        Keyword arguments for the algorithm specified in `method`.
+
+    Returns
+    -------
+    spelling : structured array
+        Array with pitch spellings. The fields are 'step', 'alter' and
+        'octave'
+
+    References
+    ----------
+    .. [4] Meredith, D. (2006). "The ps13 Pitch Spelling Algorithm". Journal
+           of New Music Research, 35(2):121.
+    .. [5] Meredith, D. (2019). "RecurSIA-RRT: Recursive translatable
+           point-set pattern discovery with removal of redundant translators".
+           12th International Workshop on Machine Learning and Music. Würzburg,
+           Germany.
+
+    """
+    if method == "ps13s1":
+        ps = ps13s1
+    step, alter, octave = ps(ensure_notearray(note_info), **kwargs)
+
+    spelling = np.empty(
+        len(step), dtype=[("step", "U1"), ("alter", int), ("octave", int)]
+    )
+
+    spelling["step"] = step
+    spelling["alter"] = alter
+    spelling["octave"] = octave
+
+    return spelling
+
+
+def ps13s1(note_array, K_pre=10, K_post=40):
+    """
+    ps13s1 Pitch Spelling Algorithm
+    """
+
+    onset_unit, _ = get_time_units_from_note_array(note_array)
+    pitch_sort_idx = note_array["pitch"].argsort()
+
+    onset_sort_idx = np.argsort(
+        note_array[pitch_sort_idx][onset_unit], kind="mergesort"
+    )
+
+    sort_idx = pitch_sort_idx[onset_sort_idx]
+
+    re_idx = sort_idx.argsort()  # o_idx[sort_idx]
+
+    sorted_ocp = np.column_stack(
+        (
+            note_array[sort_idx][onset_unit],
+            chromatic_pitch_from_midi(note_array[sort_idx]["pitch"]),
+        )
+    )
+
+    # n = len(sorted_ocp)
+    # ChromaList
+    chroma_array = compute_chroma_array(sorted_ocp=sorted_ocp)
+    # ChromaVectorList
+    chroma_vector_array = compute_chroma_vector_array(
+        chroma_array=chroma_array, K_pre=K_pre, K_post=K_post
+    )
+    morph_array = compute_morph_array(
+        chroma_array=chroma_array, chroma_vector_array=chroma_vector_array
+    )
+
+    morphetic_pitch = compute_morphetic_pitch(sorted_ocp, morph_array)
+
+    step, alter, octave = p2pn(
+        sorted_ocp[:, 1],
+        morphetic_pitch.reshape(
+            -1,
+        ),
+    )
+    # sort back pitch names
+    step = step[re_idx]
+    alter = alter[re_idx]
+    octave = octave[re_idx]
+
+    return step, alter, octave
+
+
+def chromatic_pitch_from_midi(midi_pitch):
+    return midi_pitch - 21
+
+
+def chroma_from_chromatic_pitch(chromatic_pitch):
+    return np.mod(chromatic_pitch, 12)
+
+
+def pitch_class_from_chroma(chroma):
+    return np.mod(chroma - 3, 12)
+
+
+def compute_chroma_array(sorted_ocp):
+    return chroma_from_chromatic_pitch(sorted_ocp[:, 1]).astype(int)
+
+
+def compute_chroma_vector_array(chroma_array, K_pre, K_post):
+    """
+    Computes the chroma frequency distribution within the context surrounding
+    each note.
+    """
+    n = len(chroma_array)
+    chroma_vector = np.zeros(12, dtype=int)
+
+    for i in range(np.minimum(n, K_post)):
+        chroma_vector[chroma_array[i]] = 1 + chroma_vector[chroma_array[i]]
+
+    chroma_vector_list = [chroma_vector.copy()]
+
+    for i in range(1, n):
+        if i + K_post <= n:
+            chroma_vector[chroma_array[i + K_post - 1]] = (
+                1 + chroma_vector[chroma_array[i + K_post - 1]]
+            )
+
+        if i - K_pre > 0:
+            chroma_vector[chroma_array[i - K_pre - 1]] = (
+                chroma_vector[chroma_array[i - K_pre - 1]] - 1
+            )
+
+        chroma_vector_list.append(chroma_vector.copy())
+
+    return np.array(chroma_vector_list)
+
+
+def compute_morph_array(chroma_array, chroma_vector_array):
+
+    n = len(chroma_array)
+    # Line 1: Initialize morph array
+    morph_array = np.empty(n, dtype=int)
+
+    # Compute m0
+    # Line 2
+    init_morph = np.array([0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6], dtype=int)
+    # Line 3
+    c0 = chroma_array[0]
+    # Line 4
+    m0 = init_morph[c0]
+
+    # Line 5
+    morph_int = np.array([0, 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6], dtype=int)
+
+    # Lines 6-8
+    tonic_morph_for_tonic_chroma = np.mod(
+        m0 - morph_int[np.mod(c0 - np.arange(12), 12)], 7
+    )
+
+    # Line 10
+    tonic_chroma_set_for_morph = [[] for i in range(7)]
+
+    # Line 11
+    morph_strength = np.zeros(7, dtype=int)
+
+    # Line 12
+    for j in range(n):
+        # Lines 13-15 (skipped line 9, since we do not need to
+        # initialize morph_for_tonic_chroma)
+        morph_for_tonic_chroma = np.mod(
+            morph_int[np.mod(chroma_array[j] - np.arange(12), 12)]
+            + tonic_morph_for_tonic_chroma,
+            7,
+        )
+        # Lines 16-17
+        tonic_chroma_set_for_morph = [[] for i in range(7)]
+
+        # Line 18
+        for m in range(7):
+            # Line 19
+            for ct in range(12):
+                # Line 20
+                if morph_for_tonic_chroma[ct] == m:
+                    # Line 21
+                    tonic_chroma_set_for_morph[m].append(ct)
+
+        # Line 22
+        for m in range(7):
+            # Line 23
+            morph_strength[m] = sum(
+                [chroma_vector_array[j, ct] for ct in tonic_chroma_set_for_morph[m]]
+            )
+
+        # Line 24
+        morph_array[j] = np.argmax(morph_strength)
+
+    return morph_array
+
+
+def compute_ocm_chord_list(sorted_ocp, chroma_array, morph_array):
+
+    # Lines 1-3
+    ocm_array = np.column_stack((sorted_ocp[:, 0], chroma_array, morph_array)).astype(
+        int
+    )
+
+    # Alternative implementation of lines 4--9
+    unique_onsets = np.unique(ocm_array[:, 0])
+    unique_onset_idxs = [np.where(ocm_array[:, 0] == u) for u in unique_onsets]
+    ocm_chord_list = [ocm_array[uix] for uix in unique_onset_idxs]
+
+    return ocm_chord_list
+
+
+def compute_morphetic_pitch(sorted_ocp, morph_array):
+    """
+    Compute morphetic pitch
+
+    Parameters
+    ----------
+    sorted_ocp : array
+       Sorted array of (onset in beats, chromatic pitch)
+    morph_array : array
+       Array of morphs
+
+    Returns
+    -------
+    morphetic_pitch : array
+        Morphetic pitch of the notes
+    """
+    n = len(sorted_ocp)
+    chromatic_pitch = sorted_ocp[:, 1]
+    morph = morph_array.reshape(-1, 1)
+
+    morph_oct_1 = np.floor(chromatic_pitch / 12.0).astype(int)
+
+    morph_octs = np.column_stack((morph_oct_1, morph_oct_1 + 1, morph_oct_1 - 1))
+
+    chroma = np.mod(chromatic_pitch, 12)
+
+    mps = morph_octs + (morph / 7)
+
+    cp = (morph_oct_1 + (chroma / 12)).reshape(-1, 1)
+
+    diffs = abs(cp - mps)
+
+    best_morph_oct = morph_octs[np.arange(n), diffs.argmin(1)]
+
+    morphetic_pitch = (
+        morph.reshape(
+            -1,
+        )
+        + 7 * best_morph_oct
+    )
+
+    return morphetic_pitch
+
+
+def p2pn(c_pitch, m_pitch):
+    """
+    Chromamorphetic pitch to pitch name
+
+    Parameters
+    ----------
+    c_pitch : int or array
+        Chromatic pitch.
+    m_pitch : int or array
+        Morphetic pitch.
+
+    Returns
+    -------
+    step : str or array
+        Note name (step)
+    alter : int or array
+        Alteration(s) of the notes. 1 is sharp, -1 is flat and 0 is natural
+    octave : int or array
+        Octave
+    """
+    morph = np.mod(m_pitch, 7)
+
+    step = STEPS[morph]
+    undisplaced_chroma = UND_CHROMA[morph]
+
+    # displacement in paper
+    alter = c_pitch - 12 * np.floor(m_pitch / 7.0) - undisplaced_chroma
+
+    asa_octave = np.floor(m_pitch / 7)
+
+    if isinstance(morph, (int, float)):
+        if morph > 1:
+            asa_octave += 1
+    else:
+        asa_octave[morph > 1] += 1
+
+    return step, alter, asa_octave
```

### Comparing `partitura-1.2.1/partitura/score.py` & `partitura-1.2.2/partitura/score.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,4728 +1,4910 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-This module defines an ontology of musical elements to represent
-musical scores, such as measures, notes, slurs, words, tempo and
-loudness directions. A score is defined at the highest level by a
-`Part` object (or a hierarchy of `Part` objects, in a `PartGroup`
-object). This object serves as a timeline at which musical elements
-are registered in terms of their start and end times.
-"""
-
-from copy import copy
-from collections import defaultdict
-from collections.abc import Iterable
-from numbers import Number
-
-# import copy
-from partitura.utils.music import MUSICAL_BEATS
-import warnings
-import numpy as np
-from scipy.interpolate import PPoly
-from typing import Union, List, Optional, Iterator, Iterable as Itertype
-
-from partitura.utils import (
-    ComparableMixin,
-    ReplaceRefMixin,
-    iter_subclasses,
-    iter_current_next,
-    sorted_dict_items,
-    PrettyPrintTree,
-    ALTER_SIGNS,
-    find_tie_split,
-    format_symbolic_duration,
-    estimate_symbolic_duration,
-    symbolic_to_numeric_duration,
-    fifths_mode_to_key_name,
-    pitch_spelling_to_midi_pitch,
-    note_array_from_part,
-    rest_array_from_part,
-    rest_array_from_part_list,
-    note_array_from_part_list,
-    to_quarter_tempo,
-    key_mode_to_int,
-    _OrderedSet,
-    update_note_ids_after_unfolding,
-)
-
-from partitura.utils.generic import interp1d
-
-
-class Part(object):
-    """Represents a score part, e.g. all notes of one single instrument
-    (or multiple instruments written in the same staff). Note that
-    there may be more than one staff per score part.
-
-    Parameters
-    ----------
-    id : str
-        The identifier of the part. In order to be compatible with
-        MusicXML the identifier should not start with a number.
-    part_name : str or None, optional
-        Name for the part. Defaults to None
-    part_abbreviation : str or None, optional
-        Abbreviated name for part
-    quarter_duration : int, optional
-        The default quarter duration. See
-        :meth:`~partitura.score.Part.set_quarter_duration` for
-        details.
-
-    Attributes
-    ----------
-    id : str
-        See parameters
-    part_name : str
-        See parameters
-    part_abbreviation : str
-        See parameters
-
-    """
-
-    def __init__(self, id, part_name=None, part_abbreviation=None, quarter_duration=1):
-        super().__init__()
-        self.id = id
-        self.parent = None
-        self.part_name = part_name
-        self.part_abbreviation = part_abbreviation
-
-        # timeline init
-        self._points = np.array([], dtype=TimePoint)
-        self._quarter_times = [0]
-        self._quarter_durations = [quarter_duration]
-        self._quarter_map = self.quarter_duration_map
-
-        # set beat reference
-        self._use_musical_beat = False
-        
-        # store number of staves
-        self._number_of_staves = None
-
-    def __str__(self):
-        return 'Part id="{}" name="{}"'.format(self.id, self.part_name)
-
-    def _pp(self, tree):
-        result = [self.__str__()]
-        tree.push()
-        N = len(self._points)
-        for i, timepoint in enumerate(self._points):
-            result.append("{}".format(tree).rstrip())
-            if i == N - 1:
-                tree.last_item()
-            else:
-                tree.next_item()
-            result.extend(timepoint._pp(tree))
-        tree.pop()
-        return result
-
-    def pretty(self):
-        """Return a pretty representation of this object.
-
-        Returns
-        -------
-        str
-            A pretty representation
-
-        """
-        return "\n".join(self._pp(PrettyPrintTree()))
-
-    @property
-    def time_signature_map(self):
-        """A function mapping timeline times to the beats and beat_type
-        of the time signature at that time. The function can take
-        scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        tss = np.array(
-            [
-                (ts.start.t, ts.beats, ts.beat_type, ts.musical_beats)
-                for ts in self.iter_all(TimeSignature)
-            ]
-        )
-
-        if len(tss) == 0:
-            # default time sig
-            beats, beat_type = 4, 4
-            warnings.warn(
-                "No time signatures found, assuming {}/{}".format(beats, beat_type)
-            )
-            if self.first_point is None:
-                t0, tN = 0, 0
-            else:
-                t0 = self.first_point.t
-                tN = self.last_point.t
-            tss = np.array(
-                [
-                    (t0, beats, beat_type),
-                    (tN, beats, beat_type),
-                ]
-            )
-        elif len(tss) == 1:
-            # If there is only a single time signature
-            tss = np.array([tss[0, :], tss[0, :]])
-        elif tss[0, 0] > self.first_point.t:
-            tss = np.vstack(((self.first_point.t, tss[0, 1], tss[0, 2]), tss))
-
-        return interp1d(
-            tss[:, 0],
-            tss[:, 1:],
-            axis=0,
-            kind="previous",
-            bounds_error=False,
-            fill_value="extrapolate",
-        )
-
-    @property
-    def key_signature_map(self):
-        """A function mappting timeline times to the key and mode of
-        the key signature at that time. The function can take scalar
-        values or lists/arrays of values
-
-        Returns
-        -------
-        function
-            The mapping function
-        """
-        kss = np.array(
-            [
-                (ks.start.t, ks.fifths, key_mode_to_int(ks.mode))
-                for ks in self.iter_all(KeySignature)
-            ]
-        )
-
-        if len(kss) == 0:
-            # default key signature
-            fifths, mode = 0, 1
-            warnings.warn("No key signature found, assuming C major")
-            if self.first_point is None:
-                t0, tN = 0, 0
-            else:
-                t0 = self.first_point.t
-                tN = self.first_point.t
-
-            kss = np.array([(t0, fifths, mode), (tN, fifths, mode)])
-
-        elif kss[0, 0] > self.first_point.t:
-            kss = np.vstack(((self.first_point.t, kss[0, 1], kss[0, 2]), kss))
-
-        return interp1d(
-            kss[:, 0],
-            kss[:, 1:],
-            axis=0,
-            kind="previous",
-            bounds_error=False,
-            fill_value="extrapolate",
-        )
-
-    @property
-    def measure_map(self):
-        """A function mapping timeline times to the start and end of
-        the measure they are contained in. The function can take
-        scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        measures = np.array([(m.start.t, m.end.t) for m in self.iter_all(Measure)])
-
-        # correct for anacrusis
-        divs_per_beat = self.inv_beat_map(
-            1 + self.beat_map(0)
-        )  # find the divs per beat in the first measure
-        if (
-            measures[0][1] - measures[0][0]
-            < self.time_signature_map(0)[0] * divs_per_beat
-        ):
-            measures[0][0] = (
-                measures[0][1] - self.time_signature_map(0)[0] * divs_per_beat
-            )
-
-        if len(measures) == 0:  # no measures in the piece
-            # default only one measure spanning the entire timeline
-            warnings.warn("No measures found, assuming only one measure")
-            if self.first_point is None:
-                t0, tN = 0, 0
-            else:
-                t0 = self.first_point.t
-                tN = self.last_point.t
-
-            measures = np.array([(t0, tN)])
-
-        inter_function = interp1d(
-            measures[:, 0],
-            measures[:, :].astype(int),
-            kind="previous",
-            axis=0,
-            fill_value="extrapolate",
-            dtype=int,
-        )
-
-        return inter_function
-
-    @property
-    def measure_number_map(self):
-        """A function mapping timeline times to the measure number of
-        the measure they are contained in. The function can take
-        scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        # operations to avoid None values and filter them efficiently.
-        m_it = self.measures
-        measures = np.array(
-            [
-                [
-                    m.start.t,
-                    m.end.t,
-                    (m_it[i - 1].number if m.number == None else m.number),
-                ]
-                for i, m in enumerate(m_it)
-            ]
-        )
-        # correct for anacrusis
-        divs_per_beat = self.inv_beat_map(
-            1 + self.beat_map(0)
-        )  # find the divs per beat in the first measure
-        if (
-            measures[0][1] - measures[0][0]
-            < self.time_signature_map(0)[0] * divs_per_beat
-        ):
-            measures[0][0] = (
-                measures[0][1] - self.time_signature_map(0)[0] * divs_per_beat
-            )
-
-        if len(measures) == 0:  # no measures in the piece
-            # default only one measure spanning the entire timeline
-            warnings.warn("No measures found, assuming only one measure")
-            if self.first_point is None:
-                t0, tN = 0, 0
-            else:
-                t0 = self.first_point.t
-                tN = self.last_point.t
-
-            measures = np.array([(t0, tN, 1)])
-
-        inter_function = interp1d(
-            measures[:, 0],
-            measures[:, 2],
-            kind="previous",
-            fill_value="extrapolate",
-            dtype=int,
-        )
-
-        return inter_function
-
-    @property
-    def metrical_position_map(self):
-        """A function mapping timeline times to their relative position in
-        the measure they are contained in. The function can take
-        scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        measure_map = self.measure_map
-        ms = [measure_map(m.start.t)[0] for m in self.iter_all(Measure)]
-        me = [measure_map(m.start.t)[1] for m in self.iter_all(Measure)]
-
-        if len(ms) < 2:
-            warnings.warn("No or single measures found, metrical position 0 everywhere")
-            zero_interpolator = interp1d(
-                np.arange(0, 2),
-                np.zeros((2, 2)),
-                axis=0,
-                kind="linear",
-                fill_value="extrapolate",
-                dtype=int,
-            )
-
-            return zero_interpolator
-        else:
-            barlines = np.array(ms + me[-1:])
-            bar_durations = np.diff(barlines)
-            measure_inter_function = interp1d(
-                barlines[:-1],
-                bar_durations,
-                axis=0,
-                kind="previous",
-                fill_value="extrapolate",
-            )
-
-            lin_poly_coeff = np.row_stack(
-                (np.ones(bar_durations.shape[0]), np.zeros(bar_durations.shape[0]))
-            )
-            inter_function = PPoly(lin_poly_coeff, barlines)
-
-            def int_interp1d(input):
-                if isinstance(input, Iterable):
-                    return np.column_stack(
-                        (
-                            inter_function(input).astype(int),
-                            measure_inter_function(input).astype(int),
-                        )
-                    )
-                else:
-                    return (
-                        inter_function(input).astype(int),
-                        measure_inter_function(input).astype(int),
-                    )
-
-            return int_interp1d
-
-    def _time_interpolator(self, quarter=False, inv=False, musical_beat=False):
-
-        if len(self._points) < 2:
-            return lambda x: np.zeros(len(x))
-
-        keypoints = defaultdict(lambda: [None, None])
-        _ = keypoints[self.first_point.t]
-        _ = keypoints[self.last_point.t]
-        for t, q in zip(self._quarter_times, self._quarter_durations):
-            keypoints[t][0] = q
-        if not quarter:
-            for ts in self.iter_all(TimeSignature):
-                # keypoints[ts.start.t][1] = int(np.log2(ts.beat_type))
-                if musical_beat:
-                    keypoints[ts.start.t][1] = (ts.beat_type / 4) * (
-                        ts.musical_beats / ts.beats
-                    )
-                else:
-                    keypoints[ts.start.t][1] = ts.beat_type / 4
-        cur_div = 1
-        cur_bt = 1
-        keypoints_list = []
-
-        for t in sorted(keypoints.keys()):
-            kp = keypoints[t]
-            if kp[0] is None:
-                kp[0] = cur_div
-            else:
-                cur_div = kp[0]
-            if kp[1] is None:
-                kp[1] = cur_bt
-            else:
-                cur_bt = kp[1]
-            if not keypoints_list or kp != keypoints_list[-1]:
-                keypoints_list.append([t] + kp)
-        keypoints = np.array(keypoints_list, dtype=float)
-
-        x = keypoints[:, 0]
-        y = np.r_[
-            0,
-            np.cumsum(
-                (keypoints[:-1, 2] * np.diff(keypoints[:, 0])) / keypoints[:-1, 1]
-            ),
-        ]
-
-        m1 = next(self.first_point.iter_starting(Measure), None)
-
-        if m1 and m1.start is not None and m1.end is not None:
-
-            f = interp1d(x, y)
-            actual_dur = np.diff(f((m1.start.t, m1.end.t)))[0]
-            ts = next(m1.start.iter_starting(TimeSignature), None)
-
-            if ts:
-
-                normal_dur = ts.beats
-                if quarter:
-                    normal_dur *= 4 / ts.beat_type
-                if musical_beat:
-                    normal_dur = ts.musical_beats
-                if actual_dur < normal_dur:
-                    y -= actual_dur
-            else:
-                # warn
-                pass
-
-        if inv:
-            return interp1d(y, x)
-        else:
-            return interp1d(x, y)
-
-    @property
-    def beat_map(self):
-        """A function mapping timeline times to beat times. The function
-        can take scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        if self._use_musical_beat:
-            return self._time_interpolator(musical_beat=True)
-        else:
-            return self._time_interpolator()
-
-    @property
-    def inv_beat_map(self):
-        """A function mapping beat times to timeline times. The function
-        can take scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        if self._use_musical_beat:
-            return self._time_interpolator(inv=True, musical_beat=True)
-        else:
-            return self._time_interpolator(inv=True)
-
-    @property
-    def quarter_map(self):
-        """A function mapping timeline times to quarter times. The
-        function can take scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        return self._time_interpolator(quarter=True)
-
-    @property
-    def inv_quarter_map(self):
-        """A function mapping quarter times to timeline times. The
-        function can take scalar values or lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        return self._time_interpolator(quarter=True, inv=True)
-
-    @property
-    def notes(self):
-        """Return a list of all Note objects in the part. This list includes
-        GraceNote objects but not Rest objects.
-
-        Returns
-        -------
-        list
-            list of Note objects
-
-        """
-        return list(self.iter_all(Note, include_subclasses=True))
-
-    @property
-    def notes_tied(self):
-        """Return a list of all Note objects in the part that are
-        either not tied, or the first note of a group of tied notes.
-        This list includes GraceNote objects but not Rest objects.
-
-        Returns
-        -------
-        list
-            List of Note objects
-
-        """
-        return [
-            note
-            for note in self.iter_all(Note, include_subclasses=True)
-            if note.tie_prev is None
-        ]
-
-    @property
-    def measures(self):
-        """Return a list of all Measure objects in the part
-
-        Returns
-        -------
-        list
-            List of Measure objects
-
-        """
-        return [e for e in self.iter_all(Measure, include_subclasses=False)]
-
-    @property
-    def rests(self):
-        """Return a list of all rest objects in the part
-
-        Returns
-        -------
-        list
-            List of Rest objects
-
-        """
-        return [e for e in self.iter_all(Rest, include_subclasses=False)]
-
-    @property
-    def repeats(self):
-        """Return a list of all Repeat objects in the part
-
-        Returns
-        -------
-        list
-            List of Repeat objects
-
-        """
-        return [e for e in self.iter_all(Repeat, include_subclasses=False)]
-
-    @property
-    def key_sigs(self):
-        """Return a list of all Key Signature objects in the part
-
-        Returns
-        -------
-        list
-            List of Key Signature objects
-
-        """
-        return [e for e in self.iter_all(KeySignature, include_subclasses=False)]
-
-    @property
-    def time_sigs(self):
-        """Return a list of all Time Signature objects in the part
-
-        Returns
-        -------
-        list
-            List of Time Signature objects
-
-        """
-        return [e for e in self.iter_all(TimeSignature, include_subclasses=False)]
-
-    @property
-    def dynamics(self):
-        """Return a list of all Dynamics markings in the part
-
-        Returns
-        -------
-        list
-            List of Dynamics objects
-
-        """
-        return [e for e in self.iter_all(LoudnessDirection, include_subclasses=True)]
-
-    @property
-    def articulations(self):
-        """Return a list of all Articulation markings in the part
-
-        Returns
-        -------
-        list
-            List of Articulation objects
-
-        """
-        return [
-            e for e in self.iter_all(ArticulationDirection, include_subclasses=True)
-        ]
-
-    def quarter_durations(self, start=None, end=None):
-        """Return an Nx2 array with quarter duration (second column)
-        and their respective times (first column).
-
-        When a start and or end time is specified, the returned
-        array will contain only the entries within those bounds.
-
-        Parameters
-        ----------
-        start : number, optional
-            Start of range
-        end : number, optional
-            End of range
-
-        Returns
-        -------
-        ndarray
-            An array with quarter durations and times
-
-        """
-
-        qd = np.column_stack((self._quarter_times, self._quarter_durations))
-        if start is not None:
-            qd = qd[qd[:, 0] >= start, :]
-        if end is not None:
-            qd = qd[qd[:, 0] < end, :]
-        return qd
-
-    @property
-    def quarter_duration_map(self):
-        """A function mapping timeline times to quarter durations in
-        effect at those times. The function can take scalar values or
-        lists/arrays of values.
-
-        Returns
-        -------
-        function
-            The mapping function
-
-        """
-        x = self._quarter_times
-        y = self._quarter_durations
-        if len(x) == 1:
-            x = x + x
-            y = y + y
-        return interp1d(
-            x, y, kind="previous", bounds_error=False, fill_value=(y[0], y[-1])
-        )
-
-    def set_quarter_duration(self, t, quarter):
-        """Set the duration of a quarter note from timepoint `t`
-        onwards.
-
-        Setting the quarter note duration defines how intervals
-        between timepoints are related to musical durations. For
-        example when two timepoints `t1` and `t2` have associated
-        times 10 and 20 respecively, then the interval between `t1`
-        and `t2` corresponds to a half note when the quarter duration
-        equals 5 during that interval.
-
-        The quarter duration can vary throughout the part. When
-        setting a quarter duration at time t, then that value takes
-        effect until the time of the next quarter duration. If a
-        different quarter duration was already set at time t, it wil
-        be replaced.
-
-        Note setting the quarter duration does not change the
-        timepoints, only the relation to musical time. For
-        illustration: in the example above, when changing the current
-        quarter duration from 5 to 10, a note that starts at `t1` and
-        ends at `t2` will change from being a half note to being a
-        quarter note.
-
-        Parameters
-        ----------
-        t : int
-            Time at which to set the quarter duration
-        quarter : int
-            The quarter duration
-
-        """
-
-        # add quarter duration at time t, unless it is redundant. If another
-        # quarter duration is at t, replace it.
-
-        # shorthand
-        times = self._quarter_times
-        quarters = self._quarter_durations
-
-        i = np.searchsorted(times, t)
-        changed = False
-
-        if i == 0 or quarters[i - 1] != quarter:
-            # add or replace
-            if i == len(times) or times[i] != t:
-                # add
-                times.insert(i, t)
-                quarters.insert(i, quarter)
-                changed = True
-            elif quarters[i] != quarter:
-                # replace
-                quarters[i] = quarter
-                changed = True
-            else:
-                # times[i] == t, quarters[i] == quarter
-                pass
-
-        if not changed:
-            return
-
-        if i + 1 == len(times):
-            t_next = np.inf
-        else:
-            t_next = times[i + 1]
-
-        # update quarter attribute of all timepoints in the range [t, t_next]
-        start_idx = np.searchsorted(self._points, TimePoint(t))
-        end_idx = np.searchsorted(self._points, TimePoint(t_next))
-        for tp in self._points[start_idx:end_idx]:
-            tp.quarter = quarter
-
-        # update the interpolation function
-        self._quarter_map = self.quarter_duration_map
-
-    def _add_point(self, tp):
-        # Add `TimePoint` object `tp` to the part, unless there is
-        # already a timepoint at the same time.
-
-        i = np.searchsorted(self._points, tp)
-        if i == len(self._points) or self._points[i].t != tp.t:
-            self._points = np.insert(self._points, i, tp)
-            if i > 0:
-                self._points[i - 1].next = self._points[i]
-                self._points[i].prev = self._points[i - 1]
-            if i < len(self._points) - 1:
-                self._points[i].next = self._points[i + 1]
-                self._points[i + 1].prev = self._points[i]
-
-    @property
-    def number_of_staves(self):
-        if self._number_of_staves is not None:
-            return self._number_of_staves
-        else:
-            return self.compute_number_of_staves()
-
-    def compute_number_of_staves(self):
-        max_staves = 1
-        for e in self.iter_all(GenericNote, include_subclasses=True):
-            if e.staff is not None and e.staff > max_staves:
-                max_staves = e.staff
-        for e in self.iter_all(Clef):
-            if e.staff is not None and e.staff > max_staves:
-                max_staves = e.staff
-        for e in self.iter_all(Direction, include_subclasses=True):
-            if e.staff is not None and e.staff > max_staves:
-                max_staves = e.staff
-        for e in self.iter_all(Words):
-            if e.staff is not None and e.staff > max_staves:
-                max_staves = e.staff
-        
-        self._number_of_staves = max_staves
-        return max_staves
-    
-    def _remove_point(self, tp):
-        i = np.searchsorted(self._points, tp)
-        if self._points[i] == tp:
-            self._points = np.delete(self._points, i)
-            if i > 0:
-                self._points[i - 1].next = self._points[i]
-                self._points[i].prev = self._points[i - 1]
-            if i < len(self._points) - 1:
-                self._points[i].next = self._points[i + 1]
-                self._points[i + 1].prev = self._points[i]
-
-    def get_point(self, t):
-        """Return the `TimePoint` object with time `t`, or None if
-        there is no such object.
-
-        """
-        if t < 0:
-            raise InvalidTimePointException(
-                "TimePoints should have non-negative integer values"
-            )
-
-        i = np.searchsorted(self._points, TimePoint(t))
-        if i < len(self._points) and self._points[i].t == t:
-            return self._points[i]
-        else:
-            return None
-
-    def get_or_add_point(self, t):
-        """Return the `TimePoint` object with time `t`; if there is no
-        such object, create it, add it to the time line, and return
-        it.
-
-        Parameters
-        ----------
-        t : int
-            Time value `t`
-
-        Returns
-        -------
-        :class:`TimePoint`
-            a TimePoint object with time `t`
-
-        """
-        if t < 0:
-            raise InvalidTimePointException(
-                "TimePoints should have non-negative integer values"
-            )
-
-        tp = self.get_point(t)
-        if tp is None:
-            tp = TimePoint(t, int(self._quarter_map(t)))
-            self._add_point(tp)
-        return tp
-
-    def add(self, o, start=None, end=None):
-        """Add an object to the timeline.
-
-        An object can be added by start time, end time, or both,
-        depending on which of the `start` and `end` keywords are
-        provided. If neither is provided this method does nothing.
-
-        `start` and `end` should be non-negative integers.
-
-        Parameters
-        ----------
-        o : :class:`TimedObject`
-            Object to be removed
-        start : int, optional
-            The start time of the object
-        end : int, optional
-            The end time of the object
-
-        """
-        if start is not None:
-            if start < 0:
-                raise InvalidTimePointException(
-                    "TimePoints should have non-negative integer values"
-                )
-            self.get_or_add_point(start).add_starting_object(o)
-        if end is not None:
-            if end < 0:
-                raise InvalidTimePointException(
-                    "TimePoints should have non-negative integer values"
-                )
-            self.get_or_add_point(end).add_ending_object(o)
-
-    def remove(self, o, which="both"):
-        """Remove an object from the timeline.
-
-        An object can be removed by start time, end time, or both.
-
-        Parameters
-        ----------
-        o : :class:`TimedObject`
-            Object to be removed
-        which : {'start', 'end', 'both'}, optional
-            Whether to remove o as a starting object, an ending
-            object, or both. Defaults to 'both'.
-
-        """
-
-        if which in ("start", "both") and o.start:
-            try:
-                o.start.starting_objects[o.__class__].remove(o)
-            except (KeyError, ValueError):
-                raise Exception(
-                    "Not implemented: removing an object "
-                    "that is registered by its superclass"
-                )
-            # cleanup timepoint if no starting/ending objects are left
-            self._cleanup_point(o.start)
-            o.start = None
-
-        if which in ("end", "both") and o.end:
-            try:
-                o.end.ending_objects[o.__class__].remove(o)
-            except (KeyError, ValueError):
-                raise Exception(
-                    "Not implemented: removing an object "
-                    "that is registered by its superclass"
-                )
-            # cleanup timepoint if no starting/ending objects are left
-            self._cleanup_point(o.end)
-            o.end = None
-
-    def _cleanup_point(self, tp):
-        # remove tp when it has no starting or ending objects
-        if (
-            sum(len(oo) for oo in tp.starting_objects.values())
-            + sum(len(oo) for oo in tp.ending_objects.values())
-        ) == 0:
-            self._remove_point(tp)
-
-    def iter_all(
-        self, cls=None, start=None, end=None, include_subclasses=False, mode="starting"
-    ):
-        """Iterate (in direction of increasing time) over all
-        instances of `cls` that either start or end (depending on
-        `mode`) in the interval `start` to `end`.  When `start` and
-        `end` are omitted, the whole timeline is searched.
-
-        Parameters
-        ----------
-        cls : class, optional
-            The class of objects to iterate over. If omitted, iterate
-            over all objects in the part.
-        start : :class:`TimePoint`, optional
-            The start of the interval to search. If omitted or None,
-            the search starts at the start of the timeline. Defaults
-            to None.
-        end : :class:`TimePoint`, optional
-            The end of the interval to search. If omitted or None, the
-            search ends at the end of the timeline. Defaults to None.
-        include_subclasses : bool, optional
-            If True also return instances that are subclasses of
-            `cls`. Defaults to False.
-        mode : {'starting', 'ending'}, optional
-            Flag indicating whether to search for starting or ending
-            objects. Defaults to 'starting'.
-
-        Yields
-        ------
-        object
-            Instances of the specified type.
-
-        """
-        if mode not in ("starting", "ending"):
-            warnings.warn('unknown mode "{}", using "starting" instead'.format(mode))
-            mode = "starting"
-
-        if start is None:
-            start_idx = 0
-        else:
-            if not isinstance(start, TimePoint):
-                start = TimePoint(start)
-            start_idx = np.searchsorted(self._points, start)
-
-        if end is None:
-            end_idx = len(self._points)
-        else:
-            if not isinstance(end, TimePoint):
-                end = TimePoint(end)
-            end_idx = np.searchsorted(self._points, end)
-
-        if cls is None:
-            cls = object
-            include_subclasses = True
-
-        if mode == "ending":
-            for tp in self._points[start_idx:end_idx]:
-                yield from tp.iter_ending(cls, include_subclasses)
-        else:
-            for tp in self._points[start_idx:end_idx]:
-                yield from tp.iter_starting(cls, include_subclasses)
-
-    @property
-    def last_point(self):
-        """The last TimePoint on the timeline, or None if the timeline
-        is empty.
-
-        Returns
-        -------
-        :class:`TimePoint`
-
-        """
-        return self._points[-1] if len(self._points) > 0 else None
-
-    @property
-    def first_point(self):
-        """The first TimePoint on the timeline, or None if the
-        timeline is empty.
-
-        Returns
-        -------
-        :class:`TimePoint`
-
-        """
-        return self._points[0] if len(self._points) > 0 else None
-
-    def note_array(self, **kwargs):
-        """
-        Create a structured array with note information
-        from a `Part` object.
-
-        Parameters
-        ----------
-
-        include_pitch_spelling : bool (optional)
-            If `True`, includes pitch spelling information for each
-            note. Default is False
-        include_key_signature : bool (optional)
-            If `True`, includes key signature information, i.e.,
-            the key signature at the onset time of each note (all
-            notes starting at the same time have the same key signature).
-            Default is False
-        include_time_signature : bool (optional)
-            If `True`,  includes time signature information, i.e.,
-            the time signature at the onset time of each note (all
-            notes starting at the same time have the same time signature).
-            Default is False
-        include_metrical_position : bool (optional)
-            If `True`,  includes metrical position information, i.e.,
-            the position of the onset time of each note with respect to its
-            measure (all notes starting at the same time have the same metrical
-            position).
-            Default is False
-        include_grace_notes : bool (optional)
-            If `True`,  includes grace note information, i.e. if a note is a
-            grace note and the grace type "" for non grace notes).
-            Default is False
-        include_divs_per_quarter : bool (optional)
-            If `True`,  includes the number of divs per quarter note.
-            Default is False
-
-        Returns:
-
-        note_array : structured array
-        """
-        return note_array_from_part(self, **kwargs)
-
-    def rest_array(
-        self,
-        include_pitch_spelling=False,
-        include_key_signature=False,
-        include_time_signature=False,
-        include_metrical_position=False,
-        include_grace_notes=False,
-        include_staff=False,
-        collapse=False,
-    ):
-        """
-        Create a structured array with rest information
-        from a `Part` object.
-
-        Parameters
-        ----------
-
-        include_pitch_spelling : bool (optional)
-            If `True`, includes pitch spelling information for each
-            rest, i.e. all information is 0. Default is False
-        include_key_signature : bool (optional)
-            If `True`, includes key signature information, i.e.,
-            the key signature at the onset time of each rest (all
-            notes starting at the same time have the same key signature).
-            Default is False
-        include_time_signature : bool (optional)
-            If `True`,  includes time signature information, i.e.,
-            the time signature at the onset time of each note (all
-            notes starting at the same time have the same time signature).
-            Default is False
-        include_metrical_position : bool (optional)
-            If `True`,  includes metrical position information, i.e.,
-            the position of the onset time of each rest with respect to its
-            measure (all notes starting at the same time have the same metrical
-            position).
-            Default is False
-        include_grace_notes : bool (optional)
-            If `True`,  includes returns empty strings as type and false.
-        feature_functions : list or str
-            A list of feature functions. Elements of the list can be either
-            the functions themselves or the names of a feature function as
-            strings (or a mix). The feature functions specified by name are
-            looked up in the `featuremixer.featurefunctions` module.
-
-        Returns:
-
-        rest_array : structured array
-        """
-        return rest_array_from_part(
-            self,
-            include_pitch_spelling=include_pitch_spelling,
-            include_key_signature=include_key_signature,
-            include_time_signature=include_time_signature,
-            include_metrical_position=include_metrical_position,
-            include_grace_notes=include_grace_notes,
-            include_staff=include_staff,
-            collapse=collapse,
-        )
-
-    def set_musical_beat_per_ts(self, mbeats_per_ts={}):
-        """Set the number of musical beats for each time signature.
-        If no musical beat is specified for a certain time signature,
-        the default one is used, i.e. 2 for 6/X, 3 for 9/X, 4 for 12/X,
-        and the number of beats for the others ts. Each musical beat
-        has equal duration.
-
-        Parameters
-        ----------
-        mbeats_per_ts : dict, optional
-            A dict where the keys are time signature strings
-            (e.g. "3/4") and the values are the number of musical beats.
-            If a certain time signature is not specified, the defaults
-            values are used.
-            Defaults to an empty dict.
-
-        """
-        if not isinstance(mbeats_per_ts, dict):
-            raise TypeError("mbeats_per_ts must be either a dictionary")
-
-        # correctly set the musical beat for all time signatures
-        for ts in self.iter_all(TimeSignature):
-            ts_string = "{}/{}".format(ts.beats, ts.beat_type)
-            if ts_string in mbeats_per_ts:
-                ts.musical_beats = mbeats_per_ts[ts_string]
-            else:  # set to default if not specified
-                if ts.beats in MUSICAL_BEATS:
-                    ts.musical_beats = MUSICAL_BEATS[ts.beats]
-                else:
-                    ts.musical_beats = ts.beats
-
-    def use_musical_beat(self, mbeats_per_ts={}):
-        """Consider the musical beat as the reference for all elements
-        that concern the number and position of beats.
-        An optional parameter can set the number of musical beats for
-        specific time signatures, otherwise the default values are
-        used.
-
-        Parameters
-        ----------
-        mbeats_per_ts : dict, optional
-            A dict where the keys are time signature strings
-            (e.g. "3/4") and the values are the number of musical beats.
-            If a certain time signature is not specified, the defaults
-            values are used.
-            Defaults to an empty dict.
-
-        """
-        if not self._use_musical_beat:
-            self._use_musical_beat = True
-            if mbeats_per_ts != {}:  # set the number of nbeats if specified
-                self.set_musical_beat_per_ts(mbeats_per_ts)
-        else:
-            warnings.warn("Musical beats were already being used!")
-
-    def use_notated_beat(self):
-        """Consider the notated beat (numerator of time signature)
-        as the reference for all elements that concern the number
-        and position of beats.
-        It also reset the number of musical beats for each time signature
-        to default values.
-        """
-        if self._use_musical_beat:
-            self._use_musical_beat = False
-            # reset the number of musical beats to default values
-            self.set_musical_beat_per_ts()
-        else:
-            warnings.warn("Notated beats were already being used!")
-
-    # @property
-    # def part_names(self):
-    #     # get instrument name parts recursively
-    #     chunks = []
-
-    #     if self.part_name is not None:
-    #         chunks.append(self.part_name)
-    #         yield self.part_name
-
-    #     pg = self.parent
-    #     while pg is not None:
-    #         if pg.group_name is not None:
-    #             chunks.insert(0, pg.group_name)
-    #             yield '  '.join(chunks)
-    #         pg = pg.parent
-
-
-class TimePoint(ComparableMixin):
-
-    """A TimePoint represents a temporal position within a
-    :class:`Part`.
-
-    TimePoints are used to keep track of the starting and ending of
-    musical elements in the part. They are created automatically when
-    adding musical elements to a part using its :meth:`~Part.add`
-    method, so there should be normally no reason to instantiate
-    TimePoints manually.
-
-    Parameters
-    ----------
-    t : int
-        The time associated to this TimePoint. Should be a non-
-        negative integer.
-    quarter : int
-        The duration of a quarter note at this TimePoint
-
-    Attributes
-    ----------
-    t : int
-        See parameters
-    quarter : int
-        See parameters
-    starting_objects : dictionary
-        A dictionary where the musical objects starting at this time
-        are grouped by class.
-    ending_objects : dictionary
-        A dictionary where the musical objects ending at this time are
-        grouped by class.
-    prev : TimePoint
-        The preceding TimePoint (or None if there is none)
-    next : TimePoint
-        The succeding TimePoint (or None if there is none)
-
-    """
-
-    def __init__(self, t, quarter=None):
-        self.t = t
-        self.quarter = quarter
-        self.starting_objects = defaultdict(_OrderedSet)
-        self.ending_objects = defaultdict(_OrderedSet)
-        # prev and next are dynamically updated once the timepoint is part of a timeline
-        self.next = None
-        self.prev = None
-
-    def __iadd__(self, value):
-        assert isinstance(value, Number)
-        self.t += value
-        return self
-
-    def __isub__(self, value):
-        assert isinstance(value, Number)
-        self.t -= value
-        return self
-
-    def __add__(self, value):
-        assert isinstance(value, Number)
-        new = copy(self)
-        new += value
-        return new
-
-    def __sub__(self, value):
-        assert isinstance(value, Number)
-        new = copy(self)
-        new -= value
-        return new
-
-    def __str__(self):
-        return "TimePoint t={} quarter={}".format(self.t, self.quarter)
-
-    def add_starting_object(self, obj):
-        """Add object `obj` to the list of starting objects."""
-        obj.start = self
-        self.starting_objects[type(obj)].add(obj)
-
-    def remove_starting_object(self, obj):
-        """Remove object `obj` from the list of starting objects."""
-        # TODO: check if object is stored under a superclass
-        obj.start = None
-        if type(obj) in self.starting_objects:
-            try:
-                self.starting_objects[type(obj)].remove(obj)
-            except ValueError:
-                # don't complain if the object isn't in starting_objects
-                pass
-
-    def remove_ending_object(self, obj):
-        """Remove object `obj` from the list of ending objects."""
-        # TODO: check if object is stored under a superclass
-        obj.end = None
-        if type(obj) in self.ending_objects:
-            try:
-                self.ending_objects[type(obj)].remove(obj)
-            except ValueError:
-                # don't complain if the object isn't in ending_objects
-                pass
-
-    def add_ending_object(self, obj):
-        """Add object `obj` to the list of ending objects."""
-        obj.end = self
-        self.ending_objects[type(obj)].add(obj)
-
-    def iter_starting(self, cls, include_subclasses=False):
-        """Iterate over all objects of type `cls` that start at this
-        time point.
-
-        Parameters
-        ----------
-        cls : class
-            The type of objects to iterate over
-        include_subclasses : bool, optional
-            When True, include all objects of all subclasses of `cls`
-            in the iteration. Defaults to False.
-
-        Yields
-        -------
-        cls
-            Instance of type `cls`
-
-        """
-        yield from self.starting_objects[cls]
-        if include_subclasses:
-            for subcls in iter_subclasses(cls):
-                yield from self.starting_objects[subcls]
-
-    def iter_ending(self, cls, include_subclasses=False):
-        """Iterate over all objects of type `cls` that end at this
-        time point.
-
-        Parameters
-        ----------
-        cls : class
-            The type of objects to iterate over
-        include_subclasses : bool, optional
-            When True, include all objects of all subclasses of `cls`
-            in the iteration. Defaults to False.
-
-        Yields
-        ------
-        cls
-            Instance of type `cls`
-
-        """
-        yield from self.ending_objects[cls]
-        if include_subclasses:
-            for subcls in iter_subclasses(cls):
-                yield from self.ending_objects[subcls]
-
-    def iter_prev(self, cls, eq=False, include_subclasses=False):
-        """Iterate backwards in time from the current timepoint over
-        starting object(s) of type `cls`.
-
-        Parameters
-        ----------
-        cls : class
-            Class of objects to iterate over
-        eq : bool, optional
-            If True start iterating at the current timepoint, rather
-            than its predecessor. Defaults to False.
-        include_subclasses : bool, optional
-            If True include subclasses of `cls` in the iteration.
-            Defaults to False.
-
-        Yields
-        ------
-        cls
-            Instances of `cls`
-
-        """
-        if eq:
-            tp = self
-        else:
-            tp = self.prev
-
-        while tp:
-            yield from tp.iter_starting(cls, include_subclasses)
-            tp = tp.prev
-
-    def iter_next(self, cls, eq=False, include_subclasses=False):
-        """Iterate forwards in time from the current timepoint over
-        starting object(s) of type `cls`.
-
-        Parameters
-        ----------
-        cls : class
-            Class of objects to iterate over
-        eq : bool, optional
-            If True start iterating at the current timepoint, rather
-            than its successor. Defaults to False.
-        include_subclasses : bool, optional
-            If True include subclasses of `cls` in the iteration.
-            Defaults to False.
-
-        Yields
-        ------
-        cls
-            Instances of `cls`
-
-        """
-        if eq:
-            tp = self
-        else:
-            tp = self.next
-
-        while tp:
-            yield from tp.iter_starting(cls, include_subclasses)
-            tp = tp.next
-
-    def _cmpkey(self):
-        # This method returns the value to be compared (code for that is in
-        # the ComparableMixin class)
-        return self.t
-
-    def _pp(self, tree):
-        # pretty print the timepoint, including its starting and ending
-        # objects
-        result = ["{}{}".format(tree, self.__str__())]
-        tree.push()
-
-        ending_items_lists = sorted_dict_items(
-            self.ending_objects.items(), key=lambda x: x[0].__name__
-        )
-        starting_items_lists = sorted_dict_items(
-            self.starting_objects.items(), key=lambda x: x[0].__name__
-        )
-
-        ending_items = [
-            o
-            for _, oo in ending_items_lists
-            for o in sorted(oo, key=lambda x: x.duration or -1, reverse=True)
-        ]
-        starting_items = [
-            o
-            for _, oo in starting_items_lists
-            for o in sorted(oo, key=lambda x: x.duration or -1)
-        ]
-
-        if ending_items:
-
-            result.append("{}".format(tree).rstrip())
-
-            if starting_items:
-                tree.next_item()
-            else:
-                tree.last_item()
-
-            result.append("{}ending objects".format(tree))
-            tree.push()
-            result.append("{}".format(tree).rstrip())
-
-            for i, item in enumerate(ending_items):
-
-                if i == (len(ending_items) - 1):
-                    tree.last_item()
-                else:
-                    tree.next_item()
-
-                result.append("{}{}".format(tree, item))
-
-            tree.pop()
-
-        if starting_items:
-
-            result.append("{}".format(tree).rstrip())
-            tree.last_item()
-            result.append("{}starting objects".format(tree))
-            tree.push()
-            result.append("{}".format(tree).rstrip())
-
-            for i, item in enumerate(starting_items):
-
-                if i == (len(starting_items) - 1):
-                    tree.last_item()
-                else:
-                    tree.next_item()
-                result.append("{}{}".format(tree, item))
-
-            tree.pop()
-
-        tree.pop()
-        return result
-
-
-class TimedObject(ReplaceRefMixin):
-    """This is the base class of all classes that have a start and end
-    point. The start and end attributes initialized to None, and are
-    set/unset when the object is added to/removed from a Part, using
-    its :meth:`~Part.add` and :meth:`~Part.remove` methods,
-    respectively.
-
-    Attributes
-    ----------
-    start : :class:`TimePoint`
-        Start time of the object
-    end : :class:`TimePoint`
-        End time of the object
-
-    """
-
-    def __init__(self):
-        super().__init__()
-        self.start = None
-        self.end = None
-
-    def __str__(self):
-        start = "" if self.start is None else f"{self.start.t}"
-        end = "" if self.end is None else f"{self.end.t}"
-        return start + "--" + end + " " + type(self).__name__
-
-    @property
-    def duration(self):
-        """The duration of the timed object in divisions. When either
-        the start or the end property of the object are None, the
-        duration is None.
-
-        Returns
-        -------
-        int or None
-
-        """
-        if self.start is None or self.end is None:
-            return None
-        else:
-            return self.end.t - self.start.t
-
-
-class GenericNote(TimedObject):
-    """Represents the common aspects of notes, rests, and unpitched
-    notes.
-
-    Parameters
-    ----------
-    id : str, optional (default: None)
-        A string identifying the note. To be compatible with the
-        MusicXML format, the id must be unique within a part and must
-        not start with a number.
-    voice : int, optional
-        An integer representing the voice to which the note belongs.
-        Defaults to None.
-    staff : str, optional
-        An integer representing the staff to which the note belongs.
-        Defaults to None.
-    doc_order : int, optional
-        The document order index (zero-based), expressing the order of
-        appearance of this note (with respect to other notes) in the
-        document in case the Note belongs to a part that was imported
-        from MusicXML. Defaults to None.
-
-    """
-
-    def __init__(
-        self,
-        id=None,
-        voice=None,
-        staff=None,
-        symbolic_duration=None,
-        articulations=None,
-        ornaments=None,
-        doc_order=None,
-    ):
-        self._sym_dur = None
-        super().__init__()
-        self.voice = voice
-        self.id = id
-        self.staff = staff
-        self.symbolic_duration = symbolic_duration
-        self.articulations = articulations
-        self.ornaments = ornaments
-        self.doc_order = doc_order
-
-        # these attributes are set after the instance is constructed
-        self.fermata = None
-        self.tie_prev = None
-        self.tie_next = None
-        self.slur_stops = []
-        self.slur_starts = []
-        self.tuplet_stops = []
-        self.tuplet_starts = []
-
-        # maintain a list of attributes to update when cloning this instance
-        self._ref_attrs.extend(
-            [
-                "tie_prev",
-                "tie_next",
-                "slur_stops",
-                "slur_starts",
-                "tuplet_stops",
-                "tuplet_starts",
-            ]
-        )
-
-    @property
-    def symbolic_duration(self):
-        """The symbolic duration of the note.
-
-        This property returns a dictionary specifying the symbolic
-        duration of the note. The dictionary may have the following
-        keys:
-
-        * type : the note type as a string, e.g. 'quarter', 'half'
-
-        * dots : an integer specifying the number of dots. When
-          this key is missing it means there are no dots.
-
-        * actual_notes : Specifies the number of actual notes in a
-          rhythmical tuplet. Used in conjunction with `normal_notes`.
-
-        * normal_notes : Specifies the normal number of notes in a
-          rhythmical tuplet. For example a triplet of eights in the
-          time of two eights would correspond to actual_notes=3,
-          normal_notes=2.
-
-        The symbolic duration dictionary of a note can either be
-        set manually (for example by specifying the
-        `symbolic_duration` constructor keyword argument), or left
-        unspecified (i.e. None). In the latter case the symbolic
-        duration is estimated dynamically based on the note start and
-        end times. Note that this latter case is generally preferrable
-        because it ensures that the symbolic duration is consistent
-        with the numeric duration.
-
-        If the symbolic duration cannot be estimated from the
-        numeric duration None is returned.
-
-        Returns
-        -------
-        dict or None
-            A dictionary specifying the symbolic duration of the note, or
-            None if the symbolic duration could not be estimated from the
-            numeric duration.
-
-        """
-        if self._sym_dur is None:
-            # compute value
-            if not self.start or not self.end:
-                warnings.warn(
-                    "Cannot estimate symbolic duration for notes that "
-                    "are not added to a Part"
-                )
-                return None
-            if self.start.quarter is None:
-                warnings.warn(
-                    "Cannot estimate symbolic duration when not "
-                    "quarter_duration has been set. "
-                    "See Part.set_quarter_duration."
-                )
-                return None
-            return estimate_symbolic_duration(self.duration, self.start.quarter)
-        else:
-            # return set value
-            return self._sym_dur
-
-    @symbolic_duration.setter
-    def symbolic_duration(self, v):
-        self._sym_dur = v
-
-    @property
-    def end_tied(self):
-        """The `Timepoint` corresponding to the end of the note, or---
-        when this note belongs to a group of tied notes---the end of
-        the last note in the group.
-
-        Returns
-        -------
-        TimePoint
-            End of note
-
-        """
-        if self.tie_next is None:
-            return self.end
-        else:
-            return self.tie_next.end_tied
-
-    @property
-    def duration_tied(self):
-        """Time difference of the start of the note to the end of the
-        note, or---when  this note belongs to a group of tied notes---
-        the end of the last note in the group.
-
-        Returns
-        -------
-        int
-            Duration of note
-
-        """
-        if self.tie_next is None:
-            return self.duration
-        else:
-            return self.duration + self.tie_next.duration_tied
-
-    @property
-    def duration_from_symbolic(self):
-        """Return the numeric duration given the symbolic duration of
-        the note and the quarter_duration in effect.
-
-        Returns
-        -------
-        int or None
-
-        """
-
-        if self.symbolic_duration:
-            # check for self.start, and self.start.quarter
-            return symbolic_to_numeric_duration(
-                self.symbolic_duration, self.start.quarter
-            )
-        else:
-            return None
-
-    @property
-    def tie_prev_notes(self):
-        """TODO
-
-        Parameters
-        ----------
-
-        Returns
-        -------
-        type
-            Description of return value
-        """
-
-        if self.tie_prev:
-            return self.tie_prev.tie_prev_notes + [self.tie_prev]
-        else:
-            return []
-
-    @property
-    def tie_next_notes(self):
-        """TODO
-
-        Parameters
-        ----------
-
-        Returns
-        -------
-        type
-            Description of return value
-        """
-
-        if self.tie_next:
-            return [self.tie_next] + self.tie_next.tie_next_notes
-        else:
-            return []
-
-    # def iter_voice_prev(self):
-    #     """TODO
-
-    #     Parameters
-    #     ----------
-
-    #     Returns
-    #     -------
-    #     type
-    #         Description of return value
-    #     """
-
-    #     for n in self.start.iter_prev(GenericNote, include_subclasses=True):
-    #         if n.voice == n.voice:
-    #             yield n
-
-    # def iter_voice_next(self):
-    #     """TODO
-
-    #     Parameters
-    #     ----------
-
-    #     Returns
-    #     -------
-    #     type
-    #         Description of return value
-    #     """
-
-    #     for n in self.start.iter_next(GenericNote, include_subclasses=True):
-    #         if n.voice == n.voice:
-    #             yield n
-
-    def iter_chord(self, same_duration=True, same_voice=True):
-        """Iterate over notes with coinciding start times.
-
-        Parameters
-        ----------
-        same_duration : bool, optional
-            When True limit the iteration to notes that have the same
-            duration as the current note. Defaults to True.
-        same_voice : bool, optional
-            When True limit the iteration to notes that have the same
-            voice as the current note. Defaults to True.
-
-        Yields
-        ------
-        GenericNote
-
-        """
-
-        for n in self.start.iter_starting(GenericNote, include_subclasses=True):
-            if ((not same_voice) or n.voice == self.voice) and (
-                (not same_duration) or (n.duration == self.duration)
-            ):
-                yield n
-
-    def __str__(self):
-        s = "{} id={} voice={} staff={} type={}".format(
-            super().__str__(),
-            self.id,
-            self.voice,
-            self.staff,
-            format_symbolic_duration(self.symbolic_duration),
-        )
-        if self.articulations:
-            s += " articulations=({})".format(", ".join(self.articulations))
-        if self.tie_prev or self.tie_next:
-            all_tied = self.tie_prev_notes + [self] + self.tie_next_notes
-            tied_id = "+".join(n.id or "None" for n in all_tied)
-            return s + " tie_group={}".format(tied_id)
-        else:
-            return s
-
-
-class Note(GenericNote):
-    """Subclass of GenericNote representing pitched notes.
-
-    Parameters
-    ----------
-    step : {'C', 'D', 'E', 'F', 'G', 'A', 'B'}
-        The note name of the pitch (in upper case). If a lower case
-        note name is given, it will be converted to upper case.
-    octave : int
-        An integer representing the octave of the pitch
-    alter : int, optional
-        An integer (or None) representing the alteration of the pitch as
-        follows:
-
-        -2
-            double flat
-        -1
-            flat
-        0 or None
-            unaltered
-        1
-            sharp
-        2
-            double sharp
-
-        Defaults to None.
-
-    """
-
-    def __init__(self, step, octave, alter=None, beam=None, **kwargs):
-        super().__init__(**kwargs)
-        self.step = step.upper()
-        self.octave = octave
-        self.alter = alter
-        self.beam = beam
-
-        if self.beam is not None:
-            self.beam.append(self)
-
-    def __str__(self):
-        return " ".join(
-            (
-                super().__str__(),
-                "pitch={}{}{}".format(self.step, self.alter_sign, self.octave),
-            )
-        )
-
-    @property
-    def midi_pitch(self):
-        """The midi pitch value of the note (MIDI note number). C4
-        (middle C, in german: c') is note number 60.
-
-        Returns
-        -------
-        integer
-            The note's pitch as MIDI note number.
-
-        """
-        return pitch_spelling_to_midi_pitch(
-            step=self.step, octave=self.octave, alter=self.alter
-        )
-
-    @property
-    def alter_sign(self):
-        """The alteration of the note
-
-        Returns
-        -------
-        str
-
-        """
-        return ALTER_SIGNS[self.alter]
-
-
-class UnpitchedNote(GenericNote):
-    """Subclass of GenericNote representing unpitched notes.
-
-    Parameters
-    ----------
-        Parameters
-    ----------
-    step : {'C', 'D', 'E', 'F', 'G', 'A', 'B'}
-        The note name of the pitch (in upper case). If a lower case
-        note name is given, it will be converted to upper case.
-    octave : int
-        An integer representing the octave of the pitch
-    notehead : string
-        A string representing the notehead.
-        Defaults to None
-    noteheadstyle : bool
-        A boolean indicating whether the notehead is filled.
-        Defaults to true
-
-    """
-
-    def __init__(
-        self, step, octave, beam=None, notehead=None, noteheadstyle=True, **kwargs
-    ):
-        super().__init__(**kwargs)
-        self.step = step.upper()
-        self.octave = octave
-        self.beam = beam
-        self.notehead = notehead
-        self.noteheadstyle = noteheadstyle
-
-        if self.beam is not None:
-            self.beam.append(self)
-
-    def __str__(self):
-        return " ".join(
-            (
-                super().__str__(),
-                "pitch={}{}{}".format(self.step, "", self.octave),
-            )
-        )
-
-    @property
-    def midi_pitch(self):
-        """The midi pitch value of the note (MIDI note number).
-
-        Returns
-        -------
-        integer
-            The note's position as MIDI note number.
-
-        """
-        return pitch_spelling_to_midi_pitch(step=self.step, octave=self.octave, alter=0)
-
-
-class Rest(GenericNote):
-    """A subclass of GenericNote representing a rest."""
-
-    def __init__(self, hidden=False, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.hidden = hidden
-
-
-class Beam(TimedObject):
-    """Represent beams (for MEI)"""
-
-    def __init__(self, id=None):
-        super().__init__()
-        self.id = id
-        self.notes = []
-
-    def append(self, note):
-        note.beam = self
-        self.notes.append(note)
-        self.update_time()
-
-    def update_time(self):
-        start_idx = np.argmin([n.start.t for n in self.notes])
-        end_idx = np.argmax([n.end.t for n in self.notes])
-
-        self.start = self.notes[start_idx].start
-        self.end = self.notes[end_idx].end
-
-
-class GraceNote(Note):
-    """A subclass of Note representing a grace note.
-
-    Parameters
-    ----------
-    grace_type : {'grace', 'acciaccatura', 'appoggiatura'}
-        The type of grace note. Use 'grace' for a unspecified grace
-        note type.
-    steal_proportion : float, optional
-        The proportion of the previous (acciaccatura) or next
-        (appoggiatura) note duration that is occupied by the grace
-        note. Defaults to None.
-
-    Attributes
-    ----------
-    main_note : :class:`Note`
-        The (non-grace) note to which this grace note belongs.
-    grace_seq_len : list
-        The length of the sequence of grace notes to which this grace
-        note belongs.
-
-    """
-
-    def __init__(self, grace_type, *args, steal_proportion=None, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.grace_type = grace_type
-        self.steal_proportion = steal_proportion
-        self.grace_next = None
-        self.grace_prev = None
-        self._ref_attrs.extend(["grace_next", "grace_prev"])
-
-    @property
-    def main_note(self):
-        n = self.grace_next
-        while isinstance(n, GraceNote):
-            n = n.grace_next
-        return n
-
-    @property
-    def grace_seq_len(self):
-        return (
-            sum(1 for _ in self.iter_grace_seq(backwards=True))
-            + sum(1 for _ in self.iter_grace_seq())
-            - 1
-        )  # subtract one because self is counted twice
-
-    @property
-    def last_grace_note_in_seq(self):
-        n = self
-        while isinstance(n.grace_next, GraceNote):
-            n = n.grace_next
-        return n
-
-    def iter_grace_seq(self, backwards=False):
-        """Iterate over this and all subsequent/preceding grace notes,
-        excluding the main note.
-
-        Parameters
-        ----------
-        backwards : bool, optional
-            When True, iterate over preceding grace notes. Otherwise
-            iterate over subsequent grace notes. Defaults to False.
-
-        Yields
-        ------
-        GraceNote
-
-        """
-
-        yield self
-        if backwards:
-            n = self.grace_prev
-        else:
-            n = self.grace_next
-        while isinstance(n, GraceNote):
-            yield n
-            if backwards:
-                n = n.grace_prev
-            else:
-                n = n.grace_next
-
-    def __str__(self):
-        return f"{super().__str__()} main_note={self.main_note}"
-
-
-class Page(TimedObject):
-    """A page in a musical score. Its start and end times describe the
-    range of musical time that is spanned by the page.
-
-    Parameters
-    ----------
-    number : int, optional
-        The number of the system. Defaults to 0.
-
-    Attributes
-    ----------
-    number : int
-        See parameters
-
-    """
-
-    def __init__(self, number=0):
-        super().__init__()
-        self.number = number
-
-    def __str__(self):
-        return f"{super().__str__()} number={self.number}"
-
-
-class System(TimedObject):
-    """A system in a musical score. Its start and end times describe
-    the range of musical time that is spanned by the system.
-
-    Parameters
-    ----------
-    number : int, optional
-        The number of the system. Defaults to 0.
-
-    Attributes
-    ----------
-    number : int
-        See parameters
-
-    """
-
-    def __init__(self, number=0):
-        super().__init__()
-        self.number = number
-
-    def __str__(self):
-        return f"{super().__str__()} number={self.number}"
-
-
-class Clef(TimedObject):
-    """Clefs associate the lines of a staff to musical pitches.
-
-    Parameters
-    ----------
-    staff : int, optional
-        The number of the staff to which this clef belongs.
-    sign : {'G', 'F', 'C', 'percussion', 'TAB', 'jianpu',  'none'}
-        The sign of the clef
-    line : int
-        The staff line at which the sign is positioned
-    octave_change : int
-        The number of octaves to shift the pitches up (postive) or
-        down (negative)
-
-    Attributes
-    ----------
-    staff : int
-        See parameters
-    sign : {'G', 'F', 'C', 'percussion', 'TAB', 'jianpu',  'none'}
-        See parameters
-    line : int
-        See parameters
-    octave_change : int
-        See parameters
-
-    """
-
-    def __init__(self, staff, sign, line, octave_change):
-
-        super().__init__()
-        self.staff = staff
-        self.sign = sign
-        self.line = line
-        self.octave_change = octave_change
-
-    def __str__(self):
-        return (
-            f"{super().__str__()} sign={self.sign} "
-            f"line={self.line} number={self.staff}"
-        )
-
-
-class Slur(TimedObject):
-    """Slurs indicate musical grouping across notes.
-
-    Parameters
-    ----------
-    start_note : :class:`Note`, optional
-        The note at which this slur starts. Defaults to None.
-    end_note : :class:`Note`, optional
-        The note at which this slur ends. Defaults to None.
-
-    Attributes
-    ----------
-    start_note : :class:`Note` or None
-        See parameters
-    end_note : :class:`Note` or None
-        See parameters
-
-
-    """
-
-    def __init__(self, start_note=None, end_note=None):
-        super().__init__()
-        self._start_note = None
-        self._end_note = None
-        self.start_note = start_note
-        self.end_note = end_note
-        # maintain a list of attributes to update when cloning this instance
-        self._ref_attrs.extend(["start_note", "end_note"])
-
-    @property
-    def start_note(self):
-        return self._start_note
-
-    @start_note.setter
-    def start_note(self, note):
-        # make sure we received a note
-        if note:
-            if self.start:
-                #  remove the slur from the current start time
-                self.start.remove_starting_object(self)
-            note.slur_starts.append(self)
-        self._start_note = note
-
-    @property
-    def end_note(self):
-        return self._end_note
-
-    @end_note.setter
-    def end_note(self, note):
-        # make sure we received a note
-        if note:
-            if self.end:
-                #  remove the slur from the current end time
-                self.end.remove_ending_object(self)
-            if note.end:
-                # add it to the end time of the new end note
-                note.end.add_ending_object(self)
-            note.slur_stops.append(self)
-        self._end_note = note
-
-    def __str__(self):
-        start = "" if self.start_note is None else "start={}".format(self.start_note.id)
-        end = "" if self.end_note is None else "end={}".format(self.end_note.id)
-        return " ".join((super().__str__(), start, end)).strip()
-
-
-class Tuplet(TimedObject):
-    """Tuplets indicate musical grouping across notes.
-
-    Parameters
-    ----------
-    start_note : :class:`Note`, optional
-        The note at which this tuplet starts. Defaults to None.
-    end_note : :class:`Note`, optional
-        The note at which this tuplet ends. Defaults to None.
-
-    Attributes
-    ----------
-    start_note : :class:`Note` or None
-        See parameters
-    end_note : :class:`Note` or None
-        See parameters
-
-    """
-
-    def __init__(self, start_note=None, end_note=None):
-        super().__init__()
-        self._start_note = None
-        self._end_note = None
-        self.start_note = start_note
-        self.end_note = end_note
-        # maintain a list of attributes to update when cloning this instance
-        self._ref_attrs.extend(["start_note", "end_note"])
-
-    @property
-    def start_note(self):
-        return self._start_note
-
-    @start_note.setter
-    def start_note(self, note):
-        # make sure we received a note
-        if note:
-            if note.start:
-                #  remove the tuplet from the current start time
-                if self.start_note and self.start_note.start:
-                    self.start_note.start.remove_starting_object(self)
-            # else:
-            #     warnings.warn('Note has no start time')
-            note.tuplet_starts.append(self)
-        self._start_note = note
-
-    @property
-    def end_note(self):
-        return self._end_note
-
-    @end_note.setter
-    def end_note(self, note):
-        # make sure we received a note
-        if note:
-            if note.end:
-                if self.end_note and self.end_note.end:
-                    #  remove the tuplet from the currentend time
-                    self.end_note.end.remove_ending_object(self)
-            # else:
-            #     warnings.warn('Note has no end time')
-            note.tuplet_stops.append(self)
-        self._end_note = note
-
-    def __str__(self):
-        start = "" if self.start_note is None else "start={}".format(self.start_note.id)
-        end = "" if self.end_note is None else "end={}".format(self.end_note.id)
-        return " ".join((super().__str__(), start, end)).strip()
-
-
-class Repeat(TimedObject):
-    """Repeats represent a repeated section in the score, designated
-    by its start and end times.
-
-    """
-
-    def __init__(self):
-        super().__init__()
-
-
-class DaCapo(TimedObject):
-    """A Da Capo sign."""
-
-
-class Fine(TimedObject):
-    """A Fine sign."""
-
-
-class DalSegno(TimedObject):
-    """A Dal Segno sign."""
-
-
-class Segno(TimedObject):
-    """A Segno sign."""
-
-
-class ToCoda(TimedObject):
-    """A To Coda sign."""
-
-
-class Coda(TimedObject):
-    """A Coda sign."""
-
-
-class Fermata(TimedObject):
-    """A Fermata sign.
-
-    Parameters
-    ----------
-    ref : :class:`TimedObject` or None, optional
-        An object to which this fermata applies. In practice this is a
-        Note or a Barline. Defaults to None.
-
-    Attributes
-    ----------
-    ref : :class:`TimedObject` or None
-        See parameters
-
-    """
-
-    def __init__(self, ref=None):
-        super().__init__()
-        # ref(erent) can be a note or a barline
-        self.ref = ref
-
-    def __str__(self):
-        return f"{super().__str__()} ref={self.ref}"
-
-
-class Ending(TimedObject):
-    """Class that represents one part of a 1---2--- type ending of a
-    musical passage (a.k.a Volta brackets).
-
-    Parameters
-    ----------
-    number : int
-        The number associated to this ending
-
-    Attributes
-    ----------
-    number : int
-        See parameters
-
-    """
-
-    def __init__(self, number):
-        super().__init__()
-        self.number = number
-
-
-class Barline(TimedObject):
-    """Class that represents the style of a barline"""
-
-    def __init__(self, style):
-        super().__init__()
-        self.style = style
-
-
-class Measure(TimedObject):
-    """A measure
-
-    Parameters
-    ----------
-    number : int or None, optional
-        The number of the measure. Defaults to None
-
-    Attributes
-    ----------
-    number : intp
-        See parameters
-
-    """
-
-    def __init__(self, number=None):
-        super().__init__()
-        self.number = number
-
-    def __str__(self):
-        return f"{super().__str__()} number={self.number}"
-
-    @property
-    def page(self):
-        """The page number on which this measure appears, or None if
-        there is no associated page.
-
-        Returns
-        -------
-        int or None
-
-        """
-        page = next(self.start.iter_prev(Page, eq=True), None)
-        if page:
-            return page.number
-        else:
-            return None
-
-    @property
-    def system(self):
-        """The system number in which this measure appears, or None if
-        there is no associated system.
-
-        Returns
-        -------
-        int or None
-
-        """
-        system = next(self.start.iter_prev(System, eq=True), None)
-        if system:
-            return system.number
-        else:
-            return None
-
-    # TODO: add `incomplete` or `anacrusis` property
-
-
-class TimeSignature(TimedObject):
-    """A time signature.
-
-    Parameters
-    ----------
-    beats : int
-        The number of beats in a measure (the numerator).
-    beat_type : int
-        The note type that defines the beat unit (the denominator).
-        (4 for quarter notes, 2 for half notes, etc.)
-    musical_beats : int
-        The number of beats according to musicologial standards
-        (2 if beats is 2 or 6; 3 if beats is 3 or 9; 4 if beats is 4 or 12;
-        else beats)
-
-    Attributes
-    ----------
-    beats : int
-        See parameters
-    beat_type : int
-        See parameters
-    musical_beat : int
-        See parameters
-
-    """
-
-    def __init__(self, beats, beat_type):
-        super().__init__()
-        self.beats = beats
-        self.beat_type = beat_type
-        self.musical_beats = (  # if a value is provided, otherwise default to beats
-            MUSICAL_BEATS[self.beats]
-            if self.beats in MUSICAL_BEATS.keys()
-            else self.beats
-        )
-
-    def __str__(self):
-        return f"{super().__str__()} {self.beats}/{self.beat_type}"
-
-
-class Tempo(TimedObject):
-    """A tempo indication.
-
-    Parameters
-    ----------
-    bpm : number
-        The tempo indicated in rate per minute
-    unit : str or None, optional
-        The unit to which the specified rate correspnds. This is a
-        string that expreses a duration category, such as "q" for
-        quarter "h." for dotted half, and so on. When None, the unit
-        is assumed to be quarters. Defaults to None.
-
-    Attributes
-    ----------
-    bpm : number
-        See parameters
-    unit : str or None
-        See parameters
-
-    """
-
-    def __init__(self, bpm, unit=None):
-        super().__init__()
-        self.bpm = bpm
-        self.unit = unit
-
-    @property
-    def microseconds_per_quarter(self):
-        """The number of microseconds per quarter under this tempo.
-
-        This is useful for MIDI representations.
-
-        Returns
-        -------
-        int
-
-        """
-        return int(
-            np.round(60 * (10**6 / to_quarter_tempo(self.unit or "q", self.bpm)))
-        )
-
-    def __str__(self):
-        if self.unit:
-            return f"{super().__str__()} {self.unit}={self.bpm}"
-        else:
-            return f"{super().__str__()} bpm={self.bpm}"
-
-
-class KeySignature(TimedObject):
-    """Key signature.
-
-    Parameters
-    ----------
-    fifths : number
-        Number of sharps (positive) or flats (negative)
-    mode : str
-        Mode of the key, either 'major' or 'minor'
-
-    Attributes
-    ----------
-    fifths : number
-        See parameters
-    mode : str
-        See parameters
-
-    """
-
-    def __init__(self, fifths, mode):
-        super().__init__()
-        self.fifths = fifths
-        self.mode = mode
-
-    @property
-    def name(self):
-        """The key signature name, where the root is uppercase, and an
-        trailing 'm' indicates minor modes (e.g. 'Am', 'G#').
-
-        Returns
-        -------
-        str
-            The key signature name
-
-        """
-        return fifths_mode_to_key_name(self.fifths, self.mode)
-
-    def __str__(self):
-        return (
-            f"{super().__str__()} fifths={self.fifths}, mode={self.mode} ({self.name})"
-        )
-
-
-class Transposition(TimedObject):
-    """Represents a <transpose> tag that tells how to change all
-    (following) pitches of that part to put it to concert pitch (i.e.
-    sounding pitch).
-
-    Parameters
-    ----------
-    diatonic : int
-        TODO
-    chromatic : int
-        The number of semi-tone steps to add or subtract to the pitch
-        to get to the (sounding) concert pitch.
-
-    Attributes
-    ----------
-    diatonic : int
-        See parameters
-    chromatic : int
-        See parameters
-
-    """
-
-    def __init__(self, diatonic, chromatic):
-        super().__init__()
-        self.diatonic = diatonic
-        self.chromatic = chromatic
-
-    def __str__(self):
-        return (
-            f"{super().__str__()} diatonic={self.diatonic}, chromatic={self.chromatic}"
-        )
-
-
-class Words(TimedObject):
-    """A textual element in the score.
-
-    Parameters
-    ----------
-    text : str
-        The text
-    staff : int or None, optional
-        The staff to which the text is associated. Defaults to None
-
-    Attributes
-    ----------
-    text : str
-        See parameters
-    staff : int or None, optional
-        See parameters
-
-    """
-
-    def __init__(self, text, staff=None):
-        super().__init__()
-        self.text = text
-        self.staff = staff
-
-    def __str__(self):
-        return f'{super().__str__()} "{self.text}"'
-
-
-class Direction(TimedObject):
-    """Base class for performance directions in the score."""
-
-    def __init__(self, text=None, raw_text=None, staff=None):
-        super().__init__()
-        self.text = text if text is not None else ""
-        self.raw_text = raw_text
-        self.staff = staff
-
-    def __str__(self):
-        if self.raw_text is not None:
-            return f'{super().__str__()} "{self.text}" raw_text="{self.raw_text}"'
-        else:
-            return f'{super().__str__()} "{self.text}"'
-
-
-class LoudnessDirection(Direction):
-    pass
-
-
-class TempoDirection(Direction):
-    pass
-
-
-class ArticulationDirection(Direction):
-    pass
-
-
-class PedalDirection(Direction):
-    pass
-
-
-class ConstantDirection(Direction):
-    pass
-
-
-class DynamicDirection(Direction):
-    pass
-
-
-class ImpulsiveDirection(Direction):
-    pass
-
-
-class ConstantLoudnessDirection(ConstantDirection, LoudnessDirection):
-    pass
-
-
-class ConstantTempoDirection(ConstantDirection, TempoDirection):
-    pass
-
-
-class ConstantArticulationDirection(ConstantDirection, ArticulationDirection):
-    pass
-
-
-class DynamicLoudnessDirection(DynamicDirection, LoudnessDirection):
-    def __init__(self, *args, wedge=False, **kwargs):
-        super().__init__(*args, **kwargs)
-        self.wedge = wedge
-
-    def __str__(self):
-        if self.wedge:
-            return f"{super().__str__()} wedge"
-        else:
-            return super().__str__()
-
-
-class DynamicTempoDirection(DynamicDirection, TempoDirection):
-    pass
-
-
-class IncreasingLoudnessDirection(DynamicLoudnessDirection):
-    pass
-
-
-class DecreasingLoudnessDirection(DynamicLoudnessDirection):
-    pass
-
-
-class IncreasingTempoDirection(DynamicTempoDirection):
-    pass
-
-
-class DecreasingTempoDirection(DynamicTempoDirection):
-    pass
-
-
-class ImpulsiveLoudnessDirection(ImpulsiveDirection, LoudnessDirection):
-    pass
-
-
-class SustainPedalDirection(PedalDirection):
-    """Represents a Sustain Pedal Direction"""
-
-    def __init__(self, line=False, *args, **kwargs):
-        super().__init__("sustain_pedal", *args, **kwargs)
-        self.line = line
-
-
-class ResetTempoDirection(ConstantTempoDirection):
-    @property
-    def reference_tempo(self):
-        direction = None
-        for d in self.start.iter_prev(ConstantTempoDirection):
-            direction = d
-        return direction
-
-
-class PartGroup(object):
-    """Represents a grouping of several instruments, usually named,
-    and expressed in the score with a group symbol such as a brace or
-    a bracket. In symphonic scores, bracketed part groups usually
-    group families of instruments, such as woodwinds or brass, whereas
-    braces are often used to group multiple instances of the same
-    instrument. See the `MusicXML documentation
-    <https://usermanuals.musicxml.com/MusicXML/Content/ST-MusicXML-
-    group-symbol-value.htm>`_ for further information.
-
-    Parameters
-    ----------
-    group_symbol : str or None, optional
-        The symbol used for grouping instruments.
-
-    Attributes
-    ----------
-    group_symbol : str or None
-
-    name : str or None
-
-    number : int
-
-    parent : PartGroup or None
-
-    children : list of Part or PartGroup objects
-
-    """
-
-    def __init__(self, group_symbol=None, group_name=None, number=None, id=None):
-        self.group_symbol = group_symbol
-        self.group_name = group_name
-        self.number = number
-        self.parent = None
-        self.id = id
-        self.children = []
-
-    def _pp(self, tree):
-        result = [
-            '{}PartGroup: group_name="{}" group_symbol="{}"'.format(
-                tree, self.group_name, self.group_symbol
-            )
-        ]
-        tree.push()
-        N = len(self.children)
-        for i, child in enumerate(self.children):
-            result.append("{}".format(tree).rstrip())
-            if i == N - 1:
-                tree.last_item()
-            else:
-                tree.next_item()
-            result.extend(child._pp(tree))
-        tree.pop()
-        return result
-
-    def pretty(self):
-        """Return a pretty representation of this object.
-
-        Returns
-        -------
-        str
-            A pretty representation
-
-        """
-        return "\n".join(self._pp(PrettyPrintTree()))
-
-    def note_array(self, *args, **kwargs):
-        """A structured array containing pitch, onset, duration, voice
-        and id for each note in each part of the PartGroup. The note
-        ids in this array include the number of the part to which they
-        belong.
-
-        See Part.note_array()
-
-        """
-        return note_array_from_part_list(self.children, *args, **kwargs)
-
-    def rest_array(self, *args, **kwargs):
-        """A structured array containing pitch, onset, duration, voice
-        and id for each note in each part of the PartGroup. The note
-        ids in this array include the number of the part to which they
-        belong.
-
-        See Part.note_array()
-
-        """
-        return rest_array_from_part_list(self.children, *args, **kwargs)
-
-
-class Score(object):
-    """Main object for representing a score.
-
-    The `Score` object is basically an iterable that provides access to all
-    `Part` objects in a musical score.
-
-    Parameters
-    ----------
-    id : str
-        The identifier of the score. In order to be compatible with MusicXML
-        the identifier should not start with a number.
-    partlist : `Part`, `PartGroup` or list of `Part` or `PartGroup` instances.
-        List of  `Part` or `PartGroup` objects.
-    title: str, optional
-        Title of the score.
-    subtitle: str, optional
-        Subtitle of the score.
-    composer: str, optional
-        Composer of the score.
-    lyricist: str, optional
-        Lyricist of the score.
-    copyright: str, optional.
-        Copyright notice of the score.
-
-    Attributes
-    ----------
-    id : str
-        See parameters.
-    parts : list of `Part` objects
-        All `Part` objects.
-    part_structure: list of `Part` or `PartGrop`
-        List of all `Part` or `PartGroup` objects that specify the structure of
-        the score.
-     title: str
-        See parameters.
-    subtitle: str
-        See parameters.
-    composer: str
-        See parameters.
-    lyricist: str
-        See parameters.
-    copyright: str.
-        See parameters.
-
-    """
-
-    id: Optional[str]
-    title: Optional[str]
-    subtitle: Optional[str]
-    composer: Optional[str]
-    lyricist: Optional[str]
-    copyright: Optional[str]
-    parts: List[Part]
-    part_structure: List[Union[Part, PartGroup]]
-
-    def __init__(
-        self,
-        partlist: Union[Part, PartGroup, Itertype[Union[Part, PartGroup]]],
-        id: Optional[str] = None,
-        title: Optional[str] = None,
-        subtitle: Optional[str] = None,
-        composer: Optional[str] = None,
-        lyricist: Optional[str] = None,
-        copyright: Optional[str] = None,
-    ) -> None:
-        self.id = id
-
-        # Score Information (default from MuseScore/MusicXML)
-        self.title = title
-        self.subtitle = subtitle
-        self.composer = composer
-        self.lyricist = lyricist
-        self.copyright = copyright
-
-        # Flat list of parts
-        self.parts = list(iter_parts(partlist))
-        # List of Parts and PartGroups
-
-        if isinstance(partlist, (Part, PartGroup)):
-            self.part_structure = [partlist]
-        elif isinstance(partlist, Iterable):
-            self.part_structure = list(partlist)
-        else:
-            raise ValueError(
-                "`partlist` should be a list, a `Part` or a `PartGrop` but"
-                f" is {type(partlist)}."
-            )
-
-    def __getitem__(self, index: int) -> Part:
-        """Get `Part in the score by index"""
-        return self.parts[index]
-
-    def __setitem__(self, index: int, part: Part) -> None:
-        """Set `Part` in the score by index"""
-        # TODO: How to update the score structure as well?
-        self.parts[index] = part
-
-    def __iter__(self) -> Iterator[Part]:
-        self.iter_idx = 0
-        return self
-
-    def __next__(self) -> Part:
-        if self.iter_idx == len(self.parts):
-            raise StopIteration
-        res = self[self.iter_idx]
-        self.iter_idx += 1
-        return res
-
-    def __len__(self) -> int:
-        """
-        The lenght of the score is the number of part objects in `self.parts`
-        """
-        return len(self.parts)
-
-    def note_array(
-        self,
-        unique_id_per_part=True,
-        include_pitch_spelling=False,
-        include_key_signature=False,
-        include_time_signature=False,
-        include_metrical_position=False,
-        include_grace_notes=False,
-        include_staff=False,
-        include_divs_per_quarter=False,
-        **kwargs,
-    ) -> np.ndarray:
-        """
-        Get a note array that concatenates the note arrays of all Part/PartGroup
-        objects in the score.
-        """
-        return note_array_from_part_list(
-            part_list=self.parts,
-            unique_id_per_part=unique_id_per_part,
-            include_pitch_spelling=include_pitch_spelling,
-            include_key_signature=include_key_signature,
-            include_time_signature=include_time_signature,
-            include_grace_notes=include_grace_notes,
-            include_metrical_position=include_metrical_position,
-            include_staff=include_staff,
-            include_divs_per_quarter=include_divs_per_quarter,
-            **kwargs,
-        )
-
-
-# Alias for typing score-like objects
-ScoreLike = Union[List[Union[Part, PartGroup]], Part, PartGroup, Score]
-
-
-class ScoreVariant(object):
-    # non-public
-
-    def __init__(self, part, start_time=0):
-        self.t_unfold = start_time
-        self.segments = []
-        self.part = part
-
-    def add_segment(self, start, end):
-        self.segments.append((start, end, self.t_unfold))
-        self.t_unfold += end.t - start.t
-
-    @property
-    def segment_times(self):
-        """
-        Return segment (start, end, offset) information for each of the segments in
-        the score variant.
-        """
-        return [(s.t, e.t, o) for (s, e, o) in self.segments]
-
-    def __str__(self):
-        return f"{super().__str__()} {self.segment_times}"
-
-    def clone(self):
-        """
-        Return a clone of the ScoreVariant
-        """
-        clone = ScoreVariant(self.part, self.t_unfold)
-        clone.segments = self.segments[:]
-        return clone
-
-    def create_variant_part(self):
-        part = Part(self.part.id, part_name=self.part.part_name)
-
-        for start, end, offset in self.segments:
-            delta = offset - start.t
-            qd = self.part.quarter_durations(start.t, end.t)
-            for t, quarter in qd:
-                part.set_quarter_duration(t + delta, quarter)
-            # After creating the new part we need to replace references to
-            # objects in the old part to references in the new part
-            # (e.g. t.next, t.prev, note.tie_next). For this we keep track of
-            # correspondences between objects (timepoints, notes, measures,
-            # etc), in o_map
-            o_map = {}
-            o_new = set()
-            tp = start
-            while tp != end:
-                # make a new timepoint, corresponding to tp
-                tp_new = part.get_or_add_point(tp.t + delta)
-                o_gen = (o for oo in tp.starting_objects.values() for o in oo)
-                for o in o_gen:
-
-                    # special cases:
-
-                    # don't include some TimedObjects in the unfolded part
-                    if isinstance(
-                        o,
-                        (
-                            Repeat,
-                            Ending,
-                            ToCoda,
-                            DaCapo,
-                            DalSegno,
-                            Segment,
-                            System,
-                            Page,
-                        ),
-                    ):
-                        continue
-
-                    # don't repeat time sig if it hasn't changed
-                    elif isinstance(o, TimeSignature):
-                        prev = next(tp_new.iter_prev(TimeSignature), None)
-                        if (prev is not None) and (
-                            (o.beats, o.beat_type) == (prev.beats, prev.beat_type)
-                        ):
-                            continue
-                    # don't repeat key sig if it hasn't changed
-                    elif isinstance(o, KeySignature):
-                        prev = next(tp_new.iter_prev(KeySignature), None)
-                        if (prev is not None) and (
-                            (o.fifths, o.mode) == (prev.fifths, prev.mode)
-                        ):
-                            continue
-
-                    # don't repeat clef if it hasn't changed
-                    elif isinstance(o, Clef):
-                        prev = next(tp_new.iter_prev(Clef), None)
-                        if (prev is not None) and (
-                            (o.sign, o.line, o.staff)
-                            == (prev.sign, prev.line, prev.staff)
-                        ):
-                            continue
-
-                    # make a copy of the object
-                    o_copy = copy(o)
-                    # add it to the set of new objects (for which the refs will
-                    # be replaced)
-                    o_new.add(o_copy)
-                    # keep track of the correspondence between o and o_copy
-                    o_map[o] = o_copy
-                    # add the start of the new object to the part
-                    tp_new.add_starting_object(o_copy)
-                    if o.end is not None:
-                        # add the end of the object to the part
-                        tp_end = part.get_or_add_point(o.end.t + delta)
-                        tp_end.add_ending_object(o_copy)
-
-                tp = tp.next
-                if tp is None:
-                    raise Exception(
-                        "segment end not a successor of segment start, "
-                        "invalid score variant"
-                    )
-
-            # special case: fermata starting at end of segment should be
-            # included if it does not belong to a note, and comes at the end of
-            # a measure (o.ref == 'right')
-            for o in end.starting_objects[Fermata]:
-                if o.ref in (None, "right"):
-                    o_copy = copy(o)
-                    tp_new = part.get_or_add_point(end.t + delta)
-                    tp_new.add_starting_object(o_copy)
-
-            # for each of the new objects, replace the references to the old
-            # objects to their corresponding new objects
-            for o in o_new:
-                o.replace_refs(o_map)
-
-        # replace prev/next references in timepoints
-        for tp, tp_next in iter_current_next(part._points):
-            tp.next = tp_next
-            tp_next.prev = tp
-
-        return part
-
-
-def add_measures(part):
-    """Add measures to a part.
-
-    This function adds Measure objects to the part according to any
-    time signatures present in the part. Any existing measures will be
-    untouched, and added measures will be delimited by the existing
-    measures.
-
-    The Part object will be modified in place.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        Part instance
-
-    """
-
-    timesigs = np.array(
-        [(ts.start.t, ts.beats) for ts in part.iter_all(TimeSignature)], dtype=int
-    )
-
-    if len(timesigs) == 0:
-        warnings.warn("No time signatures found, not adding measures")
-        return
-
-    start = part.first_point.t
-    end = part.last_point.t
-
-    if start == end:
-        return
-
-    # make sure we cover time from the start of the timeline
-    if len(timesigs) == 0 or timesigs[0, 0] > start:
-        timesigs = np.vstack(([[start, 4]], timesigs))
-
-    # in unlikely case of timesig at last point, remove it
-    if timesigs[-1, 0] >= end:
-        timesigs = timesigs[:-1]
-
-    ts_start_times = timesigs[:, 0]
-    beats_per_measure = timesigs[:, 1]
-    ts_end_times = ts_start_times[1:]
-
-    # make sure we cover time until the end of the timeline
-    if len(ts_end_times) == 0 or ts_end_times[-1] < end:
-        ts_end_times = np.r_[ts_end_times, end]
-
-    assert len(ts_start_times) == len(ts_end_times)
-
-    beat_map = part.beat_map
-    inv_beat_map = part.inv_beat_map
-    mcounter = 1
-
-    for ts_start, ts_end, measure_dur in zip(
-        ts_start_times, ts_end_times, beats_per_measure
-    ):
-        pos = ts_start
-
-        while pos < ts_end:
-
-            measure_start = pos
-            measure_end_beats = min(beat_map(pos) + measure_dur, beat_map(end))
-            measure_end = min(ts_end, inv_beat_map(measure_end_beats))
-            # any existing measures between measure_start and measure_end
-            existing_measure = next(
-                part.iter_all(Measure, measure_start, measure_end), None
-            )
-            if existing_measure:
-                if existing_measure.start.t == measure_start:
-                    assert existing_measure.end.t > pos
-                    pos = existing_measure.end.t
-                    if existing_measure.number != 0:
-                        # if existing_measure is a match anacrusis measure,
-                        # keep number 0
-                        existing_measure.number = mcounter
-                        mcounter += 1
-                    continue
-
-                else:
-                    measure_end = existing_measure.start.t
-
-            part.add(Measure(number=mcounter), int(measure_start), int(measure_end))
-
-            # if measure exists but was not at measure_start,
-            # a filler measure is added with number mcounter
-            if existing_measure:
-                pos = existing_measure.end.t
-                existing_measure.number = mcounter + 1
-                mcounter = mcounter + 2
-            else:
-                pos = measure_end
-                mcounter += 1
-
-
-def remove_grace_notes(part):
-    """Remove all grace notes from a timeline.
-
-    The specified timeline object will be modified in place.
-
-    Parameters
-    ----------
-    timeline : Timeline
-        The timeline from which to remove the grace notes
-
-    """
-    for gn in list(part.iter_all(GraceNote)):
-        part.remove(gn)
-
-
-def expand_grace_notes(part):
-    """Expand grace note durations in a part.
-
-    The specified part object will be modified in place.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        The part on which to expand the grace notes
-
-    """
-    for gn in part.iter_all(GraceNote):
-        dur = symbolic_to_numeric_duration(gn.symbolic_duration, gn.start.quarter)
-        part.remove(gn, "end")
-        part.add(gn, end=gn.start.t + int(np.round(dur)))
-
-
-def iter_parts(partlist):
-    """Iterate over all Part instances in partlist, which is a list of
-    either Part or PartGroup instances. PartGroup instances contain
-    one or more parts or further partgroups, and are traversed in a
-    depth-first fashion.
-
-    This function is designed to take the result of
-    :func:`partitura.load_score_midi` and :func:`partitura.load_musicxml` as
-    input.
-
-    Parameters
-    ----------
-    partlist : Score, list, Part, or PartGroup
-        A :class:`partitura.score.Part` object,
-        :class:`partitura.score.PartGroup` or a list of these
-
-    Yields
-    -------
-        :class:`Part` instances in `partlist`
-
-    """
-
-    if not isinstance(partlist, (list, tuple, set)):
-        _partlist = [partlist]
-
-    elif isinstance(partlist, Score):
-        _partlist = partlist.parts
-
-    else:
-        _partlist = partlist
-
-    for el in _partlist:
-        if isinstance(el, Part):
-            yield el
-        else:
-            for eel in iter_parts(el.children):
-                yield eel
-
-
-def repeats_to_start_end(repeats, first, last):
-    # non-public, deprecated, unused
-    """Return pairs of (start, end) TimePoints corresponding to the start and
-    end times of each Repeat object. If any of the start or end attributes
-    are None, replace it with the end/start of the preceding/succeeding
-    Repeat, respectively, or `first` or `last`.
-
-    Parameters
-    ----------
-    repeats : list
-        list of Repeat instances, possibly with None-valued start/end
-        attributes
-    first : TimePoint
-        The first TimePoint in the timeline
-    last : TimePoint
-        The last TimePoint in the timeline
-
-    Returns
-    -------
-    list
-        list of (start, end) TimePoints corresponding to each Repeat in
-        `repeats`
-
-    """
-    t = first
-    starts = []
-    ends = []
-    for repeat in repeats:
-        starts.append(t if repeat.start is None else repeat.start)
-        if repeat.end is not None:
-            t = repeat.end
-
-    t = last
-    for repeat in reversed(repeats):
-        ends.append(t if repeat.end is None else repeat.end)
-        if repeat.start is not None:
-            t = repeat.start
-    ends.reverse()
-    return list(zip(starts, ends))
-
-
-def _make_tied_note_id(prev_id):
-    # non-public
-    """Create a derived note ID for newly created notes, by appending
-    letters to the ID. If the original ID has the form X-Y (e.g.
-    n1-1), then the letter will be appended to the X part.
-
-    Parameters
-    ----------
-    prev_id : str
-        Original note ID
-
-    Returns
-    -------
-    str
-        Derived note ID
-
-    Examples
-    --------
-    >>> _make_tied_note_id('n0')
-    'n0a'
-    >>> _make_tied_note_id('n0a')
-    'n0b'
-    >>> _make_tied_note_id('n0-1')
-    'n0a-1'
-
-    """
-    prev_id_parts = prev_id.split("-", 1)
-    prev_id_p1 = prev_id_parts[0]
-    if prev_id_p1:
-        if ord(prev_id_p1[-1]) < ord("a") - 1:
-            return "-".join(["{}a".format(prev_id_p1)] + prev_id_parts[1:])
-        else:
-            return "-".join(
-                ["{}{}".format(prev_id_p1[:-1], chr(ord(prev_id[-1]) + 1))]
-                + prev_id_parts[1:]
-            )
-    else:
-        return None
-
-
-def tie_notes(part):
-    """Find notes that span measure boundaries and notes with composite
-    durations, and split them adding ties.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        Description of `part`
-
-    """
-    # split and tie notes at measure boundaries
-    for note in list(part.iter_all(Note)):
-        next_measure = next(note.start.iter_next(Measure), None)
-        cur_note = note
-        note_end = cur_note.end
-
-        # keep the list of stopping slurs, we need to transfer them to the last
-        # tied note
-        slur_stops = cur_note.slur_stops
-
-        while next_measure and cur_note.end > next_measure.start:
-            part.remove(cur_note, "end")
-            cur_note.slur_stops = []
-            part.add(cur_note, None, next_measure.start.t)
-            cur_note.symbolic_duration = estimate_symbolic_duration(
-                next_measure.start.t - cur_note.start.t, cur_note.start.quarter
-            )
-            sym_dur = estimate_symbolic_duration(
-                note_end.t - next_measure.start.t, next_measure.start.quarter
-            )
-            if cur_note.id is not None:
-                note_id = _make_tied_note_id(cur_note.id)
-            else:
-                note_id = None
-            next_note = Note(
-                note.step,
-                note.octave,
-                note.alter,
-                id=note_id,
-                voice=note.voice,
-                staff=note.staff,
-                symbolic_duration=sym_dur,
-            )
-            part.add(next_note, next_measure.start.t, note_end.t)
-
-            cur_note.tie_next = next_note
-            next_note.tie_prev = cur_note
-
-            cur_note = next_note
-
-            next_measure = next(cur_note.start.iter_next(Measure), None)
-
-        if cur_note != note:
-            for slur in slur_stops:
-                slur.end_note = cur_note
-
-    # then split/tie any notes that do not have a fractional/dot duration
-    divs_map = part.quarter_duration_map
-    max_splits = 3
-    failed = 0
-    succeeded = 0
-    for i, note in enumerate(list(part.iter_all(Note))):
-        if note.symbolic_duration is None:
-
-            splits = find_tie_split(
-                note.start.t, note.end.t, int(divs_map(note.start.t)), max_splits
-            )
-
-            if splits:
-                succeeded += 1
-                split_note(part, note, splits)
-            else:
-                failed += 1
-
-
-def set_end_times(parts):
-    # non-public
-    """Set missing end times of musical elements in a part to equal
-    the start times of the subsequent element of the same class. This
-    is useful for some classes
-
-    This function modifies the parts in place.
-
-    Parameters
-    ----------
-    part : Part or PartGroup, or list of these
-        Parts to be processed
-
-    """
-    for part in iter_parts(parts):
-        # page, system, loudnessdirection, tempodirection
-        _set_end_times(part, Page)
-        _set_end_times(part, System)
-        _set_end_times(part, ConstantLoudnessDirection)
-        _set_end_times(part, ConstantTempoDirection)
-        _set_end_times(part, ConstantArticulationDirection)
-
-
-def _set_end_times(part, cls):
-    acc = []
-    t = None
-
-    for obj in part.iter_all(cls, include_subclasses=True):
-
-        if obj.start == t:
-
-            if obj.end is None:
-
-                acc.append(obj)
-
-        else:
-
-            for o in acc:
-
-                part.add(o, end=obj.start.t)
-
-            acc = []
-
-            if obj.end is None:
-
-                acc.append(obj)
-
-            t = obj.start
-
-    for o in acc:
-
-        part.add(o, end=part.last_point.t)
-
-
-def split_note(part, note, splits):
-    # non-public
-
-    # TODO: we shouldn't do this, but for now it's a good sanity check
-    assert len(splits) > 0
-    # TODO: we shouldn't do this, but for now it's a good sanity check
-    assert note.symbolic_duration is None
-    part.remove(note)
-    orig_tie_next = note.tie_next
-    slur_stops = note.slur_stops
-    cur_note = note
-    start, end, sym_dur = splits.pop(0)
-    cur_note.symbolic_duration = sym_dur
-    part.add(cur_note, start, end)
-    while splits:
-        note.slur_stops = []
-
-        if cur_note.id is not None:
-            note_id = _make_tied_note_id(cur_note.id)
-        else:
-            note_id = None
-
-        next_note = Note(
-            note.step,
-            note.octave,
-            note.alter,
-            voice=note.voice,
-            id=note_id,
-            staff=note.staff,
-        )
-        cur_note.tie_next = next_note
-        next_note.tie_prev = cur_note
-
-        cur_note = next_note
-        start, end, sym_dur = splits.pop(0)
-        cur_note.symbolic_duration = sym_dur
-
-        part.add(cur_note, start, end)
-
-    cur_note.tie_next = orig_tie_next
-
-    if cur_note != note:
-        for slur in slur_stops:
-            slur.end_note = cur_note
-
-
-def find_tuplets(part):
-    """Identify tuplets in `part` and set their symbolic durations
-    explicitly.
-
-    This function adds `actual_notes` and `normal_notes` keys to
-    the symbolic duration of tuplet notes.
-
-    This function modifies the part in place.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        Part instance
-
-    """
-
-    # quick shot at finding tuplets intended to cover some common cases.
-
-    # are tuplets always in the same voice?
-
-    # quite arbitrary:
-    search_for_tuplets = [9, 7, 5, 3]
-    # only look for x:2 tuplets
-    normal_notes = 2
-
-    candidates = []
-    prev_end = None
-
-    # 1. group consecutive notes without symbolic_duration
-    for note in part.iter_all(GenericNote, include_subclasses=True):
-
-        if note.symbolic_duration is None:
-            if note.start.t == prev_end:
-                candidates[-1].append(note)
-            else:
-                candidates.append([note])
-            prev_end = note.end.t
-
-    # 2. within each group
-    for group in candidates:
-
-        # 3. search for the predefined list of tuplets
-        for actual_notes in search_for_tuplets:
-
-            if actual_notes > len(group):
-                # tuplet requires more notes than we have
-                continue
-
-            tup_start = 0
-
-            while tup_start <= (len(group) - actual_notes):
-                note_tuplet = group[tup_start : tup_start + actual_notes]
-                # durs = set(n.duration for n in group[:tuplet-1])
-                durs = set(n.duration for n in note_tuplet)
-
-                if len(durs) > 1:
-                    # notes have different durations (possibly valid but not
-                    # supported here)
-                    # continue
-                    tup_start += 1
-                else:
-
-                    start = note_tuplet[0].start.t
-                    end = note_tuplet[-1].end.t
-                    total_dur = end - start
-
-                    # total duration of tuplet notes must be integer-divisble by
-                    # normal_notes
-                    if total_dur % normal_notes > 0:
-                        tup_start += 1
-                    else:
-                        # estimate duration type
-                        dur_type = estimate_symbolic_duration(
-                            total_dur // normal_notes, note_tuplet[0].start.quarter
-                        )
-
-                        if dur_type and dur_type.get("dots", 0) == 0:
-                            # recognized duration without dots
-                            dur_type["actual_notes"] = actual_notes
-                            dur_type["normal_notes"] = normal_notes
-                            for note in note_tuplet:
-                                note.symbolic_duration = dur_type.copy()
-                            start_note = note_tuplet[0]
-                            stop_note = note_tuplet[-1]
-                            tuplet = Tuplet(start_note, stop_note)
-                            part.add(tuplet, start_note.start.t, stop_note.end.t)
-                            tup_start += actual_notes
-
-                        else:
-                            tup_start += 1
-
-
-def sanitize_part(part, tie_tolerance=0):
-    """Find and remove incomplete structures in a part such as Tuplets
-    and Slurs without start or end and grace notes without a main
-    note.
-
-    This function modifies the part in place.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        Part instance
-    tie_tolerange: int, optional
-        The maximum number of divs that separates notes that are tied together.
-        Ideally, it is 0, but not so nice scores happen.
-
-    """
-    remove_grace_counter = 0
-    elements_to_remove = []
-    for gn in part.iter_all(GraceNote):
-        if gn.main_note is None:
-            for no in part.iter_all(
-                Note, include_subclasses=False, start=gn.start.t, end=gn.start.t + 1
-            ):
-
-                if no.voice == gn.voice:
-                    gn.last_grace_note_in_seq.grace_next = no
-
-        if gn.main_note is None:
-            elements_to_remove.append(gn)
-            remove_grace_counter += 1
-
-    remove_tuplet_counter = 0
-    for tp in part.iter_all(Tuplet):
-        if tp.end_note is None or tp.start_note is None:
-            elements_to_remove.append(tp)
-            remove_tuplet_counter += 1
-
-    remove_slur_counter = 0
-    for sl in part.iter_all(Slur):
-        if sl.end_note is None or sl.start_note is None:
-            elements_to_remove.append(sl)
-            remove_slur_counter += 1
-
-    for el in elements_to_remove:
-        part.remove(el)
-
-    remove_tie_counter = 0
-    for n in part.notes_tied:
-        if n.tie_next != None:
-            d = n.duration_tied
-            s = n.start.t
-            e = n.end_tied.t
-            if abs((e - s) - d) > tie_tolerance:
-                remove_tie_counter += 1
-                all_tied = n.tie_prev_notes + [n] + n.tie_next_notes
-                for tn in all_tied:
-                    tn.tie_next = None
-                    tn.tie_prev = None
-
-    warnings.warn(
-        "part_sanitize removed {} incomplete tuplets, "
-        "{} incomplete slurs, {} incomplete grace, "
-        "and {} wrong ties."
-        "notes".format(
-            remove_tuplet_counter,
-            remove_slur_counter,
-            remove_grace_counter,
-            remove_tie_counter,
-        ),
-        stacklevel=2,
-    )
-
-
-def assign_note_ids(parts, keep=False):
-    """
-    Assigns new note IDs mainly used for loaders.
-
-    parts : list or score.PartGroup or score.Part
-        Some Partitura parts
-    keep : bool
-        Keep or given note IDs or assign new ones.
-    """
-    if keep:
-        # Keep existing note id's
-        for p, part in enumerate(iter_parts(parts)):
-            for ni, n in enumerate(part.iter_all(GenericNote, include_subclasses=True)):
-                if isinstance(n, Rest):
-                    n.id = "p{0}r{1}".format(p, ni) if n.id is None else n.id
-                else:
-                    n.id = "p{0}n{1}".format(p, ni) if n.id is None else n.id
-
-    else:
-        # assign note ids to ensure uniqueness across all parts, discarding any
-        # existing note ids
-        ni = 0
-        ri = 0
-        for part in iter_parts(parts):
-            for n in part.iter_all(GenericNote, include_subclasses=True):
-                if isinstance(n, Rest):
-                    n.id = "r{}".format(ri)
-                    ri += 1
-                else:
-                    n.id = "n{}".format(ni)
-                    ni += 1
-
-
-class Segment(TimedObject):
-    """
-    Class that represents any segment between two navigation markers such as repetitions,
-    Volta brackets, or capo/fine/coda/segno directions.
-
-    Parameters
-    ----------
-    id: string
-        unique, ordererd identifier string
-    to: list
-        list of ids of possible destinations
-    await_to:
-        list of ids of possible destinations after a jump
-    type : string, optional
-        String for the type of the segment (either "default" or "leap_start" and "leap_end"). A "leap" tuple has the effect of forcing the fastest (shortest) repetition unfolding after this segment, as is commonly expected after capo/fine/coda/segno directions.
-    info: string, optional
-        String to describe the segment, used only for printing (pretty_segments)
-
-    """
-
-    def __init__(self, id, to, await_to, force_seq=False, type="default", info=""):
-        self.id = id
-        self.to = to
-        self.await_to = await_to
-        self.force_full_sequence = force_seq
-        self.type = type
-        self.info = info
-
-
-def add_segments(part):
-    """
-    Add segment objects to a part based on repetition and capo/fine/coda/segno directions.
-
-    Parameters
-    ----------
-    part: part
-        A score part
-    """
-    if len([seg for seg in part.iter_all(Segment)]) > 0:
-        # only add segments if no segments exist
-        pass
-    else:
-        boundaries = defaultdict(dict)
-        destinations = defaultdict(list)
-
-        valid_repeats = [
-            r
-            for r in part.iter_all(Repeat)
-            if r.start is not None and r.end is not None
-        ]
-        valid_endings = [
-            r
-            for r in part.iter_all(Ending)
-            if r.start is not None and r.end is not None
-        ]
-
-        for r in valid_repeats:
-            boundaries[r.start.t]["repeat_start"] = r
-            boundaries[r.end.t]["repeat_end"] = r
-        for v in valid_endings:
-            boundaries[v.start.t]["volta_start"] = v
-            boundaries[v.end.t]["volta_end"] = v
-        for c in part.iter_all(Coda):
-            boundaries[c.start.t]["coda"] = c
-            destinations["coda"].append(c.start.t)
-        for c in part.iter_all(ToCoda):
-            boundaries[c.start.t]["tocoda"] = c
-        for c in part.iter_all(DaCapo):
-            boundaries[c.start.t]["dacapo"] = c
-        for c in part.iter_all(Fine):
-            boundaries[c.start.t]["fine"] = c
-        for c in part.iter_all(Segno):
-            boundaries[c.start.t]["segno"] = c
-            destinations["segno"].append(c.start.t)
-        for c in part.iter_all(DalSegno):
-            boundaries[c.start.t]["dalsegno"] = c
-
-        boundaries[part.last_point.t]["end"] = None
-        boundaries[part.first_point.t]["start"] = None
-
-        boundary_times = list(boundaries.keys())
-        boundary_times.sort()
-
-        # for every segment get an id, its jump destinations and properties
-        init_character = 65
-        segment_info = dict()
-        for i, (s, e) in enumerate(zip(boundary_times[:-1], boundary_times[1:])):
-            segment_info[s] = {
-                "ID": chr(init_character + i),
-                "start": s,
-                "end": e,
-                "to": [],
-                "force_full_sequence": False,
-                "type": "default",
-                "info": list(),
-                "volta_numbers": list(),
-            }
-        segment_info[boundary_times[-1]] = {"ID": "END"}
-
-        current_volta_repeat_start = 0
-        current_volta_end = 0
-        current_volta_total_number = 0
-
-        for ss in boundary_times[:-1]:
-            se = segment_info[ss]["end"]
-
-            # loop through the boundaries at the end of current segment
-            for boundary_type in boundaries[se].keys():
-
-                # REPEATS
-                if boundary_type == "repeat_start":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                if boundary_type == "repeat_end":
-                    if "volta_end" not in list(boundaries[se].keys()):
-                        segment_info[ss]["to"].append(segment_info[se]["ID"])
-                        repeat_start = boundaries[se][boundary_type].start.t
-                        segment_info[ss]["to"].append(segment_info[repeat_start]["ID"])
-                    segment_info[ss]["info"].append("repeat_end")
-
-                # VOLTA BRACKETS
-                if boundary_type == "volta_start":
-                    if "volta_end" not in list(boundaries[se].keys()):
-                        current_volta_total_number = 0
-                        current_volta_end = se
-                        for volta_number in range(
-                            10
-                        ):  # maximal expected number of volta brackets 10
-                            if "volta_start" in list(
-                                boundaries[current_volta_end].keys()
-                            ):
-                                # add the beginning to the jump destinations
-                                numbers = boundaries[current_volta_end][
-                                    "volta_start"
-                                ].number.split(",")
-                                numbers = [str(int(n)) for n in numbers]
-                                current_volta_total_number += len(numbers)
-                                for no in numbers:
-                                    segment_info[ss]["to"].append(
-                                        no
-                                        + "_Volta_"
-                                        + segment_info[current_volta_end]["ID"]
-                                    )
-                                segment_info[current_volta_end]["info"].append(
-                                    "volta " + ",".join(numbers)
-                                )
-                                segment_info[current_volta_end][
-                                    "volta_numbers"
-                                ] += numbers
-                                # segment_info[bracket_end]["info"].append(str(len(numbers)))
-                                # update the search time to the end of the ext bracket
-                                current_volta_end = boundaries[current_volta_end][
-                                    "volta_start"
-                                ].end.t
-
-                if boundary_type == "volta_end":
-                    current_volta_numbers = segment_info[ss]["volta_numbers"]
-                    for vn in current_volta_numbers:
-                        if vn != str(current_volta_total_number):
-                            # if repeating volta bracket, jump back to start
-                            # check if repeat exists (might not be for 3+ volta brackets)
-                            if "repeat_end" in list(boundaries[se].keys()):
-                                current_volta_repeat_start = max(
-                                    boundaries[se]["repeat_end"].start.t,
-                                    current_volta_repeat_start,
-                                )
-                            repeat_start = current_volta_repeat_start
-                            segment_info[ss]["to"].append(
-                                "Z_Volta_" + segment_info[repeat_start]["ID"]
-                            )
-
-                    if str(current_volta_total_number) in current_volta_numbers:
-                        # else just go to the segment after the last
-                        segment_info[ss]["to"].append(
-                            segment_info[current_volta_end]["ID"]
-                        )
-
-                # NAVIGATION SYMBOLS
-                if boundary_type == "coda":
-                    # if a coda symbol is passed just continue
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    segment_info[se]["type"] = "leap_end"
-                    segment_info[se]["info"].append("Coda")
-
-                if boundary_type == "tocoda":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    # find the coda and jump there
-                    coda_time = destinations["coda"][0]
-                    segment_info[ss]["to"].append(
-                        "Navigation2_" + segment_info[coda_time]["ID"]
-                    )
-                    segment_info[ss]["type"] = "leap_start"
-                    segment_info[ss]["info"].append("al coda")
-
-                if boundary_type == "segno":
-                    # if a segno symbol is passed just continue
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    segment_info[se]["type"] = "leap_end"
-                    segment_info[se]["info"].append("segno")
-
-                if boundary_type == "dalsegno":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    # find the segno and jump there
-                    segno_time = destinations["segno"][0]
-                    segment_info[ss]["to"].append(
-                        "Navigation1_" + segment_info[segno_time]["ID"]
-                    )
-                    segment_info[ss]["type"] = "leap_start"
-                    segment_info[ss]["info"].append("dal segno")
-
-                if boundary_type == "dacapo":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    # jump to the start
-                    segment_info[ss]["to"].append(
-                        "Navigation1_" + segment_info[part.first_point.t]["ID"]
-                    )
-                    segment_info[ss]["type"] = "leap_start"
-                    segment_info[ss]["info"].append("da capo")
-
-                if boundary_type == "fine":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-                    # jump to the start
-                    segment_info[ss]["to"].append(
-                        "Navigation2_" + segment_info[part.last_point.t]["ID"]
-                    )
-                    segment_info[ss]["info"].append("fine")
-
-                # GENERIC
-                if boundary_type == "end":
-                    segment_info[ss]["to"].append(segment_info[se]["ID"])
-
-                # first segments is always a leap destination (da capo)
-                if ss == 0:
-                    segment_info[ss]["type"] = "leap_end"
-
-        # clean up and ORDER all the jump destination information
-        for start_time in boundary_times[:-1]:
-            destinations = segment_info[start_time]["to"]
-            destinations_no_volta = [
-                dest
-                for dest in destinations
-                if "Volta_" not in dest and "Navigation" not in dest
-            ]
-            destinations_volta = [dest for dest in destinations if "Volta_" in dest]
-            # dal segno and da capo
-            destinations_navigation1 = [
-                dest[12:] for dest in destinations if "Navigation1_" in dest
-            ]
-            # al coda and fine
-            destinations_navigation2 = [
-                dest[12:] for dest in destinations if "Navigation2_" in dest
-            ]
-
-            # sort the repeats by ascending segment ID
-            destinations_no_volta = list(set(destinations_no_volta))
-            # make sure the "END" destination is the last
-            destinations_except_await = (
-                destinations_volta + destinations_no_volta + destinations_navigation1
-            )
-            if "END" in destinations_except_await:
-                while "END" in destinations_no_volta:
-                    destinations_no_volta.remove("END")
-                destinations_navigation1.append("END")
-
-            # sort repeat destinations by ascending ID
-            destinations_no_volta.sort()
-            # sort destinations by volta number
-            destinations_volta.sort()
-            # keep only the segment IDs
-            destinations_volta = [d[8:] for d in destinations_volta]
-            # don't jump to volta brackets w/t number
-            destinations_no_volta = [
-                d for d in destinations_no_volta if d not in destinations_volta
-            ]
-            destinations_cleaned = (
-                destinations_volta + destinations_no_volta + destinations_navigation1
-            )
-
-            # if len(destinations_navigation2) > 0:
-            #     # keep only jumps to the past
-            #     await_to = [idx for idx in destinations_cleaned if idx <= segment_info[start_time]["ID"]]
-            #     # add the waiting destinations
-            #     await_to += destinations_navigation2
-
-            # else:
-            #     await_to = destinations_cleaned
-
-            part.add(
-                Segment(
-                    id=segment_info[start_time]["ID"],
-                    to=destinations_cleaned,
-                    await_to=destinations_navigation2,  # await_to,
-                    force_seq=segment_info[start_time]["force_full_sequence"],
-                    type=segment_info[start_time]["type"],
-                    info=", ".join(segment_info[start_time]["info"]),
-                ),
-                segment_info[start_time]["start"],
-                segment_info[start_time]["end"],
-            )
-
-
-def get_segments(part):
-    """
-    Get dictionary of segment objects of a part.
-
-    Parameters
-    ----------
-    part: part
-        A score part
-
-    Returns
-    -------
-    segments: dict
-        A dictionary of Segment objects indexed by segment IDs.
-
-    """
-    return {seg.id: seg for seg in part.iter_all(Segment)}
-
-
-def pretty_segments(part):
-    """
-    Get a pretty string of all the segments in a part.
-    """
-    add_segments(part)
-    segments = get_segments(part)
-    string_list = [
-        str(segments[p].id)
-        + " -> (choice) "
-        + "{:<8}".format(",".join(segments[p].to))
-        + "\t segment "
-        + "{:<20}".format(
-            str(part.beat_map(segments[p].start.t))
-            + " - "
-            + str(part.beat_map(segments[p].end.t))
-        )
-        + "\t duration: "
-        + "{:<6}".format(str(part.beat_map(segments[p].duration)))
-        + "\t info: "
-        + str(segments[p].info)
-        for p in segments.keys()
-    ]
-    return "\n".join(string_list)
-
-
-class Path:
-    """
-    Path that represents a sequence of segments.
-
-    Parameters
-    ----------
-    path : list
-        The string of segment IDs
-    segments : dict
-        A dictionary of available segments by segment ID
-    used_segment_jumps : defaultdict(list), optional
-        dictionary of used jumps per segment in this path
-    no_repeats : bool, optional
-        Flag to generate no repeating jump destinations with list_of_destinations_from_last_segment
-    all_repeats : bool, optional
-        Flag to generate all repeating jump destinations with list_of_destinations_from_last_segment
-        (lower prority than no_repeats)
-    jumped: bool
-        indicates the presence of a da capo, dal segno, or al coda jump in this path
-    """
-
-    def __init__(
-        self,
-        path_list,
-        segments,
-        used_segment_jumps=None,
-        no_repeats=False,
-        all_repeats=False,
-        jumped=False,
-    ):
-
-        self.path = path_list
-        self.segments = segments
-        if used_segment_jumps is None:
-            self.used_segment_jumps = defaultdict(list)
-        else:
-            self.used_segment_jumps = used_segment_jumps
-        self.ended = False
-        self.jumped = False
-        self.no_repeats = no_repeats
-        self.all_repeats = all_repeats
-        self.jumped = jumped
-
-    def __str__(self):
-        """
-        return a string of segment IDs.
-        """
-        return "-".join(self.path)
-
-    def __len__(self):
-        return len(self.path)
-
-    def pretty(self, part=None):
-        """
-        create a pretty string describing this path instance.
-        If a corresponding part is given, the string will give
-        segment times in beats, else in divs.
-        """
-        if part is None:
-            string_list = [
-                str(self.segments[p].id)
-                + " -> (choice) "
-                + ",".join(self.segments[p].to)
-                + "  \t segment "
-                + str(self.segments[p].start.t)
-                + " - "
-                + str(self.segments[p].end.t)
-                + "\t duration: "
-                + str(self.segments[p].duration)
-                + "  \t type: "
-                + str(self.segments[p].type)
-                for p in self.path
-            ]
-        else:
-            string_list = [
-                str(self.segments[p].id)
-                + " -> (choice) "
-                + ",".join(self.segments[p].to)
-                + "  \t segment "
-                + str(part.beat_map(self.segments[p].start.t))
-                + " - "
-                + str(part.beat_map(self.segments[p].end.t))
-                + "\t duration: "
-                + str(part.beat_map(self.segments[p].duration))
-                + "  \t type: "
-                + str(self.segments[p].type)
-                for p in self.path
-            ]
-        return "\n".join(string_list)
-
-    def copy(self):
-        """
-        create a copy of this path instance.
-        """
-        return Path(
-            copy(self.path),
-            copy(self.segments),
-            copy(self.used_segment_jumps),
-            no_repeats=self.no_repeats,
-            all_repeats=self.all_repeats,
-            jumped=self.jumped,
-        )
-
-    def make_copy_with_jump_to(self, destination, ignore_leap_info=True):
-        """
-        create a copy of this path instance with an added jump.
-        If the jump is a leap (dal segno, da capo, al coda)
-        and leap information is not ignored,
-        set the new Path to subsequently follow the the shortest version.
-        """
-        new_path = self.copy()
-        new_path.used_segment_jumps[new_path.path[-1]].append(destination)
-        new_path.path.append(destination)
-        if (
-            self.segments[destination].type == "leap_end"
-            and self.segments[self.path[-1]].type == "leap_start"
-        ):
-            if not self.jumped:
-                self.jumped = True
-                for segid in new_path.segments.keys():
-                    seg = new_path.segments[segid]
-                    # if destinations await the second round, add them
-                    if len(seg.await_to) > 0:
-                        # keep only jumps to the past
-                        to = [idx for idx in seg.to if idx <= seg.id]
-                        # add the waiting destinations
-                        to += seg.await_to
-                        # replace destinations
-                        seg.to = to
-                        # delete used destinations
-                        new_path.used_segment_jumps[segid] = list()
-
-            if not ignore_leap_info:
-                new_path.no_repeats = True
-        return new_path
-
-    @property
-    def list_of_destinations_from_last_segment(self):
-        destinations = list(self.segments[self.path[-1]].to)
-        previously_used_destinations = self.used_segment_jumps[self.path[-1]]
-        # only continue in order of the sequence, after full consumption, start at zero
-        # if the full or minimal sequence is forced,
-        # return only the single possible jump destination, else return possibly many.
-
-        if len(previously_used_destinations) != 0:
-            last_destination = previously_used_destinations[-1]
-            last_destination_count = previously_used_destinations.count(
-                last_destination
-            )
-            last_destination_index = [
-                i for i, n in enumerate(destinations * 100) if n == last_destination
-            ][last_destination_count - 1]
-            last_destination_index %= len(destinations)
-
-        if self.no_repeats:
-            # currently this is in higher priority than the full sequence
-            return [destinations[-1]]
-
-        elif self.segments[self.path[-1]].force_full_sequence or self.all_repeats:
-            # if the full sequence should be used in general
-            if len(previously_used_destinations) == 0:
-                return [destinations[0]]
-            else:
-                # last_destination = previously_used_destinations[-1]
-                # last_destination_index = destinations.index(last_destination)
-                if last_destination_index < (len(destinations) - 1):
-                    return [destinations[last_destination_index + 1]]
-                else:
-                    return [destinations[0]]
-
-        else:
-            if len(previously_used_destinations) == 0:
-                return copy(destinations)
-            else:
-                # last_destination = previously_used_destinations[-1]
-                # last_destination_index = destinations.index(last_destination)
-                if last_destination_index < (len(destinations) - 1):
-                    return copy(destinations[last_destination_index + 1 :])
-                else:
-                    return copy(destinations)
-
-
-def unfold_paths(path, paths, ignore_leap_info=True):
-    """
-    Given a starting Path (at least one segment) recursively unfold into all possible
-    Paths with its segments. Ended Paths are stored in a list.
-
-    Parameters
-    ----------
-    path : Path
-        a starting Path with at least one segment to be unfolded
-    paths : list
-        empty list to accumulate paths that are fully unfolded until an "end" keyword was found
-    """
-    destinations = path.list_of_destinations_from_last_segment
-    for destination_id in destinations:
-        if destination_id == "END":
-            path.ended = True
-            paths.append(path)
-        else:
-            new_path = path.make_copy_with_jump_to(
-                destination_id, ignore_leap_info=ignore_leap_info
-            )
-            unfold_paths(new_path, paths, ignore_leap_info=ignore_leap_info)
-
-
-def get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True):
-    """
-    Get a list of paths and and a dictionary of segment objects of a part.
-
-    Common settings to get specific paths:
-    - default: all possible paths
-        (no_repeats = False, all_repeats = False, ignore_leap_info = True)
-    - default: all possible paths but without repetitions after leap
-        (no_repeats = False, all_repeats = False, ignore_leap_info = False)
-    - The longest possible path
-        (no_repeats = False, all_repeats = True, ignore_leap_info = True)
-    - The longest possible path but without repetitions after leap
-        (no_repeats = False, all_repeats = True, ignore_leap_info = False)
-    - The shortest possible path.
-        (no_repeats = True)
-        Note this might not be musically valid, e.g. a passing a "fine"
-        even a first time will stop this unfolding.
-
-    Parameters
-    ----------
-    part: part
-        A score part
-    no_repeats : bool, optional
-        Flag to choose no repeating segments, i.e. the shortest path.
-    all_repeats : bool, optional
-        Flag to choose all repeating segments, i.e. the longest path.
-        (lower priority than the previous flag)
-    ignore_leap_info : bool, optional
-        If not ignored, Path changes to no_repeats = True if a leap is encountered.
-        (A leap is a used dal segno, da capo, or al coda marking)
-
-    Returns
-    -------
-    paths: list
-        A list of path objects
-
-    """
-    add_segments(part)
-    segments = get_segments(part)
-    paths = list()
-    unfold_paths(
-        Path(["A"], segments, no_repeats=no_repeats, all_repeats=all_repeats),
-        paths,
-        ignore_leap_info=ignore_leap_info,
-    )
-
-    return paths
-
-
-def new_part_from_path(path, part, update_ids=True):
-    """
-    create a new Part from a Path and an underlying Part
-
-    Parameters
-    ----------
-    path: Path
-        A Path object
-    part: part
-        A score part
-    update_ids : bool (optional)
-        Update note ids to reflect the repetitions. Note IDs will have
-        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
-        represent the first and second repetition of 'n132' in the
-        input `part`. Defaults to False.
-
-    Returns
-    -------
-    new_part: part
-        A score part corresponding to the Path
-
-    """
-    scorevariant = ScoreVariant(part)
-    for segment_id in path.path:
-        scorevariant.add_segment(
-            path.segments[segment_id].start, path.segments[segment_id].end
-        )
-
-    new_part = scorevariant.create_variant_part()
-    if update_ids:
-        update_note_ids_after_unfolding(new_part)
-    return new_part
-
-
-def new_scorevariant_from_path(path, part):
-    """
-    create a new Part from a Path and an underlying Part
-
-    Parameters
-    ----------
-    path: Path
-        A Path object
-    part: part
-        A score part
-
-    Returns
-    -------
-    scorevariant: ScoreVariant
-        A ScoreVariant object with segments corresponding to the part
-
-    """
-    scorevariant = ScoreVariant(part)
-    for segment_id in path.path:
-        scorevariant.add_segment(
-            path.segments[segment_id].start, path.segments[segment_id].end
-        )
-    return scorevariant
-
-
-# UPDATED VERSION
-def iter_unfolded_parts(part, update_ids=True):
-    """Iterate over unfolded clones of `part`.
-
-    For each repeat construct in `part` the iterator produces two
-    clones, one with the repeat included and another without the
-    repeat. That means the number of items returned is two to the
-    power of the number of repeat constructs in the part.
-
-    The first item returned by the iterator is the version of the part
-    without any repeated sections, the last item is the version of the
-    part with all repeat constructs expanded.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        Part to unfold
-    update_ids : bool (optional)
-        Update note ids to reflect the repetitions. Note IDs will have
-        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
-        represent the first and second repetition of 'n132' in the
-        input `part`. Defaults to False.
-
-    Yields
-    ------
-
-    """
-    paths = get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True)
-
-    for p in paths:
-        yield new_part_from_path(p, part, update_ids=update_ids)
-
-
-# UPDATED VERSION
-def unfold_part_maximal(part, update_ids=True, ignore_leaps=True):
-    """Return the "maximally" unfolded part, that is, a copy of the
-    part where all segments marked with repeat signs are included
-    twice.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        The Part to unfold.
-    update_ids : bool (optional)
-        Update note ids to reflect the repetitions. Note IDs will have
-        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
-        represent the first and second repetition of 'n132' in the
-        input `part`. Defaults to False.
-    ignore_leaps : bool (optional)
-        If ignored, repetitions after a leap are unfolded fully.
-        A leap is a used dal segno, da capo, or al coda marking.
-        Defaults to True.
-
-    Returns
-    -------
-    unfolded_part : :class:`Part`
-        The unfolded Part
-
-    """
-
-    paths = get_paths(
-        part, no_repeats=False, all_repeats=True, ignore_leap_info=ignore_leaps
-    )
-
-    unfolded_part = new_part_from_path(paths[0], part, update_ids=update_ids)
-    return unfolded_part
-
-
-# UPDATED / UNCHANGED VERSION
-def unfold_part_alignment(part, alignment):
-    """Return the unfolded part given an alignment, that is, a copy
-    of the part where the segments are repeated according to the
-    repetitions in a performance.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        The Part to unfold.
-    alignment : list of dictionaries
-        List of dictionaries containing an alignment (like the ones
-        obtained from a MatchFile (see `alignment_from_matchfile`).
-
-    Returns
-    -------
-    unfolded_part : :class:`Part`
-        The unfolded Part
-
-    """
-
-    unfolded_parts = []
-
-    alignment_ids = []
-
-    for n in alignment:
-        if n["label"] == "match" or n["label"] == "deletion":
-            alignment_ids.append(n["score_id"])
-
-    score_variants = make_score_variants(part)
-
-    alignment_score_ids = np.zeros((len(alignment_ids), len(score_variants)))
-    unfolded_part_length = np.zeros(len(score_variants))
-    for j, sv in enumerate(score_variants):
-        u_part = sv.create_variant_part()
-        update_note_ids_after_unfolding(u_part)
-        unfolded_parts.append(u_part)
-        u_part_ids = [n.id for n in u_part.notes_tied]
-        unfolded_part_length[j] = len(u_part_ids)
-        for i, aid in enumerate(alignment_ids):
-            alignment_score_ids[i, j] = aid in u_part_ids
-
-    coverage = np.mean(alignment_score_ids, 0)
-
-    best_idx = np.where(coverage == coverage.max())[0]
-
-    if len(best_idx) > 1:
-        best_idx = best_idx[unfolded_part_length[best_idx].argmin()]
-
-    # append "-1" to alignment if the score_id's in alignment
-    if not any(["-1" in al.get("score_id", "") for al in alignment]):
-        for n in alignment:
-            if "score_id" in n:
-                n["score_id"] = f"{n['score_id']}-1"
-
-    return unfolded_parts[int(best_idx)]
-
-
-# UPDATED
-def make_score_variants(part):
-    # non-public (use unfold_part_maximal, or iter_unfolded_parts)
-
-    """
-    Create a list of ScoreVariant objects, each representing a
-    distinct way to unfold the score, based on the repeat structure.
-
-    Parameters
-    ----------
-    part : :class:`Part`
-        A part for which to make the score variants
-
-    Returns
-    -------
-    list
-        List of ScoreVariant objects
-
-    """
-    paths = get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True)
-
-    svs = list()
-    for path in paths:
-        svs.append(new_scorevariant_from_path(path, part))
-
-    return svs
-
-
-def merge_parts(parts, reassign="voice"):
-    """Merge list of parts or PartGroup into a single part.
-     All parts are expected to have the same time signature
-    and quarter division.
-
-    All elements are merged, except elements with class:Barline,
-    Page, System, Clef, Measure, TimeSignature, KeySignature
-    that are only taken from the first part.
-
-    WARNING: this modifies the elements in the input, so the
-    original input should not be used anymore.
-
-    Parameters
-    ----------
-    parts : PartGroup, list of parts and partGroups
-        The parts to merge
-    reassign: string (optional)
-        If "staff" the new part have as many staves as the sum
-        of the staves in parts, and the staff numbers get reassigned.
-        If "voice", the new part have only one staff, and as manually
-        voices as the sum of the voices in parts; the voice number
-        get reassigned.
-
-    Returns
-    -------
-    Part
-        A new part that contains the elements of the old parts
-
-    """
-    # check if reassign has valid values
-    if reassign not in ["staff", "voice"]:
-        raise ValueError(
-            "Only 'staff' and 'voice' are supported ressign values. Found", reassign
-        )
-
-    # unfold grouppart and list of parts in a list of parts
-    if isinstance(parts, Score):
-        parts = parts.parts
-    else:
-        parts = list(iter_parts(parts))
-
-    # if there is only one part (it could be a list with one part or a partGroup with one part)
-    if len(parts) == 1:
-        return parts[0]
-
-    # check if there is only one division for all parts
-    parts_quarter_times = [p._quarter_times for p in parts]
-    parts_quarter_durations = [p._quarter_durations for p in parts]
-    if not all([len(qd) == 1 for qd in parts_quarter_durations]):
-        raise Exception(
-            "Merging parts with multiple divisions is not supported. Found divisions",
-            parts_quarter_durations,
-            "at times",
-            parts_quarter_times,
-        )
-
-    # pass from an array of array with one elements, to array of elements
-    parts_quarter_durations = [durs[0] for durs in parts_quarter_durations]
-
-    lcm = np.lcm.reduce(parts_quarter_durations)
-    time_multiplier_per_part = [int(lcm / d) for d in parts_quarter_durations]
-
-    # create a new part and fill it with all objects in other parts
-    new_part = Part(parts[0].id)
-    new_part._quarter_times = [0]
-    new_part._quarter_durations = [lcm]
-
-    note_arrays = [part.note_array(include_staff=True) for part in parts]
-    # find the maximum number of voices for each part (voice number start from 1)
-    maximum_voices = [
-        max(note_array["voice"], default=0)
-        if max(note_array["voice"], default=0) != 0
-        else 1
-        for note_array in note_arrays
-    ]
-    # find the maximum number of staves for each part (staff number start from 0 but we force them to 1)
-    maximum_staves = [
-        max(note_array["staff"], default=0)
-        if max(note_array["staff"], default=0) != 0
-        else 1
-        for note_array in note_arrays
-    ]
-
-    if reassign == "staff":
-        el_to_discard = (
-            Barline,
-            Page,
-            System,
-            Measure,
-            TimeSignature,
-            KeySignature,
-            DaCapo,
-            Fine,
-            Fermata,
-            Ending,
-            Tempo,
-        )
-    elif reassign == "voice":
-        el_to_discard = (
-            Barline,
-            Page,
-            System,
-            Clef,
-            Measure,
-            TimeSignature,
-            KeySignature,
-            DaCapo,
-            Fine,
-            Fermata,
-            Ending,
-            Tempo,
-        )
-
-    for p_ind, p in enumerate(parts):
-        for e in p.iter_all():
-            # full copy the first part and partially copy the others
-            # we don't copy elements like duplicate barlines, clefs or
-            # time signatures for others
-            # TODO : check  DaCapo, Fine, Fermata, Ending, Tempo
-            if p_ind == 0 or not isinstance(
-                e,
-                el_to_discard,
-            ):  # a time multiplier is used to account for different divisions
-                new_start = e.start.t * time_multiplier_per_part[p_ind]
-                new_end = (
-                    e.end.t * time_multiplier_per_part[p_ind]
-                    if e.end is not None
-                    else None
-                )
-                if reassign == "voice":
-                    if isinstance(e, GenericNote):
-                        e.voice = e.voice + sum(maximum_voices[:p_ind])
-                elif reassign == "staff":
-                    if isinstance(e, (GenericNote, Words, Direction)):
-                        e.staff = e.staff + sum(maximum_staves[:p_ind])
-                    elif isinstance(
-                        e, Clef
-                    ):  # TODO: to update if "number" get changed in "staff"
-                        e.staff = e.staff + sum(maximum_staves[:p_ind])
-                new_part.add(e, start=new_start, end=new_end)
-
-                # new_part.add(copy.deepcopy(e), start=new_start, end=new_end)
-    return new_part
-
-
-def is_a_within_b(a, b, wholly=False):
-    """
-    Returns a boolean indicating whether a is (wholly) within b.
-
-    Parameters
-    ----------
-    a: TimePoint, TimedObject, int
-        Query object
-    b: TimedObject
-        Container object
-    wholly: bool
-        True = a needs to wholly contained in b
-    """
-    contained = None
-    if not isinstance(b, TimedObject):
-        warnings.warn("b needs to be TimedObject")
-    if isinstance(a, TimePoint):
-        contained = a.t <= b.end.t and a.t >= b.start.t
-    elif isinstance(a, int):
-        contained = a <= b.end.t and a >= b.start.t
-    elif isinstance(a, TimedObject):
-        contained_start = a.start.t <= b.end.t and a.start.t >= b.start.t
-        contained_end = a.end.t <= b.end.t and a.end.t >= b.start.t
-        if wholly:
-            contained = contained_start and contained_end
-        else:
-            contained = contained_start or contained_end
-    else:
-        warnings.warn("a needs to be TimePoint, TImedObject, or int.")
-    return contained
-
-
-class InvalidTimePointException(Exception):
-    """Raised when a time point is instantiated with an invalid number."""
-
-    def __init__(self, message=None):
-        super().__init__(message)
-
-
-if __name__ == "__main__":
-    import doctest
-
-    doctest.testmod()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+This module defines an ontology of musical elements to represent
+musical scores, such as measures, notes, slurs, words, tempo and
+loudness directions. A score is defined at the highest level by a
+`Part` object (or a hierarchy of `Part` objects, in a `PartGroup`
+object). This object serves as a timeline at which musical elements
+are registered in terms of their start and end times.
+"""
+
+from copy import copy
+from collections import defaultdict
+from collections.abc import Iterable
+from numbers import Number
+
+# import copy
+from partitura.utils.music import MUSICAL_BEATS, INTERVALCLASSES
+import warnings
+import numpy as np
+from scipy.interpolate import PPoly
+from typing import Union, List, Optional, Iterator, Iterable as Itertype
+
+from partitura.utils import (
+    ComparableMixin,
+    ReplaceRefMixin,
+    iter_subclasses,
+    iter_current_next,
+    sorted_dict_items,
+    PrettyPrintTree,
+    ALTER_SIGNS,
+    find_tie_split,
+    format_symbolic_duration,
+    estimate_symbolic_duration,
+    symbolic_to_numeric_duration,
+    fifths_mode_to_key_name,
+    pitch_spelling_to_midi_pitch,
+    note_array_from_part,
+    rest_array_from_part,
+    rest_array_from_part_list,
+    note_array_from_part_list,
+    to_quarter_tempo,
+    key_mode_to_int,
+    _OrderedSet,
+    update_note_ids_after_unfolding,
+)
+
+from partitura.utils.generic import interp1d
+
+
+class Part(object):
+    """Represents a score part, e.g. all notes of one single instrument
+    (or multiple instruments written in the same staff). Note that
+    there may be more than one staff per score part.
+
+    Parameters
+    ----------
+    id : str
+        The identifier of the part. In order to be compatible with
+        MusicXML the identifier should not start with a number.
+    part_name : str or None, optional
+        Name for the part. Defaults to None
+    part_abbreviation : str or None, optional
+        Abbreviated name for part
+    quarter_duration : int, optional
+        The default quarter duration. See
+        :meth:`~partitura.score.Part.set_quarter_duration` for
+        details.
+
+    Attributes
+    ----------
+    id : str
+        See parameters
+    part_name : str
+        See parameters
+    part_abbreviation : str
+        See parameters
+
+    """
+
+    def __init__(self, id, part_name=None, part_abbreviation=None, quarter_duration=1):
+        super().__init__()
+        self.id = id
+        self.parent = None
+        self.part_name = part_name
+        self.part_abbreviation = part_abbreviation
+
+        # timeline init
+        self._points = np.array([], dtype=TimePoint)
+        self._quarter_times = [0]
+        self._quarter_durations = [quarter_duration]
+        self._quarter_map = self.quarter_duration_map
+
+        # set beat reference
+        self._use_musical_beat = False
+
+        # store number of staves
+        self._number_of_staves = None
+
+    def __str__(self):
+        return 'Part id="{}" name="{}"'.format(self.id, self.part_name)
+
+    def _pp(self, tree):
+        result = [self.__str__()]
+        tree.push()
+        N = len(self._points)
+        for i, timepoint in enumerate(self._points):
+            result.append("{}".format(tree).rstrip())
+            if i == N - 1:
+                tree.last_item()
+            else:
+                tree.next_item()
+            result.extend(timepoint._pp(tree))
+        tree.pop()
+        return result
+
+    def pretty(self):
+        """Return a pretty representation of this object.
+
+        Returns
+        -------
+        str
+            A pretty representation
+
+        """
+        return "\n".join(self._pp(PrettyPrintTree()))
+
+    @property
+    def time_signature_map(self):
+        """A function mapping timeline times to the beats and beat_type
+        of the time signature at that time. The function can take
+        scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        tss = np.array(
+            [
+                (ts.start.t, ts.beats, ts.beat_type, ts.musical_beats)
+                for ts in self.iter_all(TimeSignature)
+            ]
+        )
+
+        if len(tss) == 0:
+            # default time sig
+            beats, beat_type, musical_beats = 4, 4, 4
+            warnings.warn(
+                "No time signatures found, assuming {}/{}".format(beats, beat_type)
+            )
+            if self.first_point is None:
+                t0, tN = 0, 0
+            else:
+                t0 = self.first_point.t
+                tN = self.last_point.t
+            tss = np.array(
+                [
+                    (t0, beats, beat_type, musical_beats),
+                    (tN, beats, beat_type, musical_beats),
+                ]
+            )
+        elif len(tss) == 1:
+            # If there is only a single time signature
+            tss = np.array([tss[0, :], tss[0, :]])
+        elif tss[0, 0] > self.first_point.t:
+            tss = np.vstack(
+                ((self.first_point.t, tss[0, 1], tss[0, 2], tss[0, 3]), tss)
+            )
+
+        return interp1d(
+            tss[:, 0],
+            tss[:, 1:],
+            axis=0,
+            kind="previous",
+            bounds_error=False,
+            fill_value="extrapolate",
+        )
+
+    @property
+    def key_signature_map(self):
+        """A function mappting timeline times to the key and mode of
+        the key signature at that time. The function can take scalar
+        values or lists/arrays of values
+
+        Returns
+        -------
+        function
+            The mapping function
+        """
+        kss = np.array(
+            [
+                (ks.start.t, ks.fifths, key_mode_to_int(ks.mode))
+                for ks in self.iter_all(KeySignature)
+            ]
+        )
+
+        if len(kss) == 0:
+            # default key signature
+            fifths, mode = 0, 1
+            warnings.warn("No key signature found, assuming C major")
+            if self.first_point is None:
+                t0, tN = 0, 0
+            else:
+                t0 = self.first_point.t
+                tN = self.first_point.t
+
+            kss = np.array([(t0, fifths, mode), (tN, fifths, mode)])
+
+        elif kss[0, 0] > self.first_point.t:
+            kss = np.vstack(((self.first_point.t, kss[0, 1], kss[0, 2]), kss))
+
+        return interp1d(
+            kss[:, 0],
+            kss[:, 1:],
+            axis=0,
+            kind="previous",
+            bounds_error=False,
+            fill_value="extrapolate",
+        )
+
+    @property
+    def measure_map(self):
+        """A function mapping timeline times to the start and end of
+        the measure they are contained in. The function can take
+        scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        measures = np.array([(m.start.t, m.end.t) for m in self.iter_all(Measure)])
+
+        # correct for anacrusis
+        divs_per_beat = self.inv_beat_map(
+            1 + self.beat_map(0)
+        )  # find the divs per beat in the first measure
+        if (
+            measures[0][1] - measures[0][0]
+            < self.time_signature_map(0)[0] * divs_per_beat
+        ):
+            measures[0][0] = (
+                measures[0][1] - self.time_signature_map(0)[0] * divs_per_beat
+            )
+
+        if len(measures) == 0:  # no measures in the piece
+            # default only one measure spanning the entire timeline
+            warnings.warn("No measures found, assuming only one measure")
+            if self.first_point is None:
+                t0, tN = 0, 0
+            else:
+                t0 = self.first_point.t
+                tN = self.last_point.t
+
+            measures = np.array([(t0, tN)])
+
+        inter_function = interp1d(
+            measures[:, 0],
+            measures[:, :].astype(int),
+            kind="previous",
+            axis=0,
+            fill_value="extrapolate",
+            dtype=int,
+        )
+
+        return inter_function
+
+    @property
+    def measure_number_map(self):
+        """A function mapping timeline times to the measure number of
+        the measure they are contained in. The function can take
+        scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        # operations to avoid None values and filter them efficiently.
+        m_it = self.measures
+        measures = np.array(
+            [
+                [
+                    m.start.t,
+                    m.end.t,
+                    (m_it[i - 1].number if m.number == None else m.number),
+                ]
+                for i, m in enumerate(m_it)
+            ]
+        )
+        # correct for anacrusis
+        divs_per_beat = self.inv_beat_map(
+            1 + self.beat_map(0)
+        )  # find the divs per beat in the first measure
+        if (
+            measures[0][1] - measures[0][0]
+            < self.time_signature_map(0)[0] * divs_per_beat
+        ):
+            measures[0][0] = (
+                measures[0][1] - self.time_signature_map(0)[0] * divs_per_beat
+            )
+
+        if len(measures) == 0:  # no measures in the piece
+            # default only one measure spanning the entire timeline
+            warnings.warn("No measures found, assuming only one measure")
+            if self.first_point is None:
+                t0, tN = 0, 0
+            else:
+                t0 = self.first_point.t
+                tN = self.last_point.t
+
+            measures = np.array([(t0, tN, 1)])
+
+        inter_function = interp1d(
+            measures[:, 0],
+            measures[:, 2],
+            kind="previous",
+            fill_value="extrapolate",
+            dtype=int,
+        )
+
+        return inter_function
+
+    @property
+    def metrical_position_map(self):
+        """A function mapping timeline times to their relative position in
+        the measure they are contained in. The function can take
+        scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        measure_map = self.measure_map
+        ms = [measure_map(m.start.t)[0] for m in self.iter_all(Measure)]
+        me = [measure_map(m.start.t)[1] for m in self.iter_all(Measure)]
+
+        if len(ms) < 2:
+            warnings.warn("No or single measures found, metrical position 0 everywhere")
+            zero_interpolator = interp1d(
+                np.arange(0, 2),
+                np.zeros((2, 2)),
+                axis=0,
+                kind="linear",
+                fill_value="extrapolate",
+                dtype=int,
+            )
+
+            return zero_interpolator
+        else:
+            barlines = np.array(ms + me[-1:])
+            bar_durations = np.diff(barlines)
+            measure_inter_function = interp1d(
+                barlines[:-1],
+                bar_durations,
+                axis=0,
+                kind="previous",
+                fill_value="extrapolate",
+            )
+
+            lin_poly_coeff = np.row_stack(
+                (np.ones(bar_durations.shape[0]), np.zeros(bar_durations.shape[0]))
+            )
+            inter_function = PPoly(lin_poly_coeff, barlines)
+
+            def int_interp1d(input):
+                if isinstance(input, Iterable):
+                    return np.column_stack(
+                        (
+                            inter_function(input).astype(int),
+                            measure_inter_function(input).astype(int),
+                        )
+                    )
+                else:
+                    return (
+                        inter_function(input).astype(int),
+                        measure_inter_function(input).astype(int),
+                    )
+
+            return int_interp1d
+
+    def _time_interpolator(self, quarter=False, inv=False, musical_beat=False):
+
+        if len(self._points) < 2:
+            return lambda x: np.zeros(len(x))
+
+        keypoints = defaultdict(lambda: [None, None])
+        _ = keypoints[self.first_point.t]
+        _ = keypoints[self.last_point.t]
+        for t, q in zip(self._quarter_times, self._quarter_durations):
+            keypoints[t][0] = q
+        if not quarter:
+            for ts in self.iter_all(TimeSignature):
+                # keypoints[ts.start.t][1] = int(np.log2(ts.beat_type))
+                if musical_beat:
+                    keypoints[ts.start.t][1] = (ts.beat_type / 4) * (
+                        ts.musical_beats / ts.beats
+                    )
+                else:
+                    keypoints[ts.start.t][1] = ts.beat_type / 4
+        cur_div = 1
+        cur_bt = 1
+        keypoints_list = []
+
+        for t in sorted(keypoints.keys()):
+            kp = keypoints[t]
+            if kp[0] is None:
+                kp[0] = cur_div
+            else:
+                cur_div = kp[0]
+            if kp[1] is None:
+                kp[1] = cur_bt
+            else:
+                cur_bt = kp[1]
+            if not keypoints_list or kp != keypoints_list[-1]:
+                keypoints_list.append([t] + kp)
+        keypoints = np.array(keypoints_list, dtype=float)
+
+        x = keypoints[:, 0]
+        y = np.r_[
+            0,
+            np.cumsum(
+                (keypoints[:-1, 2] * np.diff(keypoints[:, 0])) / keypoints[:-1, 1]
+            ),
+        ]
+
+        m1 = next(self.first_point.iter_starting(Measure), None)
+
+        if m1 and m1.start is not None and m1.end is not None:
+
+            f = interp1d(x, y)
+            actual_dur = np.diff(f((m1.start.t, m1.end.t)))[0]
+            ts = next(m1.start.iter_starting(TimeSignature), None)
+
+            if ts:
+
+                normal_dur = ts.beats
+                if quarter:
+                    normal_dur *= 4 / ts.beat_type
+                if musical_beat:
+                    normal_dur = ts.musical_beats
+                if actual_dur < normal_dur:
+                    y -= actual_dur
+            else:
+                # warn
+                pass
+
+        if inv:
+            return interp1d(y, x)
+        else:
+            return interp1d(x, y)
+
+    @property
+    def beat_map(self):
+        """A function mapping timeline times to beat times. The function
+        can take scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        if self._use_musical_beat:
+            return self._time_interpolator(musical_beat=True)
+        else:
+            return self._time_interpolator()
+
+    @property
+    def inv_beat_map(self):
+        """A function mapping beat times to timeline times. The function
+        can take scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        if self._use_musical_beat:
+            return self._time_interpolator(inv=True, musical_beat=True)
+        else:
+            return self._time_interpolator(inv=True)
+
+    @property
+    def quarter_map(self):
+        """A function mapping timeline times to quarter times. The
+        function can take scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        return self._time_interpolator(quarter=True)
+
+    @property
+    def inv_quarter_map(self):
+        """A function mapping quarter times to timeline times. The
+        function can take scalar values or lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        return self._time_interpolator(quarter=True, inv=True)
+
+    @property
+    def notes(self):
+        """Return a list of all Note objects in the part. This list includes
+        GraceNote objects but not Rest objects.
+
+        Returns
+        -------
+        list
+            list of Note objects
+
+        """
+        return list(self.iter_all(Note, include_subclasses=True))
+
+    @property
+    def notes_tied(self):
+        """Return a list of all Note objects in the part that are
+        either not tied, or the first note of a group of tied notes.
+        This list includes GraceNote objects but not Rest objects.
+
+        Returns
+        -------
+        list
+            List of Note objects
+
+        """
+        return [
+            note
+            for note in self.iter_all(Note, include_subclasses=True)
+            if note.tie_prev is None
+        ]
+
+    @property
+    def measures(self):
+        """Return a list of all Measure objects in the part
+
+        Returns
+        -------
+        list
+            List of Measure objects
+
+        """
+        return [e for e in self.iter_all(Measure, include_subclasses=False)]
+
+    @property
+    def rests(self):
+        """Return a list of all rest objects in the part
+
+        Returns
+        -------
+        list
+            List of Rest objects
+
+        """
+        return [e for e in self.iter_all(Rest, include_subclasses=False)]
+
+    @property
+    def repeats(self):
+        """Return a list of all Repeat objects in the part
+
+        Returns
+        -------
+        list
+            List of Repeat objects
+
+        """
+        return [e for e in self.iter_all(Repeat, include_subclasses=False)]
+
+    @property
+    def key_sigs(self):
+        """Return a list of all Key Signature objects in the part
+
+        Returns
+        -------
+        list
+            List of Key Signature objects
+
+        """
+        return [e for e in self.iter_all(KeySignature, include_subclasses=False)]
+
+    @property
+    def time_sigs(self):
+        """Return a list of all Time Signature objects in the part
+
+        Returns
+        -------
+        list
+            List of Time Signature objects
+
+        """
+        return [e for e in self.iter_all(TimeSignature, include_subclasses=False)]
+
+    @property
+    def dynamics(self):
+        """Return a list of all Dynamics markings in the part
+
+        Returns
+        -------
+        list
+            List of Dynamics objects
+
+        """
+        return [e for e in self.iter_all(LoudnessDirection, include_subclasses=True)]
+
+    @property
+    def articulations(self):
+        """Return a list of all Articulation markings in the part
+
+        Returns
+        -------
+        list
+            List of Articulation objects
+
+        """
+        return [
+            e for e in self.iter_all(ArticulationDirection, include_subclasses=True)
+        ]
+
+    @property
+    def segments(self):
+        """Return a list of all segments in the part
+
+        Returns
+        -------
+        list
+            List of Segment objects
+
+        """
+        add_segments(self)
+        return [
+            e for e in self.iter_all(Segment, include_subclasses=False)
+        ]
+
+    def quarter_durations(self, start=None, end=None):
+        """Return an Nx2 array with quarter duration (second column)
+        and their respective times (first column).
+
+        When a start and or end time is specified, the returned
+        array will contain only the entries within those bounds.
+
+        Parameters
+        ----------
+        start : number, optional
+            Start of range
+        end : number, optional
+            End of range
+
+        Returns
+        -------
+        ndarray
+            An array with quarter durations and times
+
+        """
+
+        qd = np.column_stack((self._quarter_times, self._quarter_durations))
+        if start is not None:
+            qd = qd[qd[:, 0] >= start, :]
+        if end is not None:
+            qd = qd[qd[:, 0] < end, :]
+        return qd
+
+    @property
+    def quarter_duration_map(self):
+        """A function mapping timeline times to quarter durations in
+        effect at those times. The function can take scalar values or
+        lists/arrays of values.
+
+        Returns
+        -------
+        function
+            The mapping function
+
+        """
+        x = self._quarter_times
+        y = self._quarter_durations
+        if len(x) == 1:
+            x = x + x
+            y = y + y
+        return interp1d(
+            x, y, kind="previous", bounds_error=False, fill_value=(y[0], y[-1])
+        )
+
+    def set_quarter_duration(self, t, quarter):
+        """Set the duration of a quarter note from timepoint `t`
+        onwards.
+
+        Setting the quarter note duration defines how intervals
+        between timepoints are related to musical durations. For
+        example when two timepoints `t1` and `t2` have associated
+        times 10 and 20 respecively, then the interval between `t1`
+        and `t2` corresponds to a half note when the quarter duration
+        equals 5 during that interval.
+
+        The quarter duration can vary throughout the part. When
+        setting a quarter duration at time t, then that value takes
+        effect until the time of the next quarter duration. If a
+        different quarter duration was already set at time t, it wil
+        be replaced.
+
+        Note setting the quarter duration does not change the
+        timepoints, only the relation to musical time. For
+        illustration: in the example above, when changing the current
+        quarter duration from 5 to 10, a note that starts at `t1` and
+        ends at `t2` will change from being a half note to being a
+        quarter note.
+
+        Parameters
+        ----------
+        t : int
+            Time at which to set the quarter duration
+        quarter : int
+            The quarter duration
+
+        """
+
+        # add quarter duration at time t, unless it is redundant. If another
+        # quarter duration is at t, replace it.
+
+        # shorthand
+        times = self._quarter_times
+        quarters = self._quarter_durations
+
+        i = np.searchsorted(times, t)
+        changed = False
+
+        if i == 0 or quarters[i - 1] != quarter:
+            # add or replace
+            if i == len(times) or times[i] != t:
+                # add
+                times.insert(i, t)
+                quarters.insert(i, quarter)
+                changed = True
+            elif quarters[i] != quarter:
+                # replace
+                quarters[i] = quarter
+                changed = True
+            else:
+                # times[i] == t, quarters[i] == quarter
+                pass
+
+        if not changed:
+            return
+
+        if i + 1 == len(times):
+            t_next = np.inf
+        else:
+            t_next = times[i + 1]
+
+        # update quarter attribute of all timepoints in the range [t, t_next]
+        start_idx = np.searchsorted(self._points, TimePoint(t))
+        end_idx = np.searchsorted(self._points, TimePoint(t_next))
+        for tp in self._points[start_idx:end_idx]:
+            tp.quarter = quarter
+
+        # update the interpolation function
+        self._quarter_map = self.quarter_duration_map
+
+    def _add_point(self, tp):
+        # Add `TimePoint` object `tp` to the part, unless there is
+        # already a timepoint at the same time.
+
+        i = np.searchsorted(self._points, tp)
+        if i == len(self._points) or self._points[i].t != tp.t:
+            self._points = np.insert(self._points, i, tp)
+            if i > 0:
+                self._points[i - 1].next = self._points[i]
+                self._points[i].prev = self._points[i - 1]
+            if i < len(self._points) - 1:
+                self._points[i].next = self._points[i + 1]
+                self._points[i + 1].prev = self._points[i]
+
+    @property
+    def number_of_staves(self):
+        if self._number_of_staves is not None:
+            return self._number_of_staves
+        else:
+            return self.compute_number_of_staves()
+
+    def compute_number_of_staves(self):
+        max_staves = 1
+        for e in self.iter_all(GenericNote, include_subclasses=True):
+            if e.staff is not None and e.staff > max_staves:
+                max_staves = e.staff
+        for e in self.iter_all(Clef):
+            if e.staff is not None and e.staff > max_staves:
+                max_staves = e.staff
+        for e in self.iter_all(Direction, include_subclasses=True):
+            if e.staff is not None and e.staff > max_staves:
+                max_staves = e.staff
+        for e in self.iter_all(Words):
+            if e.staff is not None and e.staff > max_staves:
+                max_staves = e.staff
+
+        self._number_of_staves = max_staves
+        return max_staves
+
+    def _remove_point(self, tp):
+        i = np.searchsorted(self._points, tp)
+        if self._points[i] == tp:
+            self._points = np.delete(self._points, i)
+            if i > 0:
+                self._points[i - 1].next = self._points[i]
+                self._points[i].prev = self._points[i - 1]
+            if i < len(self._points) - 1:
+                self._points[i].next = self._points[i + 1]
+                self._points[i + 1].prev = self._points[i]
+
+    def get_point(self, t):
+        """Return the `TimePoint` object with time `t`, or None if
+        there is no such object.
+
+        """
+        if t < 0:
+            raise InvalidTimePointException(
+                "TimePoints should have non-negative integer values"
+            )
+
+        i = np.searchsorted(self._points, TimePoint(t))
+        if i < len(self._points) and self._points[i].t == t:
+            return self._points[i]
+        else:
+            return None
+
+    def get_or_add_point(self, t):
+        """Return the `TimePoint` object with time `t`; if there is no
+        such object, create it, add it to the time line, and return
+        it.
+
+        Parameters
+        ----------
+        t : int
+            Time value `t`
+
+        Returns
+        -------
+        :class:`TimePoint`
+            a TimePoint object with time `t`
+
+        """
+        if t < 0:
+            raise InvalidTimePointException(
+                "TimePoints should have non-negative integer values"
+            )
+
+        tp = self.get_point(t)
+        if tp is None:
+            tp = TimePoint(t, int(self._quarter_map(t)))
+            self._add_point(tp)
+        return tp
+
+    def add(self, o, start=None, end=None):
+        """Add an object to the timeline.
+
+        An object can be added by start time, end time, or both,
+        depending on which of the `start` and `end` keywords are
+        provided. If neither is provided this method does nothing.
+
+        `start` and `end` should be non-negative integers.
+
+        Parameters
+        ----------
+        o : :class:`TimedObject`
+            Object to be removed
+        start : int, optional
+            The start time of the object
+        end : int, optional
+            The end time of the object
+
+        """
+        if start is not None:
+            if start < 0:
+                raise InvalidTimePointException(
+                    "TimePoints should have non-negative integer values"
+                )
+            self.get_or_add_point(start).add_starting_object(o)
+        if end is not None:
+            if end < 0:
+                raise InvalidTimePointException(
+                    "TimePoints should have non-negative integer values"
+                )
+            self.get_or_add_point(end).add_ending_object(o)
+
+    def remove(self, o, which="both"):
+        """Remove an object from the timeline.
+
+        An object can be removed by start time, end time, or both.
+
+        Parameters
+        ----------
+        o : :class:`TimedObject`
+            Object to be removed
+        which : {'start', 'end', 'both'}, optional
+            Whether to remove o as a starting object, an ending
+            object, or both. Defaults to 'both'.
+
+        """
+
+        if which in ("start", "both") and o.start:
+            try:
+                o.start.starting_objects[o.__class__].remove(o)
+            except (KeyError, ValueError):
+                raise Exception(
+                    "Not implemented: removing an object "
+                    "that is registered by its superclass"
+                )
+            # cleanup timepoint if no starting/ending objects are left
+            self._cleanup_point(o.start)
+            o.start = None
+
+        if which in ("end", "both") and o.end:
+            try:
+                o.end.ending_objects[o.__class__].remove(o)
+            except (KeyError, ValueError):
+                raise Exception(
+                    "Not implemented: removing an object "
+                    "that is registered by its superclass"
+                )
+            # cleanup timepoint if no starting/ending objects are left
+            self._cleanup_point(o.end)
+            o.end = None
+
+    def _cleanup_point(self, tp):
+        # remove tp when it has no starting or ending objects
+        if (
+            sum(len(oo) for oo in tp.starting_objects.values())
+            + sum(len(oo) for oo in tp.ending_objects.values())
+        ) == 0:
+            self._remove_point(tp)
+
+    def iter_all(
+        self, cls=None, start=None, end=None, include_subclasses=False, mode="starting"
+    ):
+        """Iterate (in direction of increasing time) over all
+        instances of `cls` that either start or end (depending on
+        `mode`) in the interval `start` to `end`.  When `start` and
+        `end` are omitted, the whole timeline is searched.
+
+        Parameters
+        ----------
+        cls : class, optional
+            The class of objects to iterate over. If omitted, iterate
+            over all objects in the part.
+        start : :class:`TimePoint`, optional
+            The start of the interval to search. If omitted or None,
+            the search starts at the start of the timeline. Defaults
+            to None.
+        end : :class:`TimePoint`, optional
+            The end of the interval to search. If omitted or None, the
+            search ends at the end of the timeline. Defaults to None.
+        include_subclasses : bool, optional
+            If True also return instances that are subclasses of
+            `cls`. Defaults to False.
+        mode : {'starting', 'ending'}, optional
+            Flag indicating whether to search for starting or ending
+            objects. Defaults to 'starting'.
+
+        Yields
+        ------
+        object
+            Instances of the specified type.
+
+        """
+        if mode not in ("starting", "ending"):
+            warnings.warn('unknown mode "{}", using "starting" instead'.format(mode))
+            mode = "starting"
+
+        if start is None:
+            start_idx = 0
+        else:
+            if not isinstance(start, TimePoint):
+                start = TimePoint(start)
+            start_idx = np.searchsorted(self._points, start)
+
+        if end is None:
+            end_idx = len(self._points)
+        else:
+            if not isinstance(end, TimePoint):
+                end = TimePoint(end)
+            end_idx = np.searchsorted(self._points, end)
+
+        if cls is None:
+            cls = object
+            include_subclasses = True
+
+        if mode == "ending":
+            for tp in self._points[start_idx:end_idx]:
+                yield from tp.iter_ending(cls, include_subclasses)
+        else:
+            for tp in self._points[start_idx:end_idx]:
+                yield from tp.iter_starting(cls, include_subclasses)
+
+    def apply(self):
+        """Apply all changes to the timeline for objects like octave Shift."""
+        pass
+
+    @property
+    def last_point(self):
+        """The last TimePoint on the timeline, or None if the timeline
+        is empty.
+
+        Returns
+        -------
+        :class:`TimePoint`
+
+        """
+        return self._points[-1] if len(self._points) > 0 else None
+
+    @property
+    def first_point(self):
+        """The first TimePoint on the timeline, or None if the
+        timeline is empty.
+
+        Returns
+        -------
+        :class:`TimePoint`
+
+        """
+        return self._points[0] if len(self._points) > 0 else None
+
+    def note_array(self, **kwargs):
+        """
+        Create a structured array with note information
+        from a `Part` object.
+
+        Parameters
+        ----------
+
+        include_pitch_spelling : bool (optional)
+            If `True`, includes pitch spelling information for each
+            note. Default is False
+        include_key_signature : bool (optional)
+            If `True`, includes key signature information, i.e.,
+            the key signature at the onset time of each note (all
+            notes starting at the same time have the same key signature).
+            Default is False
+        include_time_signature : bool (optional)
+            If `True`,  includes time signature information, i.e.,
+            the time signature at the onset time of each note (all
+            notes starting at the same time have the same time signature).
+            Default is False
+        include_metrical_position : bool (optional)
+            If `True`,  includes metrical position information, i.e.,
+            the position of the onset time of each note with respect to its
+            measure (all notes starting at the same time have the same metrical
+            position).
+            Default is False
+        include_grace_notes : bool (optional)
+            If `True`,  includes grace note information, i.e. if a note is a
+            grace note and the grace type "" for non grace notes).
+            Default is False
+        include_divs_per_quarter : bool (optional)
+            If `True`,  includes the number of divs per quarter note.
+            Default is False
+
+        Returns:
+
+        note_array : structured array
+        """
+        return note_array_from_part(self, **kwargs)
+
+    def rest_array(
+        self,
+        include_pitch_spelling=False,
+        include_key_signature=False,
+        include_time_signature=False,
+        include_metrical_position=False,
+        include_grace_notes=False,
+        include_staff=False,
+        collapse=False,
+    ):
+        """
+        Create a structured array with rest information
+        from a `Part` object.
+
+        Parameters
+        ----------
+
+        include_pitch_spelling : bool (optional)
+            If `True`, includes pitch spelling information for each
+            rest, i.e. all information is 0. Default is False
+        include_key_signature : bool (optional)
+            If `True`, includes key signature information, i.e.,
+            the key signature at the onset time of each rest (all
+            notes starting at the same time have the same key signature).
+            Default is False
+        include_time_signature : bool (optional)
+            If `True`,  includes time signature information, i.e.,
+            the time signature at the onset time of each note (all
+            notes starting at the same time have the same time signature).
+            Default is False
+        include_metrical_position : bool (optional)
+            If `True`,  includes metrical position information, i.e.,
+            the position of the onset time of each rest with respect to its
+            measure (all notes starting at the same time have the same metrical
+            position).
+            Default is False
+        include_grace_notes : bool (optional)
+            If `True`,  includes returns empty strings as type and false.
+        feature_functions : list or str
+            A list of feature functions. Elements of the list can be either
+            the functions themselves or the names of a feature function as
+            strings (or a mix). The feature functions specified by name are
+            looked up in the `featuremixer.featurefunctions` module.
+
+        Returns:
+
+        rest_array : structured array
+        """
+        return rest_array_from_part(
+            self,
+            include_pitch_spelling=include_pitch_spelling,
+            include_key_signature=include_key_signature,
+            include_time_signature=include_time_signature,
+            include_metrical_position=include_metrical_position,
+            include_grace_notes=include_grace_notes,
+            include_staff=include_staff,
+            collapse=collapse,
+        )
+
+    def set_musical_beat_per_ts(self, mbeats_per_ts={}):
+        """Set the number of musical beats for each time signature.
+        If no musical beat is specified for a certain time signature,
+        the default one is used, i.e. 2 for 6/X, 3 for 9/X, 4 for 12/X,
+        and the number of beats for the others ts. Each musical beat
+        has equal duration.
+
+        Parameters
+        ----------
+        mbeats_per_ts : dict, optional
+            A dict where the keys are time signature strings
+            (e.g. "3/4") and the values are the number of musical beats.
+            If a certain time signature is not specified, the defaults
+            values are used.
+            Defaults to an empty dict.
+
+        """
+        if not isinstance(mbeats_per_ts, dict):
+            raise TypeError("mbeats_per_ts must be either a dictionary")
+
+        # correctly set the musical beat for all time signatures
+        for ts in self.iter_all(TimeSignature):
+            ts_string = "{}/{}".format(ts.beats, ts.beat_type)
+            if ts_string in mbeats_per_ts:
+                ts.musical_beats = mbeats_per_ts[ts_string]
+            else:  # set to default if not specified
+                if ts.beats in MUSICAL_BEATS:
+                    ts.musical_beats = MUSICAL_BEATS[ts.beats]
+                else:
+                    ts.musical_beats = ts.beats
+
+    def use_musical_beat(self, mbeats_per_ts={}):
+        """Consider the musical beat as the reference for all elements
+        that concern the number and position of beats.
+        An optional parameter can set the number of musical beats for
+        specific time signatures, otherwise the default values are
+        used.
+
+        Parameters
+        ----------
+        mbeats_per_ts : dict, optional
+            A dict where the keys are time signature strings
+            (e.g. "3/4") and the values are the number of musical beats.
+            If a certain time signature is not specified, the defaults
+            values are used.
+            Defaults to an empty dict.
+
+        """
+        if not self._use_musical_beat:
+            self._use_musical_beat = True
+            if mbeats_per_ts != {}:  # set the number of nbeats if specified
+                self.set_musical_beat_per_ts(mbeats_per_ts)
+        else:
+            warnings.warn("Musical beats were already being used!")
+
+    def use_notated_beat(self):
+        """Consider the notated beat (numerator of time signature)
+        as the reference for all elements that concern the number
+        and position of beats.
+        It also reset the number of musical beats for each time signature
+        to default values.
+        """
+        if self._use_musical_beat:
+            self._use_musical_beat = False
+            # reset the number of musical beats to default values
+            self.set_musical_beat_per_ts()
+        else:
+            warnings.warn("Notated beats were already being used!")
+
+    # @property
+    # def part_names(self):
+    #     # get instrument name parts recursively
+    #     chunks = []
+
+    #     if self.part_name is not None:
+    #         chunks.append(self.part_name)
+    #         yield self.part_name
+
+    #     pg = self.parent
+    #     while pg is not None:
+    #         if pg.group_name is not None:
+    #             chunks.insert(0, pg.group_name)
+    #             yield '  '.join(chunks)
+    #         pg = pg.parent
+
+
+class TimePoint(ComparableMixin):
+
+    """A TimePoint represents a temporal position within a
+    :class:`Part`.
+
+    TimePoints are used to keep track of the starting and ending of
+    musical elements in the part. They are created automatically when
+    adding musical elements to a part using its :meth:`~Part.add`
+    method, so there should be normally no reason to instantiate
+    TimePoints manually.
+
+    Parameters
+    ----------
+    t : int
+        The time associated to this TimePoint. Should be a non-
+        negative integer.
+    quarter : int
+        The duration of a quarter note at this TimePoint
+
+    Attributes
+    ----------
+    t : int
+        See parameters
+    quarter : int
+        See parameters
+    starting_objects : dictionary
+        A dictionary where the musical objects starting at this time
+        are grouped by class.
+    ending_objects : dictionary
+        A dictionary where the musical objects ending at this time are
+        grouped by class.
+    prev : TimePoint
+        The preceding TimePoint (or None if there is none)
+    next : TimePoint
+        The succeding TimePoint (or None if there is none)
+
+    """
+
+    def __init__(self, t, quarter=None):
+        self.t = t
+        self.quarter = quarter
+        self.starting_objects = defaultdict(_OrderedSet)
+        self.ending_objects = defaultdict(_OrderedSet)
+        # prev and next are dynamically updated once the timepoint is part of a timeline
+        self.next = None
+        self.prev = None
+
+    def __iadd__(self, value):
+        assert isinstance(value, Number)
+        self.t += value
+        return self
+
+    def __isub__(self, value):
+        assert isinstance(value, Number)
+        self.t -= value
+        return self
+
+    def __add__(self, value):
+        assert isinstance(value, Number)
+        new = copy(self)
+        new += value
+        return new
+
+    def __sub__(self, value):
+        assert isinstance(value, Number)
+        new = copy(self)
+        new -= value
+        return new
+
+    def __str__(self):
+        return "TimePoint t={} quarter={}".format(self.t, self.quarter)
+
+    def add_starting_object(self, obj):
+        """Add object `obj` to the list of starting objects."""
+        obj.start = self
+        self.starting_objects[type(obj)].add(obj)
+
+    def remove_starting_object(self, obj):
+        """Remove object `obj` from the list of starting objects."""
+        # TODO: check if object is stored under a superclass
+        obj.start = None
+        if type(obj) in self.starting_objects:
+            try:
+                self.starting_objects[type(obj)].remove(obj)
+            except ValueError:
+                # don't complain if the object isn't in starting_objects
+                pass
+
+    def remove_ending_object(self, obj):
+        """Remove object `obj` from the list of ending objects."""
+        # TODO: check if object is stored under a superclass
+        obj.end = None
+        if type(obj) in self.ending_objects:
+            try:
+                self.ending_objects[type(obj)].remove(obj)
+            except ValueError:
+                # don't complain if the object isn't in ending_objects
+                pass
+
+    def add_ending_object(self, obj):
+        """Add object `obj` to the list of ending objects."""
+        obj.end = self
+        self.ending_objects[type(obj)].add(obj)
+
+    def iter_starting(self, cls, include_subclasses=False):
+        """Iterate over all objects of type `cls` that start at this
+        time point.
+
+        Parameters
+        ----------
+        cls : class
+            The type of objects to iterate over
+        include_subclasses : bool, optional
+            When True, include all objects of all subclasses of `cls`
+            in the iteration. Defaults to False.
+
+        Yields
+        -------
+        cls
+            Instance of type `cls`
+
+        """
+        yield from self.starting_objects[cls]
+        if include_subclasses:
+            for subcls in iter_subclasses(cls):
+                yield from self.starting_objects[subcls]
+
+    def iter_ending(self, cls, include_subclasses=False):
+        """Iterate over all objects of type `cls` that end at this
+        time point.
+
+        Parameters
+        ----------
+        cls : class
+            The type of objects to iterate over
+        include_subclasses : bool, optional
+            When True, include all objects of all subclasses of `cls`
+            in the iteration. Defaults to False.
+
+        Yields
+        ------
+        cls
+            Instance of type `cls`
+
+        """
+        yield from self.ending_objects[cls]
+        if include_subclasses:
+            for subcls in iter_subclasses(cls):
+                yield from self.ending_objects[subcls]
+
+    def iter_prev(self, cls, eq=False, include_subclasses=False):
+        """Iterate backwards in time from the current timepoint over
+        starting object(s) of type `cls`.
+
+        Parameters
+        ----------
+        cls : class
+            Class of objects to iterate over
+        eq : bool, optional
+            If True start iterating at the current timepoint, rather
+            than its predecessor. Defaults to False.
+        include_subclasses : bool, optional
+            If True include subclasses of `cls` in the iteration.
+            Defaults to False.
+
+        Yields
+        ------
+        cls
+            Instances of `cls`
+
+        """
+        if eq:
+            tp = self
+        else:
+            tp = self.prev
+
+        while tp:
+            yield from tp.iter_starting(cls, include_subclasses)
+            tp = tp.prev
+
+    def iter_next(self, cls, eq=False, include_subclasses=False):
+        """Iterate forwards in time from the current timepoint over
+        starting object(s) of type `cls`.
+
+        Parameters
+        ----------
+        cls : class
+            Class of objects to iterate over
+        eq : bool, optional
+            If True start iterating at the current timepoint, rather
+            than its successor. Defaults to False.
+        include_subclasses : bool, optional
+            If True include subclasses of `cls` in the iteration.
+            Defaults to False.
+
+        Yields
+        ------
+        cls
+            Instances of `cls`
+
+        """
+        if eq:
+            tp = self
+        else:
+            tp = self.next
+
+        while tp:
+            yield from tp.iter_starting(cls, include_subclasses)
+            tp = tp.next
+
+    def _cmpkey(self):
+        # This method returns the value to be compared (code for that is in
+        # the ComparableMixin class)
+        return self.t
+
+    def _pp(self, tree):
+        # pretty print the timepoint, including its starting and ending
+        # objects
+        result = ["{}{}".format(tree, self.__str__())]
+        tree.push()
+
+        ending_items_lists = sorted_dict_items(
+            self.ending_objects.items(), key=lambda x: x[0].__name__
+        )
+        starting_items_lists = sorted_dict_items(
+            self.starting_objects.items(), key=lambda x: x[0].__name__
+        )
+
+        ending_items = [
+            o
+            for _, oo in ending_items_lists
+            for o in sorted(oo, key=lambda x: x.duration or -1, reverse=True)
+        ]
+        starting_items = [
+            o
+            for _, oo in starting_items_lists
+            for o in sorted(oo, key=lambda x: x.duration or -1)
+        ]
+
+        if ending_items:
+
+            result.append("{}".format(tree).rstrip())
+
+            if starting_items:
+                tree.next_item()
+            else:
+                tree.last_item()
+
+            result.append("{}ending objects".format(tree))
+            tree.push()
+            result.append("{}".format(tree).rstrip())
+
+            for i, item in enumerate(ending_items):
+
+                if i == (len(ending_items) - 1):
+                    tree.last_item()
+                else:
+                    tree.next_item()
+
+                result.append("{}{}".format(tree, item))
+
+            tree.pop()
+
+        if starting_items:
+
+            result.append("{}".format(tree).rstrip())
+            tree.last_item()
+            result.append("{}starting objects".format(tree))
+            tree.push()
+            result.append("{}".format(tree).rstrip())
+
+            for i, item in enumerate(starting_items):
+
+                if i == (len(starting_items) - 1):
+                    tree.last_item()
+                else:
+                    tree.next_item()
+                result.append("{}{}".format(tree, item))
+
+            tree.pop()
+
+        tree.pop()
+        return result
+
+
+class TimedObject(ReplaceRefMixin):
+    """This is the base class of all classes that have a start and end
+    point. The start and end attributes initialized to None, and are
+    set/unset when the object is added to/removed from a Part, using
+    its :meth:`~Part.add` and :meth:`~Part.remove` methods,
+    respectively.
+
+    Attributes
+    ----------
+    start : :class:`TimePoint`
+        Start time of the object
+    end : :class:`TimePoint`
+        End time of the object
+
+    """
+
+    def __init__(self):
+        super().__init__()
+        self.start = None
+        self.end = None
+
+    def __str__(self):
+        start = "" if self.start is None else f"{self.start.t}"
+        end = "" if self.end is None else f"{self.end.t}"
+        return start + "--" + end + " " + type(self).__name__
+
+    @property
+    def duration(self):
+        """The duration of the timed object in divisions. When either
+        the start or the end property of the object are None, the
+        duration is None.
+
+        Returns
+        -------
+        int or None
+
+        """
+        if self.start is None or self.end is None:
+            return None
+        else:
+            return self.end.t - self.start.t
+
+
+class GenericNote(TimedObject):
+    """Represents the common aspects of notes, rests, and unpitched
+    notes.
+
+    Parameters
+    ----------
+    id : str, optional (default: None)
+        A string identifying the note. To be compatible with the
+        MusicXML format, the id must be unique within a part and must
+        not start with a number.
+    voice : int, optional
+        An integer representing the voice to which the note belongs.
+        Defaults to None.
+    staff : str, optional
+        An integer representing the staff to which the note belongs.
+        Defaults to None.
+    doc_order : int, optional
+        The document order index (zero-based), expressing the order of
+        appearance of this note (with respect to other notes) in the
+        document in case the Note belongs to a part that was imported
+        from MusicXML. Defaults to None.
+
+    """
+
+    def __init__(
+        self,
+        id=None,
+        voice=None,
+        staff=None,
+        symbolic_duration=None,
+        articulations=None,
+        ornaments=None,
+        doc_order=None,
+    ):
+        self._sym_dur = None
+        super().__init__()
+        self.voice = voice
+        self.id = id
+        self.staff = staff
+        self.symbolic_duration = symbolic_duration
+        self.articulations = articulations
+        self.ornaments = ornaments
+        self.doc_order = doc_order
+
+        # these attributes are set after the instance is constructed
+        self.fermata = None
+        self.tie_prev = None
+        self.tie_next = None
+        self.slur_stops = []
+        self.slur_starts = []
+        self.tuplet_stops = []
+        self.tuplet_starts = []
+
+        # maintain a list of attributes to update when cloning this instance
+        self._ref_attrs.extend(
+            [
+                "tie_prev",
+                "tie_next",
+                "slur_stops",
+                "slur_starts",
+                "tuplet_stops",
+                "tuplet_starts",
+            ]
+        )
+
+    @property
+    def symbolic_duration(self):
+        """The symbolic duration of the note.
+
+        This property returns a dictionary specifying the symbolic
+        duration of the note. The dictionary may have the following
+        keys:
+
+        * type : the note type as a string, e.g. 'quarter', 'half'
+
+        * dots : an integer specifying the number of dots. When
+          this key is missing it means there are no dots.
+
+        * actual_notes : Specifies the number of actual notes in a
+          rhythmical tuplet. Used in conjunction with `normal_notes`.
+
+        * normal_notes : Specifies the normal number of notes in a
+          rhythmical tuplet. For example a triplet of eights in the
+          time of two eights would correspond to actual_notes=3,
+          normal_notes=2.
+
+        The symbolic duration dictionary of a note can either be
+        set manually (for example by specifying the
+        `symbolic_duration` constructor keyword argument), or left
+        unspecified (i.e. None). In the latter case the symbolic
+        duration is estimated dynamically based on the note start and
+        end times. Note that this latter case is generally preferrable
+        because it ensures that the symbolic duration is consistent
+        with the numeric duration.
+
+        If the symbolic duration cannot be estimated from the
+        numeric duration None is returned.
+
+        Returns
+        -------
+        dict or None
+            A dictionary specifying the symbolic duration of the note, or
+            None if the symbolic duration could not be estimated from the
+            numeric duration.
+
+        """
+        if self._sym_dur is None:
+            # compute value
+            if not self.start or not self.end:
+                warnings.warn(
+                    "Cannot estimate symbolic duration for notes that "
+                    "are not added to a Part"
+                )
+                return None
+            if self.start.quarter is None:
+                warnings.warn(
+                    "Cannot estimate symbolic duration when not "
+                    "quarter_duration has been set. "
+                    "See Part.set_quarter_duration."
+                )
+                return None
+            return estimate_symbolic_duration(self.duration, self.start.quarter)
+        else:
+            # return set value
+            return self._sym_dur
+
+    @symbolic_duration.setter
+    def symbolic_duration(self, v):
+        self._sym_dur = v
+
+    @property
+    def end_tied(self):
+        """The `Timepoint` corresponding to the end of the note, or---
+        when this note belongs to a group of tied notes---the end of
+        the last note in the group.
+
+        Returns
+        -------
+        TimePoint
+            End of note
+
+        """
+        if self.tie_next is None:
+            return self.end
+        else:
+            return self.tie_next.end_tied
+
+    @property
+    def duration_tied(self):
+        """Time difference of the start of the note to the end of the
+        note, or---when  this note belongs to a group of tied notes---
+        the end of the last note in the group.
+
+        Returns
+        -------
+        int
+            Duration of note
+
+        """
+        if self.tie_next is None:
+            return self.duration
+        else:
+            return self.duration + self.tie_next.duration_tied
+
+    @property
+    def duration_from_symbolic(self):
+        """Return the numeric duration given the symbolic duration of
+        the note and the quarter_duration in effect.
+
+        Returns
+        -------
+        int or None
+
+        """
+
+        if self.symbolic_duration:
+            # check for self.start, and self.start.quarter
+            return symbolic_to_numeric_duration(
+                self.symbolic_duration, self.start.quarter
+            )
+        else:
+            return None
+
+    @property
+    def tie_prev_notes(self):
+        """TODO
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            Description of return value
+        """
+
+        if self.tie_prev:
+            return self.tie_prev.tie_prev_notes + [self.tie_prev]
+        else:
+            return []
+
+    @property
+    def tie_next_notes(self):
+        """TODO
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        type
+            Description of return value
+        """
+
+        if self.tie_next:
+            return [self.tie_next] + self.tie_next.tie_next_notes
+        else:
+            return []
+
+    # def iter_voice_prev(self):
+    #     """TODO
+
+    #     Parameters
+    #     ----------
+
+    #     Returns
+    #     -------
+    #     type
+    #         Description of return value
+    #     """
+
+    #     for n in self.start.iter_prev(GenericNote, include_subclasses=True):
+    #         if n.voice == n.voice:
+    #             yield n
+
+    # def iter_voice_next(self):
+    #     """TODO
+
+    #     Parameters
+    #     ----------
+
+    #     Returns
+    #     -------
+    #     type
+    #         Description of return value
+    #     """
+
+    #     for n in self.start.iter_next(GenericNote, include_subclasses=True):
+    #         if n.voice == n.voice:
+    #             yield n
+
+    def iter_chord(self, same_duration=True, same_voice=True):
+        """Iterate over notes with coinciding start times.
+
+        Parameters
+        ----------
+        same_duration : bool, optional
+            When True limit the iteration to notes that have the same
+            duration as the current note. Defaults to True.
+        same_voice : bool, optional
+            When True limit the iteration to notes that have the same
+            voice as the current note. Defaults to True.
+
+        Yields
+        ------
+        GenericNote
+
+        """
+
+        for n in self.start.iter_starting(GenericNote, include_subclasses=True):
+            if ((not same_voice) or n.voice == self.voice) and (
+                (not same_duration) or (n.duration == self.duration)
+            ):
+                yield n
+
+    def __str__(self):
+        s = "{} id={} voice={} staff={} type={}".format(
+            super().__str__(),
+            self.id,
+            self.voice,
+            self.staff,
+            format_symbolic_duration(self.symbolic_duration),
+        )
+        if self.articulations:
+            s += " articulations=({})".format(", ".join(self.articulations))
+        if self.tie_prev or self.tie_next:
+            all_tied = self.tie_prev_notes + [self] + self.tie_next_notes
+            tied_id = "+".join(n.id or "None" for n in all_tied)
+            return s + " tie_group={}".format(tied_id)
+        else:
+            return s
+
+
+class Note(GenericNote):
+    """Subclass of GenericNote representing pitched notes.
+
+    Parameters
+    ----------
+    step : {'C', 'D', 'E', 'F', 'G', 'A', 'B'}
+        The note name of the pitch (in upper case). If a lower case
+        note name is given, it will be converted to upper case.
+    octave : int
+        An integer representing the octave of the pitch
+    alter : int, optional
+        An integer (or None) representing the alteration of the pitch as
+        follows:
+
+        -2
+            double flat
+        -1
+            flat
+        0 or None
+            unaltered
+        1
+            sharp
+        2
+            double sharp
+
+        Defaults to None.
+
+    """
+
+    def __init__(self, step, octave, alter=None, beam=None, **kwargs):
+        super().__init__(**kwargs)
+        self.step = step.upper()
+        self.octave = octave
+        self.alter = alter
+        self.beam = beam
+
+        if self.beam is not None:
+            self.beam.append(self)
+
+    def __str__(self):
+        return " ".join(
+            (
+                super().__str__(),
+                "pitch={}{}{}".format(self.step, self.alter_sign, self.octave),
+            )
+        )
+
+    @property
+    def midi_pitch(self):
+        """The midi pitch value of the note (MIDI note number). C4
+        (middle C, in german: c') is note number 60.
+
+        Returns
+        -------
+        integer
+            The note's pitch as MIDI note number.
+
+        """
+        return pitch_spelling_to_midi_pitch(
+            step=self.step, octave=self.octave, alter=self.alter
+        )
+
+    @property
+    def alter_sign(self):
+        """The alteration of the note
+
+        Returns
+        -------
+        str
+
+        """
+        return ALTER_SIGNS[self.alter]
+
+
+class UnpitchedNote(GenericNote):
+    """Subclass of GenericNote representing unpitched notes.
+
+    Parameters
+    ----------
+        Parameters
+    ----------
+    step : {'C', 'D', 'E', 'F', 'G', 'A', 'B'}
+        The note name of the pitch (in upper case). If a lower case
+        note name is given, it will be converted to upper case.
+    octave : int
+        An integer representing the octave of the pitch
+    notehead : string
+        A string representing the notehead.
+        Defaults to None
+    noteheadstyle : bool
+        A boolean indicating whether the notehead is filled.
+        Defaults to true
+
+    """
+
+    def __init__(
+        self, step, octave, beam=None, notehead=None, noteheadstyle=True, **kwargs
+    ):
+        super().__init__(**kwargs)
+        self.step = step.upper()
+        self.octave = octave
+        self.beam = beam
+        self.notehead = notehead
+        self.noteheadstyle = noteheadstyle
+
+        if self.beam is not None:
+            self.beam.append(self)
+
+    def __str__(self):
+        return " ".join(
+            (
+                super().__str__(),
+                "pitch={}{}{}".format(self.step, "", self.octave),
+            )
+        )
+
+    @property
+    def midi_pitch(self):
+        """The midi pitch value of the note (MIDI note number).
+
+        Returns
+        -------
+        integer
+            The note's position as MIDI note number.
+
+        """
+        return pitch_spelling_to_midi_pitch(step=self.step, octave=self.octave, alter=0)
+
+
+class Rest(GenericNote):
+    """A subclass of GenericNote representing a rest."""
+
+    def __init__(self, hidden=False, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.hidden = hidden
+
+
+class Beam(TimedObject):
+    """Represent beams (for MEI)"""
+
+    def __init__(self, id=None):
+        super().__init__()
+        self.id = id
+        self.notes = []
+
+    def append(self, note):
+        note.beam = self
+        self.notes.append(note)
+        self.update_time()
+
+    def update_time(self):
+        start_idx = np.argmin([n.start.t for n in self.notes])
+        end_idx = np.argmax([n.end.t for n in self.notes])
+
+        self.start = self.notes[start_idx].start
+        self.end = self.notes[end_idx].end
+
+
+class GraceNote(Note):
+    """A subclass of Note representing a grace note.
+
+    Parameters
+    ----------
+    grace_type : {'grace', 'acciaccatura', 'appoggiatura'}
+        The type of grace note. Use 'grace' for a unspecified grace
+        note type.
+    steal_proportion : float, optional
+        The proportion of the previous (acciaccatura) or next
+        (appoggiatura) note duration that is occupied by the grace
+        note. Defaults to None.
+
+    Attributes
+    ----------
+    main_note : :class:`Note`
+        The (non-grace) note to which this grace note belongs.
+    grace_seq_len : list
+        The length of the sequence of grace notes to which this grace
+        note belongs.
+
+    """
+
+    def __init__(self, grace_type, *args, steal_proportion=None, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.grace_type = grace_type
+        self.steal_proportion = steal_proportion
+        self.grace_next = None
+        self.grace_prev = None
+        self._ref_attrs.extend(["grace_next", "grace_prev"])
+
+    @property
+    def main_note(self):
+        n = self.grace_next
+        while isinstance(n, GraceNote):
+            n = n.grace_next
+        return n
+
+    @property
+    def grace_seq_len(self):
+        return (
+            sum(1 for _ in self.iter_grace_seq(backwards=True))
+            + sum(1 for _ in self.iter_grace_seq())
+            - 1
+        )  # subtract one because self is counted twice
+
+    @property
+    def last_grace_note_in_seq(self):
+        n = self
+        while isinstance(n.grace_next, GraceNote):
+            n = n.grace_next
+        return n
+
+    def iter_grace_seq(self, backwards=False):
+        """Iterate over this and all subsequent/preceding grace notes,
+        excluding the main note.
+
+        Parameters
+        ----------
+        backwards : bool, optional
+            When True, iterate over preceding grace notes. Otherwise
+            iterate over subsequent grace notes. Defaults to False.
+
+        Yields
+        ------
+        GraceNote
+
+        """
+
+        yield self
+        if backwards:
+            n = self.grace_prev
+        else:
+            n = self.grace_next
+        while isinstance(n, GraceNote):
+            yield n
+            if backwards:
+                n = n.grace_prev
+            else:
+                n = n.grace_next
+
+    def __str__(self):
+        return f"{super().__str__()} main_note={self.main_note}"
+
+
+class Page(TimedObject):
+    """A page in a musical score. Its start and end times describe the
+    range of musical time that is spanned by the page.
+
+    Parameters
+    ----------
+    number : int, optional
+        The number of the system. Defaults to 0.
+
+    Attributes
+    ----------
+    number : int
+        See parameters
+
+    """
+
+    def __init__(self, number=0):
+        super().__init__()
+        self.number = number
+
+    def __str__(self):
+        return f"{super().__str__()} number={self.number}"
+
+
+class System(TimedObject):
+    """A system in a musical score. Its start and end times describe
+    the range of musical time that is spanned by the system.
+
+    Parameters
+    ----------
+    number : int, optional
+        The number of the system. Defaults to 0.
+
+    Attributes
+    ----------
+    number : int
+        See parameters
+
+    """
+
+    def __init__(self, number=0):
+        super().__init__()
+        self.number = number
+
+    def __str__(self):
+        return f"{super().__str__()} number={self.number}"
+
+
+class Clef(TimedObject):
+    """Clefs associate the lines of a staff to musical pitches.
+
+    Parameters
+    ----------
+    staff : int, optional
+        The number of the staff to which this clef belongs.
+    sign : {'G', 'F', 'C', 'percussion', 'TAB', 'jianpu',  'none'}
+        The sign of the clef
+    line : int
+        The staff line at which the sign is positioned
+    octave_change : int
+        The number of octaves to shift the pitches up (postive) or
+        down (negative)
+
+    Attributes
+    ----------
+    staff : int
+        See parameters
+    sign : {'G', 'F', 'C', 'percussion', 'TAB', 'jianpu',  'none'}
+        See parameters
+    line : int
+        See parameters
+    octave_change : int
+        See parameters
+
+    """
+
+    def __init__(self, staff, sign, line, octave_change):
+
+        super().__init__()
+        self.staff = staff
+        self.sign = sign
+        self.line = line
+        self.octave_change = octave_change
+
+    def __str__(self):
+        return (
+            f"{super().__str__()} sign={self.sign} "
+            f"line={self.line} number={self.staff}"
+        )
+
+
+class Slur(TimedObject):
+    """Slurs indicate musical grouping across notes.
+
+    Parameters
+    ----------
+    start_note : :class:`Note`, optional
+        The note at which this slur starts. Defaults to None.
+    end_note : :class:`Note`, optional
+        The note at which this slur ends. Defaults to None.
+
+    Attributes
+    ----------
+    start_note : :class:`Note` or None
+        See parameters
+    end_note : :class:`Note` or None
+        See parameters
+
+
+    """
+
+    def __init__(self, start_note=None, end_note=None):
+        super().__init__()
+        self._start_note = None
+        self._end_note = None
+        self.start_note = start_note
+        self.end_note = end_note
+        # maintain a list of attributes to update when cloning this instance
+        self._ref_attrs.extend(["start_note", "end_note"])
+
+    @property
+    def start_note(self):
+        return self._start_note
+
+    @start_note.setter
+    def start_note(self, note):
+        # make sure we received a note
+        if note:
+            if self.start:
+                #  remove the slur from the current start time
+                self.start.remove_starting_object(self)
+            note.slur_starts.append(self)
+        self._start_note = note
+
+    @property
+    def end_note(self):
+        return self._end_note
+
+    @end_note.setter
+    def end_note(self, note):
+        # make sure we received a note
+        if note:
+            if self.end:
+                #  remove the slur from the current end time
+                self.end.remove_ending_object(self)
+            if note.end:
+                # add it to the end time of the new end note
+                note.end.add_ending_object(self)
+            note.slur_stops.append(self)
+        self._end_note = note
+
+    def __str__(self):
+        start = "" if self.start_note is None else "start={}".format(self.start_note.id)
+        end = "" if self.end_note is None else "end={}".format(self.end_note.id)
+        return " ".join((super().__str__(), start, end)).strip()
+
+
+class Tuplet(TimedObject):
+    """Tuplets indicate musical grouping across notes.
+
+    Parameters
+    ----------
+    start_note : :class:`Note`, optional
+        The note at which this tuplet starts. Defaults to None.
+    end_note : :class:`Note`, optional
+        The note at which this tuplet ends. Defaults to None.
+
+    Attributes
+    ----------
+    start_note : :class:`Note` or None
+        See parameters
+    end_note : :class:`Note` or None
+        See parameters
+
+    """
+
+    def __init__(self, start_note=None, end_note=None):
+        super().__init__()
+        self._start_note = None
+        self._end_note = None
+        self.start_note = start_note
+        self.end_note = end_note
+        # maintain a list of attributes to update when cloning this instance
+        self._ref_attrs.extend(["start_note", "end_note"])
+
+    @property
+    def start_note(self):
+        return self._start_note
+
+    @start_note.setter
+    def start_note(self, note):
+        # make sure we received a note
+        if note:
+            if note.start:
+                #  remove the tuplet from the current start time
+                if self.start_note and self.start_note.start:
+                    self.start_note.start.remove_starting_object(self)
+            # else:
+            #     warnings.warn('Note has no start time')
+            note.tuplet_starts.append(self)
+        self._start_note = note
+
+    @property
+    def end_note(self):
+        return self._end_note
+
+    @end_note.setter
+    def end_note(self, note):
+        # make sure we received a note
+        if note:
+            if note.end:
+                if self.end_note and self.end_note.end:
+                    #  remove the tuplet from the currentend time
+                    self.end_note.end.remove_ending_object(self)
+            # else:
+            #     warnings.warn('Note has no end time')
+            note.tuplet_stops.append(self)
+        self._end_note = note
+
+    def __str__(self):
+        start = "" if self.start_note is None else "start={}".format(self.start_note.id)
+        end = "" if self.end_note is None else "end={}".format(self.end_note.id)
+        return " ".join((super().__str__(), start, end)).strip()
+
+
+class Repeat(TimedObject):
+    """Repeats represent a repeated section in the score, designated
+    by its start and end times.
+
+    """
+
+    def __init__(self):
+        super().__init__()
+
+
+class DaCapo(TimedObject):
+    """A Da Capo sign."""
+
+
+class Fine(TimedObject):
+    """A Fine sign."""
+
+
+class DalSegno(TimedObject):
+    """A Dal Segno sign."""
+
+
+class Segno(TimedObject):
+    """A Segno sign."""
+
+
+class ToCoda(TimedObject):
+    """A To Coda sign."""
+
+
+class Coda(TimedObject):
+    """A Coda sign."""
+
+
+class Fermata(TimedObject):
+    """A Fermata sign.
+
+    Parameters
+    ----------
+    ref : :class:`TimedObject` or None, optional
+        An object to which this fermata applies. In practice this is a
+        Note or a Barline. Defaults to None.
+
+    Attributes
+    ----------
+    ref : :class:`TimedObject` or None
+        See parameters
+
+    """
+
+    def __init__(self, ref=None):
+        super().__init__()
+        # ref(erent) can be a note or a barline
+        self.ref = ref
+
+    def __str__(self):
+        return f"{super().__str__()} ref={self.ref}"
+
+
+class Ending(TimedObject):
+    """Class that represents one part of a 1---2--- type ending of a
+    musical passage (a.k.a Volta brackets).
+
+    Parameters
+    ----------
+    number : int
+        The number associated to this ending
+
+    Attributes
+    ----------
+    number : int
+        See parameters
+
+    """
+
+    def __init__(self, number):
+        super().__init__()
+        self.number = number
+
+
+class Barline(TimedObject):
+    """Class that represents the style of a barline"""
+
+    def __init__(self, style):
+        super().__init__()
+        self.style = style
+
+
+class Measure(TimedObject):
+    """A measure
+
+    Parameters
+    ----------
+    number : int or None, optional
+        The number of the measure. Defaults to None
+
+    Attributes
+    ----------
+    number : intp
+        See parameters
+
+    """
+
+    def __init__(self, number=None):
+        super().__init__()
+        self.number = number
+
+    def __str__(self):
+        return f"{super().__str__()} number={self.number}"
+
+    @property
+    def page(self):
+        """The page number on which this measure appears, or None if
+        there is no associated page.
+
+        Returns
+        -------
+        int or None
+
+        """
+        page = next(self.start.iter_prev(Page, eq=True), None)
+        if page:
+            return page.number
+        else:
+            return None
+
+    @property
+    def system(self):
+        """The system number in which this measure appears, or None if
+        there is no associated system.
+
+        Returns
+        -------
+        int or None
+
+        """
+        system = next(self.start.iter_prev(System, eq=True), None)
+        if system:
+            return system.number
+        else:
+            return None
+
+    # TODO: add `incomplete` or `anacrusis` property
+
+
+class TimeSignature(TimedObject):
+    """A time signature.
+
+    Parameters
+    ----------
+    beats : int
+        The number of beats in a measure (the numerator).
+    beat_type : int
+        The note type that defines the beat unit (the denominator).
+        (4 for quarter notes, 2 for half notes, etc.)
+    musical_beats : int
+        The number of beats according to musicologial standards
+        (2 if beats is 2 or 6; 3 if beats is 3 or 9; 4 if beats is 4 or 12;
+        else beats)
+
+    Attributes
+    ----------
+    beats : int
+        See parameters
+    beat_type : int
+        See parameters
+    musical_beat : int
+        See parameters
+
+    """
+
+    def __init__(self, beats, beat_type):
+        super().__init__()
+        self.beats = beats
+        self.beat_type = beat_type
+        self.musical_beats = (  # if a value is provided, otherwise default to beats
+            MUSICAL_BEATS[self.beats]
+            if self.beats in MUSICAL_BEATS.keys()
+            else self.beats
+        )
+
+    def __str__(self):
+        return f"{super().__str__()} {self.beats}/{self.beat_type}"
+
+
+class Tempo(TimedObject):
+    """A tempo indication.
+
+    Parameters
+    ----------
+    bpm : number
+        The tempo indicated in rate per minute
+    unit : str or None, optional
+        The unit to which the specified rate correspnds. This is a
+        string that expreses a duration category, such as "q" for
+        quarter "h." for dotted half, and so on. When None, the unit
+        is assumed to be quarters. Defaults to None.
+
+    Attributes
+    ----------
+    bpm : number
+        See parameters
+    unit : str or None
+        See parameters
+
+    """
+
+    def __init__(self, bpm, unit=None):
+        super().__init__()
+        self.bpm = bpm
+        self.unit = unit
+
+    @property
+    def microseconds_per_quarter(self):
+        """The number of microseconds per quarter under this tempo.
+
+        This is useful for MIDI representations.
+
+        Returns
+        -------
+        int
+
+        """
+        return int(
+            np.round(60 * (10**6 / to_quarter_tempo(self.unit or "q", self.bpm)))
+        )
+
+    def __str__(self):
+        if self.unit:
+            return f"{super().__str__()} {self.unit}={self.bpm}"
+        else:
+            return f"{super().__str__()} bpm={self.bpm}"
+
+
+class Staff(TimedObject):
+    """A staff.
+
+    Parameters
+    ----------
+    number : int
+        The staff number
+    lines : int, optional (default: 5)
+
+    Attributes
+    ----------
+    number : int
+        See parameters
+
+    """
+
+    def __init__(self, number, lines=5):
+        super().__init__()
+        self.number = number
+        self.lines = lines
+
+    def __str__(self):
+        return f"{super().__str__()} number={self.number} lines={self.lines}"
+
+
+
+class KeySignature(TimedObject):
+    """Key signature.
+
+    Parameters
+    ----------
+    fifths : number
+        Number of sharps (positive) or flats (negative)
+    mode : str
+        Mode of the key, either 'major' or 'minor'
+
+    Attributes
+    ----------
+    fifths : number
+        See parameters
+    mode : str
+        See parameters
+
+    """
+
+    def __init__(self, fifths, mode):
+        super().__init__()
+        self.fifths = fifths
+        self.mode = mode
+
+    @property
+    def name(self):
+        """The key signature name, where the root is uppercase, and an
+        trailing 'm' indicates minor modes (e.g. 'Am', 'G#').
+
+        Returns
+        -------
+        str
+            The key signature name
+
+        """
+        return fifths_mode_to_key_name(self.fifths, self.mode)
+
+    def __str__(self):
+        return (
+            f"{super().__str__()} fifths={self.fifths}, mode={self.mode} ({self.name})"
+        )
+
+
+class Transposition(TimedObject):
+    """Represents a <transpose> tag that tells how to change all
+    (following) pitches of that part to put it to concert pitch (i.e.
+    sounding pitch).
+
+    Parameters
+    ----------
+    diatonic : int
+        TODO
+    chromatic : int
+        The number of semi-tone steps to add or subtract to the pitch
+        to get to the (sounding) concert pitch.
+
+    Attributes
+    ----------
+    diatonic : int
+        See parameters
+    chromatic : int
+        See parameters
+
+    """
+
+    def __init__(self, diatonic, chromatic):
+        super().__init__()
+        self.diatonic = diatonic
+        self.chromatic = chromatic
+
+    def __str__(self):
+        return (
+            f"{super().__str__()} diatonic={self.diatonic}, chromatic={self.chromatic}"
+        )
+
+
+class Words(TimedObject):
+    """A textual element in the score.
+
+    Parameters
+    ----------
+    text : str
+        The text
+    staff : int or None, optional
+        The staff to which the text is associated. Defaults to None
+
+    Attributes
+    ----------
+    text : str
+        See parameters
+    staff : int or None, optional
+        See parameters
+
+    """
+
+    def __init__(self, text, staff=None):
+        super().__init__()
+        self.text = text
+        self.staff = staff
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.text}"'
+
+
+
+class OctaveShiftDirection(TimedObject):
+    """An octave shift direction.
+
+    Parameters
+    ----------
+
+    """
+    def __init__(self, shift_type, shift_size=8, staff=None):
+        super().__init__()
+        self.shift_type = shift_type
+        self.shift_size = shift_size
+        self.staff = staff
+        self.applied = False
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.shift_type}"'
+
+
+class Harmony(TimedObject):
+    """A harmony element in the score not currently used.
+
+        Parameters
+        ----------
+        text : str
+            The harmony text
+
+        Attributes
+        ----------
+        text : str
+            See parameters
+        """
+
+    def __init__(self, text):
+        super().__init__()
+        self.text = text
+        # assert issubclass(note, GenericNote)
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.text}"'
+
+
+class RomanNumeral(TimedObject):
+    """A harmony element in the score usually for Roman Numerals.
+
+    Parameters
+    ----------
+    text : str
+        The harmony text
+
+    Attributes
+    ----------
+    text : str
+        See parameters
+    """
+
+    def __init__(self, text):
+        super().__init__()
+        self.text = text
+        # assert issubclass(note, GenericNote)
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.text}"'
+
+
+class ChordSymbol(TimedObject):
+    """A harmony element in the score usually for Chord Symbols."""
+    def __init__(self, root, kind, bass=None):
+        super().__init__()
+        self.kind = kind
+        self.root = root
+        self.bass = bass
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.root + self.kind}"'
+
+
+class Interval(object):
+    """
+    An interval element usually used for transpositions
+
+    Parameters
+    ----------
+    number : int
+        The interval number (e.g. 1, 2, 3, 4, 5, 6, 7, ...)
+    quality : str
+        The interval quality (e.g. M, m, P, A, d, dd, AA)
+    direction : str
+        The interval direction (e.g. up, down)
+    """
+    def __init__(self, number, quality, direction="up"):
+        self.number = number
+        self.quality = quality
+        self.direction = direction
+        self.validate()
+
+    def validate(self):
+        number = self.number % 7
+        number = 7 if number == 0 else number
+        assert self.quality+str(number) in INTERVALCLASSES, f"Interval {number}{self.quality} not found"
+        assert self.direction in ["up", "down"], f"Interval direction {self.direction} not found"
+
+    def __str__(self):
+        return f'{super().__str__()} "{self.number}{self.quality}"'
+
+
+class Direction(TimedObject):
+    """Base class for performance directions in the score."""
+
+    def __init__(self, text=None, raw_text=None, staff=None):
+        super().__init__()
+        self.text = text if text is not None else ""
+        self.raw_text = raw_text
+        self.staff = staff
+
+    def __str__(self):
+        if self.raw_text is not None:
+            return f'{super().__str__()} "{self.text}" raw_text="{self.raw_text}"'
+        else:
+            return f'{super().__str__()} "{self.text}"'
+
+
+class LoudnessDirection(Direction):
+    pass
+
+
+class TempoDirection(Direction):
+    pass
+
+
+class ArticulationDirection(Direction):
+    pass
+
+
+class PedalDirection(Direction):
+    pass
+
+
+class ConstantDirection(Direction):
+    pass
+
+
+class DynamicDirection(Direction):
+    pass
+
+
+class ImpulsiveDirection(Direction):
+    pass
+
+
+class ConstantLoudnessDirection(ConstantDirection, LoudnessDirection):
+    pass
+
+
+class ConstantTempoDirection(ConstantDirection, TempoDirection):
+    pass
+
+
+class ConstantArticulationDirection(ConstantDirection, ArticulationDirection):
+    pass
+
+
+class DynamicLoudnessDirection(DynamicDirection, LoudnessDirection):
+    def __init__(self, *args, wedge=False, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.wedge = wedge
+
+    def __str__(self):
+        if self.wedge:
+            return f"{super().__str__()} wedge"
+        else:
+            return super().__str__()
+
+
+class DynamicTempoDirection(DynamicDirection, TempoDirection):
+    pass
+
+
+class IncreasingLoudnessDirection(DynamicLoudnessDirection):
+    pass
+
+
+class DecreasingLoudnessDirection(DynamicLoudnessDirection):
+    pass
+
+
+class IncreasingTempoDirection(DynamicTempoDirection):
+    pass
+
+
+class DecreasingTempoDirection(DynamicTempoDirection):
+    pass
+
+
+class ImpulsiveLoudnessDirection(ImpulsiveDirection, LoudnessDirection):
+    pass
+
+
+class SustainPedalDirection(PedalDirection):
+    """Represents a Sustain Pedal Direction"""
+
+    def __init__(self, line=False, *args, **kwargs):
+        super().__init__("sustain_pedal", *args, **kwargs)
+        self.line = line
+
+
+class ResetTempoDirection(ConstantTempoDirection):
+    @property
+    def reference_tempo(self):
+        direction = None
+        for d in self.start.iter_prev(ConstantTempoDirection):
+            direction = d
+        return direction
+
+
+class PartGroup(object):
+    """Represents a grouping of several instruments, usually named,
+    and expressed in the score with a group symbol such as a brace or
+    a bracket. In symphonic scores, bracketed part groups usually
+    group families of instruments, such as woodwinds or brass, whereas
+    braces are often used to group multiple instances of the same
+    instrument. See the `MusicXML documentation
+    <https://usermanuals.musicxml.com/MusicXML/Content/ST-MusicXML-
+    group-symbol-value.htm>`_ for further information.
+
+    Parameters
+    ----------
+    group_symbol : str or None, optional
+        The symbol used for grouping instruments.
+
+    Attributes
+    ----------
+    group_symbol : str or None
+
+    name : str or None
+
+    number : int
+
+    parent : PartGroup or None
+
+    children : list of Part or PartGroup objects
+
+    """
+
+    def __init__(self, group_symbol=None, group_name=None, number=None, id=None):
+        self.group_symbol = group_symbol
+        self.group_name = group_name
+        self.number = number
+        self.parent = None
+        self.id = id
+        self.children = []
+
+    def _pp(self, tree):
+        result = [
+            '{}PartGroup: group_name="{}" group_symbol="{}"'.format(
+                tree, self.group_name, self.group_symbol
+            )
+        ]
+        tree.push()
+        N = len(self.children)
+        for i, child in enumerate(self.children):
+            result.append("{}".format(tree).rstrip())
+            if i == N - 1:
+                tree.last_item()
+            else:
+                tree.next_item()
+            result.extend(child._pp(tree))
+        tree.pop()
+        return result
+
+    def pretty(self):
+        """Return a pretty representation of this object.
+
+        Returns
+        -------
+        str
+            A pretty representation
+
+        """
+        return "\n".join(self._pp(PrettyPrintTree()))
+
+    def note_array(self, *args, **kwargs):
+        """A structured array containing pitch, onset, duration, voice
+        and id for each note in each part of the PartGroup. The note
+        ids in this array include the number of the part to which they
+        belong.
+
+        See Part.note_array()
+
+        """
+        return note_array_from_part_list(self.children, *args, **kwargs)
+
+    def rest_array(self, *args, **kwargs):
+        """A structured array containing pitch, onset, duration, voice
+        and id for each note in each part of the PartGroup. The note
+        ids in this array include the number of the part to which they
+        belong.
+
+        See Part.note_array()
+
+        """
+        return rest_array_from_part_list(self.children, *args, **kwargs)
+
+
+class Score(object):
+    """Main object for representing a score.
+
+    The `Score` object is basically an iterable that provides access to all
+    `Part` objects in a musical score.
+
+    Parameters
+    ----------
+    id : str
+        The identifier of the score. In order to be compatible with MusicXML
+        the identifier should not start with a number.
+    partlist : `Part`, `PartGroup` or list of `Part` or `PartGroup` instances.
+        List of  `Part` or `PartGroup` objects.
+    title: str, optional
+        Title of the score.
+    subtitle: str, optional
+        Subtitle of the score.
+    composer: str, optional
+        Composer of the score.
+    lyricist: str, optional
+        Lyricist of the score.
+    copyright: str, optional.
+        Copyright notice of the score.
+
+    Attributes
+    ----------
+    id : str
+        See parameters.
+    parts : list of `Part` objects
+        All `Part` objects.
+    part_structure: list of `Part` or `PartGrop`
+        List of all `Part` or `PartGroup` objects that specify the structure of
+        the score.
+     title: str
+        See parameters.
+    subtitle: str
+        See parameters.
+    composer: str
+        See parameters.
+    lyricist: str
+        See parameters.
+    copyright: str.
+        See parameters.
+
+    """
+
+    id: Optional[str]
+    title: Optional[str]
+    subtitle: Optional[str]
+    composer: Optional[str]
+    lyricist: Optional[str]
+    copyright: Optional[str]
+    parts: List[Part]
+    part_structure: List[Union[Part, PartGroup]]
+
+    def __init__(
+        self,
+        partlist: Union[Part, PartGroup, Itertype[Union[Part, PartGroup]]],
+        id: Optional[str] = None,
+        title: Optional[str] = None,
+        subtitle: Optional[str] = None,
+        composer: Optional[str] = None,
+        lyricist: Optional[str] = None,
+        copyright: Optional[str] = None,
+    ) -> None:
+        self.id = id
+
+        # Score Information (default from MuseScore/MusicXML)
+        self.title = title
+        self.subtitle = subtitle
+        self.composer = composer
+        self.lyricist = lyricist
+        self.copyright = copyright
+
+        # Flat list of parts
+        self.parts = list(iter_parts(partlist))
+        # List of Parts and PartGroups
+
+        if isinstance(partlist, (Part, PartGroup)):
+            self.part_structure = [partlist]
+        elif isinstance(partlist, Iterable):
+            self.part_structure = list(partlist)
+        else:
+            raise ValueError(
+                "`partlist` should be a list, a `Part` or a `PartGrop` but"
+                f" is {type(partlist)}."
+            )
+
+    def __getitem__(self, index: int) -> Part:
+        """Get `Part in the score by index"""
+        return self.parts[index]
+
+    def __setitem__(self, index: int, part: Part) -> None:
+        """Set `Part` in the score by index"""
+        # TODO: How to update the score structure as well?
+        self.parts[index] = part
+
+    def __iter__(self) -> Iterator[Part]:
+        self.iter_idx = 0
+        return self
+
+    def __next__(self) -> Part:
+        if self.iter_idx == len(self.parts):
+            raise StopIteration
+        res = self[self.iter_idx]
+        self.iter_idx += 1
+        return res
+
+    def __len__(self) -> int:
+        """
+        The lenght of the score is the number of part objects in `self.parts`
+        """
+        return len(self.parts)
+
+    def note_array(
+        self,
+        unique_id_per_part=True,
+        include_pitch_spelling=False,
+        include_key_signature=False,
+        include_time_signature=False,
+        include_metrical_position=False,
+        include_grace_notes=False,
+        include_staff=False,
+        include_divs_per_quarter=False,
+        **kwargs,
+    ) -> np.ndarray:
+        """
+        Get a note array that concatenates the note arrays of all Part/PartGroup
+        objects in the score.
+        """
+        return note_array_from_part_list(
+            part_list=self.parts,
+            unique_id_per_part=unique_id_per_part,
+            include_pitch_spelling=include_pitch_spelling,
+            include_key_signature=include_key_signature,
+            include_time_signature=include_time_signature,
+            include_grace_notes=include_grace_notes,
+            include_metrical_position=include_metrical_position,
+            include_staff=include_staff,
+            include_divs_per_quarter=include_divs_per_quarter,
+            **kwargs,
+        )
+
+
+# Alias for typing score-like objects
+ScoreLike = Union[List[Union[Part, PartGroup]], Part, PartGroup, Score]
+
+
+class ScoreVariant(object):
+    # non-public
+
+    def __init__(self, part, start_time=0):
+        self.t_unfold = start_time
+        self.segments = []
+        self.part = part
+
+    def add_segment(self, start, end):
+        self.segments.append((start, end, self.t_unfold))
+        self.t_unfold += end.t - start.t
+
+    @property
+    def segment_times(self):
+        """
+        Return segment (start, end, offset) information for each of the segments in
+        the score variant.
+        """
+        return [(s.t, e.t, o) for (s, e, o) in self.segments]
+
+    def __str__(self):
+        return f"{super().__str__()} {self.segment_times}"
+
+    def clone(self):
+        """
+        Return a clone of the ScoreVariant
+        """
+        clone = ScoreVariant(self.part, self.t_unfold)
+        clone.segments = self.segments[:]
+        return clone
+
+    def create_variant_part(self):
+        part = Part(self.part.id, part_name=self.part.part_name)
+
+        for start, end, offset in self.segments:
+            delta = offset - start.t
+            qd = self.part.quarter_durations(start.t, end.t)
+            for t, quarter in qd:
+                part.set_quarter_duration(t + delta, quarter)
+            # After creating the new part we need to replace references to
+            # objects in the old part to references in the new part
+            # (e.g. t.next, t.prev, note.tie_next). For this we keep track of
+            # correspondences between objects (timepoints, notes, measures,
+            # etc), in o_map
+            o_map = {}
+            o_new = set()
+            tp = start
+            while tp != end:
+                # make a new timepoint, corresponding to tp
+                tp_new = part.get_or_add_point(tp.t + delta)
+                o_gen = (o for oo in tp.starting_objects.values() for o in oo)
+                for o in o_gen:
+
+                    # special cases:
+
+                    # don't include some TimedObjects in the unfolded part
+                    if isinstance(
+                        o,
+                        (
+                            Repeat,
+                            Ending,
+                            ToCoda,
+                            DaCapo,
+                            DalSegno,
+                            Segment,
+                            System,
+                            Page,
+                        ),
+                    ):
+                        continue
+
+                    # don't repeat time sig if it hasn't changed
+                    elif isinstance(o, TimeSignature):
+                        prev = next(tp_new.iter_prev(TimeSignature), None)
+                        if (prev is not None) and (
+                            (o.beats, o.beat_type) == (prev.beats, prev.beat_type)
+                        ):
+                            continue
+                    # don't repeat key sig if it hasn't changed
+                    elif isinstance(o, KeySignature):
+                        prev = next(tp_new.iter_prev(KeySignature), None)
+                        if (prev is not None) and (
+                            (o.fifths, o.mode) == (prev.fifths, prev.mode)
+                        ):
+                            continue
+
+                    # don't repeat clef if it hasn't changed
+                    elif isinstance(o, Clef):
+                        prev = next(tp_new.iter_prev(Clef), None)
+                        if (prev is not None) and (
+                            (o.sign, o.line, o.staff)
+                            == (prev.sign, prev.line, prev.staff)
+                        ):
+                            continue
+
+                    # make a copy of the object
+                    o_copy = copy(o)
+                    # add it to the set of new objects (for which the refs will
+                    # be replaced)
+                    o_new.add(o_copy)
+                    # keep track of the correspondence between o and o_copy
+                    o_map[o] = o_copy
+                    # add the start of the new object to the part
+                    tp_new.add_starting_object(o_copy)
+                    if o.end is not None:
+                        # add the end of the object to the part
+                        tp_end = part.get_or_add_point(o.end.t + delta)
+                        tp_end.add_ending_object(o_copy)
+
+                tp = tp.next
+                if tp is None:
+                    raise Exception(
+                        "segment end not a successor of segment start, "
+                        "invalid score variant"
+                    )
+
+            # special case: fermata starting at end of segment should be
+            # included if it does not belong to a note, and comes at the end of
+            # a measure (o.ref == 'right')
+            for o in end.starting_objects[Fermata]:
+                if o.ref in (None, "right"):
+                    o_copy = copy(o)
+                    tp_new = part.get_or_add_point(end.t + delta)
+                    tp_new.add_starting_object(o_copy)
+
+            # for each of the new objects, replace the references to the old
+            # objects to their corresponding new objects
+            for o in o_new:
+                o.replace_refs(o_map)
+
+        # replace prev/next references in timepoints
+        for tp, tp_next in iter_current_next(part._points):
+            tp.next = tp_next
+            tp_next.prev = tp
+
+        return part
+
+
+def add_measures(part):
+    """Add measures to a part.
+
+    This function adds Measure objects to the part according to any
+    time signatures present in the part. Any existing measures will be
+    untouched, and added measures will be delimited by the existing
+    measures.
+
+    The Part object will be modified in place.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        Part instance
+
+    """
+
+    timesigs = np.array(
+        [(ts.start.t, ts.beats) for ts in part.iter_all(TimeSignature)], dtype=int
+    )
+
+    if len(timesigs) == 0:
+        warnings.warn("No time signatures found, not adding measures")
+        return
+
+    start = part.first_point.t
+    end = part.last_point.t
+
+    if start == end:
+        return
+
+    # make sure we cover time from the start of the timeline
+    if len(timesigs) == 0 or timesigs[0, 0] > start:
+        timesigs = np.vstack(([[start, 4]], timesigs))
+
+    # in unlikely case of timesig at last point, remove it
+    if timesigs[-1, 0] >= end:
+        timesigs = timesigs[:-1]
+
+    ts_start_times = timesigs[:, 0]
+    beats_per_measure = timesigs[:, 1]
+    ts_end_times = ts_start_times[1:]
+
+    # make sure we cover time until the end of the timeline
+    if len(ts_end_times) == 0 or ts_end_times[-1] < end:
+        ts_end_times = np.r_[ts_end_times, end]
+
+    assert len(ts_start_times) == len(ts_end_times)
+
+    beat_map = part.beat_map
+    inv_beat_map = part.inv_beat_map
+    mcounter = 1
+
+    for ts_start, ts_end, measure_dur in zip(
+        ts_start_times, ts_end_times, beats_per_measure
+    ):
+        pos = ts_start
+
+        while pos < ts_end:
+
+            measure_start = pos
+            measure_end_beats = min(beat_map(pos) + measure_dur, beat_map(end))
+            measure_end = min(ts_end, inv_beat_map(measure_end_beats))
+            # any existing measures between measure_start and measure_end
+            existing_measure = next(
+                part.iter_all(Measure, measure_start, measure_end), None
+            )
+            if existing_measure:
+                if existing_measure.start.t == measure_start:
+                    assert existing_measure.end.t > pos
+                    pos = existing_measure.end.t
+                    if existing_measure.number != 0:
+                        # if existing_measure is a match anacrusis measure,
+                        # keep number 0
+                        existing_measure.number = mcounter
+                        mcounter += 1
+                    continue
+
+                else:
+                    measure_end = existing_measure.start.t
+
+            part.add(Measure(number=mcounter), int(measure_start), int(measure_end))
+
+            # if measure exists but was not at measure_start,
+            # a filler measure is added with number mcounter
+            if existing_measure:
+                pos = existing_measure.end.t
+                existing_measure.number = mcounter + 1
+                mcounter = mcounter + 2
+            else:
+                pos = measure_end
+                mcounter += 1
+
+
+def remove_grace_notes(part):
+    """Remove all grace notes from a timeline.
+
+    The specified timeline object will be modified in place.
+
+    Parameters
+    ----------
+    timeline : Timeline
+        The timeline from which to remove the grace notes
+
+    """
+    for gn in list(part.iter_all(GraceNote)):
+        part.remove(gn)
+
+
+def expand_grace_notes(part):
+    """Expand grace note durations in a part.
+
+    The specified part object will be modified in place.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        The part on which to expand the grace notes
+
+    """
+    for gn in part.iter_all(GraceNote):
+        dur = symbolic_to_numeric_duration(gn.symbolic_duration, gn.start.quarter)
+        part.remove(gn, "end")
+        part.add(gn, end=gn.start.t + int(np.round(dur)))
+
+
+def iter_parts(partlist):
+    """Iterate over all Part instances in partlist, which is a list of
+    either Part or PartGroup instances. PartGroup instances contain
+    one or more parts or further partgroups, and are traversed in a
+    depth-first fashion.
+
+    This function is designed to take the result of
+    :func:`partitura.load_score_midi` and :func:`partitura.load_musicxml` as
+    input.
+
+    Parameters
+    ----------
+    partlist : Score, list, Part, or PartGroup
+        A :class:`partitura.score.Part` object,
+        :class:`partitura.score.PartGroup` or a list of these
+
+    Yields
+    -------
+        :class:`Part` instances in `partlist`
+
+    """
+
+    if not isinstance(partlist, (list, tuple, set)):
+        _partlist = [partlist]
+
+    elif isinstance(partlist, Score):
+        _partlist = partlist.parts
+
+    else:
+        _partlist = partlist
+
+    for el in _partlist:
+        if isinstance(el, Part):
+            yield el
+        else:
+            for eel in iter_parts(el.children):
+                yield eel
+
+
+def repeats_to_start_end(repeats, first, last):
+    # non-public, deprecated, unused
+    """Return pairs of (start, end) TimePoints corresponding to the start and
+    end times of each Repeat object. If any of the start or end attributes
+    are None, replace it with the end/start of the preceding/succeeding
+    Repeat, respectively, or `first` or `last`.
+
+    Parameters
+    ----------
+    repeats : list
+        list of Repeat instances, possibly with None-valued start/end
+        attributes
+    first : TimePoint
+        The first TimePoint in the timeline
+    last : TimePoint
+        The last TimePoint in the timeline
+
+    Returns
+    -------
+    list
+        list of (start, end) TimePoints corresponding to each Repeat in
+        `repeats`
+
+    """
+    t = first
+    starts = []
+    ends = []
+    for repeat in repeats:
+        starts.append(t if repeat.start is None else repeat.start)
+        if repeat.end is not None:
+            t = repeat.end
+
+    t = last
+    for repeat in reversed(repeats):
+        ends.append(t if repeat.end is None else repeat.end)
+        if repeat.start is not None:
+            t = repeat.start
+    ends.reverse()
+    return list(zip(starts, ends))
+
+
+def _make_tied_note_id(prev_id):
+    # non-public
+    """Create a derived note ID for newly created notes, by appending
+    letters to the ID. If the original ID has the form X-Y (e.g.
+    n1-1), then the letter will be appended to the X part.
+
+    Parameters
+    ----------
+    prev_id : str
+        Original note ID
+
+    Returns
+    -------
+    str
+        Derived note ID
+
+    Examples
+    --------
+    >>> _make_tied_note_id('n0')
+    'n0a'
+    >>> _make_tied_note_id('n0a')
+    'n0b'
+    >>> _make_tied_note_id('n0-1')
+    'n0a-1'
+
+    """
+    prev_id_parts = prev_id.split("-", 1)
+    prev_id_p1 = prev_id_parts[0]
+    if prev_id_p1:
+        if ord(prev_id_p1[-1]) < ord("a") - 1:
+            return "-".join(["{}a".format(prev_id_p1)] + prev_id_parts[1:])
+        else:
+            return "-".join(
+                ["{}{}".format(prev_id_p1[:-1], chr(ord(prev_id[-1]) + 1))]
+                + prev_id_parts[1:]
+            )
+    else:
+        return None
+
+
+def tie_notes(part):
+    """Find notes that span measure boundaries and notes with composite
+    durations, and split them adding ties.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        Description of `part`
+
+    """
+    # split and tie notes at measure boundaries
+    for note in list(part.iter_all(Note)):
+        next_measure = next(note.start.iter_next(Measure), None)
+        cur_note = note
+        note_end = cur_note.end
+
+        # keep the list of stopping slurs, we need to transfer them to the last
+        # tied note
+        slur_stops = cur_note.slur_stops
+
+        while next_measure and cur_note.end > next_measure.start:
+            part.remove(cur_note, "end")
+            cur_note.slur_stops = []
+            part.add(cur_note, None, next_measure.start.t)
+            cur_note.symbolic_duration = estimate_symbolic_duration(
+                next_measure.start.t - cur_note.start.t, cur_note.start.quarter
+            )
+            sym_dur = estimate_symbolic_duration(
+                note_end.t - next_measure.start.t, next_measure.start.quarter
+            )
+            if cur_note.id is not None:
+                note_id = _make_tied_note_id(cur_note.id)
+            else:
+                note_id = None
+            if isinstance(cur_note, UnpitchedNote):
+                next_note = UnpitchedNote(
+                    cur_note.step,
+                    cur_note.octave,
+                    id=note_id,
+                    voice=cur_note.voice,
+                    staff=cur_note.staff,
+                    symbolic_duration=sym_dur,
+                )
+            else:
+                next_note = Note(
+                    note.step,
+                    note.octave,
+                    note.alter,
+                    id=note_id,
+                    voice=note.voice,
+                    staff=note.staff,
+                    symbolic_duration=sym_dur,
+                )
+            part.add(next_note, next_measure.start.t, note_end.t)
+
+            cur_note.tie_next = next_note
+            next_note.tie_prev = cur_note
+
+            cur_note = next_note
+
+            next_measure = next(cur_note.start.iter_next(Measure), None)
+
+        if cur_note != note:
+            for slur in slur_stops:
+                slur.end_note = cur_note
+
+    # then split/tie any notes that do not have a fractional/dot duration
+    divs_map = part.quarter_duration_map
+    max_splits = 3
+    failed = 0
+    succeeded = 0
+    for i, note in enumerate(list(part.iter_all(Note))):
+        if note.symbolic_duration is None:
+
+            splits = find_tie_split(
+                note.start.t, note.end.t, int(divs_map(note.start.t)), max_splits
+            )
+
+            if splits:
+                succeeded += 1
+                split_note(part, note, splits)
+            else:
+                failed += 1
+
+
+def set_end_times(parts):
+    # non-public
+    """Set missing end times of musical elements in a part to equal
+    the start times of the subsequent element of the same class. This
+    is useful for some classes
+
+    This function modifies the parts in place.
+
+    Parameters
+    ----------
+    part : Part or PartGroup, or list of these
+        Parts to be processed
+
+    """
+    for part in iter_parts(parts):
+        # page, system, loudnessdirection, tempodirection
+        _set_end_times(part, Page)
+        _set_end_times(part, System)
+        _set_end_times(part, ConstantLoudnessDirection)
+        _set_end_times(part, ConstantTempoDirection)
+        _set_end_times(part, ConstantArticulationDirection)
+
+
+def _set_end_times(part, cls):
+    acc = []
+    t = None
+
+    for obj in part.iter_all(cls, include_subclasses=True):
+
+        if obj.start == t:
+
+            if obj.end is None:
+
+                acc.append(obj)
+
+        else:
+
+            for o in acc:
+
+                part.add(o, end=obj.start.t)
+
+            acc = []
+
+            if obj.end is None:
+
+                acc.append(obj)
+
+            t = obj.start
+
+    for o in acc:
+
+        part.add(o, end=part.last_point.t)
+
+
+def split_note(part, note, splits):
+    # non-public
+
+    # TODO: we shouldn't do this, but for now it's a good sanity check
+    assert len(splits) > 0
+    # TODO: we shouldn't do this, but for now it's a good sanity check
+    assert note.symbolic_duration is None
+    part.remove(note)
+    orig_tie_next = note.tie_next
+    slur_stops = note.slur_stops
+    cur_note = note
+    start, end, sym_dur = splits.pop(0)
+    cur_note.symbolic_duration = sym_dur
+    part.add(cur_note, start, end)
+    while splits:
+        note.slur_stops = []
+
+        if cur_note.id is not None:
+            note_id = _make_tied_note_id(cur_note.id)
+        else:
+            note_id = None
+
+        next_note = Note(
+            note.step,
+            note.octave,
+            note.alter,
+            voice=note.voice,
+            id=note_id,
+            staff=note.staff,
+        )
+        cur_note.tie_next = next_note
+        next_note.tie_prev = cur_note
+
+        cur_note = next_note
+        start, end, sym_dur = splits.pop(0)
+        cur_note.symbolic_duration = sym_dur
+
+        part.add(cur_note, start, end)
+
+    cur_note.tie_next = orig_tie_next
+
+    if cur_note != note:
+        for slur in slur_stops:
+            slur.end_note = cur_note
+
+
+def find_tuplets(part):
+    """Identify tuplets in `part` and set their symbolic durations
+    explicitly.
+
+    This function adds `actual_notes` and `normal_notes` keys to
+    the symbolic duration of tuplet notes.
+
+    This function modifies the part in place.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        Part instance
+
+    """
+
+    # quick shot at finding tuplets intended to cover some common cases.
+
+    # are tuplets always in the same voice?
+
+    # quite arbitrary:
+    search_for_tuplets = [9, 7, 5, 3]
+    # only look for x:2 tuplets
+    normal_notes = 2
+
+    candidates = []
+    prev_end = None
+
+    # 1. group consecutive notes without symbolic_duration
+    for note in part.iter_all(GenericNote, include_subclasses=True):
+
+        if note.symbolic_duration is None:
+            if note.start.t == prev_end:
+                candidates[-1].append(note)
+            else:
+                candidates.append([note])
+            prev_end = note.end.t
+
+    # 2. within each group
+    for group in candidates:
+
+        # 3. search for the predefined list of tuplets
+        for actual_notes in search_for_tuplets:
+
+            if actual_notes > len(group):
+                # tuplet requires more notes than we have
+                continue
+
+            tup_start = 0
+
+            while tup_start <= (len(group) - actual_notes):
+                note_tuplet = group[tup_start : tup_start + actual_notes]
+                # durs = set(n.duration for n in group[:tuplet-1])
+                durs = set(n.duration for n in note_tuplet)
+
+                if len(durs) > 1:
+                    # notes have different durations (possibly valid but not
+                    # supported here)
+                    # continue
+                    tup_start += 1
+                else:
+
+                    start = note_tuplet[0].start.t
+                    end = note_tuplet[-1].end.t
+                    total_dur = end - start
+
+                    # total duration of tuplet notes must be integer-divisble by
+                    # normal_notes
+                    if total_dur % normal_notes > 0:
+                        tup_start += 1
+                    else:
+                        # estimate duration type
+                        dur_type = estimate_symbolic_duration(
+                            total_dur // normal_notes, note_tuplet[0].start.quarter
+                        )
+
+                        if dur_type and dur_type.get("dots", 0) == 0:
+                            # recognized duration without dots
+                            dur_type["actual_notes"] = actual_notes
+                            dur_type["normal_notes"] = normal_notes
+                            for note in note_tuplet:
+                                note.symbolic_duration = dur_type.copy()
+                            start_note = note_tuplet[0]
+                            stop_note = note_tuplet[-1]
+                            tuplet = Tuplet(start_note, stop_note)
+                            part.add(tuplet, start_note.start.t, stop_note.end.t)
+                            tup_start += actual_notes
+
+                        else:
+                            tup_start += 1
+
+
+def sanitize_part(part, tie_tolerance=0):
+    """Find and remove incomplete structures in a part such as Tuplets
+    and Slurs without start or end and grace notes without a main
+    note.
+
+    This function modifies the part in place.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        Part instance
+    tie_tolerange: int, optional
+        The maximum number of divs that separates notes that are tied together.
+        Ideally, it is 0, but not so nice scores happen.
+
+    """
+    remove_grace_counter = 0
+    elements_to_remove = []
+    for gn in part.iter_all(GraceNote):
+        if gn.main_note is None:
+            for no in part.iter_all(
+                Note, include_subclasses=False, start=gn.start.t, end=gn.start.t + 1
+            ):
+
+                if no.voice == gn.voice:
+                    gn.last_grace_note_in_seq.grace_next = no
+
+        if gn.main_note is None:
+            elements_to_remove.append(gn)
+            remove_grace_counter += 1
+
+    remove_tuplet_counter = 0
+    for tp in part.iter_all(Tuplet):
+        if tp.end_note is None or tp.start_note is None:
+            elements_to_remove.append(tp)
+            remove_tuplet_counter += 1
+
+    remove_slur_counter = 0
+    for sl in part.iter_all(Slur):
+        if sl.end_note is None or sl.start_note is None:
+            elements_to_remove.append(sl)
+            remove_slur_counter += 1
+
+    for el in elements_to_remove:
+        part.remove(el)
+
+    remove_tie_counter = 0
+    for n in part.notes_tied:
+        if n.tie_next != None:
+            d = n.duration_tied
+            s = n.start.t
+            e = n.end_tied.t
+            if abs((e - s) - d) > tie_tolerance:
+                remove_tie_counter += 1
+                all_tied = n.tie_prev_notes + [n] + n.tie_next_notes
+                for tn in all_tied:
+                    tn.tie_next = None
+                    tn.tie_prev = None
+
+    warnings.warn(
+        "part_sanitize removed {} incomplete tuplets, "
+        "{} incomplete slurs, {} incomplete grace, "
+        "and {} wrong ties."
+        "notes".format(
+            remove_tuplet_counter,
+            remove_slur_counter,
+            remove_grace_counter,
+            remove_tie_counter,
+        ),
+        stacklevel=2,
+    )
+
+
+def assign_note_ids(parts, keep=False):
+    """
+    Assigns new note IDs mainly used for loaders.
+
+    parts : list or score.PartGroup or score.Part
+        Some Partitura parts
+    keep : bool
+        Keep or given note IDs or assign new ones.
+    """
+    if keep:
+        # Keep existing note id's
+        for p, part in enumerate(iter_parts(parts)):
+            for ni, n in enumerate(part.iter_all(GenericNote, include_subclasses=True)):
+                if isinstance(n, Rest):
+                    n.id = "p{0}r{1}".format(p, ni) if n.id is None else n.id
+                else:
+                    n.id = "p{0}n{1}".format(p, ni) if n.id is None else n.id
+
+    else:
+        # assign note ids to ensure uniqueness across all parts, discarding any
+        # existing note ids
+        ni = 0
+        ri = 0
+        for part in iter_parts(parts):
+            for n in part.iter_all(GenericNote, include_subclasses=True):
+                if isinstance(n, Rest):
+                    n.id = "r{}".format(ri)
+                    ri += 1
+                else:
+                    n.id = "n{}".format(ni)
+                    ni += 1
+
+
+class Segment(TimedObject):
+    """
+    Class that represents any segment between two navigation markers such as repetitions,
+    Volta brackets, or capo/fine/coda/segno directions.
+
+    Parameters
+    ----------
+    id: string
+        unique, ordererd identifier string
+    to: list
+        list of ids of possible destinations
+    await_to:
+        list of ids of possible destinations after a jump
+    type : string, optional
+        String for the type of the segment (either "default" or "leap_start" and "leap_end"). A "leap" tuple has the effect of forcing the fastest (shortest) repetition unfolding after this segment, as is commonly expected after capo/fine/coda/segno directions.
+    info: string, optional
+        String to describe the segment, used only for printing (pretty_segments)
+
+    """
+
+    def __init__(self, id, to, await_to, force_seq=False, type="default", info=""):
+        self.id = id
+        self.to = to
+        self.await_to = await_to
+        self.force_full_sequence = force_seq
+        self.type = type
+        self.info = info
+
+
+def add_segments(part):
+    """
+    Add segment objects to a part based on repetition and capo/fine/coda/segno directions.
+
+    Parameters
+    ----------
+    part: part
+        A score part
+    """
+    if len([seg for seg in part.iter_all(Segment)]) > 0:
+        # only add segments if no segments exist
+        pass
+    else:
+        boundaries = defaultdict(dict)
+        destinations = defaultdict(list)
+
+        valid_repeats = [
+            r
+            for r in part.iter_all(Repeat)
+            if r.start is not None and r.end is not None
+        ]
+        valid_endings = [
+            r
+            for r in part.iter_all(Ending)
+            if r.start is not None and r.end is not None
+        ]
+
+        for r in valid_repeats:
+            boundaries[r.start.t]["repeat_start"] = r
+            boundaries[r.end.t]["repeat_end"] = r
+        for v in valid_endings:
+            boundaries[v.start.t]["volta_start"] = v
+            boundaries[v.end.t]["volta_end"] = v
+        for c in part.iter_all(Coda):
+            boundaries[c.start.t]["coda"] = c
+            destinations["coda"].append(c.start.t)
+        for c in part.iter_all(ToCoda):
+            boundaries[c.start.t]["tocoda"] = c
+        for c in part.iter_all(DaCapo):
+            boundaries[c.start.t]["dacapo"] = c
+        for c in part.iter_all(Fine):
+            boundaries[c.start.t]["fine"] = c
+        for c in part.iter_all(Segno):
+            boundaries[c.start.t]["segno"] = c
+            destinations["segno"].append(c.start.t)
+        for c in part.iter_all(DalSegno):
+            boundaries[c.start.t]["dalsegno"] = c
+
+        boundaries[part.last_point.t]["end"] = None
+        boundaries[part.first_point.t]["start"] = None
+
+        boundary_times = list(boundaries.keys())
+        boundary_times.sort()
+
+        # for every segment get an id, its jump destinations and properties
+        init_character = 65
+        segment_info = dict()
+        for i, (s, e) in enumerate(zip(boundary_times[:-1], boundary_times[1:])):
+            segment_info[s] = {
+                "ID": chr(init_character + i),
+                "start": s,
+                "end": e,
+                "to": [],
+                "force_full_sequence": False,
+                "type": "default",
+                "info": list(),
+                "volta_numbers": list(),
+            }
+        segment_info[boundary_times[-1]] = {"ID": "END"}
+
+        current_volta_repeat_start = 0
+        current_volta_end = 0
+        current_volta_total_number = 0
+
+        for ss in boundary_times[:-1]:
+            se = segment_info[ss]["end"]
+
+            # loop through the boundaries at the end of current segment
+            for boundary_type in boundaries[se].keys():
+
+                # REPEATS
+                if boundary_type == "repeat_start":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                if boundary_type == "repeat_end":
+                    if "volta_end" not in list(boundaries[se].keys()):
+                        segment_info[ss]["to"].append(segment_info[se]["ID"])
+                        repeat_start = boundaries[se][boundary_type].start.t
+                        segment_info[ss]["to"].append(segment_info[repeat_start]["ID"])
+                    segment_info[ss]["info"].append("repeat_end")
+
+                # VOLTA BRACKETS
+                if boundary_type == "volta_start":
+                    if "volta_end" not in list(boundaries[se].keys()):
+                        current_volta_total_number = 0
+                        current_volta_end = se
+                        for volta_number in range(
+                            10
+                        ):  # maximal expected number of volta brackets 10
+                            if "volta_start" in list(
+                                boundaries[current_volta_end].keys()
+                            ):
+                                # add the beginning to the jump destinations
+                                numbers = boundaries[current_volta_end][
+                                    "volta_start"
+                                ].number.split(",")
+                                numbers = [str(int(n)) for n in numbers]
+                                current_volta_total_number += len(numbers)
+                                for no in numbers:
+                                    segment_info[ss]["to"].append(
+                                        no
+                                        + "_Volta_"
+                                        + segment_info[current_volta_end]["ID"]
+                                    )
+                                segment_info[current_volta_end]["info"].append(
+                                    "volta " + ",".join(numbers)
+                                )
+                                segment_info[current_volta_end][
+                                    "volta_numbers"
+                                ] += numbers
+                                # segment_info[bracket_end]["info"].append(str(len(numbers)))
+                                # update the search time to the end of the ext bracket
+                                current_volta_end = boundaries[current_volta_end][
+                                    "volta_start"
+                                ].end.t
+
+                if boundary_type == "volta_end":
+                    current_volta_numbers = segment_info[ss]["volta_numbers"]
+                    for vn in current_volta_numbers:
+                        if vn != str(current_volta_total_number):
+                            # if repeating volta bracket, jump back to start
+                            # check if repeat exists (might not be for 3+ volta brackets)
+                            if "repeat_end" in list(boundaries[se].keys()):
+                                current_volta_repeat_start = max(
+                                    boundaries[se]["repeat_end"].start.t,
+                                    current_volta_repeat_start,
+                                )
+                            repeat_start = current_volta_repeat_start
+                            segment_info[ss]["to"].append(
+                                "Z_Volta_" + segment_info[repeat_start]["ID"]
+                            )
+
+                    if str(current_volta_total_number) in current_volta_numbers:
+                        # else just go to the segment after the last
+                        segment_info[ss]["to"].append(
+                            segment_info[current_volta_end]["ID"]
+                        )
+
+                # NAVIGATION SYMBOLS
+                
+                # Navigation1_ = destinations that should only be used after all others
+                # Navigation2_ = destinations that are used *after* a jump
+                if boundary_type == "coda":
+                    # if a coda symbol is passed just continue
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    segment_info[se]["type"] = "leap_end"
+                    segment_info[se]["info"].append("Coda")
+
+                if boundary_type == "tocoda":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    # find the coda and jump there
+                    coda_time = destinations["coda"][0]
+                    segment_info[ss]["to"].append(
+                        "Navigation2_" + segment_info[coda_time]["ID"]
+                    )
+                    segment_info[ss]["type"] = "leap_start"
+                    segment_info[ss]["info"].append("al coda")
+
+                if boundary_type == "segno":
+                    # if a segno symbol is passed just continue
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    segment_info[se]["type"] = "leap_end"
+                    segment_info[se]["info"].append("segno")
+
+                if boundary_type == "dalsegno":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    # find the segno and jump there
+                    segno_time = destinations["segno"][0]
+                    segment_info[ss]["to"].append(
+                        "Navigation1_" + segment_info[segno_time]["ID"] 
+                    )
+                    segment_info[ss]["to"].append(
+                        "Navigation2_" + segment_info[se]["ID"] 
+                    )
+                    segment_info[ss]["type"] = "leap_start"
+                    segment_info[ss]["info"].append("dal segno")
+
+                if boundary_type == "dacapo":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    # jump to the start
+                    segment_info[ss]["to"].append(
+                        "Navigation1_" + segment_info[part.first_point.t]["ID"]
+                    )
+                    segment_info[ss]["to"].append(
+                        "Navigation2_" + segment_info[se]["ID"] 
+                    )
+                    segment_info[ss]["type"] = "leap_start"
+                    segment_info[ss]["info"].append("da capo")
+
+                if boundary_type == "fine":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+                    # jump to the start
+                    segment_info[ss]["to"].append(
+                        "Navigation2_" + segment_info[part.last_point.t]["ID"]
+                    )
+                    segment_info[ss]["info"].append("fine")
+
+                # GENERIC
+                if boundary_type == "end":
+                    segment_info[ss]["to"].append(segment_info[se]["ID"])
+
+                # first segments is always a leap destination (da capo)
+                if ss == 0:
+                    segment_info[ss]["type"] = "leap_end"
+
+        # clean up and ORDER all the jump destination information
+        for start_time in boundary_times[:-1]:
+            destinations = segment_info[start_time]["to"]
+            destinations_no_volta = [
+                dest
+                for dest in destinations
+                if "Volta_" not in dest and "Navigation" not in dest
+            ]
+            destinations_volta = [dest for dest in destinations if "Volta_" in dest]
+            # dal segno and da capo
+            destinations_navigation1 = [
+                dest[12:] for dest in destinations if "Navigation1_" in dest
+            ]
+            # al coda and fine
+            destinations_navigation2 = [
+                dest[12:] for dest in destinations if "Navigation2_" in dest
+            ]
+
+            # sort the repeats by ascending segment ID
+            destinations_no_volta = list(set(destinations_no_volta))
+            # make sure the "END" destination is the last
+            destinations_except_await = (
+                destinations_volta + destinations_no_volta + destinations_navigation1
+            )
+            if "END" in destinations_except_await:
+                while "END" in destinations_no_volta:
+                    destinations_no_volta.remove("END")
+                destinations_navigation1.append("END")
+
+            # sort repeat destinations by ascending ID
+            destinations_no_volta.sort()
+            # sort destinations by volta number
+            destinations_volta.sort()
+            # keep only the segment IDs
+            destinations_volta = [d[8:] for d in destinations_volta]
+            # don't jump to volta brackets w/t number
+            destinations_no_volta = [
+                d for d in destinations_no_volta if d not in destinations_volta
+            ]
+            destinations_cleaned = (
+                destinations_volta + destinations_no_volta + destinations_navigation1
+            )
+
+            # if len(destinations_navigation2) > 0:
+            #     # keep only jumps to the past
+            #     await_to = [idx for idx in destinations_cleaned if idx <= segment_info[start_time]["ID"]]
+            #     # add the waiting destinations
+            #     await_to += destinations_navigation2
+
+            # else:
+            #     await_to = destinations_cleaned
+
+            part.add(
+                Segment(
+                    id=segment_info[start_time]["ID"],
+                    to=destinations_cleaned,
+                    await_to=destinations_navigation2,  # await_to,
+                    force_seq=segment_info[start_time]["force_full_sequence"],
+                    type=segment_info[start_time]["type"],
+                    info=", ".join(segment_info[start_time]["info"]),
+                ),
+                segment_info[start_time]["start"],
+                segment_info[start_time]["end"],
+            )
+
+
+def get_segments(part):
+    """
+    Get dictionary of segment objects of a part.
+
+    Parameters
+    ----------
+    part: part
+        A score part
+
+    Returns
+    -------
+    segments: dict
+        A dictionary of Segment objects indexed by segment IDs.
+
+    """
+    return {seg.id: seg for seg in part.iter_all(Segment)}
+
+
+def pretty_segments(part):
+    """
+    Get a pretty string of all the segments in a part.
+    """
+    add_segments(part)
+    segments = get_segments(part)
+    string_list = [
+        str(segments[p].id)
+        + " -> (choice) "
+        + "{:<8}".format(",".join(segments[p].to))
+        + "\t segment "
+        + "{:<20}".format(
+            str(part.beat_map(segments[p].start.t))
+            + " - "
+            + str(part.beat_map(segments[p].end.t))
+        )
+        + "\t duration: "
+        + "{:<6}".format(str(part.beat_map(segments[p].end.t) - \
+                             part.beat_map(segments[p].start.t)))
+        + "\t info: "
+        + str(segments[p].info)
+        for p in segments.keys()
+    ]
+    return "\n".join(string_list)
+
+
+class Path:
+    """
+    Path that represents a sequence of segments.
+
+    Parameters
+    ----------
+    path : list
+        The string of segment IDs
+    segments : dict
+        A dictionary of available segments by segment ID
+    used_segment_jumps : defaultdict(list), optional
+        dictionary of used jumps per segment in this path
+    no_repeats : bool, optional
+        Flag to generate no repeating jump destinations with list_of_destinations_from_last_segment
+    all_repeats : bool, optional
+        Flag to generate all repeating jump destinations with list_of_destinations_from_last_segment
+        (lower prority than no_repeats)
+    jumped: bool
+        indicates the presence of a da capo, dal segno, or al coda jump in this path
+    """
+
+    def __init__(
+        self,
+        path_list,
+        segments,
+        used_segment_jumps=None,
+        no_repeats=False,
+        all_repeats=False,
+        jumped=False,
+    ):
+
+        self.path = path_list
+        self.segments = segments
+        if used_segment_jumps is None:
+            self.used_segment_jumps = defaultdict(list)
+        else:
+            self.used_segment_jumps = used_segment_jumps
+        self.ended = False
+        self.jumped = False
+        self.no_repeats = no_repeats
+        self.all_repeats = all_repeats
+        self.jumped = jumped
+
+    def __str__(self):
+        """
+        return a string of segment IDs.
+        """
+        return "-".join(self.path)
+
+    def __len__(self):
+        return len(self.path)
+
+    def pretty(self, part=None):
+        """
+        create a pretty string describing this path instance.
+        If a corresponding part is given, the string will give
+        segment times in beats, else in divs.
+        """
+        if part is None:
+            string_list = [
+                str(self.segments[p].id)
+                + " -> (choice) "
+                + ",".join(self.segments[p].to)
+                + "  \t segment "
+                + str(self.segments[p].start.t)
+                + " - "
+                + str(self.segments[p].end.t)
+                + "\t duration: "
+                + str(self.segments[p].duration)
+                + "  \t type: "
+                + str(self.segments[p].type)
+                for p in self.path
+            ]
+        else:
+            string_list = [
+                str(self.segments[p].id)
+                + " -> (choice) "
+                + ",".join(self.segments[p].to)
+                + "  \t segment "
+                + str(part.beat_map(self.segments[p].start.t))
+                + " - "
+                + str(part.beat_map(self.segments[p].end.t))
+                + "\t duration: "
+                + str(part.beat_map(self.segments[p].duration))
+                + "  \t type: "
+                + str(self.segments[p].type)
+                for p in self.path
+            ]
+        return "\n".join(string_list)
+
+    def copy(self):
+        """
+        create a copy of this path instance.
+        """
+        new_path = Path(
+            copy(self.path),
+            copy(self.segments),
+            no_repeats=self.no_repeats,
+            all_repeats=self.all_repeats,
+            jumped=self.jumped,
+        )
+        for key in self.used_segment_jumps:
+            for used_dest in self.used_segment_jumps[key]:
+                new_path.used_segment_jumps[key].append(used_dest)
+        
+        return new_path
+
+    def make_copy_with_jump_to(self, destination, ignore_leap_info=True):
+        """
+        create a copy of this path instance with an added jump.
+        If the jump is a leap (dal segno, da capo, al coda)
+        and leap information is not ignored,
+        set the new Path to subsequently follow the the shortest version.
+        """
+        new_path = self.copy()
+        new_path.used_segment_jumps[new_path.path[-1]].append(destination)
+        new_path.path.append(destination)
+        
+        if (
+            new_path.segments[destination].type == "leap_end"
+            and new_path.segments[new_path.path[-2]].type == "leap_start"
+        ):
+            if not new_path.jumped:
+                new_path.jumped = True
+                for segid in new_path.segments.keys():
+                    seg = new_path.segments[segid]
+                    # if destinations await the second round, add them
+                    if len(seg.await_to) > 0:
+                        # keep only jumps to the past
+                        to = [idx for idx in seg.to if idx <= seg.id]
+                        # add the waiting destinations
+                        to += seg.await_to
+                        # replace destinations
+                        seg.to = to
+                    # delete used destinations
+                    new_path.used_segment_jumps[segid] = list()
+                # add the jump destination to the used ones
+                new_path.used_segment_jumps[new_path.path[-2]].append(destination)      
+                        
+            if not ignore_leap_info:
+                new_path.no_repeats = True
+        return new_path
+
+    @property
+    def list_of_destinations_from_last_segment(self):    
+        destinations = list(self.segments[self.path[-1]].to)
+        previously_used_destinations = self.used_segment_jumps[self.path[-1]]
+        # only continue in order of the sequence, after full consumption, start at zero
+        # if the full or minimal sequence is forced,
+        # return only the single possible jump destination, else return possibly many.
+        
+        if len(previously_used_destinations) != 0:       
+            last_destination = previously_used_destinations[-1]
+            last_destination_count = previously_used_destinations.count(
+                last_destination
+            )               
+            last_destination_index = [
+                i for i, n in enumerate(destinations * 100) if n == last_destination
+            ][last_destination_count - 1]
+            last_destination_index %= len(destinations)
+
+        if self.no_repeats:
+            # currently this is in higher priority than the full sequence
+            return [destinations[-1]]
+
+        elif self.segments[self.path[-1]].force_full_sequence or self.all_repeats:
+            # if the full sequence should be used in general
+            if len(previously_used_destinations) == 0:
+                return [destinations[0]]
+            else:
+                # last_destination = previously_used_destinations[-1]
+                # last_destination_index = destinations.index(last_destination)
+                if last_destination_index < (len(destinations) - 1):
+                    return [destinations[last_destination_index + 1]]
+                else:
+                    return [destinations[0]]
+
+        else:
+            if len(previously_used_destinations) == 0:
+                return copy(destinations)
+            else:
+                # last_destination = previously_used_destinations[-1]
+                # last_destination_index = destinations.index(last_destination)
+                if last_destination_index < (len(destinations) - 1):
+                    return copy(destinations[last_destination_index + 1 :])
+                else:
+                    return copy(destinations)
+
+
+def unfold_paths(path, paths, ignore_leap_info=True):
+    """
+    Given a starting Path (at least one segment) recursively unfold into all possible
+    Paths with its segments. Ended Paths are stored in a list.
+
+    Parameters
+    ----------
+    path : Path
+        a starting Path with at least one segment to be unfolded
+    paths : list
+        empty list to accumulate paths that are fully unfolded until an "end" keyword was found
+    """
+    destinations = path.list_of_destinations_from_last_segment
+    for destination_id in destinations:
+        if destination_id == "END":
+            path.ended = True
+            paths.append(path)
+        else:
+            new_path = path.make_copy_with_jump_to(
+                destination_id, ignore_leap_info=ignore_leap_info
+            )
+            unfold_paths(new_path, paths, ignore_leap_info=ignore_leap_info)
+
+
+def get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True):
+    """
+    Get a list of paths and and a dictionary of segment objects of a part.
+
+    Common settings to get specific paths:
+    - default: all possible paths
+        (no_repeats = False, all_repeats = False, ignore_leap_info = True)
+    - default: all possible paths but without repetitions after leap
+        (no_repeats = False, all_repeats = False, ignore_leap_info = False)
+    - The longest possible path
+        (no_repeats = False, all_repeats = True, ignore_leap_info = True)
+    - The longest possible path but without repetitions after leap
+        (no_repeats = False, all_repeats = True, ignore_leap_info = False)
+    - The shortest possible path.
+        (no_repeats = True)
+        Note this might not be musically valid, e.g. a passing a "fine"
+        even a first time will stop this unfolding.
+
+    Parameters
+    ----------
+    part: part
+        A score part
+    no_repeats : bool, optional
+        Flag to choose no repeating segments, i.e. the shortest path.
+    all_repeats : bool, optional
+        Flag to choose all repeating segments, i.e. the longest path.
+        (lower priority than the previous flag)
+    ignore_leap_info : bool, optional
+        If not ignored, Path changes to no_repeats = True if a leap is encountered.
+        (A leap is a used dal segno, da capo, or al coda marking)
+
+    Returns
+    -------
+    paths: list
+        A list of path objects
+
+    """
+    add_segments(part)
+    segments = get_segments(part)
+    paths = list()
+    unfold_paths(
+        Path(["A"], segments, no_repeats=no_repeats, all_repeats=all_repeats),
+        paths,
+        ignore_leap_info=ignore_leap_info,
+    )
+
+    return paths
+
+
+def new_part_from_path(path, part, update_ids=True):
+    """
+    create a new Part from a Path and an underlying Part
+
+    Parameters
+    ----------
+    path: Path
+        A Path object
+    part: part
+        A score part
+    update_ids : bool (optional)
+        Update note ids to reflect the repetitions. Note IDs will have
+        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
+        represent the first and second repetition of 'n132' in the
+        input `part`. Defaults to False.
+
+    Returns
+    -------
+    new_part: part
+        A score part corresponding to the Path
+
+    """
+    scorevariant = ScoreVariant(part)
+    for segment_id in path.path:
+        scorevariant.add_segment(
+            path.segments[segment_id].start, path.segments[segment_id].end
+        )
+
+    new_part = scorevariant.create_variant_part()
+    if update_ids:
+        update_note_ids_after_unfolding(new_part)
+    return new_part
+
+
+def new_scorevariant_from_path(path, part):
+    """
+    create a new Part from a Path and an underlying Part
+
+    Parameters
+    ----------
+    path: Path
+        A Path object
+    part: part
+        A score part
+
+    Returns
+    -------
+    scorevariant: ScoreVariant
+        A ScoreVariant object with segments corresponding to the part
+
+    """
+    scorevariant = ScoreVariant(part)
+    for segment_id in path.path:
+        scorevariant.add_segment(
+            path.segments[segment_id].start, path.segments[segment_id].end
+        )
+    return scorevariant
+
+
+# UPDATED VERSION
+def iter_unfolded_parts(part, update_ids=True):
+    """Iterate over unfolded clones of `part`.
+
+    For each repeat construct in `part` the iterator produces two
+    clones, one with the repeat included and another without the
+    repeat. That means the number of items returned is two to the
+    power of the number of repeat constructs in the part.
+
+    The first item returned by the iterator is the version of the part
+    without any repeated sections, the last item is the version of the
+    part with all repeat constructs expanded.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        Part to unfold
+    update_ids : bool (optional)
+        Update note ids to reflect the repetitions. Note IDs will have
+        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
+        represent the first and second repetition of 'n132' in the
+        input `part`. Defaults to False.
+
+    Yields
+    ------
+
+    """
+    paths = get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True)
+
+    for p in paths:
+        yield new_part_from_path(p, part, update_ids=update_ids)
+
+
+# UPDATED VERSION
+def unfold_part_maximal(part, update_ids=True, ignore_leaps=True):
+    """Return the "maximally" unfolded part, that is, a copy of the
+    part where all segments marked with repeat signs are included
+    twice.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        The Part to unfold.
+    update_ids : bool (optional)
+        Update note ids to reflect the repetitions. Note IDs will have
+        a '-<repetition number>', e.g., 'n132-1' and 'n132-2'
+        represent the first and second repetition of 'n132' in the
+        input `part`. Defaults to False.
+    ignore_leaps : bool (optional)
+        If ignored, repetitions after a leap are unfolded fully.
+        A leap is a used dal segno, da capo, or al coda marking.
+        Defaults to True.
+
+    Returns
+    -------
+    unfolded_part : :class:`Part`
+        The unfolded Part
+
+    """
+
+    paths = get_paths(
+        part, no_repeats=False, all_repeats=True, ignore_leap_info=ignore_leaps
+    )
+
+    unfolded_part = new_part_from_path(paths[0], part, update_ids=update_ids)
+    return unfolded_part
+
+
+# UPDATED / UNCHANGED VERSION
+def unfold_part_alignment(part, alignment):
+    """Return the unfolded part given an alignment, that is, a copy
+    of the part where the segments are repeated according to the
+    repetitions in a performance.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        The Part to unfold.
+    alignment : list of dictionaries
+        List of dictionaries containing an alignment (like the ones
+        obtained from a MatchFile (see `alignment_from_matchfile`).
+
+    Returns
+    -------
+    unfolded_part : :class:`Part`
+        The unfolded Part
+
+    """
+
+    unfolded_parts = []
+
+    alignment_ids = []
+
+    for n in alignment:
+        if n["label"] == "match" or n["label"] == "deletion":
+            alignment_ids.append(n["score_id"])
+
+    score_variants = make_score_variants(part)
+
+    alignment_score_ids = np.zeros((len(alignment_ids), len(score_variants)))
+    unfolded_part_length = np.zeros(len(score_variants))
+    for j, sv in enumerate(score_variants):
+        u_part = sv.create_variant_part()
+        update_note_ids_after_unfolding(u_part)
+        unfolded_parts.append(u_part)
+        u_part_ids = [n.id for n in u_part.notes_tied]
+        unfolded_part_length[j] = len(u_part_ids)
+        for i, aid in enumerate(alignment_ids):
+            alignment_score_ids[i, j] = aid in u_part_ids
+
+    coverage = np.mean(alignment_score_ids, 0)
+
+    best_idx = np.where(coverage == coverage.max())[0]
+
+    if len(best_idx) > 1:
+        best_idx = best_idx[unfolded_part_length[best_idx].argmin()]
+
+    # append "-1" to alignment if the score_id's in alignment
+    if not any(["-1" in al.get("score_id", "") for al in alignment]):
+        for n in alignment:
+            if "score_id" in n:
+                n["score_id"] = f"{n['score_id']}-1"
+
+    return unfolded_parts[int(best_idx)]
+
+
+# UPDATED
+def make_score_variants(part):
+    # non-public (use unfold_part_maximal, or iter_unfolded_parts)
+
+    """
+    Create a list of ScoreVariant objects, each representing a
+    distinct way to unfold the score, based on the repeat structure.
+
+    Parameters
+    ----------
+    part : :class:`Part`
+        A part for which to make the score variants
+
+    Returns
+    -------
+    list
+        List of ScoreVariant objects
+
+    """
+    paths = get_paths(part, no_repeats=False, all_repeats=False, ignore_leap_info=True)
+
+    svs = list()
+    for path in paths:
+        svs.append(new_scorevariant_from_path(path, part))
+
+    return svs
+
+
+def merge_parts(parts, reassign="voice"):
+    """Merge list of parts or PartGroup into a single part.
+     All parts are expected to have the same time signature
+    and quarter division.
+
+    All elements are merged, except elements with class:Barline,
+    Page, System, Clef, Measure, TimeSignature, KeySignature
+    that are only taken from the first part.
+
+    WARNING: this modifies the elements in the input, so the
+    original input should not be used anymore.
+
+    Parameters
+    ----------
+    parts : PartGroup, list of parts and partGroups
+        The parts to merge
+    reassign: string (optional)
+        If "staff" the new part have as many staves as the sum
+        of the staves in parts, and the staff numbers get reassigned.
+        If "voice", the new part have only one staff, and as manually
+        voices as the sum of the voices in parts; the voice number
+        get reassigned.
+
+    Returns
+    -------
+    Part
+        A new part that contains the elements of the old parts
+
+    """
+    # check if reassign has valid values
+    if reassign not in ["staff", "voice"]:
+        raise ValueError(
+            "Only 'staff' and 'voice' are supported ressign values. Found", reassign
+        )
+
+    # unfold grouppart and list of parts in a list of parts
+    if isinstance(parts, Score):
+        parts = parts.parts
+    else:
+        parts = list(iter_parts(parts))
+
+    # if there is only one part (it could be a list with one part or a partGroup with one part)
+    if len(parts) == 1:
+        return parts[0]
+
+    # check if there is only one division for all parts
+    parts_quarter_times = [p._quarter_times for p in parts]
+    parts_quarter_durations = [p._quarter_durations for p in parts]
+    if not all([len(qd) == 1 for qd in parts_quarter_durations]):
+        raise Exception(
+            "Merging parts with multiple divisions is not supported. Found divisions",
+            parts_quarter_durations,
+            "at times",
+            parts_quarter_times,
+        )
+
+    # pass from an array of array with one elements, to array of elements
+    parts_quarter_durations = [durs[0] for durs in parts_quarter_durations]
+
+    lcm = np.lcm.reduce(parts_quarter_durations)
+    time_multiplier_per_part = [int(lcm / d) for d in parts_quarter_durations]
+
+    # create a new part and fill it with all objects in other parts
+    new_part = Part(parts[0].id)
+    new_part._quarter_times = [0]
+    new_part._quarter_durations = [lcm]
+
+    note_arrays = [part.note_array(include_staff=True) for part in parts]
+    # find the maximum number of voices for each part (voice number start from 1)
+    maximum_voices = [
+        max(note_array["voice"], default=0)
+        if max(note_array["voice"], default=0) != 0
+        else 1
+        for note_array in note_arrays
+    ]
+    # find the maximum number of staves for each part (staff number start from 0 but we force them to 1)
+    maximum_staves = [
+        max(note_array["staff"], default=0)
+        if max(note_array["staff"], default=0) != 0
+        else 1
+        for note_array in note_arrays
+    ]
+
+    if reassign == "staff":
+        el_to_discard = (
+            Barline,
+            Page,
+            System,
+            Measure,
+            TimeSignature,
+            KeySignature,
+            DaCapo,
+            Fine,
+            Fermata,
+            Ending,
+            Tempo,
+        )
+    elif reassign == "voice":
+        el_to_discard = (
+            Barline,
+            Page,
+            System,
+            Clef,
+            Measure,
+            TimeSignature,
+            KeySignature,
+            DaCapo,
+            Fine,
+            Fermata,
+            Ending,
+            Tempo,
+        )
+
+    for p_ind, p in enumerate(parts):
+        for e in p.iter_all():
+            # full copy the first part and partially copy the others
+            # we don't copy elements like duplicate barlines, clefs or
+            # time signatures for others
+            # TODO : check  DaCapo, Fine, Fermata, Ending, Tempo
+            if p_ind == 0 or not isinstance(
+                e,
+                el_to_discard,
+            ):  # a time multiplier is used to account for different divisions
+                new_start = e.start.t * time_multiplier_per_part[p_ind]
+                new_end = (
+                    e.end.t * time_multiplier_per_part[p_ind]
+                    if e.end is not None
+                    else None
+                )
+                if reassign == "voice":
+                    if isinstance(e, GenericNote):
+                        e.voice = e.voice + sum(maximum_voices[:p_ind])
+                elif reassign == "staff":
+                    if isinstance(e, (GenericNote, Words, Direction)):
+
+                        e.staff = (e.staff if e.staff is not None else 1) + sum(maximum_staves[:p_ind])
+                    elif isinstance(
+                        e, Clef
+                    ):  # TODO: to update if "number" get changed in "staff"
+
+                        e.staff = (e.staff if e.staff is not None else 1) + sum(maximum_staves[:p_ind])
+                new_part.add(e, start=new_start, end=new_end)
+
+                # new_part.add(copy.deepcopy(e), start=new_start, end=new_end)
+    return new_part
+
+
+def is_a_within_b(a, b, wholly=False):
+    """
+    Returns a boolean indicating whether a is (wholly) within b.
+
+    Parameters
+    ----------
+    a: TimePoint, TimedObject, int
+        Query object
+    b: TimedObject
+        Container object
+    wholly: bool
+        True = a needs to wholly contained in b
+    """
+    contained = None
+    if not isinstance(b, TimedObject):
+        warnings.warn("b needs to be TimedObject")
+    if isinstance(a, TimePoint):
+        contained = a.t <= b.end.t and a.t >= b.start.t
+    elif isinstance(a, int):
+        contained = a <= b.end.t and a >= b.start.t
+    elif isinstance(a, TimedObject):
+        contained_start = a.start.t <= b.end.t and a.start.t >= b.start.t
+        contained_end = a.end.t <= b.end.t and a.end.t >= b.start.t
+        if wholly:
+            contained = contained_start and contained_end
+        else:
+            contained = contained_start or contained_end
+    else:
+        warnings.warn("a needs to be TimePoint, TimedObject, or int.")
+    return contained
+
+
+class InvalidTimePointException(Exception):
+    """Raised when a time point is instantiated with an invalid number."""
+
+    def __init__(self, message=None):
+        super().__init__(message)
+
+
+if __name__ == "__main__":
+    import doctest
+
+    doctest.testmod()
```

### Comparing `partitura-1.2.1/partitura/utils/generic.py` & `partitura-1.2.2/partitura/utils/generic.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,621 +1,621 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-This module contains generic class- and numerical-related utilities
-"""
-import warnings
-from collections import defaultdict
-
-from typing import Union, Callable, Optional
-
-from textwrap import dedent
-import numpy as np
-from scipy.interpolate import interp1d as sc_interp1d
-
-
-__all__ = ["find_nearest", "iter_current_next", "partition", "iter_subclasses"]
-
-
-class _OrderedSet(dict):
-    def add(self, x):
-        self[x] = None
-
-    def remove(self, x):
-        self.pop(x, None)
-
-
-def find_nearest(array, value):
-    """
-    Return the index of the value in `array` that is closest to `value`.
-
-    Parameters
-    ----------
-    array: ndarray
-        Array of numbers
-    value: float
-        The query value
-
-    Returns
-    -------
-    int
-        Index of closest value
-    """
-
-    idx = np.searchsorted(array, value, side="left")
-    if idx > 0 and (
-        idx == len(array)
-        or np.abs(value - array[idx - 1]) <= np.abs(value - array[idx])
-    ):
-        return idx - 1
-    else:
-        return idx
-
-
-# we need a globally unique value to detect whether a keyword argument was
-# passed to iter_current_next
-_sentinel = object()
-
-
-def iter_current_next(iterable, start=_sentinel, end=_sentinel):
-    """Iterate over pairs of consecutive values in an iterable.
-
-    This creates generator that yields a (current, next) tuple per element. If the
-    iterable contains less than two elements a StopIteration exception is
-    raised.
-
-    Parameters
-    ----------
-    iterable: iterable
-        Iterable to take values from
-    start: object, optional
-        If specified, this value will be treated as if it were the first element
-        of the iterator
-    end: object, optional
-        If specified, this value will be treated as if it were the last element
-        of the iterator
-
-    Yields
-    ------
-    (object, object)
-        Pairs of items
-
-    Examples
-    --------
-
-    >>> for pair in iter_current_next([]):
-    ...     print(pair)
-
-    >>> for pair in iter_current_next([0]):
-    ...     print(pair)
-
-    >>> for pair in iter_current_next([0, 1, 2]):
-    ...     print(pair)
-    (0, 1)
-    (1, 2)
-
-    >>> for pair in iter_current_next([0, 1, 2], start=None):
-    ...     print(pair)
-    (None, 0)
-    (0, 1)
-    (1, 2)
-
-    >>> for pair in iter_current_next([0, 1, 2], end='end_value'):
-    ...     print(pair)
-    (0, 1)
-    (1, 2)
-    (2, 'end_value')
-
-    >>> for pair in iter_current_next([], start='start', end='end'):
-    ...     print(pair)
-    ('start', 'end')
-
-    """
-    iterable = iter(iterable)
-
-    cur = start
-    try:
-
-        if cur is _sentinel:
-            cur = next(iterable)
-
-        while True:
-
-            nxt = next(iterable)
-            yield (cur, nxt)
-            cur = nxt
-
-    except StopIteration:
-
-        if cur is not _sentinel and end is not _sentinel:
-            yield (cur, end)
-
-
-def iter_subclasses(cls, _seen=None):
-    """
-    iter_subclasses(cls)
-
-    Generator over all subclasses of a given class, in depth first order.
-
-    Examples
-    --------
-
-    >>> class A(object): pass
-    >>> class B(A): pass
-    >>> class C(A): pass
-    >>> class D(B,C): pass
-    >>> class E(D): pass
-    >>>
-    >>> for cls in iter_subclasses(A):
-    ...     print(cls.__name__)
-    B
-    D
-    E
-    C
-    >>> # get ALL (new-style) classes currently defined
-    >>> [cls.__name__ for cls in iter_subclasses(object)] #doctest: +ELLIPSIS
-    ['type', ...'tuple', ...]
-    """
-
-    if not isinstance(cls, type):
-        raise TypeError(
-            "iter_subclasses must be called with " "new-style classes, not %.100r" % cls
-        )
-    if _seen is None:
-        _seen = set()
-    try:
-        subs = cls.__subclasses__()
-    except TypeError:  # fails only when cls is type
-        subs = cls.__subclasses__(cls)
-    for sub in subs:
-        if sub not in _seen:
-            _seen.add(sub)
-            yield sub
-            for sub in iter_subclasses(sub, _seen):
-                yield sub
-
-
-class ReplaceRefMixin(object):
-    """This class is a utility mixin class to replace references to
-    objects with references to other objects. This is functionality is
-    used when unfolding timelines.
-
-    To use this functionality, a class should inherit from this class,
-    and keep a list of all attributes that contain references.
-
-    Examples
-    --------
-    The following class defines `prev` as a referential attribute, to
-    be replaced when a class instance is copied:
-
-    >>> class MyClass(ReplaceRefMixin):
-    ...     def __init__(self, prev=None):
-    ...         super().__init__()
-    ...         self.prev = prev
-    ...         self._ref_attrs.append('prev')
-
-    Create two instance `a1` and `a2`, where `a1` is the `prev` of
-    `a2``
-
-    >>> a1 = MyClass()
-    >>> a2 = MyClass(a1)
-
-    Copy `a1` and `a2` to `b1` and `b2`, respectively:
-    >>> from copy import copy
-    >>> b1 = copy(a1)
-    >>> b2 = copy(a2)
-
-    After copying the prev of `b2` is `a1`, not `b1`:
-
-    >>> b2.prev == b1
-    False
-    >>> b2.prev == a1
-    True
-
-    To fix that we define an object map:
-
-    >>> object_map = {a1: b1, a2: b2}
-
-    and replace the references according to the map:
-
-    >>> b2.replace_refs(object_map)
-    >>> b2.prev == b1
-    True
-
-    """
-
-    def __init__(self):
-        self._ref_attrs = []
-
-    def replace_refs(self, o_map):
-        if hasattr(self, "_ref_attrs"):
-            for attr in self._ref_attrs:
-                o = getattr(self, attr)
-                if o is None:
-                    pass
-                elif isinstance(o, list):
-                    o_list_new = []
-
-                    for o_el in o:
-                        if o_el in o_map:
-                            o_list_new.append(o_map[o_el])
-                        else:
-                            warnings.warn(
-                                dedent(
-                                    """reference not found in
-                            o_map: {} start={} end={}, substituting None
-                            """.format(
-                                        o_el, o_el.start, o_el.end
-                                    )
-                                )
-                            )
-                            o_list_new.append(None)
-
-                    setattr(self, attr, o_list_new)
-                else:
-                    if o in o_map:
-                        o_new = o_map[o]
-                    else:
-                        warnings.warn(
-                            dedent(
-                                """reference not found in o_map:
-                        {} start={} end={}, substituting None
-                        """.format(
-                                    o, o.start, o.end
-                                )
-                            )
-                        )
-                        o_new = None
-                    setattr(self, attr, o_new)
-
-
-class ComparableMixin(object):
-    """
-    Mixin class that makes instances comparable in a rich way (i.e. in !=, <, <=
-    etc), by just implementing a _cmpkey() method that returns a comparable
-    value.
-
-    source:
-    http://regebro.wordpress.com/2010/12/13/python-implementing-rich-comparison-the-correct-way/
-
-    Examples
-    --------
-
-    >>> class MyClass(ComparableMixin):
-    ...     def __init__(self, x):
-    ...         self.x = x
-    ...     def _cmpkey(self):
-    ...         return self.x
-    >>>
-    >>> a = MyClass(3)
-    >>> b = MyClass(4)
-    >>> a == b
-    False
-    >>> a < b
-    True
-
-    """
-
-    def _compare(self, other, method):
-        try:
-            return method(self._cmpkey(), other._cmpkey())
-        except (AttributeError, TypeError):
-            # _cmpkey not implemented, or return different type,
-            # so I can't compare with "other".
-            return NotImplemented
-
-    def __lt__(self, other):
-        return self._compare(other, lambda s, o: s < o)
-
-    def __le__(self, other):
-        return self._compare(other, lambda s, o: s <= o)
-
-    def __eq__(self, other):
-        return self._compare(other, lambda s, o: s == o)
-
-    def __ge__(self, other):
-        return self._compare(other, lambda s, o: s >= o)
-
-    def __gt__(self, other):
-        return self._compare(other, lambda s, o: s > o)
-
-    def __ne__(self, other):
-        return self._compare(other, lambda s, o: s != o)
-
-
-def partition(func, iterable):
-    """
-    Return a dictionary containing the equivalence classes (actually bags)
-    of `iterable`, partioned according to `func`. The value of a key `k` is the
-    list of all elements `e` from iterable such that `k = func(e)`.
-
-    Examples
-    ========
-
-    The following example groups the integers from 0 to 10 by their
-    respective modulo 3 values:
-
-    >>> lst = range(10)
-    >>> partition(lambda x: x % 3, lst)
-    {0: [0, 3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
-
-    """
-    result = defaultdict(list)
-    for v in iterable:
-        result[func(v)].append(v)
-    return dict(result)
-
-
-def add_field(a, descr):
-    """
-    Return a new array that is like `a`, but has additional fields.
-    The contents of `a` are copied over to the appropriate fields in
-    the new array, whereas the new fields are uninitialized.  The
-    arguments are not modified. Source [8]_.
-
-    Parameters
-    ----------
-    a: np.ndarray
-        A structured numpy array
-    descr: np.dtype or list
-        A numpy type description of the new fields
-
-    Returns
-    -------
-    np.ndarray
-         The new structured numpy array
-
-    Examples
-    --------
-    >>> import numpy as np
-    >>> sa = np.array([(1, 'Foo'), (2, 'Bar')], \
-                         dtype=[('id', int), ('name', 'S3')])
-    >>> sa.dtype.descr == np.dtype([('id', int), ('name', 'S3')])
-    True
-    >>> sb = add_field(sa, [('score', float)])
-    >>> sb.dtype.descr == np.dtype([('id', int), ('name', 'S3'), \
-                                       ('score', float)])
-    True
-    >>> np.all(sa['id'] == sb['id'])
-    True
-    >>> np.all(sa['name'] == sb['name'])
-    True
-
-    Notes
-    -----
-    Source:
-
-    .. [8]
-       https://stackoverflow.com/questions/1201817/\
-adding-a-field-to-a-structured-numpy-array
-
-    """
-    if a.dtype.fields is None:
-        raise ValueError("`A` must be a structured numpy array")
-
-    if isinstance(descr, np.dtype):
-        descr = descr.descr
-    b = np.empty(a.shape, dtype=a.dtype.descr + descr)
-    for name in a.dtype.names:
-        b[name] = a[name]
-    return b
-
-
-def sorted_dict_items(items, key=None):
-    for item in sorted(items, key=key):
-        yield item
-
-
-def show_diff(a, b):
-    """
-    Show the difference between two strings, using the difflib package. The
-    difference is printed to stdout.
-
-    Parameters
-    ----------
-    a: str
-        First string
-    b: str
-        Second string
-    """
-
-    import difflib
-
-    differ = difflib.Differ()
-    for li in differ.compare(a.split("\n"), b.split("\n")):
-        print(li)
-
-
-class PrettyPrintTree(object):
-    def __init__(self):
-        self.stack = []
-
-    def push(self):
-        self.stack.append(TreeSymbol())
-
-    def pop(self):
-        self.stack.pop()
-
-    def next_item(self):
-        assert len(self.stack) > 0
-        self.stack[-1].next_item()
-
-    def last_item(self):
-        assert len(self.stack) > 0
-        self.stack[-1].last_item()
-
-    def __str__(self):
-        return "".join(str(sym) for sym in self.stack)
-
-
-class TreeSymbol(object):
-    def __init__(self):
-        self.symbols = [" │  ", " ├─ ", " └─ ", "    "]
-        self.state = 0
-
-    def next_item(self):
-        self.state = 1
-
-    def last_item(self):
-        self.state = 2
-
-    def __str__(self):
-        sym = self.symbols[self.state]
-        if self.state == 1:
-            self.state = 0
-        elif self.state == 2:
-            self.state = 3
-        return sym
-
-
-def search(states, success, expand, combine):
-    while len(states) > 0:
-        state = states.pop(0)
-        if success(state):
-            return state
-        else:
-            states = combine(expand(state), states)
-
-
-def interp1d(
-    x: np.ndarray,
-    y: np.ndarray,
-    dtype: Optional[type] = None,
-    axis: int = -1,
-    kind: Union[str, int] = "linear",
-    copy=True,
-    bounds_error=None,
-    fill_value=np.nan,
-    assume_sorted=False,
-) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
-    """
-    Interpolate a 1-D function using scipy's interp1d method. This utility allows for
-    handling the case where `x` and `y` are only a single value (i.e. have length one,
-    which results in a ValueError if using scipy's version directly). It also allows for
-    specifying the dtype of the output.
-
-    The description of the parameters has been taken from `scipy.interpolate.interp1d`.
-
-    `x` and `y` are arrays of values used to approximate some function f:
-    ``y = f(x)``. This class returns a function whose call method uses
-    interpolation to find the value of new points.
-
-
-    Parameters
-    ----------
-    x : (N,) np.ndarray
-        A 1-D array of real values.
-    y : (...,N,...) np.ndarray
-        A N-D array of real values. The length of `y` along the interpolation
-        axis must be equal to the length of `x`.
-    dtype : type, optional
-        Type of the output array (e.g.,  `float`, `int`). By default it is set to
-        None (i.e., the array will have the same type as the outputs from
-        scipy's interp1d method.
-    axis : int, optional
-        Specifies the axis of `y` along which to interpolate.
-        Interpolation defaults to the last axis of `y`.
-    kind : str or int, optional
-        Specifies the kind of interpolation as a string or as an integer
-        specifying the order of the spline interpolator to use.
-        The string has to be one of 'linear', 'nearest', 'nearest-up', 'zero',
-        'slinear', 'quadratic', 'cubic', 'previous', or 'next'. 'zero',
-        'slinear', 'quadratic' and 'cubic' refer to a spline interpolation of
-        zeroth, first, second or third order; 'previous' and 'next' simply
-        return the previous or next value of the point; 'nearest-up' and
-        'nearest' differ when interpolating half-integers (e.g. 0.5, 1.5)
-        in that 'nearest-up' rounds up and 'nearest' rounds down. Default
-        is 'linear'.
-    copy : bool, optional
-        If True, the class makes internal copies of x and y.
-        If False, references to `x` and `y` are used. The default is to copy.
-    bounds_error : bool, optional
-        If True, a ValueError is raised any time interpolation is attempted on
-        a value outside of the range of x (where extrapolation is
-        necessary). If False, out of bounds values are assigned `fill_value`.
-        By default, an error is raised unless ``fill_value="extrapolate"``.
-    fill_value : array-like or (array-like, array_like) or "extrapolate", optional
-        - if a ndarray (or float), this value will be used to fill in for
-          requested points outside of the data range. If not provided, then
-          the default is NaN. The array-like must broadcast properly to the
-          dimensions of the non-interpolation axes.
-        - If a two-element tuple, then the first element is used as a
-          fill value for ``x_new < x[0]`` and the second element is used for
-          ``x_new > x[-1]``. Anything that is not a 2-element tuple (e.g.,
-          list or ndarray, regardless of shape) is taken to be a single
-          array-like argument meant to be used for both bounds as
-          ``below, above = fill_value, fill_value``.
-        - If "extrapolate", then points outside the data range will be
-          extrapolated.
-    assume_sorted : bool, optional
-        If False, values of `x` can be in any order and they are sorted first.
-        If True, `x` has to be an array of monotonically increasing values.
-
-    Returns
-    -------
-    interp_fun : callable
-        The interpolator instance. This method takes an input array, float
-        or integer and returns an array with the specified dtype (if `dtype`
-        is not None).
-    """
-    if len(x) > 1:
-        interp_fun = sc_interp1d(
-            x=x,
-            y=y,
-            kind=kind,
-            axis=axis,
-            copy=copy,
-            bounds_error=bounds_error,
-            fill_value=fill_value,
-            assume_sorted=assume_sorted,
-        )
-
-    else:
-
-        # If there is only one value for x and y, assume that the method
-        # will always return the same value for any input.
-
-        def interp_fun(
-            input_var: Union[float, int, np.ndarray]
-        ) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
-
-            if y.ndim > 1:
-                result = np.broadcast_to(y, (len(np.atleast_1d(input_var)), y.shape[1]))
-            else:
-                result = np.broadcast_to(y, (len(np.atleast_1d(input_var)),))
-
-            if not isinstance(input_var, np.ndarray):
-                # the output of scipy's interp1d is always an array
-                result = np.array(result[0])
-
-            return result
-
-    if dtype is not None:
-
-        def typed_interp(
-            input_var: Union[float, int, np.ndarray]
-        ) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
-            return interp_fun(input_var).astype(dtype)
-
-        return typed_interp
-    else:
-        return interp_fun
-
-
-# def search_recursive(states, success, expand, combine):
-#     try:
-#         if not states:
-#             return None
-#         elif success(states[0]):
-#             return states[0]
-#         else:
-#             new_states = combine(expand(states[0]), states[1:])
-#             return search_recursive(new_states, success, expand, combine)
-#     except RecursionError:
-#         warnings.warn('search exhausted stack, bailing out')
-#         return None
-
-
-if __name__ == "__main__":
-    import doctest
-
-    doctest.testmod()
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+This module contains generic class- and numerical-related utilities
+"""
+import warnings
+from collections import defaultdict
+
+from typing import Union, Callable, Optional
+
+from textwrap import dedent
+import numpy as np
+from scipy.interpolate import interp1d as sc_interp1d
+
+
+__all__ = ["find_nearest", "iter_current_next", "partition", "iter_subclasses"]
+
+
+class _OrderedSet(dict):
+    def add(self, x):
+        self[x] = None
+
+    def remove(self, x):
+        self.pop(x, None)
+
+
+def find_nearest(array, value):
+    """
+    Return the index of the value in `array` that is closest to `value`.
+
+    Parameters
+    ----------
+    array: ndarray
+        Array of numbers
+    value: float
+        The query value
+
+    Returns
+    -------
+    int
+        Index of closest value
+    """
+
+    idx = np.searchsorted(array, value, side="left")
+    if idx > 0 and (
+        idx == len(array)
+        or np.abs(value - array[idx - 1]) <= np.abs(value - array[idx])
+    ):
+        return idx - 1
+    else:
+        return idx
+
+
+# we need a globally unique value to detect whether a keyword argument was
+# passed to iter_current_next
+_sentinel = object()
+
+
+def iter_current_next(iterable, start=_sentinel, end=_sentinel):
+    """Iterate over pairs of consecutive values in an iterable.
+
+    This creates generator that yields a (current, next) tuple per element. If the
+    iterable contains less than two elements a StopIteration exception is
+    raised.
+
+    Parameters
+    ----------
+    iterable: iterable
+        Iterable to take values from
+    start: object, optional
+        If specified, this value will be treated as if it were the first element
+        of the iterator
+    end: object, optional
+        If specified, this value will be treated as if it were the last element
+        of the iterator
+
+    Yields
+    ------
+    (object, object)
+        Pairs of items
+
+    Examples
+    --------
+
+    >>> for pair in iter_current_next([]):
+    ...     print(pair)
+
+    >>> for pair in iter_current_next([0]):
+    ...     print(pair)
+
+    >>> for pair in iter_current_next([0, 1, 2]):
+    ...     print(pair)
+    (0, 1)
+    (1, 2)
+
+    >>> for pair in iter_current_next([0, 1, 2], start=None):
+    ...     print(pair)
+    (None, 0)
+    (0, 1)
+    (1, 2)
+
+    >>> for pair in iter_current_next([0, 1, 2], end='end_value'):
+    ...     print(pair)
+    (0, 1)
+    (1, 2)
+    (2, 'end_value')
+
+    >>> for pair in iter_current_next([], start='start', end='end'):
+    ...     print(pair)
+    ('start', 'end')
+
+    """
+    iterable = iter(iterable)
+
+    cur = start
+    try:
+
+        if cur is _sentinel:
+            cur = next(iterable)
+
+        while True:
+
+            nxt = next(iterable)
+            yield (cur, nxt)
+            cur = nxt
+
+    except StopIteration:
+
+        if cur is not _sentinel and end is not _sentinel:
+            yield (cur, end)
+
+
+def iter_subclasses(cls, _seen=None):
+    """
+    iter_subclasses(cls)
+
+    Generator over all subclasses of a given class, in depth first order.
+
+    Examples
+    --------
+
+    >>> class A(object): pass
+    >>> class B(A): pass
+    >>> class C(A): pass
+    >>> class D(B,C): pass
+    >>> class E(D): pass
+    >>>
+    >>> for cls in iter_subclasses(A):
+    ...     print(cls.__name__)
+    B
+    D
+    E
+    C
+    >>> # get ALL (new-style) classes currently defined
+    >>> [cls.__name__ for cls in iter_subclasses(object)] #doctest: +ELLIPSIS
+    ['type', ...'tuple', ...]
+    """
+
+    if not isinstance(cls, type):
+        raise TypeError(
+            "iter_subclasses must be called with " "new-style classes, not %.100r" % cls
+        )
+    if _seen is None:
+        _seen = set()
+    try:
+        subs = cls.__subclasses__()
+    except TypeError:  # fails only when cls is type
+        subs = cls.__subclasses__(cls)
+    for sub in subs:
+        if sub not in _seen:
+            _seen.add(sub)
+            yield sub
+            for sub in iter_subclasses(sub, _seen):
+                yield sub
+
+
+class ReplaceRefMixin(object):
+    """This class is a utility mixin class to replace references to
+    objects with references to other objects. This is functionality is
+    used when unfolding timelines.
+
+    To use this functionality, a class should inherit from this class,
+    and keep a list of all attributes that contain references.
+
+    Examples
+    --------
+    The following class defines `prev` as a referential attribute, to
+    be replaced when a class instance is copied:
+
+    >>> class MyClass(ReplaceRefMixin):
+    ...     def __init__(self, prev=None):
+    ...         super().__init__()
+    ...         self.prev = prev
+    ...         self._ref_attrs.append('prev')
+
+    Create two instance `a1` and `a2`, where `a1` is the `prev` of
+    `a2``
+
+    >>> a1 = MyClass()
+    >>> a2 = MyClass(a1)
+
+    Copy `a1` and `a2` to `b1` and `b2`, respectively:
+    >>> from copy import copy
+    >>> b1 = copy(a1)
+    >>> b2 = copy(a2)
+
+    After copying the prev of `b2` is `a1`, not `b1`:
+
+    >>> b2.prev == b1
+    False
+    >>> b2.prev == a1
+    True
+
+    To fix that we define an object map:
+
+    >>> object_map = {a1: b1, a2: b2}
+
+    and replace the references according to the map:
+
+    >>> b2.replace_refs(object_map)
+    >>> b2.prev == b1
+    True
+
+    """
+
+    def __init__(self):
+        self._ref_attrs = []
+
+    def replace_refs(self, o_map):
+        if hasattr(self, "_ref_attrs"):
+            for attr in self._ref_attrs:
+                o = getattr(self, attr)
+                if o is None:
+                    pass
+                elif isinstance(o, list):
+                    o_list_new = []
+
+                    for o_el in o:
+                        if o_el in o_map:
+                            o_list_new.append(o_map[o_el])
+                        else:
+                            warnings.warn(
+                                dedent(
+                                    """reference not found in
+                            o_map: {} start={} end={}, substituting None
+                            """.format(
+                                        o_el, o_el.start, o_el.end
+                                    )
+                                )
+                            )
+                            o_list_new.append(None)
+
+                    setattr(self, attr, o_list_new)
+                else:
+                    if o in o_map:
+                        o_new = o_map[o]
+                    else:
+                        warnings.warn(
+                            dedent(
+                                """reference not found in o_map:
+                        {} start={} end={}, substituting None
+                        """.format(
+                                    o, o.start, o.end
+                                )
+                            )
+                        )
+                        o_new = None
+                    setattr(self, attr, o_new)
+
+
+class ComparableMixin(object):
+    """
+    Mixin class that makes instances comparable in a rich way (i.e. in !=, <, <=
+    etc), by just implementing a _cmpkey() method that returns a comparable
+    value.
+
+    source:
+    http://regebro.wordpress.com/2010/12/13/python-implementing-rich-comparison-the-correct-way/
+
+    Examples
+    --------
+
+    >>> class MyClass(ComparableMixin):
+    ...     def __init__(self, x):
+    ...         self.x = x
+    ...     def _cmpkey(self):
+    ...         return self.x
+    >>>
+    >>> a = MyClass(3)
+    >>> b = MyClass(4)
+    >>> a == b
+    False
+    >>> a < b
+    True
+
+    """
+
+    def _compare(self, other, method):
+        try:
+            return method(self._cmpkey(), other._cmpkey())
+        except (AttributeError, TypeError):
+            # _cmpkey not implemented, or return different type,
+            # so I can't compare with "other".
+            return NotImplemented
+
+    def __lt__(self, other):
+        return self._compare(other, lambda s, o: s < o)
+
+    def __le__(self, other):
+        return self._compare(other, lambda s, o: s <= o)
+
+    def __eq__(self, other):
+        return self._compare(other, lambda s, o: s == o)
+
+    def __ge__(self, other):
+        return self._compare(other, lambda s, o: s >= o)
+
+    def __gt__(self, other):
+        return self._compare(other, lambda s, o: s > o)
+
+    def __ne__(self, other):
+        return self._compare(other, lambda s, o: s != o)
+
+
+def partition(func, iterable):
+    """
+    Return a dictionary containing the equivalence classes (actually bags)
+    of `iterable`, partioned according to `func`. The value of a key `k` is the
+    list of all elements `e` from iterable such that `k = func(e)`.
+
+    Examples
+    ========
+
+    The following example groups the integers from 0 to 10 by their
+    respective modulo 3 values:
+
+    >>> lst = range(10)
+    >>> partition(lambda x: x % 3, lst)
+    {0: [0, 3, 6, 9], 1: [1, 4, 7], 2: [2, 5, 8]}
+
+    """
+    result = defaultdict(list)
+    for v in iterable:
+        result[func(v)].append(v)
+    return dict(result)
+
+
+def add_field(a, descr):
+    """
+    Return a new array that is like `a`, but has additional fields.
+    The contents of `a` are copied over to the appropriate fields in
+    the new array, whereas the new fields are uninitialized.  The
+    arguments are not modified. Source [8]_.
+
+    Parameters
+    ----------
+    a: np.ndarray
+        A structured numpy array
+    descr: np.dtype or list
+        A numpy type description of the new fields
+
+    Returns
+    -------
+    np.ndarray
+         The new structured numpy array
+
+    Examples
+    --------
+    >>> import numpy as np
+    >>> sa = np.array([(1, 'Foo'), (2, 'Bar')], \
+                         dtype=[('id', int), ('name', 'S3')])
+    >>> sa.dtype.descr == np.dtype([('id', int), ('name', 'S3')])
+    True
+    >>> sb = add_field(sa, [('score', float)])
+    >>> sb.dtype.descr == np.dtype([('id', int), ('name', 'S3'), \
+                                       ('score', float)])
+    True
+    >>> np.all(sa['id'] == sb['id'])
+    True
+    >>> np.all(sa['name'] == sb['name'])
+    True
+
+    Notes
+    -----
+    Source:
+
+    .. [8]
+       https://stackoverflow.com/questions/1201817/\
+adding-a-field-to-a-structured-numpy-array
+
+    """
+    if a.dtype.fields is None:
+        raise ValueError("`A` must be a structured numpy array")
+
+    if isinstance(descr, np.dtype):
+        descr = descr.descr
+    b = np.empty(a.shape, dtype=a.dtype.descr + descr)
+    for name in a.dtype.names:
+        b[name] = a[name]
+    return b
+
+
+def sorted_dict_items(items, key=None):
+    for item in sorted(items, key=key):
+        yield item
+
+
+def show_diff(a, b):
+    """
+    Show the difference between two strings, using the difflib package. The
+    difference is printed to stdout.
+
+    Parameters
+    ----------
+    a: str
+        First string
+    b: str
+        Second string
+    """
+
+    import difflib
+
+    differ = difflib.Differ()
+    for li in differ.compare(a.split("\n"), b.split("\n")):
+        print(li)
+
+
+class PrettyPrintTree(object):
+    def __init__(self):
+        self.stack = []
+
+    def push(self):
+        self.stack.append(TreeSymbol())
+
+    def pop(self):
+        self.stack.pop()
+
+    def next_item(self):
+        assert len(self.stack) > 0
+        self.stack[-1].next_item()
+
+    def last_item(self):
+        assert len(self.stack) > 0
+        self.stack[-1].last_item()
+
+    def __str__(self):
+        return "".join(str(sym) for sym in self.stack)
+
+
+class TreeSymbol(object):
+    def __init__(self):
+        self.symbols = [" │  ", " ├─ ", " └─ ", "    "]
+        self.state = 0
+
+    def next_item(self):
+        self.state = 1
+
+    def last_item(self):
+        self.state = 2
+
+    def __str__(self):
+        sym = self.symbols[self.state]
+        if self.state == 1:
+            self.state = 0
+        elif self.state == 2:
+            self.state = 3
+        return sym
+
+
+def search(states, success, expand, combine):
+    while len(states) > 0:
+        state = states.pop(0)
+        if success(state):
+            return state
+        else:
+            states = combine(expand(state), states)
+
+
+def interp1d(
+    x: np.ndarray,
+    y: np.ndarray,
+    dtype: Optional[type] = None,
+    axis: int = -1,
+    kind: Union[str, int] = "linear",
+    copy=True,
+    bounds_error=None,
+    fill_value=np.nan,
+    assume_sorted=False,
+) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
+    """
+    Interpolate a 1-D function using scipy's interp1d method. This utility allows for
+    handling the case where `x` and `y` are only a single value (i.e. have length one,
+    which results in a ValueError if using scipy's version directly). It also allows for
+    specifying the dtype of the output.
+
+    The description of the parameters has been taken from `scipy.interpolate.interp1d`.
+
+    `x` and `y` are arrays of values used to approximate some function f:
+    ``y = f(x)``. This class returns a function whose call method uses
+    interpolation to find the value of new points.
+
+
+    Parameters
+    ----------
+    x : (N,) np.ndarray
+        A 1-D array of real values.
+    y : (...,N,...) np.ndarray
+        A N-D array of real values. The length of `y` along the interpolation
+        axis must be equal to the length of `x`.
+    dtype : type, optional
+        Type of the output array (e.g.,  `float`, `int`). By default it is set to
+        None (i.e., the array will have the same type as the outputs from
+        scipy's interp1d method.
+    axis : int, optional
+        Specifies the axis of `y` along which to interpolate.
+        Interpolation defaults to the last axis of `y`.
+    kind : str or int, optional
+        Specifies the kind of interpolation as a string or as an integer
+        specifying the order of the spline interpolator to use.
+        The string has to be one of 'linear', 'nearest', 'nearest-up', 'zero',
+        'slinear', 'quadratic', 'cubic', 'previous', or 'next'. 'zero',
+        'slinear', 'quadratic' and 'cubic' refer to a spline interpolation of
+        zeroth, first, second or third order; 'previous' and 'next' simply
+        return the previous or next value of the point; 'nearest-up' and
+        'nearest' differ when interpolating half-integers (e.g. 0.5, 1.5)
+        in that 'nearest-up' rounds up and 'nearest' rounds down. Default
+        is 'linear'.
+    copy : bool, optional
+        If True, the class makes internal copies of x and y.
+        If False, references to `x` and `y` are used. The default is to copy.
+    bounds_error : bool, optional
+        If True, a ValueError is raised any time interpolation is attempted on
+        a value outside of the range of x (where extrapolation is
+        necessary). If False, out of bounds values are assigned `fill_value`.
+        By default, an error is raised unless ``fill_value="extrapolate"``.
+    fill_value : array-like or (array-like, array_like) or "extrapolate", optional
+        - if a ndarray (or float), this value will be used to fill in for
+          requested points outside of the data range. If not provided, then
+          the default is NaN. The array-like must broadcast properly to the
+          dimensions of the non-interpolation axes.
+        - If a two-element tuple, then the first element is used as a
+          fill value for ``x_new < x[0]`` and the second element is used for
+          ``x_new > x[-1]``. Anything that is not a 2-element tuple (e.g.,
+          list or ndarray, regardless of shape) is taken to be a single
+          array-like argument meant to be used for both bounds as
+          ``below, above = fill_value, fill_value``.
+        - If "extrapolate", then points outside the data range will be
+          extrapolated.
+    assume_sorted : bool, optional
+        If False, values of `x` can be in any order and they are sorted first.
+        If True, `x` has to be an array of monotonically increasing values.
+
+    Returns
+    -------
+    interp_fun : callable
+        The interpolator instance. This method takes an input array, float
+        or integer and returns an array with the specified dtype (if `dtype`
+        is not None).
+    """
+    if len(x) > 1:
+        interp_fun = sc_interp1d(
+            x=x,
+            y=y,
+            kind=kind,
+            axis=axis,
+            copy=copy,
+            bounds_error=bounds_error,
+            fill_value=fill_value,
+            assume_sorted=assume_sorted,
+        )
+
+    else:
+
+        # If there is only one value for x and y, assume that the method
+        # will always return the same value for any input.
+
+        def interp_fun(
+            input_var: Union[float, int, np.ndarray]
+        ) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
+
+            if y.ndim > 1:
+                result = np.broadcast_to(y, (len(np.atleast_1d(input_var)), y.shape[1]))
+            else:
+                result = np.broadcast_to(y, (len(np.atleast_1d(input_var)),))
+
+            if not isinstance(input_var, np.ndarray):
+                # the output of scipy's interp1d is always an array
+                result = np.array(result[0])
+
+            return result
+
+    if dtype is not None:
+
+        def typed_interp(
+            input_var: Union[float, int, np.ndarray]
+        ) -> Callable[[Union[float, int, np.ndarray]], np.ndarray]:
+            return interp_fun(input_var).astype(dtype)
+
+        return typed_interp
+    else:
+        return interp_fun
+
+
+# def search_recursive(states, success, expand, combine):
+#     try:
+#         if not states:
+#             return None
+#         elif success(states[0]):
+#             return states[0]
+#         else:
+#             new_states = combine(expand(states[0]), states[1:])
+#             return search_recursive(new_states, success, expand, combine)
+#     except RecursionError:
+#         warnings.warn('search exhausted stack, bailing out')
+#         return None
+
+
+if __name__ == "__main__":
+    import doctest
+
+    doctest.testmod()
```

### Comparing `partitura-1.2.1/partitura/utils/misc.py` & `partitura-1.2.2/partitura/utils/misc.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,256 +1,257 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-"""
-This module contains miscellaneous utilities.
-"""
-import functools
-import os
-import warnings
-
-from typing import Union, Callable, Dict, Any, Iterable, Optional
-
-import numpy as np
-
-try:
-    from PIL import Image
-    from PIL.ImageFile import ImageFile
-    PIL_EXISTS = True
-except ImportError:
-    Image = None
-    ImageFile = Any
-    PIL_EXISTS = False
-
-# Recommended by PEP 519
-PathLike = Union[str, bytes, os.PathLike]
-
-
-def get_document_name(filename: PathLike) -> str:
-    """
-    Get the name of a document.
-
-    Parameters
-    ----------
-    filename : PathLike
-        The path of the file
-
-    Returns
-    -------
-    doc_name : str
-        The name of the document
-    """
-    doc_name = str(os.path.basename(os.path.splitext(filename)[0]))
-    return doc_name
-
-
-def deprecated_alias(**aliases: str) -> Callable:
-    """
-    Decorator for aliasing deprecated function and method arguments.
-
-    Use as follows:
-
-    @deprecated_alias(old_arg='new_arg')
-    def myfunc(new_arg):
-        ...
-
-    Notes
-    -----
-    Taken from https://stackoverflow.com/a/49802489 by user user2357112.
-    This code is re-distributed as (Licence)
-    """
-
-    def deco(f: Callable):
-        @functools.wraps(f)
-        def wrapper(*args, **kwargs):
-            rename_kwargs(f.__name__, kwargs, aliases)
-            return f(*args, **kwargs)
-
-        return wrapper
-
-    return deco
-
-
-def deprecated_parameter(*deprecated_kwargs: str) -> Callable:
-    """
-    Decorator for deprecating function and method arguments.
-
-    Use as follows:
-
-    @deprecated_parameter("old_argument1", "old_argument2")
-    def func(new_arg):
-        ...
-    """
-
-    def deco(f: Callable):
-        @functools.wraps(f)
-        def wrapper(*args, **kwargs):
-            to_be_deprecated(f.__name__, kwargs, deprecated_kwargs)
-            return f(*args, **kwargs)
-
-        return wrapper
-
-    return deco
-
-
-def rename_kwargs(
-    func_name: str,
-    kwargs: Dict[str, Any],
-    aliases: Dict[str, str],
-) -> None:
-    """
-    Helper function for renaming deprecated function arguments.
-    This function edits the dictionary of keyword arguments in-place.
-
-    Parameters
-    ----------
-    func_name : str
-        Name of the function which keyword arguments have been deprecated.
-    kwargs : dictionary
-        Dictionary of keyword arguments to be passed to the function
-    aliases: dictionary
-        Dictionary specifying the aliases of the deprecated keyword arguments.
-
-
-    Notes
-    -----
-    Taken from https://stackoverflow.com/a/49802489 by user user2357112.
-    """
-    for alias, new in aliases.items():
-        if alias in kwargs:
-            if new in kwargs:
-                raise TypeError(
-                    f"{func_name} received both {alias} and {new} as arguments!"
-                    f" {alias} is deprecated, use {new} instead."
-                )
-            warnings.warn(
-                message=(
-                    f"`{alias}` is deprecated as an argument to `{func_name}`; use"
-                    f" `{new}` instead."
-                ),
-                category=DeprecationWarning,
-                stacklevel=3,
-            )
-            kwargs[new] = kwargs.pop(alias)
-
-
-def to_be_deprecated(
-    func_name: str,
-    kwargs: Dict[str, Any],
-    deprecated_kwargs: Iterable[str],
-) -> None:
-    """
-    Helper function for deprecating function arguments.
-    This function edits the dictionary of keyword arguments in-place.
-
-    Parameters
-    ----------
-    func_name : str
-        Name of the function which keyword arguments have been deprecated.
-    kwargs : dictionary
-        Dictionary of keyword arguments to be passed to the function
-    deprecated_kwargs: Iterable[str]
-        An iterable specifiying the parameters to be deprecated.
-    """
-
-    for deprecated_kwarg in deprecated_kwargs:
-        if deprecated_kwarg in kwargs:
-            # raise warning
-            warnings.warn(
-                message=(
-                    f"`{deprecated_kwarg}` is a deprecatd argument of `{func_name}`"
-                    " and will be ignored."
-                ),
-                category=DeprecationWarning,
-                stacklevel=3,
-            )
-            # Remove deprecated kwarg from kwargs
-            kwargs.pop(deprecated_kwarg)
-
-
-def concatenate_images(
-    filenames: Iterable[PathLike],
-    out: Optional[PathLike] = None,
-    concat_mode: str = "vertical",
-) -> Optional[ImageFile]:
-    """
-    Concatenate Images to form one single image.
-
-    Parameters
-    ----------
-    filenames: Iterable[PathLike]
-        A list of images to be concatenated. This method assumes
-        that all of the images have the same resolution and color mode
-        (that is the case for png files generated by MuseScore).
-        See `partitura.io.musescore.render_musescore`.
-    out : Optional[PathLike]
-        The output file where the image will be saved.
-    concat_mode : {"vertical", "horizontal"}
-        Whether to concatenate the images vertically or horizontally.
-        Default is vertical.
-
-    Returns
-    -------
-    new_image : Optional[PIL.Image.Image]
-        The output image. This is only returned if `out` is not None.
-
-    Notes
-    -----
-
-    If the Pillow library is not installed, this method will return None.
-    """
-    if not PIL_EXISTS:
-        warnings.warn(
-            message=(
-                "The pillow library was not found. This method "
-                "will just return None. (You can install it with "
-                "`pip install pillow`)."
-            ),
-            category=ImportWarning,
-        )
-        return None
-    # Check that concat mode is vertical or horizontal
-    if concat_mode not in ("vertical", "horizontal"):
-        raise ValueError(
-            f"`concat_mode` should be 'vertical' or 'horizontal' but is {concat_mode}"
-        )
-
-    # Load images
-    images = [Image.open(fn) for fn in filenames]
-
-    # Get image sizes
-    image_sizes = np.array([img.size for img in images], dtype=int)
-
-    # size of the output image according to the concatenation mode
-    if concat_mode == "vertical":
-        output_size = (image_sizes[:, 0].max(), image_sizes[:, 1].sum())
-    elif concat_mode == "horizontal":
-        output_size = (image_sizes[:, 0].sum(), image_sizes[:, 1].max())
-
-    # Color mode (assume it is the same for all images)
-    mode = images[0].mode
-
-    # DPI (assume that it is the same for all images)
-    info = images[0].info
-
-    # Initialize new image
-    new_image = Image.new(mode=mode, size=output_size, color=0)
-
-    # coordinates to place the image
-    anchor_x = 0
-    anchor_y = 0
-    for img, size in zip(images, image_sizes):
-
-        new_image.paste(img, (anchor_x, anchor_y))
-
-        # update coordinates according to the concatenation mode
-        if concat_mode == "vertical":
-            anchor_y += size[1]
-
-        elif concat_mode == "horizontal":
-            anchor_x += size[0]
-
-    # save image file
-    if out is not None:
-        new_image.save(out, **info)
-
-    else:
-        return new_image
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+"""
+This module contains miscellaneous utilities.
+"""
+import functools
+import os
+import warnings
+
+from typing import Union, Callable, Dict, Any, Iterable, Optional
+
+import numpy as np
+
+try:
+    from PIL import Image
+    from PIL.ImageFile import ImageFile
+
+    PIL_EXISTS = True
+except ImportError:
+    Image = None
+    ImageFile = Any
+    PIL_EXISTS = False
+
+# Recommended by PEP 519
+PathLike = Union[str, bytes, os.PathLike]
+
+
+def get_document_name(filename: PathLike) -> str:
+    """
+    Get the name of a document.
+
+    Parameters
+    ----------
+    filename : PathLike
+        The path of the file
+
+    Returns
+    -------
+    doc_name : str
+        The name of the document
+    """
+    doc_name = str(os.path.basename(os.path.splitext(filename)[0]))
+    return doc_name
+
+
+def deprecated_alias(**aliases: str) -> Callable:
+    """
+    Decorator for aliasing deprecated function and method arguments.
+
+    Use as follows:
+
+    @deprecated_alias(old_arg='new_arg')
+    def myfunc(new_arg):
+        ...
+
+    Notes
+    -----
+    Taken from https://stackoverflow.com/a/49802489 by user user2357112.
+    This code is re-distributed as (Licence)
+    """
+
+    def deco(f: Callable):
+        @functools.wraps(f)
+        def wrapper(*args, **kwargs):
+            rename_kwargs(f.__name__, kwargs, aliases)
+            return f(*args, **kwargs)
+
+        return wrapper
+
+    return deco
+
+
+def deprecated_parameter(*deprecated_kwargs: str) -> Callable:
+    """
+    Decorator for deprecating function and method arguments.
+
+    Use as follows:
+
+    @deprecated_parameter("old_argument1", "old_argument2")
+    def func(new_arg):
+        ...
+    """
+
+    def deco(f: Callable):
+        @functools.wraps(f)
+        def wrapper(*args, **kwargs):
+            to_be_deprecated(f.__name__, kwargs, deprecated_kwargs)
+            return f(*args, **kwargs)
+
+        return wrapper
+
+    return deco
+
+
+def rename_kwargs(
+    func_name: str,
+    kwargs: Dict[str, Any],
+    aliases: Dict[str, str],
+) -> None:
+    """
+    Helper function for renaming deprecated function arguments.
+    This function edits the dictionary of keyword arguments in-place.
+
+    Parameters
+    ----------
+    func_name : str
+        Name of the function which keyword arguments have been deprecated.
+    kwargs : dictionary
+        Dictionary of keyword arguments to be passed to the function
+    aliases: dictionary
+        Dictionary specifying the aliases of the deprecated keyword arguments.
+
+
+    Notes
+    -----
+    Taken from https://stackoverflow.com/a/49802489 by user user2357112.
+    """
+    for alias, new in aliases.items():
+        if alias in kwargs:
+            if new in kwargs:
+                raise TypeError(
+                    f"{func_name} received both {alias} and {new} as arguments!"
+                    f" {alias} is deprecated, use {new} instead."
+                )
+            warnings.warn(
+                message=(
+                    f"`{alias}` is deprecated as an argument to `{func_name}`; use"
+                    f" `{new}` instead."
+                ),
+                category=DeprecationWarning,
+                stacklevel=3,
+            )
+            kwargs[new] = kwargs.pop(alias)
+
+
+def to_be_deprecated(
+    func_name: str,
+    kwargs: Dict[str, Any],
+    deprecated_kwargs: Iterable[str],
+) -> None:
+    """
+    Helper function for deprecating function arguments.
+    This function edits the dictionary of keyword arguments in-place.
+
+    Parameters
+    ----------
+    func_name : str
+        Name of the function which keyword arguments have been deprecated.
+    kwargs : dictionary
+        Dictionary of keyword arguments to be passed to the function
+    deprecated_kwargs: Iterable[str]
+        An iterable specifiying the parameters to be deprecated.
+    """
+
+    for deprecated_kwarg in deprecated_kwargs:
+        if deprecated_kwarg in kwargs:
+            # raise warning
+            warnings.warn(
+                message=(
+                    f"`{deprecated_kwarg}` is a deprecatd argument of `{func_name}`"
+                    " and will be ignored."
+                ),
+                category=DeprecationWarning,
+                stacklevel=3,
+            )
+            # Remove deprecated kwarg from kwargs
+            kwargs.pop(deprecated_kwarg)
+
+
+def concatenate_images(
+    filenames: Iterable[PathLike],
+    out: Optional[PathLike] = None,
+    concat_mode: str = "vertical",
+) -> Optional[ImageFile]:
+    """
+    Concatenate Images to form one single image.
+
+    Parameters
+    ----------
+    filenames: Iterable[PathLike]
+        A list of images to be concatenated. This method assumes
+        that all of the images have the same resolution and color mode
+        (that is the case for png files generated by MuseScore).
+        See `partitura.io.musescore.render_musescore`.
+    out : Optional[PathLike]
+        The output file where the image will be saved.
+    concat_mode : {"vertical", "horizontal"}
+        Whether to concatenate the images vertically or horizontally.
+        Default is vertical.
+
+    Returns
+    -------
+    new_image : Optional[PIL.Image.Image]
+        The output image. This is only returned if `out` is not None.
+
+    Notes
+    -----
+
+    If the Pillow library is not installed, this method will return None.
+    """
+    if not PIL_EXISTS:
+        warnings.warn(
+            message=(
+                "The pillow library was not found. This method "
+                "will just return None. (You can install it with "
+                "`pip install pillow`)."
+            ),
+            category=ImportWarning,
+        )
+        return None
+    # Check that concat mode is vertical or horizontal
+    if concat_mode not in ("vertical", "horizontal"):
+        raise ValueError(
+            f"`concat_mode` should be 'vertical' or 'horizontal' but is {concat_mode}"
+        )
+
+    # Load images
+    images = [Image.open(fn) for fn in filenames]
+
+    # Get image sizes
+    image_sizes = np.array([img.size for img in images], dtype=int)
+
+    # size of the output image according to the concatenation mode
+    if concat_mode == "vertical":
+        output_size = (image_sizes[:, 0].max(), image_sizes[:, 1].sum())
+    elif concat_mode == "horizontal":
+        output_size = (image_sizes[:, 0].sum(), image_sizes[:, 1].max())
+
+    # Color mode (assume it is the same for all images)
+    mode = images[0].mode
+
+    # DPI (assume that it is the same for all images)
+    info = images[0].info
+
+    # Initialize new image
+    new_image = Image.new(mode=mode, size=output_size, color=0)
+
+    # coordinates to place the image
+    anchor_x = 0
+    anchor_y = 0
+    for img, size in zip(images, image_sizes):
+
+        new_image.paste(img, (anchor_x, anchor_y))
+
+        # update coordinates according to the concatenation mode
+        if concat_mode == "vertical":
+            anchor_y += size[1]
+
+        elif concat_mode == "horizontal":
+            anchor_x += size[0]
+
+    # save image file
+    if out is not None:
+        new_image.save(out, **info)
+
+    else:
+        return new_image
```

### Comparing `partitura-1.2.1/setup.py` & `partitura-1.2.2/setup.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,79 +1,79 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-
-import io
-import os
-import sys
-from shutil import rmtree
-
-from setuptools import find_packages, setup, Command
-
-# Package meta-data.
-NAME = "partitura"
-DESCRIPTION = "A package for handling symbolic musical information"
-KEYWORDS = "music notation musicxml midi"
-URL = "https://github.com/CPJKU/partitura"
-EMAIL = "partitura-users@googlegroups.com"
-AUTHOR = "Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin, Thassilo Gadermaier"
-REQUIRES_PYTHON = ">=3.6"
-VERSION = "1.2.1"
-
-# What packages are required for this module to be executed?
-REQUIRED = ["numpy", "scipy", "lxml", "lark-parser", "xmlschema", "mido"]
-
-# What packages are optional?
-EXTRAS = {}
-
-here = os.path.abspath(os.path.dirname(__file__))
-
-try:
-    with io.open(os.path.join(here, "README.md"), encoding="utf-8") as f:
-        long_description = "\n" + f.read()
-except FileNotFoundError:
-    long_description = DESCRIPTION
-
-# Load the package's __version__.py module as a dictionary.
-about = {}
-if not VERSION:
-    with open(os.path.join(here, NAME, "__version__.py")) as f:
-        exec(f.read(), about)
-else:
-    about["__version__"] = VERSION
-
-
-# Where the magic happens:
-setup(
-    name=NAME,
-    version=about["__version__"],
-    description=DESCRIPTION,
-    long_description=long_description,
-    long_description_content_type="text/markdown",
-    keywords=KEYWORDS,
-    author=AUTHOR,
-    author_email=EMAIL,
-    python_requires=REQUIRES_PYTHON,
-    url=URL,
-    packages=find_packages(exclude=("tests",)),
-    package_data={
-        "partitura": [
-            "assets/musicxml.xsd",
-            "assets/score_example.mid",
-            "assets/score_example.musicxml",
-            "assets/score_example.krn",
-            "assets/score_example.mei",
-        ]
-    },
-    install_requires=REQUIRED,
-    extras_require=EXTRAS,
-    include_package_data=True,
-    license="Apache 2.0",
-    classifiers=[
-        # Trove classifiers
-        # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers
-        "License :: OSI Approved :: MIT License",
-        "Programming Language :: Python",
-        "Programming Language :: Python :: 3",
-        "Programming Language :: Python :: Implementation :: CPython",
-        "Programming Language :: Python :: Implementation :: PyPy",
-    ],
-)
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+
+import io
+import os
+import sys
+from shutil import rmtree
+
+from setuptools import find_packages, setup, Command
+
+# Package meta-data.
+NAME = "partitura"
+DESCRIPTION = "A package for handling symbolic musical information"
+KEYWORDS = "music notation musicxml midi"
+URL = "https://github.com/CPJKU/partitura"
+EMAIL = "partitura-users@googlegroups.com"
+AUTHOR = "Maarten Grachten, Carlos Cancino-Chacón, Silvan Peter, Emmanouil Karystinaios, Francesco Foscarin, Thassilo Gadermaier"
+REQUIRES_PYTHON = ">=3.6"
+VERSION = "1.2.2"
+
+# What packages are required for this module to be executed?
+REQUIRED = ["numpy", "scipy", "lxml", "lark-parser", "xmlschema", "mido"]
+
+# What packages are optional?
+EXTRAS = {}
+
+here = os.path.abspath(os.path.dirname(__file__))
+
+try:
+    with io.open(os.path.join(here, "README.md"), encoding="utf-8") as f:
+        long_description = "\n" + f.read()
+except FileNotFoundError:
+    long_description = DESCRIPTION
+
+# Load the package's __version__.py module as a dictionary.
+about = {}
+if not VERSION:
+    with open(os.path.join(here, NAME, "__version__.py")) as f:
+        exec(f.read(), about)
+else:
+    about["__version__"] = VERSION
+
+
+# Where the magic happens:
+setup(
+    name=NAME,
+    version=about["__version__"],
+    description=DESCRIPTION,
+    long_description=long_description,
+    long_description_content_type="text/markdown",
+    keywords=KEYWORDS,
+    author=AUTHOR,
+    author_email=EMAIL,
+    python_requires=REQUIRES_PYTHON,
+    url=URL,
+    packages=find_packages(exclude=("tests",)),
+    package_data={
+        "partitura": [
+            "assets/musicxml.xsd",
+            "assets/score_example.mid",
+            "assets/score_example.musicxml",
+            "assets/score_example.krn",
+            "assets/score_example.mei",
+        ]
+    },
+    install_requires=REQUIRED,
+    extras_require=EXTRAS,
+    include_package_data=True,
+    license="Apache 2.0",
+    classifiers=[
+        # Trove classifiers
+        # Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers
+        "License :: OSI Approved :: MIT License",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: Implementation :: CPython",
+        "Programming Language :: Python :: Implementation :: PyPy",
+    ],
+)
```

